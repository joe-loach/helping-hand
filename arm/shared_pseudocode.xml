<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" encoding="UTF-8" href="iform.xsl" version="1.0"?>
<!DOCTYPE instructionsection PUBLIC "-//ARM//DTD instructionsection //EN" "sharedps.dtd">
<!-- Copyright (c) 2010-2021 Arm Limited or its affiliates. All rights reserved. -->
<!-- This document is Non-Confidential. This document may only be used and distributed in accordance with the terms of the agreement entered into by Arm and the party that Arm delivered this document to. -->

<instructionsection id="shared_pseudocode" title="AArch32 Instruction Summary -- Shared Pseudocode" type="pseudocode">
  <heading>Shared Pseudocode Functions</heading>
  <desc>
    <brief>This page displays common pseudocode functions shared by many pages</brief>
  </desc>
  <ps_section howmany="1194">
    <ps name="aarch32/at/AArch32.AT" mylink="aarch32.at.AArch32.AT" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.AT()
// ============
// Perform address translation as per AT instructions.

<anchor link="AArch32.AT.4" hover="function: AArch32.AT(bits(32) vaddress, TranslationStage stage_in, bits(2) el, ATAccess ataccess)">AArch32.AT</anchor>(bits(32) vaddress, <a link="TranslationStage" file="shared_pseudocode.xml" hover="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage</a> stage_in, bits(2) el, <a link="ATAccess" file="shared_pseudocode.xml" hover="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess</a> ataccess)
    <a link="TranslationStage" file="shared_pseudocode.xml" hover="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage</a> stage = stage_in;
    <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss;
    <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime;
    boolean eae;

    // ATS1Hx instructions
    if el == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then
        regime = <a link="Regime_EL2" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>;
        eae = TRUE;
        ss = <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a>;

    // ATS1Cxx instructions
    elsif stage == <a link="TranslationStage_1" file="shared_pseudocode.xml" hover="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_1</a> || (stage == <a link="TranslationStage_12" file="shared_pseudocode.xml" hover="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_12</a> &amp;&amp; !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>)) then
        stage = <a link="TranslationStage_1" file="shared_pseudocode.xml" hover="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_1</a>;
        ss = <a link="impl-shared.SecurityStateAtEL.1" file="shared_pseudocode.xml" hover="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(PSTATE.EL);
        regime = if ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp; <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then <a link="Regime_EL30" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> else <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>;
        eae = TTBCR.EAE == '1';

    // ATS12NSOxx instructions
    else
        regime = <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>;
        eae = if <a link="impl-shared.HaveAArch32EL.1" file="shared_pseudocode.xml" hover="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then TTBCR_NS.EAE == '1' else TTBCR.EAE == '1';
        ss = <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a>;

    <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> addrdesc;
    aligned = TRUE;
    ispriv = el != <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>;
    supersection = '0';
    iswrite = ataccess IN {<a link="ATAccess_WritePAN" file="shared_pseudocode.xml" hover="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess_WritePAN</a>, <a link="ATAccess_Write" file="shared_pseudocode.xml" hover="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess_Write</a>};
    acctype = if ataccess IN {<a link="ATAccess_Read" file="shared_pseudocode.xml" hover="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess_Read</a>, <a link="ATAccess_Write" file="shared_pseudocode.xml" hover="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess_Write</a>} then <a link="AccType_AT" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</a> else <a link="AccType_ATPAN" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATPAN</a>;

    // Prepare fault fields in case a fault is detected
    fault = <a link="impl-shared.NoFault.0" file="shared_pseudocode.xml" hover="function: FaultRecord NoFault()">NoFault</a>();
    fault.acctype = acctype;
    fault.write = iswrite;

    if eae then
        (fault, addrdesc) = <a link="AArch32.S1TranslateLD.8" file="shared_pseudocode.xml" hover="function: (FaultRecord, AddressDescriptor) AArch32.S1TranslateLD(FaultRecord fault_in, Regime regime,&#13; SecurityState ss, bits(32) va,&#13; AccType acctype, boolean aligned,&#13; boolean iswrite, boolean ispriv)">AArch32.S1TranslateLD</a>(fault, regime, ss, vaddress, acctype, aligned,
                                                  iswrite, ispriv);
    else
        (fault, addrdesc, sdftype) = <a link="AArch32.S1TranslateSD.8" file="shared_pseudocode.xml" hover="function: (FaultRecord, AddressDescriptor, SDFType) AArch32.S1TranslateSD(FaultRecord fault_in, Regime regime,&#13; SecurityState ss, bits(32) va,&#13; AccType acctype, boolean aligned,&#13; boolean iswrite, boolean ispriv)">AArch32.S1TranslateSD</a>(fault, regime, ss, vaddress, acctype,
                                                           aligned, iswrite, ispriv);
        supersection = if sdftype == <a link="SDFType_Supersection" file="shared_pseudocode.xml" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Supersection</a> then '1' else '0';

    // ATS12NSOxx instructions
    if stage == <a link="TranslationStage_12" file="shared_pseudocode.xml" hover="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_12</a> &amp;&amp; fault.statuscode == <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        s2fs1walk = FALSE;
        (fault, addrdesc) = <a link="AArch32.S2Translate.8" file="shared_pseudocode.xml" hover="function: (FaultRecord, AddressDescriptor) AArch32.S2Translate(FaultRecord fault_in, AddressDescriptor ipa,&#13; SecurityState ss, boolean s2fs1walk,&#13; AccType acctype, boolean aligned,&#13; boolean iswrite, boolean ispriv)">AArch32.S2Translate</a>(fault, addrdesc, ss, s2fs1walk, acctype, aligned,
                                                iswrite, ispriv);

    if fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        // Take exception when External abort occurs on translation table walk
        if (<a link="impl-shared.IsExternalAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) || (stage == <a link="TranslationStage_1" file="shared_pseudocode.xml" hover="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_1</a> &amp;&amp; el != <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; PSTATE.EL == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>
                                       &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; fault.s2fs1walk)) then
            PAR = bits(64) UNKNOWN;
            <a link="AArch32.Abort.2" file="shared_pseudocode.xml" hover="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(vaddress, fault);

    addrdesc.fault = fault;

    if (eae || (stage == <a link="TranslationStage_12" file="shared_pseudocode.xml" hover="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_12</a> &amp;&amp; (HCR.VM == '1' || HCR.DC == '1'))
            || (stage == <a link="TranslationStage_1" file="shared_pseudocode.xml" hover="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_1</a> &amp;&amp; el != <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>)) then
        <a link="AArch32.EncodePARLD.2" file="shared_pseudocode.xml" hover="function: AArch32.EncodePARLD(AddressDescriptor addrdesc, SecurityState ss)">AArch32.EncodePARLD</a>(addrdesc, ss);
    else
        <a link="AArch32.EncodePARSD.3" file="shared_pseudocode.xml" hover="function: AArch32.EncodePARSD(AddressDescriptor addrdesc_in, bit supersection, SecurityState ss)">AArch32.EncodePARSD</a>(addrdesc, supersection, ss);
    return;</pstext>
    </ps>
    <ps name="aarch32/at/AArch32.EncodePARLD" mylink="aarch32.at.AArch32.EncodePARLD" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.EncodePARLD()
// =====================
// Returns 64-bit format PAR on address translation instruction.

<anchor link="AArch32.EncodePARLD.2" hover="function: AArch32.EncodePARLD(AddressDescriptor addrdesc, SecurityState ss)">AArch32.EncodePARLD</anchor>(<a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> addrdesc, <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss)

    if !<a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(addrdesc) then
        bit ns;
        if ss == <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a> then
            ns = bit UNKNOWN;
        elsif addrdesc.paddress.paspace == <a link="PAS_Secure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_Secure</a> then
            ns = '0';
        else
            ns = '1';
        PAR.F      = '0';
        PAR.SH     = ReportedPARShareability(<a link="impl-shared.PAREncodeShareability.1" file="shared_pseudocode.xml" hover="function: bits(2) PAREncodeShareability(MemoryAttributes memattrs)">PAREncodeShareability</a>(addrdesc.memattrs));
        PAR.NS     = ns;
        PAR&lt;10&gt;    = bit IMPLEMENTATION_DEFINED "Non-Faulting PAR";               // IMPDEF
        PAR.LPAE   = '1';
        PAR.PA     = addrdesc.paddress.address&lt;39:12&gt;;
        PAR.ATTR   = ReportedPARAttrs(<a link="impl-shared.EncodePARAttrs.1" file="shared_pseudocode.xml" hover="function: bits(8) EncodePARAttrs(MemoryAttributes memattrs)">EncodePARAttrs</a>(addrdesc.memattrs));
    else
        PAR.F      = '1';
        PAR.FST    = <a link="AArch32.PARFaultStatusLD.1" file="shared_pseudocode.xml" hover="function: bits(6) AArch32.PARFaultStatusLD(FaultRecord fault)">AArch32.PARFaultStatusLD</a>(addrdesc.fault);
        PAR.S2WLK  = if addrdesc.fault.s2fs1walk then '1' else '0';
        PAR.FSTAGE = if addrdesc.fault.secondstage then '1' else '0';
        PAR.LPAE   = '1';
        PAR&lt;63:48&gt; = bits(16) IMPLEMENTATION_DEFINED "Faulting PAR";              // IMPDEF
    return;</pstext>
    </ps>
    <ps name="aarch32/at/AArch32.EncodePARSD" mylink="aarch32.at.AArch32.EncodePARSD" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.EncodePARSD()
// =====================
// Returns 32-bit format PAR on address translation instruction.

<anchor link="AArch32.EncodePARSD.3" hover="function: AArch32.EncodePARSD(AddressDescriptor addrdesc_in, bit supersection, SecurityState ss)">AArch32.EncodePARSD</anchor>(<a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> addrdesc_in, bit supersection, <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss)
    <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> addrdesc = addrdesc_in;
    if !<a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(addrdesc) then
        if (addrdesc.memattrs.memtype == <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> ||
                (addrdesc.memattrs.inner.attrs == <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> &amp;&amp;
                 addrdesc.memattrs.outer.attrs == <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>)) then
            addrdesc.memattrs.shareability = <a link="Shareability_OSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        bit ns;
        if ss == <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a> then
            ns = bit UNKNOWN;
        elsif addrdesc.paddress.paspace == <a link="PAS_Secure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_Secure</a> then
            ns = '0';
        else
            ns = '1';
        bits(2) sh = if addrdesc.memattrs.shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then '01' else '00';
        PAR.F      = '0';
        PAR.SS     = supersection;
        PAR.Outer  = AArch32.ReportedOuterAttrs(<a link="AArch32.PAROuterAttrs.1" file="shared_pseudocode.xml" hover="function: bits(2) AArch32.PAROuterAttrs(MemoryAttributes memattrs)">AArch32.PAROuterAttrs</a>(addrdesc.memattrs));
        PAR.Inner  = AArch32.ReportedInnerAttrs(<a link="AArch32.PARInnerAttrs.1" file="shared_pseudocode.xml" hover="function: bits(3) AArch32.PARInnerAttrs(MemoryAttributes memattrs)">AArch32.PARInnerAttrs</a>(addrdesc.memattrs));
        PAR.SH     = ReportedPARShareability(sh);
        PAR&lt;8&gt;     = bit IMPLEMENTATION_DEFINED "Non-Faulting PAR";               // IMPDEF
        PAR.NS     = ns;
        PAR.NOS    = if addrdesc.memattrs.shareability == <a link="Shareability_OSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a> then '0' else '1';
        PAR.LPAE   = '0';
        PAR.PA     = addrdesc.paddress.address&lt;39:12&gt;;
    else
        PAR.F      = '1';
        PAR.FST    = <a link="AArch32.PARFaultStatusSD.1" file="shared_pseudocode.xml" hover="function: bits(6) AArch32.PARFaultStatusSD(FaultRecord fault)">AArch32.PARFaultStatusSD</a>(addrdesc.fault);
        PAR.LPAE   = '0';
        PAR&lt;31:16&gt; = bits(16) IMPLEMENTATION_DEFINED "Faulting PAR";              // IMPDEF
    return;</pstext>
    </ps>
    <ps name="aarch32/at/AArch32.PARFaultStatusLD" mylink="aarch32.at.AArch32.PARFaultStatusLD" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.PARFaultStatusLD()
// ==========================
// Fault status field decoding of 64-bit PAR

bits(6) <anchor link="AArch32.PARFaultStatusLD.1" hover="function: bits(6) AArch32.PARFaultStatusLD(FaultRecord fault)">AArch32.PARFaultStatusLD</anchor>(<a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    bits(32) syndrome;

    if fault.statuscode == <a link="Fault_Domain" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Domain</a> then
        // Report Domain fault
        assert fault.level IN {1,2};
        syndrome&lt;1:0&gt; = if fault.level == 1 then '01' else '10';
        syndrome&lt;5:2&gt; = '1111';
    else
        syndrome = <a link="AArch32.FaultStatusLD.2" file="shared_pseudocode.xml" hover="function: bits(32) AArch32.FaultStatusLD(boolean d_side, FaultRecord fault)">AArch32.FaultStatusLD</a>(TRUE, fault);
    return syndrome&lt;5:0&gt;;</pstext>
    </ps>
    <ps name="aarch32/at/AArch32.PARFaultStatusSD" mylink="aarch32.at.AArch32.PARFaultStatusSD" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.PARFaultStatusSD()
// ==========================
// Fault status field decoding of 32-bit PAR.

bits(6) <anchor link="AArch32.PARFaultStatusSD.1" hover="function: bits(6) AArch32.PARFaultStatusSD(FaultRecord fault)">AArch32.PARFaultStatusSD</anchor>(<a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    bits(32) syndrome;

    syndrome = <a link="AArch32.FaultStatusSD.2" file="shared_pseudocode.xml" hover="function: bits(32) AArch32.FaultStatusSD(boolean d_side, FaultRecord fault)">AArch32.FaultStatusSD</a>(TRUE, fault);
    return syndrome&lt;12,10,3:0&gt;;</pstext>
    </ps>
    <ps name="aarch32/at/AArch32.PARInnerAttrs" mylink="aarch32.at.AArch32.PARInnerAttrs" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.PARInnerAttrs()
// =======================
// Convert orthogonal attributes and hints to 32-bit PAR Inner field.

bits(3) <anchor link="AArch32.PARInnerAttrs.1" hover="function: bits(3) AArch32.PARInnerAttrs(MemoryAttributes memattrs)">AArch32.PARInnerAttrs</anchor>(<a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs)
    bits(3) result;

    if memattrs.memtype == <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
        if memattrs.device == <a link="DeviceType_nGnRnE" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a> then
            result = '001'; // Non-cacheable
        elsif memattrs.device == <a link="DeviceType_nGnRE" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRE</a> then
            result = '011'; // Non-cacheable
    else
        <a link="MemAttrHints" file="shared_pseudocode.xml" hover="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> inner = memattrs.inner;
        if inner.attrs == <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> then
            result = '000'; // Non-cacheable
        elsif inner.attrs == <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp; inner.hints&lt;0&gt; == '1' then
            result = '101'; // Write-Back, Write-Allocate
        elsif inner.attrs == <a link="MemAttr_WT" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a> then
            result = '110'; // Write-Through
        elsif inner.attrs == <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp; inner.hints&lt;0&gt; == '0' then
            result = '111'; // Write-Back, no Write-Allocate
    return result;</pstext>
    </ps>
    <ps name="aarch32/at/AArch32.PAROuterAttrs" mylink="aarch32.at.AArch32.PAROuterAttrs" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.PAROuterAttrs()
// =======================
// Convert orthogonal attributes and hints to 32-bit PAR Outer field.

bits(2) <anchor link="AArch32.PAROuterAttrs.1" hover="function: bits(2) AArch32.PAROuterAttrs(MemoryAttributes memattrs)">AArch32.PAROuterAttrs</anchor>(<a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs)
    bits(2) result;

    if memattrs.memtype == <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
        result = bits(2) UNKNOWN;
    else
        <a link="MemAttrHints" file="shared_pseudocode.xml" hover="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> outer = memattrs.outer;
        if outer.attrs == <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> then
            result = '00'; // Non-cacheable
        elsif outer.attrs == <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp; outer.hints&lt;0&gt; == '1' then
            result = '01'; // Write-Back, Write-Allocate
        elsif outer.attrs == <a link="MemAttr_WT" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a> &amp;&amp; outer.hints&lt;0&gt; == '0' then
            result = '10'; // Write-Through, no Write-Allocate
        elsif outer.attrs == <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp; outer.hints&lt;0&gt; == '0' then
            result = '11'; // Write-Back, no Write-Allocate
    return result;</pstext>
    </ps>
    <ps name="aarch32/dc/AArch32.DC" mylink="aarch32.dc.AArch32.DC" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.DC()
// ============
// Perform Data Cache Operation.

<anchor link="AArch32.DC.3" hover="function: AArch32.DC(bits(32) regval, CacheOp cacheop, CacheOpScope opscope)">AArch32.DC</anchor>(bits(32) regval, <a link="CacheOp" file="shared_pseudocode.xml" hover="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp</a> cacheop, <a link="CacheOpScope" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a> opscope)
    <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype = <a link="AccType_DC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>;
    <a link="CacheRecord" file="shared_pseudocode.xml" hover="type CacheRecord is ( AccType acctype, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, bits(64) regval, FullAddress paddress, bits(64) vaddress, integer set, integer way, integer level, Shareability shareability, boolean translated, boolean is_vmid_valid, bits(16) vmid, boolean is_asid_valid, bits(16) asid, SecurityState security, CachePASpace cpas )">CacheRecord</a> cache;

    cache.acctype = acctype;
    cache.cacheop = cacheop;
    cache.opscope = opscope;
    cache.cachetype = <a link="CacheType_Data" file="shared_pseudocode.xml" hover="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType_Data</a>;
    cache.security = <a link="impl-shared.SecurityStateAtEL.1" file="shared_pseudocode.xml" hover="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(PSTATE.EL);

    if opscope == <a link="CacheOpScope_SetWay" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_SetWay</a> then
        cache.shareability = <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        (cache.set, cache.way, cache.level) = <a link="impl-shared.DecodeSW.2" file="shared_pseudocode.xml" hover="function: (integer, integer, integer) DecodeSW(bits(64) regval, CacheType cachetype)">DecodeSW</a>(<a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(regval), <a link="CacheType_Data" file="shared_pseudocode.xml" hover="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType_Data</a>);

        if (cacheop == <a link="CacheOp_Invalidate" file="shared_pseudocode.xml" hover="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Invalidate</a> &amp;&amp; PSTATE.EL == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
          ((!<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR_EL2.SWIO == '1') || (<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR.SWIO == '1') ||
          (!<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR_EL2.&lt;DC,VM&gt; != '00') || (<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR.&lt;DC,VM&gt; != '00'))) then
            cache.cacheop = <a link="CacheOp_CleanInvalidate" file="shared_pseudocode.xml" hover="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_CleanInvalidate</a>;
        <a link="impl-shared.CACHE_OP.1" file="shared_pseudocode.xml" hover="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
        return;

    if <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} then
            cache.is_vmid_valid = TRUE;
            cache.vmid          = VMID[];
        else
            cache.is_vmid_valid = FALSE;
    else
        cache.is_vmid_valid = FALSE;

    if PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then
        cache.is_asid_valid = TRUE;
        cache.asid          = <a link="impl-shared.ASID.read.0" file="shared_pseudocode.xml" hover="accessor: bits(16) ASID[]">ASID</a>[];
    else
        cache.is_asid_valid = FALSE;

    need_translate = <a link="impl-shared.DCInstNeedsTranslation.1" file="shared_pseudocode.xml" hover="function: boolean DCInstNeedsTranslation(CacheOpScope opscope)">DCInstNeedsTranslation</a>(opscope);
    iswrite = cacheop == <a link="CacheOp_Invalidate" file="shared_pseudocode.xml" hover="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Invalidate</a>;
    vaddress = regval;

    size = 0;        // by default no watchpoint address
    if iswrite then
        size = integer IMPLEMENTATION_DEFINED "Data Cache Invalidate Watchpoint Size";
        assert size &gt;= 4*(2^(<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(CTR_EL0.DminLine))) &amp;&amp; size &lt;= 2048;
        assert <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(size&lt;32:0&gt; AND (size-1)&lt;32:0&gt;) == 0; // size is power of 2
        vaddress = <a link="impl-shared.Align.2" file="shared_pseudocode.xml" hover="function: integer Align(integer x, integer y)">Align</a>(regval, size);

    cache.translated = need_translate;
    cache.vaddress = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(vaddress);

    if need_translate then
        wasaligned = TRUE;
        memaddrdesc = <a link="AArch32.TranslateAddress.5" file="shared_pseudocode.xml" hover="function: AddressDescriptor AArch32.TranslateAddress(bits(32) va, AccType acctype,&#13; boolean iswrite, boolean aligned,&#13; integer size)">AArch32.TranslateAddress</a>(vaddress, acctype, iswrite, wasaligned, size);
        if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
            <a link="AArch32.Abort.2" file="shared_pseudocode.xml" hover="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(regval, memaddrdesc.fault);

        memattrs = memaddrdesc.memattrs;
        cache.paddress = memaddrdesc.paddress;
        if opscope == <a link="CacheOpScope_PoC" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoC</a> then
            cache.shareability = memattrs.shareability;
        else
            cache.shareability = <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
    else
        cache.shareability = <a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> UNKNOWN;
        cache.paddress = <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> UNKNOWN;

    if (cacheop == <a link="CacheOp_Invalidate" file="shared_pseudocode.xml" hover="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Invalidate</a> &amp;&amp; PSTATE.EL == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>()
      &amp;&amp; ((!<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR_EL2.&lt;DC,VM&gt; != '00') || (<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR.&lt;DC,VM&gt; != '00'))) then
        cache.cacheop = <a link="CacheOp_CleanInvalidate" file="shared_pseudocode.xml" hover="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_CleanInvalidate</a>;

    <a link="impl-shared.CACHE_OP.1" file="shared_pseudocode.xml" hover="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
    return;</pstext>
    </ps>
    <ps name="aarch32/debug/VCRMatch/AArch32.VCRMatch" mylink="aarch32.debug.VCRMatch.AArch32.VCRMatch" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.VCRMatch()
// ==================

boolean <anchor link="AArch32.VCRMatch.1" hover="function: boolean AArch32.VCRMatch(bits(32) vaddress)">AArch32.VCRMatch</anchor>(bits(32) vaddress)

    boolean match;
    if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; PSTATE.EL != <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then
        // Each bit position in this string corresponds to a bit in DBGVCR and an exception vector.
        match_word = <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(32);

        if vaddress&lt;31:5&gt; == <a link="impl-aarch32.ExcVectorBase.0" file="shared_pseudocode.xml" hover="function: bits(32) ExcVectorBase()">ExcVectorBase</a>()&lt;31:5&gt; then
            if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>() then
                match_word&lt;<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(vaddress&lt;4:2&gt;) + 24&gt; = '1';     // Non-secure vectors
            else
                match_word&lt;<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(vaddress&lt;4:2&gt;) + 0&gt; = '1';      // Secure vectors (or no EL3)

        if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>() &amp;&amp; vaddress&lt;31:5&gt; == MVBAR&lt;31:5&gt; then
            match_word&lt;<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(vaddress&lt;4:2&gt;) + 8&gt; = '1';          // Monitor vectors

        // Mask out bits not corresponding to vectors.
        bits(32) mask;
        if !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
            mask = '00000000':'00000000':'00000000':'11011110'; // DBGVCR[31:8] are RES0
        elsif !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
            mask = '11011110':'00000000':'00000000':'11011110'; // DBGVCR[15:8] are RES0
        else
            mask = '11011110':'00000000':'11011100':'11011110';

        match_word = match_word AND DBGVCR AND mask;
        match = !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(match_word);

        // Check for UNPREDICTABLE case - match on Prefetch Abort and Data Abort vectors
        if !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(match_word&lt;28:27,12:11,4:3&gt;) &amp;&amp; <a link="impl-shared.DebugTarget.0" file="shared_pseudocode.xml" hover="function: bits(2) DebugTarget()">DebugTarget</a>() == PSTATE.EL then
            match = <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_VCMATCHDAPA" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_VCMATCHDAPA</a>);

        if !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(vaddress&lt;1:0&gt;) &amp;&amp; match then
            match = <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_VCMATCHHALF" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_VCMATCHHALF</a>);
    else
        match = FALSE;

    return match;</pstext>
    </ps>
    <ps name="aarch32/debug/authentication/AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled" mylink="aarch32.debug.authentication.AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled()
// ========================================================

boolean <anchor link="AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled.0" hover="function: boolean AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled()">AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled</anchor>()
    // The definition of this function is IMPLEMENTATION DEFINED.
    // In the recommended interface, AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled returns
    // the state of the (DBGEN AND SPIDEN) signal.
    if !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>() then return FALSE;
    return DBGEN == HIGH &amp;&amp; SPIDEN == HIGH;</pstext>
    </ps>
    <ps name="aarch32/debug/breakpoint/AArch32.BreakpointMatch" mylink="aarch32.debug.breakpoint.AArch32.BreakpointMatch" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.BreakpointMatch()
// =========================
// Breakpoint matching in an AArch32 translation regime.

(boolean,boolean) <anchor link="AArch32.BreakpointMatch.3" hover="function: (boolean,boolean) AArch32.BreakpointMatch(integer n, bits(32) vaddress,&#13; integer size)">AArch32.BreakpointMatch</anchor>(integer n, bits(32) vaddress,
                                 integer size)
    assert <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());
    assert n &lt; <a link="impl-shared.NumBreakpointsImplemented.0" file="shared_pseudocode.xml" hover="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>();

    enabled = DBGBCR[n].E == '1';
    ispriv = PSTATE.EL != <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>;
    linked = DBGBCR[n].BT == '0x01';
    isbreakpnt = TRUE;
    linked_to = FALSE;

    state_match = <a link="AArch32.StateMatch.7" file="shared_pseudocode.xml" hover="function: boolean AArch32.StateMatch(bits(2) SSC_in,  bit HMC_in,&#13; bits(2) PxC_in, boolean linked_in, bits(4) LBN,&#13; boolean isbreakpnt,  boolean ispriv)">AArch32.StateMatch</a>(DBGBCR[n].SSC, DBGBCR[n].HMC, DBGBCR[n].PMC,
                                     linked, DBGBCR[n].LBN, isbreakpnt,  ispriv);
    (value_match, value_mismatch) = <a link="AArch32.BreakpointValueMatch.3" file="shared_pseudocode.xml" hover="function: (boolean,boolean) AArch32.BreakpointValueMatch(integer n_in, bits(32) vaddress, boolean linked_to)">AArch32.BreakpointValueMatch</a>(n, vaddress, linked_to);

    if size == 4 then                    // Check second halfword
        // If the breakpoint address and BAS of an Address breakpoint match the address of the
        // second halfword of an instruction, but not the address of the first halfword, it is
        // CONSTRAINED UNPREDICTABLE whether or not this breakpoint generates a Breakpoint debug
        // event.
        (match_i, mismatch_i) = <a link="AArch32.BreakpointValueMatch.3" file="shared_pseudocode.xml" hover="function: (boolean,boolean) AArch32.BreakpointValueMatch(integer n_in, bits(32) vaddress, boolean linked_to)">AArch32.BreakpointValueMatch</a>(n, vaddress + 2, linked_to);
        if !value_match &amp;&amp; match_i then
            value_match = <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_BPMATCHHALF" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_BPMATCHHALF</a>);
        if value_mismatch &amp;&amp; !mismatch_i then
            value_mismatch = <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_BPMISMATCHHALF" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_BPMISMATCHHALF</a>);
    if vaddress&lt;1&gt; == '1' &amp;&amp; DBGBCR[n].BAS == '1111' then
        // The above notwithstanding, if DBGBCR[n].BAS == '1111', then it is CONSTRAINED
        // UNPREDICTABLE whether or not a Breakpoint debug event is generated for an instruction
        // at the address DBGBVR[n]+2.
        if value_match then value_match = <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_BPMATCHHALF" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_BPMATCHHALF</a>);
        if !value_mismatch then value_mismatch = <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_BPMISMATCHHALF" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_BPMISMATCHHALF</a>);

    match = value_match &amp;&amp; state_match &amp;&amp; enabled;
    mismatch = value_mismatch &amp;&amp; state_match &amp;&amp; enabled;

    return (match, mismatch);</pstext>
    </ps>
    <ps name="aarch32/debug/breakpoint/AArch32.BreakpointValueMatch" mylink="aarch32.debug.breakpoint.AArch32.BreakpointValueMatch" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.BreakpointValueMatch()
// ==============================
// The first result is whether an Address Match or Context breakpoint is programmed on the
// instruction at "address". The second result is whether an Address Mismatch breakpoint is
// programmed on the instruction, that is, whether the instruction should be stepped.

(boolean,boolean) <anchor link="AArch32.BreakpointValueMatch.3" hover="function: (boolean,boolean) AArch32.BreakpointValueMatch(integer n_in, bits(32) vaddress, boolean linked_to)">AArch32.BreakpointValueMatch</anchor>(integer n_in, bits(32) vaddress, boolean linked_to)

    // "n" is the identity of the breakpoint unit to match against.
    // "vaddress" is the current instruction address, ignored if linked_to is TRUE and for Context
    //   matching breakpoints.
    // "linked_to" is TRUE if this is a call from StateMatch for linking.
    integer n = n_in;

    // If a non-existent breakpoint then it is CONSTRAINED UNPREDICTABLE whether this gives
    // no match or the breakpoint is mapped to another UNKNOWN implemented breakpoint.
    if n &gt;= <a link="impl-shared.NumBreakpointsImplemented.0" file="shared_pseudocode.xml" hover="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() then
        <a link="Constraint" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint</a> c;
        (c, n) = <a link="impl-shared.ConstrainUnpredictableInteger.3" file="shared_pseudocode.xml" hover="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high, Unpredictable which)">ConstrainUnpredictableInteger</a>(0, <a link="impl-shared.NumBreakpointsImplemented.0" file="shared_pseudocode.xml" hover="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() - 1, <a link="Unpredictable_BPNOTIMPL" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_BPNOTIMPL</a>);
        assert c IN {<a link="Constraint_DISABLED" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>, <a link="Constraint_UNKNOWN" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>};
        if c == <a link="Constraint_DISABLED" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a> then return (FALSE,FALSE);

    // If this breakpoint is not enabled, it cannot generate a match. (This could also happen on a
    // call from StateMatch for linking).
    if DBGBCR[n].E == '0' then return (FALSE,FALSE);

    context_aware = (n &gt;= (<a link="impl-shared.NumBreakpointsImplemented.0" file="shared_pseudocode.xml" hover="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() - <a link="impl-shared.NumContextAwareBreakpointsImplemented.0" file="shared_pseudocode.xml" hover="function: integer NumContextAwareBreakpointsImplemented()">NumContextAwareBreakpointsImplemented</a>()));

    // If BT is set to a reserved type, behaves either as disabled or as a not-reserved type.
    dbgtype = DBGBCR[n].BT;

    if ((dbgtype IN {'011x','11xx'} &amp;&amp; !<a link="impl-shared.HaveVirtHostExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; !<a link="impl-shared.HaveV82Debug.0" file="shared_pseudocode.xml" hover="function: boolean HaveV82Debug()">HaveV82Debug</a>()) ||    // Context matching
          (dbgtype == '010x' &amp;&amp; <a link="impl-shared.HaltOnBreakpointOrWatchpoint.0" file="shared_pseudocode.xml" hover="function: boolean HaltOnBreakpointOrWatchpoint()">HaltOnBreakpointOrWatchpoint</a>()) ||                  // Address mismatch
          (dbgtype != '0x0x' &amp;&amp; !context_aware) ||                                  // Context matching
          (dbgtype == '1xxx' &amp;&amp; !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>))) then                                 // EL2 extension
        (c, dbgtype) = <a link="impl-shared.ConstrainUnpredictableBits.1" file="shared_pseudocode.xml" hover="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a link="Unpredictable_RESBPTYPE" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESBPTYPE</a>);
        assert c IN {<a link="Constraint_DISABLED" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>, <a link="Constraint_UNKNOWN" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>};
        if c == <a link="Constraint_DISABLED" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a> then return (FALSE,FALSE);
        // Otherwise the value returned by ConstrainUnpredictableBits must be a not-reserved value

    // Determine what to compare against.
    match_addr = (dbgtype == '0x0x');
    mismatch   = (dbgtype == '010x');
    match_vmid = (dbgtype == '10xx');
    match_cid1 = (dbgtype == 'xx1x');
    match_cid2 = (dbgtype == '11xx');
    linked     = (dbgtype == 'xxx1');

    // If this is a call from StateMatch, return FALSE if the breakpoint is not programmed for a
    // VMID and/or context ID match, of if not context-aware. The above assertions mean that the
    // code can just test for match_addr == TRUE to confirm all these things.
    if linked_to &amp;&amp; (!linked || match_addr) then return (FALSE,FALSE);

    // If called from BreakpointMatch return FALSE for Linked context ID and/or VMID matches.
    if !linked_to &amp;&amp; linked &amp;&amp; !match_addr then return (FALSE,FALSE);

    // Do the comparison.
    boolean BVR_match;
    if match_addr then
        boolean byte_select_match;
        byte = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(vaddress&lt;1:0&gt;);
        assert byte IN {0,2};                     // "vaddress" is halfword aligned
        byte_select_match = (DBGBCR[n].BAS&lt;byte&gt; == '1');
        integer top = 31;
        BVR_match = (vaddress&lt;top:2&gt; == DBGBVR[n]&lt;top:2&gt;) &amp;&amp; byte_select_match;

    elsif match_cid1 then
        BVR_match = (PSTATE.EL != <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; CONTEXTIDR == DBGBVR[n]&lt;31:0&gt;);
    boolean BXVR_match;
    if match_vmid then
        bits(16) vmid;
        bits(16) bvr_vmid;
        if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
            vmid = <a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(VTTBR.VMID, 16);
            bvr_vmid = <a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(DBGBXVR[n]&lt;7:0&gt;, 16);
        elsif !<a link="impl-shared.Have16bitVMID.0" file="shared_pseudocode.xml" hover="function: boolean Have16bitVMID()">Have16bitVMID</a>() || VTCR_EL2.VS == '0' then
            vmid = <a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(VTTBR_EL2.VMID&lt;7:0&gt;, 16);
            bvr_vmid = <a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(DBGBXVR[n]&lt;7:0&gt;, 16);
        else
            vmid = VTTBR_EL2.VMID;
            bvr_vmid = DBGBXVR[n]&lt;15:0&gt;;
        BXVR_match = (PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                      vmid == bvr_vmid);
    elsif match_cid2 then
        BXVR_match = (PSTATE.EL != <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> &amp;&amp; (<a link="impl-shared.HaveVirtHostExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() || <a link="impl-shared.HaveV82Debug.0" file="shared_pseudocode.xml" hover="function: boolean HaveV82Debug()">HaveV82Debug</a>()) &amp;&amp;
                      <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                      !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp;
                      DBGBXVR[n]&lt;31:0&gt; == CONTEXTIDR_EL2&lt;31:0&gt;);

    bvr_match_valid = (match_addr || match_cid1);
    bxvr_match_valid = (match_vmid || match_cid2);

    match = (!bxvr_match_valid || BXVR_match) &amp;&amp; (!bvr_match_valid || BVR_match);

    return (match &amp;&amp; !mismatch, !match &amp;&amp; mismatch);</pstext>
    </ps>
    <ps name="aarch32/debug/breakpoint/AArch32.StateMatch" mylink="aarch32.debug.breakpoint.AArch32.StateMatch" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.StateMatch()
// ====================
// Determine whether a breakpoint or watchpoint is enabled in the current mode and state.

boolean <anchor link="AArch32.StateMatch.7" hover="function: boolean AArch32.StateMatch(bits(2) SSC_in,  bit HMC_in,&#13; bits(2) PxC_in, boolean linked_in, bits(4) LBN,&#13; boolean isbreakpnt,  boolean ispriv)">AArch32.StateMatch</anchor>(bits(2) SSC_in,  bit HMC_in,
                           bits(2) PxC_in, boolean linked_in, bits(4) LBN,
                           boolean isbreakpnt,  boolean ispriv)

    // "SSC_in","HMC_in","PxC_in" are the control fields from the DBGBCR[n] or DBGWCR[n] register.
    // "linked_in" is TRUE if this is a linked breakpoint/watchpoint type.
    // "LBN" is the linked breakpoint number from the DBGBCR[n] or DBGWCR[n] register.
    // "isbreakpnt" is TRUE for breakpoints, FALSE for watchpoints.
    // "ispriv" is valid for watchpoints, and selects between privileged and unprivileged accesses.
    bits(2) SSC = SSC_in;
    bit HMC = HMC_in;
    bits(2) PxC = PxC_in;
    boolean linked = linked_in;

    // If parameters are set to a reserved type, behaves as either disabled or a defined type
    <a link="Constraint" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint</a> c;
    (c, SSC, HMC, PxC) = <a link="impl-shared.CheckValidStateMatch.4" file="shared_pseudocode.xml" hover="function: (Constraint, bits(2), bit, bits(2)) CheckValidStateMatch(bits(2) SSC_in, bit HMC_in, bits(2) PxC_in,&#13; boolean isbreakpnt)">CheckValidStateMatch</a>(SSC, HMC, PxC, isbreakpnt);
    if c == <a link="Constraint_DISABLED" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a> then return FALSE;
    // Otherwise the HMC,SSC,PxC values are either valid or the values returned by
    // CheckValidStateMatch are valid.

    PL2_match = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; ((HMC == '1' &amp;&amp; (SSC:PxC != '1000')) || SSC == '11');
    PL1_match = PxC&lt;0&gt; == '1';
    PL0_match = PxC&lt;1&gt; == '1';
    SSU_match = isbreakpnt &amp;&amp; HMC == '0' &amp;&amp; PxC == '00' &amp;&amp; SSC != '11';

    boolean priv_match;
    if !ispriv &amp;&amp; !isbreakpnt then
        priv_match = PL0_match;
    elsif SSU_match then
        priv_match = PSTATE.M IN {<a link="M32_User" file="shared_pseudocode.xml" hover="constant bits(5) M32_User = '10000'">M32_User</a>,<a link="M32_Svc" file="shared_pseudocode.xml" hover="constant bits(5) M32_Svc = '10011'">M32_Svc</a>,<a link="M32_System" file="shared_pseudocode.xml" hover="constant bits(5) M32_System = '11111'">M32_System</a>};
    else
        case PSTATE.EL of
            when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>  priv_match = PL1_match;           // EL3 and EL1 are both PL1
            when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>  priv_match = PL2_match;
            when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>  priv_match = PL1_match;
            when <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>  priv_match = PL0_match;

    boolean security_state_match;
    ss = <a link="impl-shared.CurrentSecurityState.0" file="shared_pseudocode.xml" hover="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>();
    case SSC of
        when '00' security_state_match = TRUE;                             // Both
        when '01' security_state_match = ss == <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a>;               // Non-secure only
        when '10' security_state_match = ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>;                  // Secure only
        when '11' security_state_match = (HMC == '1' || ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>);  // HMC=1 -&gt; Both, 0 -&gt; Secure only
    integer lbn;
    if linked then
        // "LBN" must be an enabled context-aware breakpoint unit. If it is not context-aware then
        // it is CONSTRAINED UNPREDICTABLE whether this gives no match, or LBN is mapped to some
        // UNKNOWN breakpoint that is context-aware.
        lbn = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(LBN);
        first_ctx_cmp = <a link="impl-shared.NumBreakpointsImplemented.0" file="shared_pseudocode.xml" hover="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() - <a link="impl-shared.NumContextAwareBreakpointsImplemented.0" file="shared_pseudocode.xml" hover="function: integer NumContextAwareBreakpointsImplemented()">NumContextAwareBreakpointsImplemented</a>();
        last_ctx_cmp = <a link="impl-shared.NumBreakpointsImplemented.0" file="shared_pseudocode.xml" hover="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() - 1;
        if (lbn &lt; first_ctx_cmp || lbn &gt; last_ctx_cmp) then
            (c, lbn) = <a link="impl-shared.ConstrainUnpredictableInteger.3" file="shared_pseudocode.xml" hover="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high, Unpredictable which)">ConstrainUnpredictableInteger</a>(first_ctx_cmp, last_ctx_cmp, <a link="Unpredictable_BPNOTCTXCMP" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_BPNOTCTXCMP</a>);
            assert c IN {<a link="Constraint_DISABLED" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>, <a link="Constraint_NONE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>, <a link="Constraint_UNKNOWN" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>};
            case c of
                when <a link="Constraint_DISABLED" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>  return FALSE;      // Disabled
                when <a link="Constraint_NONE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>      linked = FALSE;    // No linking
                // Otherwise ConstrainUnpredictableInteger returned a context-aware breakpoint

    boolean linked_match;
    if linked then
        vaddress = bits(32) UNKNOWN;
        linked_to = TRUE;
        (linked_match,-) = <a link="AArch32.BreakpointValueMatch.3" file="shared_pseudocode.xml" hover="function: (boolean,boolean) AArch32.BreakpointValueMatch(integer n_in, bits(32) vaddress, boolean linked_to)">AArch32.BreakpointValueMatch</a>(lbn, vaddress, linked_to);

    return priv_match &amp;&amp; security_state_match &amp;&amp; (!linked || linked_match);</pstext>
    </ps>
    <ps name="aarch32/debug/enables/AArch32.GenerateDebugExceptions" mylink="aarch32.debug.enables.AArch32.GenerateDebugExceptions" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.GenerateDebugExceptions()
// =================================

boolean <anchor link="AArch32.GenerateDebugExceptions.0" hover="function: boolean AArch32.GenerateDebugExceptions()">AArch32.GenerateDebugExceptions</anchor>()
    return <a link="AArch32.GenerateDebugExceptionsFrom.2" file="shared_pseudocode.xml" hover="function: boolean AArch32.GenerateDebugExceptionsFrom(bits(2) from, boolean secure)">AArch32.GenerateDebugExceptionsFrom</a>(PSTATE.EL, <a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>());</pstext>
    </ps>
    <ps name="aarch32/debug/enables/AArch32.GenerateDebugExceptionsFrom" mylink="aarch32.debug.enables.AArch32.GenerateDebugExceptionsFrom" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.GenerateDebugExceptionsFrom()
// =====================================

boolean <anchor link="AArch32.GenerateDebugExceptionsFrom.2" hover="function: boolean AArch32.GenerateDebugExceptionsFrom(bits(2) from, boolean secure)">AArch32.GenerateDebugExceptionsFrom</anchor>(bits(2) from, boolean secure)

    if !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="impl-shared.DebugTargetFrom.1" file="shared_pseudocode.xml" hover="function: bits(2) DebugTargetFrom(boolean secure)">DebugTargetFrom</a>(secure)) then
        mask = '0';    // No PSTATE.D in AArch32 state
        return <a link="AArch64.GenerateDebugExceptionsFrom.3" file="shared_pseudocode.xml" hover="function: boolean AArch64.GenerateDebugExceptionsFrom(bits(2) from, boolean secure, bit mask)">AArch64.GenerateDebugExceptionsFrom</a>(from, secure, mask);

    if DBGOSLSR.OSLK == '1' || <a link="impl-shared.DoubleLockStatus.0" file="shared_pseudocode.xml" hover="function: boolean DoubleLockStatus()">DoubleLockStatus</a>() || <a link="impl-shared.Halted.0" file="shared_pseudocode.xml" hover="function: boolean Halted()">Halted</a>() then
        return FALSE;

    boolean enabled;
    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; secure then
        assert from != <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;    // Secure EL2 always uses AArch64
        if <a link="impl-shared.IsSecureEL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>() then
            // Implies that EL3 and EL2 both using AArch64
            enabled = MDCR_EL3.SDD == '0';
        else
            spd = if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then SDCR.SPD else MDCR_EL3.SPD32;
            if spd&lt;1&gt; == '1' then
                enabled = spd&lt;0&gt; == '1';
            else
                // SPD == 0b01 is reserved, but behaves the same as 0b00.
                enabled = <a link="AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled.0" file="shared_pseudocode.xml" hover="function: boolean AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled()">AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled</a>();
        if from == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then enabled = enabled || SDER.SUIDEN == '1';
    else
        enabled = from != <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;

    return enabled;</pstext>
    </ps>
    <ps name="aarch32/debug/pmu/AArch32.CheckForPMUOverflow" mylink="aarch32.debug.pmu.AArch32.CheckForPMUOverflow" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.CheckForPMUOverflow()
// =============================
// Signal Performance Monitors overflow IRQ and CTI overflow events

<anchor link="AArch32.CheckForPMUOverflow.0" hover="function: AArch32.CheckForPMUOverflow()">AArch32.CheckForPMUOverflow</anchor>()
    if !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then
        <a link="AArch64.CheckForPMUOverflow.0" file="shared_pseudocode.xml" hover="function: AArch64.CheckForPMUOverflow()">AArch64.CheckForPMUOverflow</a>();
        return;
    bit hpme;
    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
        hpme = if !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then MDCR_EL2.HPME else HDCR.HPME;
    boolean pmuirq;
    bit E;
    pmuirq = PMCR.E == '1' &amp;&amp; PMINTENSET.C == '1' &amp;&amp; PMOVSSET.C == '1';
    integer counters = <a link="impl-shared.GetNumEventCounters.0" file="shared_pseudocode.xml" hover="function: integer GetNumEventCounters()">GetNumEventCounters</a>();
    if counters != 0 then
        for idx = 0 to counters - 1
            E = if <a link="AArch32.PMUCounterIsHyp.1" file="shared_pseudocode.xml" hover="function: boolean AArch32.PMUCounterIsHyp(integer n)">AArch32.PMUCounterIsHyp</a>(idx) then hpme else PMCR.E;
            if E == '1' &amp;&amp; PMINTENSET&lt;idx&gt; == '1' &amp;&amp; PMOVSSET&lt;idx&gt; == '1' then pmuirq = TRUE;

    SetInterruptRequestLevel(<a link="InterruptID_PMUIRQ" file="shared_pseudocode.xml" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_PMUIRQ</a>, if pmuirq then HIGH else LOW);

    CTI_SetEventLevel(<a link="CrossTriggerIn_PMUOverflow" file="shared_pseudocode.xml" hover="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow,&#13; CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3,&#13; CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1,&#13; CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}">CrossTriggerIn_PMUOverflow</a>, if pmuirq then HIGH else LOW);

    // The request remains set until the condition is cleared. (For example, an interrupt handler
    // or cross-triggered event handler clears the overflow status flag by writing to PMOVSCLR.)</pstext>
    </ps>
    <ps name="aarch32/debug/pmu/AArch32.ClearEventCounters" mylink="aarch32.debug.pmu.AArch32.ClearEventCounters" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.ClearEventCounters()
// ============================
// Zero all the event counters.

<anchor link="AArch32.ClearEventCounters.0" hover="function: AArch32.ClearEventCounters()">AArch32.ClearEventCounters</anchor>()
    if <a link="impl-shared.HaveAArch64.0" file="shared_pseudocode.xml" hover="function: boolean HaveAArch64()">HaveAArch64</a>() then
        // Force the counter to be cleared as a 64-bit counter.
        <a link="AArch64.ClearEventCounters.0" file="shared_pseudocode.xml" hover="function: AArch64.ClearEventCounters()">AArch64.ClearEventCounters</a>();
        return;

    integer counters = <a link="AArch32.GetNumEventCountersAccessible.0" file="shared_pseudocode.xml" hover="function: integer AArch32.GetNumEventCountersAccessible()">AArch32.GetNumEventCountersAccessible</a>();
    if counters != 0 then
        for idx = 0 to counters - 1
            PMEVCNTR[idx] = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();</pstext>
    </ps>
    <ps name="aarch32/debug/pmu/AArch32.CountPMUEvents" mylink="aarch32.debug.pmu.AArch32.CountPMUEvents" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.CountPMUEvents()
// ========================
// Return TRUE if counter "idx" should count its event. For the cycle counter, idx == CYCLE_COUNTER_ID.

boolean <anchor link="AArch32.CountPMUEvents.1" hover="function: boolean AArch32.CountPMUEvents(integer idx)">AArch32.CountPMUEvents</anchor>(integer idx)
    assert idx == <a link="CYCLE_COUNTER_ID" file="shared_pseudocode.xml" hover="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> || idx &lt; <a link="impl-shared.GetNumEventCounters.0" file="shared_pseudocode.xml" hover="function: integer GetNumEventCounters()">GetNumEventCounters</a>();
    if !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then return <a link="AArch64.CountPMUEvents.1" file="shared_pseudocode.xml" hover="function: boolean AArch64.CountPMUEvents(integer idx)">AArch64.CountPMUEvents</a>(idx);
    boolean debug;
    boolean enabled;
    boolean prohibited;
    boolean filtered;
    boolean frozen;
    boolean resvd_for_el2;
    bit E;
    bit spme;
    bits(32) ovflws;
    // Event counting is disabled in Debug state
    debug = <a link="impl-shared.Halted.0" file="shared_pseudocode.xml" hover="function: boolean Halted()">Halted</a>();

    // Software can reserve some counters for EL2
    resvd_for_el2 = <a link="AArch32.PMUCounterIsHyp.1" file="shared_pseudocode.xml" hover="function: boolean AArch32.PMUCounterIsHyp(integer n)">AArch32.PMUCounterIsHyp</a>(idx);

    // Main enable controls
    if idx == <a link="CYCLE_COUNTER_ID" file="shared_pseudocode.xml" hover="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then
        enabled = PMCR.E == '1' &amp;&amp; PMCNTENSET.C == '1';
    else
        if resvd_for_el2 then
            E = if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then HDCR.HPME else MDCR_EL2.HPME;
        else
            E = PMCR.E;
        enabled = E == '1' &amp;&amp; PMCNTENSET&lt;idx&gt; == '1';

    // Event counting is allowed unless it is prohibited by any rule below
    prohibited = FALSE;

    // Event counting in Secure state is prohibited if all of:
    // * EL3 is implemented
    // * One of the following is true:
    //   - EL3 is using AArch64, MDCR_EL3.SPME == 0, and either:
    //     - FEAT_PMUv3p7 is not implemented
    //     - MDCR_EL3.MPMX == 0
    //   - EL3 is using AArch32 and SDCR.SPME == 0
    // * Not executing at EL0, or SDER.SUNIDEN == 0
    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>() then
        spme = if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then SDCR.SPME else MDCR_EL3.SPME;
        if !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a link="impl-shared.HavePMUv3p7.0" file="shared_pseudocode.xml" hover="function: boolean HavePMUv3p7()">HavePMUv3p7</a>() then
            prohibited = spme == '0' &amp;&amp; MDCR_EL3.MPMX == '0';
        else
            prohibited = spme == '0';
        if prohibited &amp;&amp; PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then
            prohibited = SDER.SUNIDEN == '0';

    // Event counting at EL2 is prohibited if all of:
    // * The HPMD Extension is implemented
    // * PMNx is not reserved for EL2
    // * HDCR.HPMD == 1
    if !prohibited &amp;&amp; PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; <a link="impl-shared.HaveHPMDExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveHPMDExt()">HaveHPMDExt</a>() &amp;&amp; !resvd_for_el2 then
        prohibited = HDCR.HPMD == '1';

    // The IMPLEMENTATION DEFINED authentication interface might override software
    if prohibited &amp;&amp; !<a link="impl-shared.HaveNoSecurePMUDisableOverride.0" file="shared_pseudocode.xml" hover="function: boolean HaveNoSecurePMUDisableOverride()">HaveNoSecurePMUDisableOverride</a>() then
        prohibited = !<a link="impl-shared.ExternalSecureNoninvasiveDebugEnabled.0" file="shared_pseudocode.xml" hover="function: boolean ExternalSecureNoninvasiveDebugEnabled()">ExternalSecureNoninvasiveDebugEnabled</a>();

    // Event counting might be frozen
    frozen = FALSE;

    // If FEAT_PMUv3p7 is implemented, event counting can be frozen
    if <a link="impl-shared.HavePMUv3p7.0" file="shared_pseudocode.xml" hover="function: boolean HavePMUv3p7()">HavePMUv3p7</a>() then
        if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
            hpmn = if !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then MDCR_EL2.HPMN else HDCR.HPMN;
        ovflws = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(PMOVSSET&lt;<a link="impl-shared.GetNumEventCounters.0" file="shared_pseudocode.xml" hover="function: integer GetNumEventCounters()">GetNumEventCounters</a>()-1:0&gt;);
        if resvd_for_el2 then
            FZ = if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then HDCR.HPMFZO else MDCR_EL2.HPMFZO;
            ovflws&lt;<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(hpmn)-1:0&gt; = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();
        else
            FZ = PMCR.FZO;
            if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(hpmn) &lt; <a link="impl-shared.GetNumEventCounters.0" file="shared_pseudocode.xml" hover="function: integer GetNumEventCounters()">GetNumEventCounters</a>() then
                ovflws&lt;<a link="impl-shared.GetNumEventCounters.0" file="shared_pseudocode.xml" hover="function: integer GetNumEventCounters()">GetNumEventCounters</a>()-1:<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(hpmn)&gt; = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();
        frozen = (FZ == '1') &amp;&amp; !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(ovflws);

    // PMCR.DP disables the cycle counter when event counting is prohibited
    if (prohibited || frozen) &amp;&amp; idx == <a link="CYCLE_COUNTER_ID" file="shared_pseudocode.xml" hover="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then
        enabled = enabled &amp;&amp; (PMCR.DP == '0');
        // Otherwise whether event counting is prohibited does not affect the cycle counter
        prohibited = FALSE;
        frozen = FALSE;

    // If FEAT_PMUv3p5 is implemented, cycle counting can be prohibited.
    // This is not overridden by PMCR.DP.
    if <a link="impl-shared.HavePMUv3p5.0" file="shared_pseudocode.xml" hover="function: boolean HavePMUv3p5()">HavePMUv3p5</a>() &amp;&amp; idx == <a link="CYCLE_COUNTER_ID" file="shared_pseudocode.xml" hover="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then
        if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>() then
            sccd = if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then SDCR.SCCD else MDCR_EL3.SCCD;
            if sccd == '1' then prohibited = TRUE;
        if PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; HDCR.HCCD == '1' then
            prohibited = TRUE;

    // Event counting can be filtered by the {P, U, NSK, NSU, NSH} bits
    filter = if idx == <a link="CYCLE_COUNTER_ID" file="shared_pseudocode.xml" hover="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then PMCCFILTR else PMEVTYPER[idx];

    P   = filter&lt;31&gt;;
    U   = filter&lt;30&gt;;
    NSK = if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then filter&lt;29&gt; else '0';
    NSU = if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then filter&lt;28&gt; else '0';
    NSH = if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then filter&lt;27&gt; else '0';

    ss = <a link="impl-shared.CurrentSecurityState.0" file="shared_pseudocode.xml" hover="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>();
    case PSTATE.EL of
        when <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> filtered = if ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> then U == '1' else U != NSU;
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> filtered = if ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> then P == '1' else P != NSK;
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> filtered = NSH == '0';
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> filtered = P == '1';

    return !debug &amp;&amp; enabled &amp;&amp; !prohibited &amp;&amp; !filtered &amp;&amp; !frozen;</pstext>
    </ps>
    <ps name="aarch32/debug/pmu/AArch32.GetNumEventCountersAccessible" mylink="aarch32.debug.pmu.AArch32.GetNumEventCountersAccessible" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.GetNumEventCountersAccessible()
// =======================================
// Return the number of event counters that can be accessed at the current Exception level.

integer <anchor link="AArch32.GetNumEventCountersAccessible.0" hover="function: integer AArch32.GetNumEventCountersAccessible()">AArch32.GetNumEventCountersAccessible</anchor>()
    integer n;
    integer total_counters = <a link="impl-shared.GetNumEventCounters.0" file="shared_pseudocode.xml" hover="function: integer GetNumEventCounters()">GetNumEventCounters</a>();
    // Software can reserve some counters for EL2
    if PSTATE.EL IN {<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>, <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() then
        n = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(if !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then MDCR_EL2.HPMN else HDCR.HPMN);
        if n &gt; total_counters || (!<a link="impl-shared.HaveFeatHPMN0.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatHPMN0()">HaveFeatHPMN0</a>() &amp;&amp; n == 0) then
            (-, n) = <a link="impl-shared.ConstrainUnpredictableInteger.3" file="shared_pseudocode.xml" hover="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high, Unpredictable which)">ConstrainUnpredictableInteger</a>(0, total_counters,
                                                   <a link="Unpredictable_PMUEVENTCOUNTER" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_PMUEVENTCOUNTER</a>);
    else
        n = total_counters;

    return n;</pstext>
    </ps>
    <ps name="aarch32/debug/pmu/AArch32.IncrementEventCounter" mylink="aarch32.debug.pmu.AArch32.IncrementEventCounter" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.IncrementEventCounter()
// ===============================
// Increment the specified event counter by the specified amount.

<anchor link="AArch32.IncrementEventCounter.2" hover="function: AArch32.IncrementEventCounter(integer idx, integer increment)">AArch32.IncrementEventCounter</anchor>(integer idx, integer increment)
    if <a link="impl-shared.HaveAArch64.0" file="shared_pseudocode.xml" hover="function: boolean HaveAArch64()">HaveAArch64</a>() then
        // Force the counter to be incremented as a 64-bit counter.
        <a link="AArch64.IncrementEventCounter.2" file="shared_pseudocode.xml" hover="function: AArch64.IncrementEventCounter(integer idx, integer increment)">AArch64.IncrementEventCounter</a>(idx, increment);
        return;

    // In this model, event counters in an AArch32-only implementation are 32 bits and
    // the LP bits are RES0 in this model, even if FEAT_PMUv3p5 is implemented.
    integer old_value;
    integer new_value;
    integer ovflw;
    bit lp;
    old_value = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PMEVCNTR[idx]);
    new_value = old_value + <a link="impl-shared.PMUCountValue.2" file="shared_pseudocode.xml" hover="function: integer PMUCountValue(integer n, integer V)">PMUCountValue</a>(idx, increment);

    PMEVCNTR[idx] = new_value&lt;31:0&gt;;
    ovflw = 32;

    if old_value&lt;64:ovflw&gt; != new_value&lt;64:ovflw&gt; then
        PMOVSSET&lt;idx&gt; = '1';
        PMOVSR&lt;idx&gt; = '1';
        // Check for the CHAIN event from an even counter
        if idx&lt;0&gt; == '0' &amp;&amp; idx + 1 &lt; <a link="impl-shared.GetNumEventCounters.0" file="shared_pseudocode.xml" hover="function: integer GetNumEventCounters()">GetNumEventCounters</a>() then
            <a link="impl-shared.PMUEvent.3" file="shared_pseudocode.xml" hover="function: PMUEvent(bits(16) event, integer increment, integer idx)">PMUEvent</a>(<a link="PMU_EVENT_CHAIN" file="shared_pseudocode.xml" hover="constant bits(16) PMU_EVENT_CHAIN = 0x001E&lt;15:0&gt;">PMU_EVENT_CHAIN</a>, 1, idx + 1);</pstext>
    </ps>
    <ps name="aarch32/debug/pmu/AArch32.PMUCounterIsHyp" mylink="aarch32.debug.pmu.AArch32.PMUCounterIsHyp" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.PMUCounterIsHyp
// =======================
// Returns TRUE if a counter is reserved for use by EL2, FALSE otherwise.

boolean <anchor link="AArch32.PMUCounterIsHyp.1" hover="function: boolean AArch32.PMUCounterIsHyp(integer n)">AArch32.PMUCounterIsHyp</anchor>(integer n)
    boolean resvd_for_el2;
    // Software can reserve some event counters for EL2
    if n != <a link="CYCLE_COUNTER_ID" file="shared_pseudocode.xml" hover="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> &amp;&amp; <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
        hpmn = if !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then MDCR_EL2.HPMN else HDCR.HPMN;
        resvd_for_el2 = n &gt;= <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(hpmn);
        if <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(hpmn) &gt; <a link="impl-shared.GetNumEventCounters.0" file="shared_pseudocode.xml" hover="function: integer GetNumEventCounters()">GetNumEventCounters</a>() || (!<a link="impl-shared.HaveFeatHPMN0.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatHPMN0()">HaveFeatHPMN0</a>() &amp;&amp; <a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(hpmn)) then
            resvd_for_el2 = boolean UNKNOWN;
    else
        resvd_for_el2 = FALSE;

    return resvd_for_el2;</pstext>
    </ps>
    <ps name="aarch32/debug/pmu/AArch32.PMUCycle" mylink="aarch32.debug.pmu.AArch32.PMUCycle" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.PMUCycle()
// ==================
// Called at the end of each cycle to increment event counters and
// check for PMU overflow. In pseudocode, a cycle ends after the
// execution of the operational pseudocode.

<anchor link="AArch32.PMUCycle.0" hover="function: AArch32.PMUCycle()">AArch32.PMUCycle</anchor>()
    if !<a link="impl-shared.HavePMUv3.0" file="shared_pseudocode.xml" hover="function: boolean HavePMUv3()">HavePMUv3</a>() then
        return;

    <a link="impl-shared.PMUEvent.1" file="shared_pseudocode.xml" hover="function: PMUEvent(bits(16) event)">PMUEvent</a>(<a link="PMU_EVENT_CPU_CYCLES" file="shared_pseudocode.xml" hover="constant bits(16) PMU_EVENT_CPU_CYCLES = 0x0011&lt;15:0&gt;">PMU_EVENT_CPU_CYCLES</a>);

    integer counters = <a link="impl-shared.GetNumEventCounters.0" file="shared_pseudocode.xml" hover="function: integer GetNumEventCounters()">GetNumEventCounters</a>();
    if counters != 0 then
        for idx = 0 to counters - 1
            if <a link="AArch32.CountPMUEvents.1" file="shared_pseudocode.xml" hover="function: boolean AArch32.CountPMUEvents(integer idx)">AArch32.CountPMUEvents</a>(idx) then
                accumulated = PMUEventAccumulator[idx];
                <a link="AArch32.IncrementEventCounter.2" file="shared_pseudocode.xml" hover="function: AArch32.IncrementEventCounter(integer idx, integer increment)">AArch32.IncrementEventCounter</a>(idx, accumulated);
            PMUEventAccumulator[idx] = 0;

    integer old_value;
    integer new_value;
    integer ovflw;
    if (<a link="AArch32.CountPMUEvents.1" file="shared_pseudocode.xml" hover="function: boolean AArch32.CountPMUEvents(integer idx)">AArch32.CountPMUEvents</a>(<a link="CYCLE_COUNTER_ID" file="shared_pseudocode.xml" hover="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a>) &amp;&amp;
        (PMCR.LC == '1' || PMCR.D == '0' || <a link="impl-shared.HasElapsed64Cycles.0" file="shared_pseudocode.xml" hover="function: boolean HasElapsed64Cycles()">HasElapsed64Cycles</a>())) then
        old_value = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PMCCNTR);
        new_value = old_value + 1;
        PMCCNTR = new_value&lt;63:0&gt;;

        ovflw = if PMCR.LC == '1' then 64 else 32;

        if old_value&lt;64:ovflw&gt; != new_value&lt;64:ovflw&gt; then
            PMOVSSET.C = '1';
            PMOVSR.C = '1';

    <a link="AArch32.CheckForPMUOverflow.0" file="shared_pseudocode.xml" hover="function: AArch32.CheckForPMUOverflow()">AArch32.CheckForPMUOverflow</a>();</pstext>
    </ps>
    <ps name="aarch32/debug/pmu/AArch32.PMUSwIncrement" mylink="aarch32.debug.pmu.AArch32.PMUSwIncrement" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.PMUSwIncrement()
// ========================
// Generate PMU Events on a write to PMSWINC.

<anchor link="AArch32.PMUSwIncrement.1" hover="function: AArch32.PMUSwIncrement(bits(32) sw_incr)">AArch32.PMUSwIncrement</anchor>(bits(32) sw_incr)
    integer counters = <a link="AArch32.GetNumEventCountersAccessible.0" file="shared_pseudocode.xml" hover="function: integer AArch32.GetNumEventCountersAccessible()">AArch32.GetNumEventCountersAccessible</a>();
    if counters != 0 then
        for idx = 0 to counters - 1
            if sw_incr&lt;idx&gt; == '1' then
                <a link="impl-shared.PMUEvent.3" file="shared_pseudocode.xml" hover="function: PMUEvent(bits(16) event, integer increment, integer idx)">PMUEvent</a>(<a link="PMU_EVENT_SW_INCR" file="shared_pseudocode.xml" hover="constant bits(16) PMU_EVENT_SW_INCR = 0x0000&lt;15:0&gt;">PMU_EVENT_SW_INCR</a>, 1, idx);</pstext>
    </ps>
    <ps name="aarch32/debug/takeexceptiondbg/AArch32.EnterHypModeInDebugState" mylink="aarch32.debug.takeexceptiondbg.AArch32.EnterHypModeInDebugState" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.EnterHypModeInDebugState()
// ==================================
// Take an exception in Debug state to Hyp mode.

<anchor link="AArch32.EnterHypModeInDebugState.1" hover="function: AArch32.EnterHypModeInDebugState(ExceptionRecord exception)">AArch32.EnterHypModeInDebugState</anchor>(<a link="ExceptionRecord" file="shared_pseudocode.xml" hover="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception)
    <a link="impl-shared.SynchronizeContext.0" file="shared_pseudocode.xml" hover="function: SynchronizeContext()">SynchronizeContext</a>();
    assert <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; !<a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>() &amp;&amp; <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>);

    <a link="AArch32.ReportHypEntry.1" file="shared_pseudocode.xml" hover="function: AArch32.ReportHypEntry(ExceptionRecord exception)">AArch32.ReportHypEntry</a>(exception);
    <a link="AArch32.WriteMode.1" file="shared_pseudocode.xml" hover="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a link="M32_Hyp" file="shared_pseudocode.xml" hover="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>);
    <a link="impl-shared.SPSR.write.0" file="shared_pseudocode.xml" hover="accessor: SPSR[] = bits(N) value">SPSR</a>[] = bits(32) UNKNOWN;
    ELR_hyp = bits(32) UNKNOWN;
    // In Debug state, the PE always execute T32 instructions when in AArch32 state, and
    // PSTATE.{SS,A,I,F} are not observable so behave as UNKNOWN.
    PSTATE.T = '1';                             // PSTATE.J is RES0
    PSTATE.&lt;SS,A,I,F&gt; = bits(4) UNKNOWN;
    DLR = bits(32) UNKNOWN;
    DSPSR = bits(32) UNKNOWN;
    PSTATE.E = HSCTLR.EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    if <a link="impl-shared.HaveSSBSExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = bit UNKNOWN;
    EDSCR.ERR = '1';
    <a link="impl-shared.UpdateEDSCRFields.0" file="shared_pseudocode.xml" hover="function: UpdateEDSCRFields()">UpdateEDSCRFields</a>();

    <a link="impl-shared.EndOfInstruction.0" file="shared_pseudocode.xml" hover="function: EndOfInstruction()">EndOfInstruction</a>();</pstext>
    </ps>
    <ps name="aarch32/debug/takeexceptiondbg/AArch32.EnterModeInDebugState" mylink="aarch32.debug.takeexceptiondbg.AArch32.EnterModeInDebugState" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.EnterModeInDebugState()
// ===============================
// Take an exception in Debug state to a mode other than Monitor and Hyp mode.

<anchor link="AArch32.EnterModeInDebugState.1" hover="function: AArch32.EnterModeInDebugState(bits(5) target_mode)">AArch32.EnterModeInDebugState</anchor>(bits(5) target_mode)
    <a link="impl-shared.SynchronizeContext.0" file="shared_pseudocode.xml" hover="function: SynchronizeContext()">SynchronizeContext</a>();
    assert <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; PSTATE.EL != <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;

    if PSTATE.M == <a link="M32_Monitor" file="shared_pseudocode.xml" hover="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then SCR.NS = '0';
    <a link="AArch32.WriteMode.1" file="shared_pseudocode.xml" hover="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(target_mode);
    <a link="impl-shared.SPSR.write.0" file="shared_pseudocode.xml" hover="accessor: SPSR[] = bits(N) value">SPSR</a>[] = bits(32) UNKNOWN;
    <a link="impl-aarch32.R.write.1" file="shared_pseudocode.xml" hover="accessor: R[integer n] = bits(32) value">R</a>[14] = bits(32) UNKNOWN;
    // In Debug state, the PE always execute T32 instructions when in AArch32 state, and
    // PSTATE.{SS,A,I,F} are not observable so behave as UNKNOWN.
    PSTATE.T = '1';                             // PSTATE.J is RES0
    PSTATE.&lt;SS,A,I,F&gt; = bits(4) UNKNOWN;
    DLR = bits(32) UNKNOWN;
    DSPSR = bits(32) UNKNOWN;
    PSTATE.E = SCTLR.EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    if <a link="impl-shared.HavePANExt.0" file="shared_pseudocode.xml" hover="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; SCTLR.SPAN == '0' then PSTATE.PAN = '1';
    if <a link="impl-shared.HaveSSBSExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = bit UNKNOWN;
    EDSCR.ERR = '1';
    <a link="impl-shared.UpdateEDSCRFields.0" file="shared_pseudocode.xml" hover="function: UpdateEDSCRFields()">UpdateEDSCRFields</a>();                        // Update EDSCR processor state flags.

    <a link="impl-shared.EndOfInstruction.0" file="shared_pseudocode.xml" hover="function: EndOfInstruction()">EndOfInstruction</a>();</pstext>
    </ps>
    <ps name="aarch32/debug/takeexceptiondbg/AArch32.EnterMonitorModeInDebugState" mylink="aarch32.debug.takeexceptiondbg.AArch32.EnterMonitorModeInDebugState" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.EnterMonitorModeInDebugState()
// ======================================
// Take an exception in Debug state to Monitor mode.

<anchor link="AArch32.EnterMonitorModeInDebugState.0" hover="function: AArch32.EnterMonitorModeInDebugState()">AArch32.EnterMonitorModeInDebugState</anchor>()
    <a link="impl-shared.SynchronizeContext.0" file="shared_pseudocode.xml" hover="function: SynchronizeContext()">SynchronizeContext</a>();
    assert <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>);
    from_secure = <a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>();
    if PSTATE.M == <a link="M32_Monitor" file="shared_pseudocode.xml" hover="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then SCR.NS = '0';
    <a link="AArch32.WriteMode.1" file="shared_pseudocode.xml" hover="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a link="M32_Monitor" file="shared_pseudocode.xml" hover="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>);
    <a link="impl-shared.SPSR.write.0" file="shared_pseudocode.xml" hover="accessor: SPSR[] = bits(N) value">SPSR</a>[] = bits(32) UNKNOWN;
    <a link="impl-aarch32.R.write.1" file="shared_pseudocode.xml" hover="accessor: R[integer n] = bits(32) value">R</a>[14] = bits(32) UNKNOWN;
    // In Debug state, the PE always execute T32 instructions when in AArch32 state, and
    // PSTATE.{SS,A,I,F} are not observable so behave as UNKNOWN.
    PSTATE.T = '1';                             // PSTATE.J is RES0
    PSTATE.&lt;SS,A,I,F&gt; = bits(4) UNKNOWN;
    PSTATE.E = SCTLR.EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    if <a link="impl-shared.HavePANExt.0" file="shared_pseudocode.xml" hover="function: boolean HavePANExt()">HavePANExt</a>() then
        if !from_secure then
            PSTATE.PAN = '0';
        elsif SCTLR.SPAN == '0' then
            PSTATE.PAN = '1';
    if <a link="impl-shared.HaveSSBSExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = bit UNKNOWN;
    DLR = bits(32) UNKNOWN;
    DSPSR = bits(32) UNKNOWN;
    EDSCR.ERR = '1';
    <a link="impl-shared.UpdateEDSCRFields.0" file="shared_pseudocode.xml" hover="function: UpdateEDSCRFields()">UpdateEDSCRFields</a>();                        // Update EDSCR processor state flags.

    <a link="impl-shared.EndOfInstruction.0" file="shared_pseudocode.xml" hover="function: EndOfInstruction()">EndOfInstruction</a>();</pstext>
    </ps>
    <ps name="aarch32/debug/watchpoint/AArch32.WatchpointByteMatch" mylink="aarch32.debug.watchpoint.AArch32.WatchpointByteMatch" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.WatchpointByteMatch()
// =============================

boolean <anchor link="AArch32.WatchpointByteMatch.2" hover="function: boolean AArch32.WatchpointByteMatch(integer n,  bits(32) vaddress)">AArch32.WatchpointByteMatch</anchor>(integer n,  bits(32) vaddress)

    integer top = 31;
    bottom = if DBGWVR[n]&lt;2&gt; == '1' then 2 else 3;            // Word or doubleword
    byte_select_match = (DBGWCR[n].BAS&lt;<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(vaddress&lt;bottom-1:0&gt;)&gt; != '0');
    mask = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(DBGWCR[n].MASK);

    // If DBGWCR[n].MASK is non-zero value and DBGWCR[n].BAS is not set to '11111111', or
    // DBGWCR[n].BAS specifies a non-contiguous set of bytes behavior is CONSTRAINED
    // UNPREDICTABLE.
    if mask &gt; 0 &amp;&amp; !<a link="impl-shared.IsOnes.1" file="shared_pseudocode.xml" hover="function: boolean IsOnes(bits(N) x)">IsOnes</a>(DBGWCR[n].BAS) then
        byte_select_match = <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_WPMASKANDBAS" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_WPMASKANDBAS</a>);
    else
        LSB = (DBGWCR[n].BAS AND NOT(DBGWCR[n].BAS - 1));  MSB = (DBGWCR[n].BAS + LSB);
        if !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(MSB AND (MSB - 1)) then                     // Not contiguous
            byte_select_match = <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_WPBASCONTIGUOUS" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_WPBASCONTIGUOUS</a>);
            bottom = 3;                                        // For the whole doubleword

    // If the address mask is set to a reserved value, the behavior is CONSTRAINED UNPREDICTABLE.
    if mask &gt; 0 &amp;&amp; mask &lt;= 2 then
        <a link="Constraint" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint</a> c;
        (c, mask) = <a link="impl-shared.ConstrainUnpredictableInteger.3" file="shared_pseudocode.xml" hover="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high, Unpredictable which)">ConstrainUnpredictableInteger</a>(3, 31, <a link="Unpredictable_RESWPMASK" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESWPMASK</a>);
        assert c IN {<a link="Constraint_DISABLED" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>, <a link="Constraint_NONE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>, <a link="Constraint_UNKNOWN" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>};
        case c of
            when <a link="Constraint_DISABLED" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>  return FALSE;            // Disabled
            when <a link="Constraint_NONE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>      mask = 0;                // No masking
            // Otherwise the value returned by ConstrainUnpredictableInteger is a not-reserved value

    boolean WVR_match;
    if mask &gt; bottom then
        // If the DBGxVR&lt;n&gt;_EL1.RESS field bits are not a sign extension of the MSB
        // of DBGBVR&lt;n&gt;_EL1.VA, it is UNPREDICTABLE whether they appear to be
        // included in the match.
        if !<a link="impl-shared.IsOnes.1" file="shared_pseudocode.xml" hover="function: boolean IsOnes(bits(N) x)">IsOnes</a>(DBGBVR_EL1[n]&lt;63:top&gt;) &amp;&amp; !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(DBGBVR_EL1[n]&lt;63:top&gt;) then
            if <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_DBGxVR_RESS" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_DBGxVR_RESS</a>) then
                top = 63;
        WVR_match = (vaddress&lt;top:mask&gt; == DBGWVR[n]&lt;top:mask&gt;);
        // If masked bits of DBGWVR_EL1[n] are not zero, the behavior is CONSTRAINED UNPREDICTABLE.
        if WVR_match &amp;&amp; !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(DBGWVR[n]&lt;mask-1:bottom&gt;) then
            WVR_match = <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_WPMASKEDBITS" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_WPMASKEDBITS</a>);
    else
        WVR_match = vaddress&lt;top:bottom&gt; == DBGWVR[n]&lt;top:bottom&gt;;

    return WVR_match &amp;&amp; byte_select_match;</pstext>
    </ps>
    <ps name="aarch32/debug/watchpoint/AArch32.WatchpointMatch" mylink="aarch32.debug.watchpoint.AArch32.WatchpointMatch" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.WatchpointMatch()
// =========================
// Watchpoint matching in an AArch32 translation regime.

boolean <anchor link="AArch32.WatchpointMatch.6" hover="function: boolean AArch32.WatchpointMatch(integer n, bits(32) vaddress, integer size, boolean ispriv,&#13; AccType acctype, boolean iswrite)">AArch32.WatchpointMatch</anchor>(integer n, bits(32) vaddress, integer size, boolean ispriv,
                                <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite)
    assert <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());
    assert n &lt; <a link="impl-shared.NumWatchpointsImplemented.0" file="shared_pseudocode.xml" hover="function: integer NumWatchpointsImplemented()">NumWatchpointsImplemented</a>();

    // "ispriv" is:
    //  * FALSE for all loads, stores, and atomic operations executed at EL0.
    //  * FALSE if the access is unprivileged.
    //  * TRUE for all other loads, stores, and atomic operations.

    enabled = DBGWCR[n].E == '1';
    linked = DBGWCR[n].WT == '1';
    isbreakpnt = FALSE;

    state_match = <a link="AArch32.StateMatch.7" file="shared_pseudocode.xml" hover="function: boolean AArch32.StateMatch(bits(2) SSC_in,  bit HMC_in,&#13; bits(2) PxC_in, boolean linked_in, bits(4) LBN,&#13; boolean isbreakpnt,  boolean ispriv)">AArch32.StateMatch</a>(DBGWCR[n].SSC, DBGWCR[n].HMC, DBGWCR[n].PAC,
                                     linked, DBGWCR[n].LBN, isbreakpnt,  ispriv);
    ls_match = FALSE;
    ls_match = (DBGWCR[n].LSC&lt;(if iswrite then 1 else 0)&gt; == '1');

    value_match = FALSE;
    for byte = 0 to size - 1
        value_match = value_match || <a link="AArch32.WatchpointByteMatch.2" file="shared_pseudocode.xml" hover="function: boolean AArch32.WatchpointByteMatch(integer n,  bits(32) vaddress)">AArch32.WatchpointByteMatch</a>(n,  vaddress + byte);

    return value_match &amp;&amp; state_match &amp;&amp; ls_match &amp;&amp; enabled;</pstext>
    </ps>
    <ps name="aarch32/exceptions/aborts/AArch32.Abort" mylink="aarch32.exceptions.aborts.AArch32.Abort" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.Abort()
// ===============
// Abort and Debug exception handling in an AArch32 translation regime.

<anchor link="AArch32.Abort.2" hover="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</anchor>(bits(32) vaddress, <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)

    // Check if routed to AArch64 state
    route_to_aarch64 = PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>);

    if !route_to_aarch64 &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
        route_to_aarch64 = (HCR_EL2.TGE == '1' || <a link="impl-shared.IsSecondStage.1" file="shared_pseudocode.xml" hover="function: boolean IsSecondStage(FaultRecord fault)">IsSecondStage</a>(fault) ||
                            (<a link="impl-shared.HaveRASExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; HCR_EL2.TEA == '1' &amp;&amp; <a link="impl-shared.IsExternalAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault)) ||
                            (<a link="impl-shared.IsDebugException.1" file="shared_pseudocode.xml" hover="function: boolean IsDebugException(FaultRecord fault)">IsDebugException</a>(fault) &amp;&amp; MDCR_EL2.TDE == '1'));

    if !route_to_aarch64 &amp;&amp; <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
        route_to_aarch64 = SCR_EL3.EA == '1' &amp;&amp; <a link="impl-shared.IsExternalAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault);

    if route_to_aarch64 then
        <a link="AArch64.Abort.2" file="shared_pseudocode.xml" hover="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(<a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(vaddress), fault);
    elsif fault.acctype == <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> then
        <a link="AArch32.TakePrefetchAbortException.2" file="shared_pseudocode.xml" hover="function: AArch32.TakePrefetchAbortException(bits(32) vaddress, FaultRecord fault)">AArch32.TakePrefetchAbortException</a>(vaddress, fault);
    else
        <a link="AArch32.TakeDataAbortException.2" file="shared_pseudocode.xml" hover="function: AArch32.TakeDataAbortException(bits(32) vaddress, FaultRecord fault)">AArch32.TakeDataAbortException</a>(vaddress, fault);</pstext>
    </ps>
    <ps name="aarch32/exceptions/aborts/AArch32.AbortSyndrome" mylink="aarch32.exceptions.aborts.AArch32.AbortSyndrome" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.AbortSyndrome()
// =======================
// Creates an exception syndrome record for Abort  exceptions taken to Hyp mode
// from an AArch32 translation regime.

ExceptionRecord <anchor link="AArch32.AbortSyndrome.3" hover="function: ExceptionRecord AArch32.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(32) vaddress)">AArch32.AbortSyndrome</anchor>(<a link="Exception" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception</a> exceptype, <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault, bits(32) vaddress)
    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(exceptype);

    d_side = exceptype == <a link="Exception_DataAbort" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>;

    exception.syndrome = <a link="AArch32.FaultSyndrome.2" file="shared_pseudocode.xml" hover="function: bits(25) AArch32.FaultSyndrome(boolean d_side, FaultRecord fault)">AArch32.FaultSyndrome</a>(d_side, fault);
    exception.vaddress = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(vaddress);
    if <a link="impl-shared.IPAValid.1" file="shared_pseudocode.xml" hover="function: boolean IPAValid(FaultRecord fault)">IPAValid</a>(fault) then
        exception.ipavalid = TRUE;
        exception.NS = if fault.ipaddress.paspace == <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a> then '1' else '0';
        exception.ipaddress = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(fault.ipaddress.address);
    else
        exception.ipavalid = FALSE;

    return exception;</pstext>
    </ps>
    <ps name="aarch32/exceptions/aborts/AArch32.CheckPCAlignment" mylink="aarch32.exceptions.aborts.AArch32.CheckPCAlignment" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.CheckPCAlignment()
// ==========================

<anchor link="AArch32.CheckPCAlignment.0" hover="function: AArch32.CheckPCAlignment()">AArch32.CheckPCAlignment</anchor>()

    bits(32) pc = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    if (<a link="impl-shared.CurrentInstrSet.0" file="shared_pseudocode.xml" hover="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() == <a link="InstrSet_A32" file="shared_pseudocode.xml" hover="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> &amp;&amp; pc&lt;1&gt; == '1') || pc&lt;0&gt; == '1' then
        if <a link="AArch32.GeneralExceptionsToAArch64.0" file="shared_pseudocode.xml" hover="function: boolean AArch32.GeneralExceptionsToAArch64()">AArch32.GeneralExceptionsToAArch64</a>() then <a link="AArch64.PCAlignmentFault.0" file="shared_pseudocode.xml" hover="function: AArch64.PCAlignmentFault()">AArch64.PCAlignmentFault</a>();

        // Generate an Alignment fault Prefetch Abort exception
        vaddress = pc;
        acctype = <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a>;
        iswrite = FALSE;
        secondstage = FALSE;
        <a link="AArch32.Abort.2" file="shared_pseudocode.xml" hover="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(vaddress, <a link="impl-shared.AlignmentFault.3" file="shared_pseudocode.xml" hover="function: FaultRecord AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)">AlignmentFault</a>(acctype, iswrite, secondstage));</pstext>
    </ps>
    <ps name="aarch32/exceptions/aborts/AArch32.ReportDataAbort" mylink="aarch32.exceptions.aborts.AArch32.ReportDataAbort" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.ReportDataAbort()
// =========================
// Report syndrome information for aborts taken to modes other than Hyp mode.

<anchor link="AArch32.ReportDataAbort.3" hover="function: AArch32.ReportDataAbort(boolean route_to_monitor, FaultRecord fault, bits(32) vaddress)">AArch32.ReportDataAbort</anchor>(boolean route_to_monitor, <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault, bits(32) vaddress)
    long_format = FALSE;
    if route_to_monitor &amp;&amp; !<a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>() then
        long_format = ((TTBCR_S.EAE == '1') ||
                       (<a link="impl-shared.IsExternalSyncAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(fault) &amp;&amp; ((PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> || TTBCR.EAE == '1') ||
                        (fault.secondstage &amp;&amp; boolean IMPLEMENTATION_DEFINED "Stage 2 synchronous external abort reports using Long-descriptor format when TTBCR_S.EAE is 0b0"))));
    else
        long_format = TTBCR.EAE == '1';
    d_side = TRUE;
    bits(32) syndrome;
    if long_format then
        syndrome = <a link="AArch32.FaultStatusLD.2" file="shared_pseudocode.xml" hover="function: bits(32) AArch32.FaultStatusLD(boolean d_side, FaultRecord fault)">AArch32.FaultStatusLD</a>(d_side, fault);
    else
        syndrome = <a link="AArch32.FaultStatusSD.2" file="shared_pseudocode.xml" hover="function: bits(32) AArch32.FaultStatusSD(boolean d_side, FaultRecord fault)">AArch32.FaultStatusSD</a>(d_side, fault);

    if fault.acctype == <a link="AccType_IC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a> then
        bits(32) i_syndrome;
        if (!long_format &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Report I-cache maintenance fault in IFSR") then
            i_syndrome = syndrome;
            syndrome&lt;10,3:0&gt; = <a link="impl-aarch32.EncodeSDFSC.2" file="shared_pseudocode.xml" hover="function: bits(5) EncodeSDFSC(Fault statuscode, integer level)">EncodeSDFSC</a>(<a link="Fault_ICacheMaint" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_ICacheMaint</a>, 1);
        else
            i_syndrome = bits(32) UNKNOWN;
        if route_to_monitor then
            IFSR_S = i_syndrome;
        else
            IFSR = i_syndrome;

    if route_to_monitor then
        DFSR_S = syndrome;
        DFAR_S = vaddress;
    else
        DFSR = syndrome;
        DFAR = vaddress;

    return;</pstext>
    </ps>
    <ps name="aarch32/exceptions/aborts/AArch32.ReportPrefetchAbort" mylink="aarch32.exceptions.aborts.AArch32.ReportPrefetchAbort" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.ReportPrefetchAbort()
// =============================
// Report syndrome information for aborts taken to modes other than Hyp mode.

<anchor link="AArch32.ReportPrefetchAbort.3" hover="function: AArch32.ReportPrefetchAbort(boolean route_to_monitor, FaultRecord fault, bits(32) vaddress)">AArch32.ReportPrefetchAbort</anchor>(boolean route_to_monitor, <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault, bits(32) vaddress)
    // The encoding used in the IFSR can be Long-descriptor format or Short-descriptor format.
    // Normally, the current translation table format determines the format. For an abort from
    // Non-secure state to Monitor mode, the IFSR uses the Long-descriptor format if any of the
    // following applies:
    // * The Secure TTBCR.EAE is set to 1.
    // * It is taken from Hyp mode.
    // * It is taken from EL1 or EL0, and the Non-secure TTBCR.EAE is set to 1.
    long_format = FALSE;
    if route_to_monitor &amp;&amp; !<a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>() then
        long_format = TTBCR_S.EAE == '1' || PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> || TTBCR.EAE == '1';
    else
        long_format = TTBCR.EAE == '1';

    d_side = FALSE;
    bits(32) fsr;
    if long_format then
        fsr = <a link="AArch32.FaultStatusLD.2" file="shared_pseudocode.xml" hover="function: bits(32) AArch32.FaultStatusLD(boolean d_side, FaultRecord fault)">AArch32.FaultStatusLD</a>(d_side, fault);
    else
        fsr = <a link="AArch32.FaultStatusSD.2" file="shared_pseudocode.xml" hover="function: bits(32) AArch32.FaultStatusSD(boolean d_side, FaultRecord fault)">AArch32.FaultStatusSD</a>(d_side, fault);

    if route_to_monitor then
        IFSR_S = fsr;
        IFAR_S = vaddress;
    else
        IFSR = fsr;
        IFAR = vaddress;

    return;</pstext>
    </ps>
    <ps name="aarch32/exceptions/aborts/AArch32.TakeDataAbortException" mylink="aarch32.exceptions.aborts.AArch32.TakeDataAbortException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.TakeDataAbortException()
// ================================

<anchor link="AArch32.TakeDataAbortException.2" hover="function: AArch32.TakeDataAbortException(bits(32) vaddress, FaultRecord fault)">AArch32.TakeDataAbortException</anchor>(bits(32) vaddress, <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    route_to_monitor = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR.EA == '1' &amp;&amp; <a link="impl-shared.IsExternalAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault);
    route_to_hyp = (<a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp;
                    (HCR.TGE == '1' ||
                     (<a link="impl-shared.HaveRASExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; HCR2.TEA == '1' &amp;&amp; <a link="impl-shared.IsExternalAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault)) ||
                     (<a link="impl-shared.IsDebugException.1" file="shared_pseudocode.xml" hover="function: boolean IsDebugException(FaultRecord fault)">IsDebugException</a>(fault) &amp;&amp; HDCR.TDE == '1') ||
                     <a link="impl-shared.IsSecondStage.1" file="shared_pseudocode.xml" hover="function: boolean IsSecondStage(FaultRecord fault)">IsSecondStage</a>(fault)));

    bits(32) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x10;
    lr_offset = 8;

    if <a link="impl-shared.IsDebugException.1" file="shared_pseudocode.xml" hover="function: boolean IsDebugException(FaultRecord fault)">IsDebugException</a>(fault) then DBGDSCRext.MOE = fault.debugmoe;
    if route_to_monitor then
        <a link="AArch32.ReportDataAbort.3" file="shared_pseudocode.xml" hover="function: AArch32.ReportDataAbort(boolean route_to_monitor, FaultRecord fault, bits(32) vaddress)">AArch32.ReportDataAbort</a>(route_to_monitor, fault, vaddress);
        <a link="AArch32.EnterMonitorMode.3" file="shared_pseudocode.xml" hover="function: AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMonitorMode</a>(preferred_exception_return, lr_offset, vect_offset);
    elsif PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> || route_to_hyp then
        exception = <a link="AArch32.AbortSyndrome.3" file="shared_pseudocode.xml" hover="function: ExceptionRecord AArch32.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(32) vaddress)">AArch32.AbortSyndrome</a>(<a link="Exception_DataAbort" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>, fault, vaddress);
        if PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then
            <a link="AArch32.EnterHypMode.3" file="shared_pseudocode.xml" hover="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
        else
            <a link="AArch32.EnterHypMode.3" file="shared_pseudocode.xml" hover="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, 0x14);
    else
        <a link="AArch32.ReportDataAbort.3" file="shared_pseudocode.xml" hover="function: AArch32.ReportDataAbort(boolean route_to_monitor, FaultRecord fault, bits(32) vaddress)">AArch32.ReportDataAbort</a>(route_to_monitor, fault, vaddress);
        <a link="AArch32.EnterMode.4" file="shared_pseudocode.xml" hover="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a link="M32_Abort" file="shared_pseudocode.xml" hover="constant bits(5) M32_Abort = '10111'">M32_Abort</a>, preferred_exception_return, lr_offset, vect_offset);</pstext>
    </ps>
    <ps name="aarch32/exceptions/aborts/AArch32.TakePrefetchAbortException" mylink="aarch32.exceptions.aborts.AArch32.TakePrefetchAbortException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.TakePrefetchAbortException()
// ====================================

<anchor link="AArch32.TakePrefetchAbortException.2" hover="function: AArch32.TakePrefetchAbortException(bits(32) vaddress, FaultRecord fault)">AArch32.TakePrefetchAbortException</anchor>(bits(32) vaddress, <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    route_to_monitor = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR.EA == '1' &amp;&amp; <a link="impl-shared.IsExternalAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault);
    route_to_hyp = (<a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp;
                    (HCR.TGE == '1' ||
                     (<a link="impl-shared.HaveRASExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; HCR2.TEA == '1' &amp;&amp; <a link="impl-shared.IsExternalAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault)) ||
                     (<a link="impl-shared.IsDebugException.1" file="shared_pseudocode.xml" hover="function: boolean IsDebugException(FaultRecord fault)">IsDebugException</a>(fault) &amp;&amp; HDCR.TDE == '1') ||
                     <a link="impl-shared.IsSecondStage.1" file="shared_pseudocode.xml" hover="function: boolean IsSecondStage(FaultRecord fault)">IsSecondStage</a>(fault)));

    <a link="ExceptionRecord" file="shared_pseudocode.xml" hover="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception;
    bits(32) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0C;

    lr_offset = 4;

    if <a link="impl-shared.IsDebugException.1" file="shared_pseudocode.xml" hover="function: boolean IsDebugException(FaultRecord fault)">IsDebugException</a>(fault) then DBGDSCRext.MOE = fault.debugmoe;
    if route_to_monitor then
        <a link="AArch32.ReportPrefetchAbort.3" file="shared_pseudocode.xml" hover="function: AArch32.ReportPrefetchAbort(boolean route_to_monitor, FaultRecord fault, bits(32) vaddress)">AArch32.ReportPrefetchAbort</a>(route_to_monitor, fault, vaddress);
        <a link="AArch32.EnterMonitorMode.3" file="shared_pseudocode.xml" hover="function: AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMonitorMode</a>(preferred_exception_return, lr_offset, vect_offset);
    elsif PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> || route_to_hyp then
        if fault.statuscode == <a link="Fault_Alignment" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a> then             // PC Alignment fault
            exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_PCAlignment" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PCAlignment</a>);
            exception.vaddress = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
        else
            exception = <a link="AArch32.AbortSyndrome.3" file="shared_pseudocode.xml" hover="function: ExceptionRecord AArch32.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(32) vaddress)">AArch32.AbortSyndrome</a>(<a link="Exception_InstructionAbort" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_InstructionAbort</a>, fault, vaddress);
        if PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then
            <a link="AArch32.EnterHypMode.3" file="shared_pseudocode.xml" hover="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
        else
            <a link="AArch32.EnterHypMode.3" file="shared_pseudocode.xml" hover="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, 0x14);
    else
        <a link="AArch32.ReportPrefetchAbort.3" file="shared_pseudocode.xml" hover="function: AArch32.ReportPrefetchAbort(boolean route_to_monitor, FaultRecord fault, bits(32) vaddress)">AArch32.ReportPrefetchAbort</a>(route_to_monitor, fault, vaddress);
        <a link="AArch32.EnterMode.4" file="shared_pseudocode.xml" hover="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a link="M32_Abort" file="shared_pseudocode.xml" hover="constant bits(5) M32_Abort = '10111'">M32_Abort</a>, preferred_exception_return, lr_offset, vect_offset);</pstext>
    </ps>
    <ps name="aarch32/exceptions/async/AArch32.TakePhysicalFIQException" mylink="aarch32.exceptions.async.AArch32.TakePhysicalFIQException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.TakePhysicalFIQException()
// ==================================

<anchor link="AArch32.TakePhysicalFIQException.0" hover="function: AArch32.TakePhysicalFIQException()">AArch32.TakePhysicalFIQException</anchor>()

    // Check if routed to AArch64 state
    route_to_aarch64 = PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>);
    if !route_to_aarch64 &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
        route_to_aarch64 = HCR_EL2.TGE == '1' || (HCR_EL2.FMO == '1' &amp;&amp; !<a link="impl-shared.IsInHost.0" file="shared_pseudocode.xml" hover="function: boolean IsInHost()">IsInHost</a>());

    if !route_to_aarch64 &amp;&amp; <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
        route_to_aarch64 = SCR_EL3.FIQ == '1';

    if route_to_aarch64 then <a link="AArch64.TakePhysicalFIQException.0" file="shared_pseudocode.xml" hover="function: AArch64.TakePhysicalFIQException()">AArch64.TakePhysicalFIQException</a>();
    route_to_monitor = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR.FIQ == '1';
    route_to_hyp = (PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                    (HCR.TGE == '1' || HCR.FMO == '1'));
    bits(32) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x1C;
    lr_offset = 4;
    if route_to_monitor then
        <a link="AArch32.EnterMonitorMode.3" file="shared_pseudocode.xml" hover="function: AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMonitorMode</a>(preferred_exception_return, lr_offset, vect_offset);
    elsif PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> || route_to_hyp then
        exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_FIQ" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FIQ</a>);
        <a link="AArch32.EnterHypMode.3" file="shared_pseudocode.xml" hover="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
    else
        <a link="AArch32.EnterMode.4" file="shared_pseudocode.xml" hover="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a link="M32_FIQ" file="shared_pseudocode.xml" hover="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>, preferred_exception_return, lr_offset, vect_offset);</pstext>
    </ps>
    <ps name="aarch32/exceptions/async/AArch32.TakePhysicalIRQException" mylink="aarch32.exceptions.async.AArch32.TakePhysicalIRQException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.TakePhysicalIRQException()
// ==================================
// Take an enabled physical IRQ exception.

<anchor link="AArch32.TakePhysicalIRQException.0" hover="function: AArch32.TakePhysicalIRQException()">AArch32.TakePhysicalIRQException</anchor>()

    // Check if routed to AArch64 state
    route_to_aarch64 = PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>);
    if !route_to_aarch64 &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
        route_to_aarch64 = HCR_EL2.TGE == '1' || (HCR_EL2.IMO == '1' &amp;&amp; !<a link="impl-shared.IsInHost.0" file="shared_pseudocode.xml" hover="function: boolean IsInHost()">IsInHost</a>());
    if !route_to_aarch64 &amp;&amp; <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
        route_to_aarch64 = SCR_EL3.IRQ == '1';

    if route_to_aarch64 then <a link="AArch64.TakePhysicalIRQException.0" file="shared_pseudocode.xml" hover="function: AArch64.TakePhysicalIRQException()">AArch64.TakePhysicalIRQException</a>();

    route_to_monitor = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR.IRQ == '1';
    route_to_hyp = (PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                    (HCR.TGE == '1' || HCR.IMO == '1'));
    bits(32) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x18;
    lr_offset = 4;
    if route_to_monitor then
        <a link="AArch32.EnterMonitorMode.3" file="shared_pseudocode.xml" hover="function: AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMonitorMode</a>(preferred_exception_return, lr_offset, vect_offset);
    elsif PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> || route_to_hyp then
        exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_IRQ" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IRQ</a>);
        <a link="AArch32.EnterHypMode.3" file="shared_pseudocode.xml" hover="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
    else
        <a link="AArch32.EnterMode.4" file="shared_pseudocode.xml" hover="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a link="M32_IRQ" file="shared_pseudocode.xml" hover="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>, preferred_exception_return, lr_offset, vect_offset);</pstext>
    </ps>
    <ps name="aarch32/exceptions/async/AArch32.TakePhysicalSErrorException" mylink="aarch32.exceptions.async.AArch32.TakePhysicalSErrorException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.TakePhysicalSErrorException()
// =====================================

<anchor link="AArch32.TakePhysicalSErrorException.4" hover="function: AArch32.TakePhysicalSErrorException(boolean parity, bit extflag, bits(2) pe_error_state,&#13; bits(25) full_syndrome)">AArch32.TakePhysicalSErrorException</anchor>(boolean parity, bit extflag, bits(2) pe_error_state,
                                         bits(25) full_syndrome)
    // Check if routed to AArch64 state
    route_to_aarch64 = PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>);

    if !route_to_aarch64 &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
        route_to_aarch64 = (HCR_EL2.TGE == '1' || (!<a link="impl-shared.IsInHost.0" file="shared_pseudocode.xml" hover="function: boolean IsInHost()">IsInHost</a>() &amp;&amp; HCR_EL2.AMO == '1'));
    if !route_to_aarch64 &amp;&amp; <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
        route_to_aarch64 = SCR_EL3.EA == '1';

    if route_to_aarch64 then
        <a link="AArch64.TakePhysicalSErrorException.1" file="shared_pseudocode.xml" hover="function: AArch64.TakePhysicalSErrorException(bits(25) syndrome)">AArch64.TakePhysicalSErrorException</a>(full_syndrome);

    route_to_monitor = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR.EA == '1';
    route_to_hyp = (PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                    (HCR.TGE == '1' || HCR.AMO == '1'));
    bits(32) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x10;
    lr_offset = 8;

    bits(2) target_el;
    if route_to_monitor then
        target_el = <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>;
    elsif PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> || route_to_hyp then
        target_el = <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;
    else
        target_el = <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;

    if <a link="impl-shared.IsSErrorEdgeTriggered.2" file="shared_pseudocode.xml" hover="function: boolean IsSErrorEdgeTriggered(bits(2) target_el, bits(25) syndrome)">IsSErrorEdgeTriggered</a>(target_el, full_syndrome) then
        <a link="impl-shared.ClearPendingPhysicalSError.0" file="shared_pseudocode.xml" hover="function: ClearPendingPhysicalSError()">ClearPendingPhysicalSError</a>();

    fault = <a link="impl-shared.AsyncExternalAbort.3" file="shared_pseudocode.xml" hover="function: FaultRecord AsyncExternalAbort(boolean parity, bits(2) errortype, bit extflag)">AsyncExternalAbort</a>(parity, pe_error_state, extflag);
    vaddress = bits(32) UNKNOWN;

    case target_el of
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>
            <a link="AArch32.ReportDataAbort.3" file="shared_pseudocode.xml" hover="function: AArch32.ReportDataAbort(boolean route_to_monitor, FaultRecord fault, bits(32) vaddress)">AArch32.ReportDataAbort</a>(route_to_monitor, fault, vaddress);
            <a link="AArch32.EnterMonitorMode.3" file="shared_pseudocode.xml" hover="function: AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMonitorMode</a>(preferred_exception_return, lr_offset, vect_offset);
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>
            exception = <a link="AArch32.AbortSyndrome.3" file="shared_pseudocode.xml" hover="function: ExceptionRecord AArch32.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(32) vaddress)">AArch32.AbortSyndrome</a>(<a link="Exception_DataAbort" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>, fault, vaddress);
            if PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then
                <a link="AArch32.EnterHypMode.3" file="shared_pseudocode.xml" hover="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
            else
                <a link="AArch32.EnterHypMode.3" file="shared_pseudocode.xml" hover="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, 0x14);
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>
            <a link="AArch32.ReportDataAbort.3" file="shared_pseudocode.xml" hover="function: AArch32.ReportDataAbort(boolean route_to_monitor, FaultRecord fault, bits(32) vaddress)">AArch32.ReportDataAbort</a>(route_to_monitor, fault, vaddress);
            <a link="AArch32.EnterMode.4" file="shared_pseudocode.xml" hover="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a link="M32_Abort" file="shared_pseudocode.xml" hover="constant bits(5) M32_Abort = '10111'">M32_Abort</a>, preferred_exception_return, lr_offset, vect_offset);
        otherwise
            <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();</pstext>
    </ps>
    <ps name="aarch32/exceptions/async/AArch32.TakeVirtualFIQException" mylink="aarch32.exceptions.async.AArch32.TakeVirtualFIQException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.TakeVirtualFIQException()
// =================================

<anchor link="AArch32.TakeVirtualFIQException.0" hover="function: AArch32.TakeVirtualFIQException()">AArch32.TakeVirtualFIQException</anchor>()
    assert PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>();
    if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then  // Virtual IRQ enabled if TGE==0 and FMO==1
        assert HCR.TGE == '0' &amp;&amp; HCR.FMO == '1';
    else
        assert HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.FMO == '1';
    // Check if routed to AArch64 state
    if PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then <a link="AArch64.TakeVirtualFIQException.0" file="shared_pseudocode.xml" hover="function: AArch64.TakeVirtualFIQException()">AArch64.TakeVirtualFIQException</a>();

    bits(32) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x1C;
    lr_offset = 4;

    <a link="AArch32.EnterMode.4" file="shared_pseudocode.xml" hover="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a link="M32_FIQ" file="shared_pseudocode.xml" hover="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>, preferred_exception_return, lr_offset, vect_offset);</pstext>
    </ps>
    <ps name="aarch32/exceptions/async/AArch32.TakeVirtualIRQException" mylink="aarch32.exceptions.async.AArch32.TakeVirtualIRQException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.TakeVirtualIRQException()
// =================================

<anchor link="AArch32.TakeVirtualIRQException.0" hover="function: AArch32.TakeVirtualIRQException()">AArch32.TakeVirtualIRQException</anchor>()
    assert PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>();

    if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then   // Virtual IRQs enabled if TGE==0 and IMO==1
        assert HCR.TGE == '0' &amp;&amp; HCR.IMO == '1';
    else
        assert HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.IMO == '1';

    // Check if routed to AArch64 state
    if PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then <a link="AArch64.TakeVirtualIRQException.0" file="shared_pseudocode.xml" hover="function: AArch64.TakeVirtualIRQException()">AArch64.TakeVirtualIRQException</a>();

    bits(32) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x18;
    lr_offset = 4;

    <a link="AArch32.EnterMode.4" file="shared_pseudocode.xml" hover="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a link="M32_IRQ" file="shared_pseudocode.xml" hover="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>, preferred_exception_return, lr_offset, vect_offset);</pstext>
    </ps>
    <ps name="aarch32/exceptions/async/AArch32.TakeVirtualSErrorException" mylink="aarch32.exceptions.async.AArch32.TakeVirtualSErrorException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.TakeVirtualSErrorException()
// ====================================

<anchor link="AArch32.TakeVirtualSErrorException.3" hover="function: AArch32.TakeVirtualSErrorException(bit extflag, bits(2) pe_error_state, bits(25) full_syndrome)">AArch32.TakeVirtualSErrorException</anchor>(bit extflag, bits(2) pe_error_state, bits(25) full_syndrome)

    assert PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>();
    if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then   // Virtual SError enabled if TGE==0 and AMO==1
        assert HCR.TGE == '0' &amp;&amp; HCR.AMO == '1';
    else
        assert HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.AMO == '1';
    // Check if routed to AArch64 state
    if PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then <a link="AArch64.TakeVirtualSErrorException.1" file="shared_pseudocode.xml" hover="function: AArch64.TakeVirtualSErrorException(bits(25) syndrome)">AArch64.TakeVirtualSErrorException</a>(full_syndrome);

    route_to_monitor = FALSE;

    bits(32) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x10;
    lr_offset = 8;

    vaddress = bits(32) UNKNOWN;
    parity = FALSE;
    <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault;
    if <a link="impl-shared.HaveRASExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveRASExt()">HaveRASExt</a>() then
        if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
            fault = <a link="impl-shared.AsyncExternalAbort.3" file="shared_pseudocode.xml" hover="function: FaultRecord AsyncExternalAbort(boolean parity, bits(2) errortype, bit extflag)">AsyncExternalAbort</a>(FALSE, VDFSR.AET, VDFSR.ExT);
        else
            fault = <a link="impl-shared.AsyncExternalAbort.3" file="shared_pseudocode.xml" hover="function: FaultRecord AsyncExternalAbort(boolean parity, bits(2) errortype, bit extflag)">AsyncExternalAbort</a>(FALSE, VSESR_EL2.AET, VSESR_EL2.ExT);
    else
        fault = <a link="impl-shared.AsyncExternalAbort.3" file="shared_pseudocode.xml" hover="function: FaultRecord AsyncExternalAbort(boolean parity, bits(2) errortype, bit extflag)">AsyncExternalAbort</a>(parity, pe_error_state, extflag);

    <a link="impl-shared.ClearPendingVirtualSError.0" file="shared_pseudocode.xml" hover="function: ClearPendingVirtualSError()">ClearPendingVirtualSError</a>();
    <a link="AArch32.ReportDataAbort.3" file="shared_pseudocode.xml" hover="function: AArch32.ReportDataAbort(boolean route_to_monitor, FaultRecord fault, bits(32) vaddress)">AArch32.ReportDataAbort</a>(route_to_monitor, fault, vaddress);
    <a link="AArch32.EnterMode.4" file="shared_pseudocode.xml" hover="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a link="M32_Abort" file="shared_pseudocode.xml" hover="constant bits(5) M32_Abort = '10111'">M32_Abort</a>, preferred_exception_return, lr_offset, vect_offset);</pstext>
    </ps>
    <ps name="aarch32/exceptions/debug/AArch32.SoftwareBreakpoint" mylink="aarch32.exceptions.debug.AArch32.SoftwareBreakpoint" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.SoftwareBreakpoint()
// ============================

<anchor link="AArch32.SoftwareBreakpoint.1" hover="function: AArch32.SoftwareBreakpoint(bits(16) immediate)">AArch32.SoftwareBreakpoint</anchor>(bits(16) immediate)

    if (<a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp;
        (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1')) || !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then
        <a link="AArch64.SoftwareBreakpoint.1" file="shared_pseudocode.xml" hover="function: AArch64.SoftwareBreakpoint(bits(16) immediate)">AArch64.SoftwareBreakpoint</a>(immediate);
    vaddress = bits(32) UNKNOWN;
    acctype = <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a>;           // Take as a Prefetch Abort
    iswrite = FALSE;
    entry = <a link="DebugException_BKPT" file="shared_pseudocode.xml" hover="constant bits(4) DebugException_BKPT = '0011'">DebugException_BKPT</a>;

    fault = <a link="AArch32.DebugFault.3" file="shared_pseudocode.xml" hover="function: FaultRecord AArch32.DebugFault(AccType acctype, boolean iswrite, bits(4) debugmoe)">AArch32.DebugFault</a>(acctype, iswrite, entry);
    <a link="AArch32.Abort.2" file="shared_pseudocode.xml" hover="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(vaddress, fault);</pstext>
    </ps>
    <ps name="aarch32/exceptions/debug/DebugException" mylink="aarch32.exceptions.debug.DebugException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">constant bits(4) <anchor link="DebugException_Breakpoint" hover="constant bits(4) DebugException_Breakpoint = '0001'">DebugException_Breakpoint</anchor>  = '0001';
constant bits(4) <anchor link="DebugException_BKPT" hover="constant bits(4) DebugException_BKPT = '0011'">DebugException_BKPT</anchor>        = '0011';
constant bits(4) <anchor link="DebugException_VectorCatch" hover="constant bits(4) DebugException_VectorCatch = '0101'">DebugException_VectorCatch</anchor> = '0101';
constant bits(4) <anchor link="DebugException_Watchpoint" hover="constant bits(4) DebugException_Watchpoint = '1010'">DebugException_Watchpoint</anchor>  = '1010';</pstext>
    </ps>
    <ps name="aarch32/exceptions/exceptions/AArch32.CheckAdvSIMDOrFPRegisterTraps" mylink="aarch32.exceptions.exceptions.AArch32.CheckAdvSIMDOrFPRegisterTraps" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.CheckAdvSIMDOrFPRegisterTraps()
// =======================================
// Check if an instruction that accesses an Advanced SIMD and
// floating-point System register is trapped by an appropriate HCR.TIDx
// ID group trap control.

<anchor link="AArch32.CheckAdvSIMDOrFPRegisterTraps.1" hover="function: AArch32.CheckAdvSIMDOrFPRegisterTraps(bits(4) reg)">AArch32.CheckAdvSIMDOrFPRegisterTraps</anchor>(bits(4) reg)

    if PSTATE.EL == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() then
        tid0 = if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then HCR.TID0 else HCR_EL2.TID0;
        tid3 = if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then HCR.TID3 else HCR_EL2.TID3;

        if (tid0 == '1' &amp;&amp; reg == '0000')                             // FPSID
          || (tid3 == '1' &amp;&amp; reg IN {'0101', '0110', '0111'}) then    // MVFRx
            if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
                <a link="AArch32.SystemAccessTrap.2" file="shared_pseudocode.xml" hover="function: AArch32.SystemAccessTrap(bits(5) mode, integer ec)">AArch32.SystemAccessTrap</a>(<a link="M32_Hyp" file="shared_pseudocode.xml" hover="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>, 0x8);               // Exception_AdvSIMDFPAccessTrap
            else
                <a link="AArch64.AArch32SystemAccessTrap.2" file="shared_pseudocode.xml" hover="function: AArch64.AArch32SystemAccessTrap(bits(2) target_el, integer ec)">AArch64.AArch32SystemAccessTrap</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, 0x8);            // Exception_AdvSIMDFPAccessTrap</pstext>
    </ps>
    <ps name="aarch32/exceptions/exceptions/AArch32.ExceptionClass" mylink="aarch32.exceptions.exceptions.AArch32.ExceptionClass" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.ExceptionClass()
// ========================
// Returns the Exception Class and Instruction Length fields to be reported in HSR

(integer,bit) <anchor link="AArch32.ExceptionClass.1" hover="function: (integer,bit) AArch32.ExceptionClass(Exception exceptype)">AArch32.ExceptionClass</anchor>(<a link="Exception" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception</a> exceptype)

    il_is_valid = TRUE;
    integer ec;
    case exceptype of
        when <a link="Exception_Uncategorized" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a>        ec = 0x00; il_is_valid = FALSE;
        when <a link="Exception_WFxTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_WFxTrap</a>              ec = 0x01;
        when <a link="Exception_CP15RTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RTTrap</a>           ec = 0x03;
        when <a link="Exception_CP15RRTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RRTTrap</a>          ec = 0x04;
        when <a link="Exception_CP14RTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RTTrap</a>           ec = 0x05;
        when <a link="Exception_CP14DTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14DTTrap</a>           ec = 0x06;
        when <a link="Exception_AdvSIMDFPAccessTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>  ec = 0x07;
        when <a link="Exception_FPIDTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPIDTrap</a>             ec = 0x08;
        when <a link="Exception_PACTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PACTrap</a>              ec = 0x09;
        when <a link="Exception_CP14RRTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RRTTrap</a>          ec = 0x0C;
        when <a link="Exception_BranchTarget" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_BranchTarget</a>         ec = 0x0D;
        when <a link="Exception_IllegalState" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IllegalState</a>         ec = 0x0E; il_is_valid = FALSE;
        when <a link="Exception_SupervisorCall" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SupervisorCall</a>       ec = 0x11;
        when <a link="Exception_HypervisorCall" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_HypervisorCall</a>       ec = 0x12;
        when <a link="Exception_MonitorCall" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_MonitorCall</a>          ec = 0x13;
        when <a link="Exception_InstructionAbort" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_InstructionAbort</a>     ec = 0x20; il_is_valid = FALSE;
        when <a link="Exception_PCAlignment" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PCAlignment</a>          ec = 0x22; il_is_valid = FALSE;
        when <a link="Exception_DataAbort" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>            ec = 0x24;
        when <a link="Exception_NV2DataAbort" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2DataAbort</a>         ec = 0x25;
        when <a link="Exception_FPTrappedException" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPTrappedException</a>   ec = 0x28;
        otherwise                           <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();

    if ec IN {0x20,0x24} &amp;&amp; PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then
        ec = ec + 1;
    bit il;
    if il_is_valid then
        il = if <a link="impl-shared.ThisInstrLength.0" file="shared_pseudocode.xml" hover="function: integer ThisInstrLength()">ThisInstrLength</a>() == 32 then '1' else '0';
    else
        il = '1';

    return (ec,il);</pstext>
    </ps>
    <ps name="aarch32/exceptions/exceptions/AArch32.GeneralExceptionsToAArch64" mylink="aarch32.exceptions.exceptions.AArch32.GeneralExceptionsToAArch64" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.GeneralExceptionsToAArch64()
// ====================================
// Returns TRUE if exceptions normally routed to EL1 are being handled at an Exception
// level using AArch64, because either EL1 is using AArch64 or TGE is in force and EL2
// is using AArch64.

boolean <anchor link="AArch32.GeneralExceptionsToAArch64.0" hover="function: boolean AArch32.GeneralExceptionsToAArch64()">AArch32.GeneralExceptionsToAArch64</anchor>()
    return ((PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>)) ||
            (<a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR_EL2.TGE == '1'));</pstext>
    </ps>
    <ps name="aarch32/exceptions/exceptions/AArch32.ReportHypEntry" mylink="aarch32.exceptions.exceptions.AArch32.ReportHypEntry" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.ReportHypEntry()
// ========================
// Report syndrome information to Hyp mode registers.

<anchor link="AArch32.ReportHypEntry.1" hover="function: AArch32.ReportHypEntry(ExceptionRecord exception)">AArch32.ReportHypEntry</anchor>(<a link="ExceptionRecord" file="shared_pseudocode.xml" hover="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception)

    <a link="Exception" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception</a> exceptype = exception.exceptype;

    (ec,il) = <a link="AArch32.ExceptionClass.1" file="shared_pseudocode.xml" hover="function: (integer,bit) AArch32.ExceptionClass(Exception exceptype)">AArch32.ExceptionClass</a>(exceptype);
    iss = exception.syndrome;

    // IL is not valid for Data Abort exceptions without valid instruction syndrome information
    if ec IN {0x24,0x25} &amp;&amp; iss&lt;24&gt; == '0' then
        il = '1';

    HSR = ec&lt;5:0&gt;:il:iss;

    if exceptype IN {<a link="Exception_InstructionAbort" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_InstructionAbort</a>, <a link="Exception_PCAlignment" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PCAlignment</a>} then
        HIFAR = exception.vaddress&lt;31:0&gt;;
        HDFAR = bits(32) UNKNOWN;
    elsif exceptype == <a link="Exception_DataAbort" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a> then
        HIFAR = bits(32) UNKNOWN;
        HDFAR = exception.vaddress&lt;31:0&gt;;

    if exception.ipavalid then
        HPFAR&lt;31:4&gt; = exception.ipaddress&lt;39:12&gt;;
    else
        HPFAR&lt;31:4&gt; = bits(28) UNKNOWN;

    return;</pstext>
    </ps>
    <ps name="aarch32/exceptions/exceptions/AArch32.ResetControlRegisters" mylink="aarch32.exceptions.exceptions.AArch32.ResetControlRegisters" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Resets System registers and memory-mapped control registers that have architecturally-defined
// reset values to those values.
<anchor link="AArch32.ResetControlRegisters.1" hover="function: AArch32.ResetControlRegisters(boolean cold_reset)">AArch32.ResetControlRegisters</anchor>(boolean cold_reset);</pstext>
    </ps>
    <ps name="aarch32/exceptions/exceptions/AArch32.TakeReset" mylink="aarch32.exceptions.exceptions.AArch32.TakeReset" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.TakeReset()
// ===================
// Reset into AArch32 state

<anchor link="AArch32.TakeReset.1" hover="function: AArch32.TakeReset(boolean cold_reset)">AArch32.TakeReset</anchor>(boolean cold_reset)
    assert !<a link="impl-shared.HaveAArch64.0" file="shared_pseudocode.xml" hover="function: boolean HaveAArch64()">HaveAArch64</a>();

    // Enter the highest implemented Exception level in AArch32 state
    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
        <a link="AArch32.WriteMode.1" file="shared_pseudocode.xml" hover="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a link="M32_Svc" file="shared_pseudocode.xml" hover="constant bits(5) M32_Svc = '10011'">M32_Svc</a>);
        SCR.NS = '0';                     // Secure state
    elsif <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
        <a link="AArch32.WriteMode.1" file="shared_pseudocode.xml" hover="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a link="M32_Hyp" file="shared_pseudocode.xml" hover="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>);
    else
        <a link="AArch32.WriteMode.1" file="shared_pseudocode.xml" hover="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a link="M32_Svc" file="shared_pseudocode.xml" hover="constant bits(5) M32_Svc = '10011'">M32_Svc</a>);

    // Reset System registers in the coproc=0b111x encoding space and other system components
    <a link="AArch32.ResetControlRegisters.1" file="shared_pseudocode.xml" hover="function: AArch32.ResetControlRegisters(boolean cold_reset)">AArch32.ResetControlRegisters</a>(cold_reset);
    FPEXC.EN = '0';

    // Reset all other PSTATE fields, including instruction set and endianness according to the
    // SCTLR values produced by the above call to ResetControlRegisters()
    PSTATE.&lt;A,I,F&gt; = '111';       // All asynchronous exceptions masked
    PSTATE.IT = '00000000';       // IT block state reset
    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
        PSTATE.T = HSCTLR.TE;     // Instruction set: TE=0: A32, TE=1: T32. PSTATE.J is RES0.
        PSTATE.E = HSCTLR.EE;     // Endianness: EE=0: little-endian, EE=1: big-endian
    else
        PSTATE.T = SCTLR.TE;      // Instruction set: TE=0: A32, TE=1: T32. PSTATE.J is RES0.
        PSTATE.E = SCTLR.EE;      // Endianness: EE=0: little-endian, EE=1: big-endian
    PSTATE.IL = '0';              // Clear Illegal Execution state bit

    // All registers, bits and fields not reset by the above pseudocode or by the BranchTo() call
    // below are UNKNOWN bitstrings after reset. In particular, the return information registers
    // R14 or ELR_hyp and SPSR have UNKNOWN values, so that it
    // is impossible to return from a reset in an architecturally defined way.
    <a link="AArch32.ResetGeneralRegisters.0" file="shared_pseudocode.xml" hover="function: AArch32.ResetGeneralRegisters()">AArch32.ResetGeneralRegisters</a>();
    <a link="AArch32.ResetSIMDFPRegisters.0" file="shared_pseudocode.xml" hover="function: AArch32.ResetSIMDFPRegisters()">AArch32.ResetSIMDFPRegisters</a>();
    <a link="AArch32.ResetSpecialRegisters.0" file="shared_pseudocode.xml" hover="function: AArch32.ResetSpecialRegisters()">AArch32.ResetSpecialRegisters</a>();
    <a link="impl-shared.ResetExternalDebugRegisters.1" file="shared_pseudocode.xml" hover="function: ResetExternalDebugRegisters(boolean cold_reset)">ResetExternalDebugRegisters</a>(cold_reset);

    bits(32) rv;                      // IMPLEMENTATION DEFINED reset vector

    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
        if MVBAR&lt;0&gt; == '1' then           // Reset vector in MVBAR
            rv = MVBAR&lt;31:1&gt;:'0';
        else
            rv = bits(32) IMPLEMENTATION_DEFINED "reset vector address";
    else
        rv = RVBAR&lt;31:1&gt;:'0';

    // The reset vector must be correctly aligned
    assert rv&lt;0&gt; == '0' &amp;&amp; (PSTATE.T == '1' || rv&lt;1&gt; == '0');

    boolean branch_conditional = FALSE;
    <a link="impl-shared.BranchTo.3" file="shared_pseudocode.xml" hover="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(rv, <a link="BranchType_RESET" file="shared_pseudocode.xml" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType_RESET</a>, branch_conditional);</pstext>
    </ps>
    <ps name="aarch32/exceptions/exceptions/ExcVectorBase" mylink="aarch32.exceptions.exceptions.ExcVectorBase" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ExcVectorBase()
// ===============

bits(32) <anchor link="impl-aarch32.ExcVectorBase.0" hover="function: bits(32) ExcVectorBase()">ExcVectorBase</anchor>()
    if SCTLR.V == '1' then  // Hivecs selected, base = 0xFFFF0000
        return <a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(16):<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(16);
    else
        return VBAR&lt;31:5&gt;:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(5);</pstext>
    </ps>
    <ps name="aarch32/exceptions/ieeefp/AArch32.FPTrappedException" mylink="aarch32.exceptions.ieeefp.AArch32.FPTrappedException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.FPTrappedException()
// ============================

<anchor link="AArch32.FPTrappedException.1" hover="function: AArch32.FPTrappedException(bits(8) accumulated_exceptions)">AArch32.FPTrappedException</anchor>(bits(8) accumulated_exceptions)
    if <a link="AArch32.GeneralExceptionsToAArch64.0" file="shared_pseudocode.xml" hover="function: boolean AArch32.GeneralExceptionsToAArch64()">AArch32.GeneralExceptionsToAArch64</a>() then
        is_ase = FALSE;
        element = 0;
        <a link="AArch64.FPTrappedException.2" file="shared_pseudocode.xml" hover="function: AArch64.FPTrappedException(boolean is_ase, bits(8) accumulated_exceptions)">AArch64.FPTrappedException</a>(is_ase, accumulated_exceptions);
    FPEXC.DEX    = '1';
    FPEXC.TFV    = '1';
    FPEXC&lt;7,4:0&gt; = accumulated_exceptions&lt;7,4:0&gt;;                  // IDF,IXF,UFF,OFF,DZF,IOF
    FPEXC&lt;10:8&gt;  = '111';                                          // VECITR is RES1

    <a link="AArch32.TakeUndefInstrException.0" file="shared_pseudocode.xml" hover="function: AArch32.TakeUndefInstrException()">AArch32.TakeUndefInstrException</a>();</pstext>
    </ps>
    <ps name="aarch32/exceptions/syscalls/AArch32.CallHypervisor" mylink="aarch32.exceptions.syscalls.AArch32.CallHypervisor" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.CallHypervisor()
// ========================
// Performs a HVC call

<anchor link="AArch32.CallHypervisor.1" hover="function: AArch32.CallHypervisor(bits(16) immediate)">AArch32.CallHypervisor</anchor>(bits(16) immediate)
    assert <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>);

    if !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
        <a link="AArch64.CallHypervisor.1" file="shared_pseudocode.xml" hover="function: AArch64.CallHypervisor(bits(16) immediate)">AArch64.CallHypervisor</a>(immediate);
    else
        <a link="AArch32.TakeHVCException.1" file="shared_pseudocode.xml" hover="function: AArch32.TakeHVCException(bits(16) immediate)">AArch32.TakeHVCException</a>(immediate);</pstext>
    </ps>
    <ps name="aarch32/exceptions/syscalls/AArch32.CallSupervisor" mylink="aarch32.exceptions.syscalls.AArch32.CallSupervisor" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.CallSupervisor()
// ========================
// Calls the Supervisor

<anchor link="AArch32.CallSupervisor.1" hover="function: AArch32.CallSupervisor(bits(16) immediate_in)">AArch32.CallSupervisor</anchor>(bits(16) immediate_in)
    bits(16) immediate = immediate_in;
    if <a link="AArch32.CurrentCond.0" file="shared_pseudocode.xml" hover="function: bits(4) AArch32.CurrentCond()">AArch32.CurrentCond</a>() != '1110' then
        immediate = bits(16) UNKNOWN;
    if <a link="AArch32.GeneralExceptionsToAArch64.0" file="shared_pseudocode.xml" hover="function: boolean AArch32.GeneralExceptionsToAArch64()">AArch32.GeneralExceptionsToAArch64</a>() then
        <a link="AArch64.CallSupervisor.1" file="shared_pseudocode.xml" hover="function: AArch64.CallSupervisor(bits(16) immediate_in)">AArch64.CallSupervisor</a>(immediate);
    else
        <a link="AArch32.TakeSVCException.1" file="shared_pseudocode.xml" hover="function: AArch32.TakeSVCException(bits(16) immediate)">AArch32.TakeSVCException</a>(immediate);</pstext>
    </ps>
    <ps name="aarch32/exceptions/syscalls/AArch32.TakeHVCException" mylink="aarch32.exceptions.syscalls.AArch32.TakeHVCException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.TakeHVCException()
// ==========================

<anchor link="AArch32.TakeHVCException.1" hover="function: AArch32.TakeHVCException(bits(16) immediate)">AArch32.TakeHVCException</anchor>(bits(16) immediate)
    assert <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>);

    <a link="AArch32.ITAdvance.0" file="shared_pseudocode.xml" hover="function: AArch32.ITAdvance()">AArch32.ITAdvance</a>();
    <a link="impl-shared.SSAdvance.0" file="shared_pseudocode.xml" hover="function: SSAdvance()">SSAdvance</a>();
    bits(32) preferred_exception_return = <a link="impl-shared.NextInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) NextInstrAddr()">NextInstrAddr</a>();
    vect_offset = 0x08;

    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_HypervisorCall" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_HypervisorCall</a>);
    exception.syndrome&lt;15:0&gt; = immediate;

    if PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then
        <a link="AArch32.EnterHypMode.3" file="shared_pseudocode.xml" hover="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
    else
        <a link="AArch32.EnterHypMode.3" file="shared_pseudocode.xml" hover="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, 0x14);</pstext>
    </ps>
    <ps name="aarch32/exceptions/syscalls/AArch32.TakeSMCException" mylink="aarch32.exceptions.syscalls.AArch32.TakeSMCException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.TakeSMCException()
// ==========================

<anchor link="AArch32.TakeSMCException.0" hover="function: AArch32.TakeSMCException()">AArch32.TakeSMCException</anchor>()
    assert <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>);
    <a link="AArch32.ITAdvance.0" file="shared_pseudocode.xml" hover="function: AArch32.ITAdvance()">AArch32.ITAdvance</a>();
    <a link="impl-shared.SSAdvance.0" file="shared_pseudocode.xml" hover="function: SSAdvance()">SSAdvance</a>();
    bits(32) preferred_exception_return = <a link="impl-shared.NextInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) NextInstrAddr()">NextInstrAddr</a>();
    vect_offset = 0x08;
    lr_offset = 0;

    <a link="AArch32.EnterMonitorMode.3" file="shared_pseudocode.xml" hover="function: AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMonitorMode</a>(preferred_exception_return, lr_offset, vect_offset);</pstext>
    </ps>
    <ps name="aarch32/exceptions/syscalls/AArch32.TakeSVCException" mylink="aarch32.exceptions.syscalls.AArch32.TakeSVCException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.TakeSVCException()
// ==========================

<anchor link="AArch32.TakeSVCException.1" hover="function: AArch32.TakeSVCException(bits(16) immediate)">AArch32.TakeSVCException</anchor>(bits(16) immediate)

    <a link="AArch32.ITAdvance.0" file="shared_pseudocode.xml" hover="function: AArch32.ITAdvance()">AArch32.ITAdvance</a>();
    <a link="impl-shared.SSAdvance.0" file="shared_pseudocode.xml" hover="function: SSAdvance()">SSAdvance</a>();
    route_to_hyp = PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR.TGE == '1';

    bits(32) preferred_exception_return = <a link="impl-shared.NextInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) NextInstrAddr()">NextInstrAddr</a>();
    vect_offset = 0x08;
    lr_offset = 0;

    if PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> || route_to_hyp then
        exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_SupervisorCall" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SupervisorCall</a>);
        exception.syndrome&lt;15:0&gt; = immediate;
        if PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then
            <a link="AArch32.EnterHypMode.3" file="shared_pseudocode.xml" hover="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
        else
            <a link="AArch32.EnterHypMode.3" file="shared_pseudocode.xml" hover="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, 0x14);
    else
        <a link="AArch32.EnterMode.4" file="shared_pseudocode.xml" hover="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a link="M32_Svc" file="shared_pseudocode.xml" hover="constant bits(5) M32_Svc = '10011'">M32_Svc</a>, preferred_exception_return, lr_offset, vect_offset);</pstext>
    </ps>
    <ps name="aarch32/exceptions/takeexception/AArch32.EnterHypMode" mylink="aarch32.exceptions.takeexception.AArch32.EnterHypMode" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.EnterHypMode()
// ======================
// Take an exception to Hyp mode.

<anchor link="AArch32.EnterHypMode.3" hover="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</anchor>(<a link="ExceptionRecord" file="shared_pseudocode.xml" hover="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception, bits(32) preferred_exception_return,
                     integer vect_offset)
    <a link="impl-shared.SynchronizeContext.0" file="shared_pseudocode.xml" hover="function: SynchronizeContext()">SynchronizeContext</a>();
    assert <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; !<a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>() &amp;&amp; <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>);

    bits(32) spsr = <a link="impl-shared.GetPSRFromPSTATE.1" file="shared_pseudocode.xml" hover="function: bits(N) GetPSRFromPSTATE(ExceptionalOccurrenceTargetState targetELState)">GetPSRFromPSTATE</a>(<a link="AArch32_NonDebugState" file="shared_pseudocode.xml" hover="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">AArch32_NonDebugState</a>);
    if !(exception.exceptype IN {<a link="Exception_IRQ" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IRQ</a>, <a link="Exception_FIQ" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FIQ</a>}) then
        <a link="AArch32.ReportHypEntry.1" file="shared_pseudocode.xml" hover="function: AArch32.ReportHypEntry(ExceptionRecord exception)">AArch32.ReportHypEntry</a>(exception);
    <a link="AArch32.WriteMode.1" file="shared_pseudocode.xml" hover="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a link="M32_Hyp" file="shared_pseudocode.xml" hover="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>);
    <a link="impl-shared.SPSR.write.0" file="shared_pseudocode.xml" hover="accessor: SPSR[] = bits(N) value">SPSR</a>[] = spsr;
    ELR_hyp = preferred_exception_return;
    PSTATE.T = HSCTLR.TE;                       // PSTATE.J is RES0
    PSTATE.SS = '0';
    if !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) || <a link="impl-shared.SCR_GEN.read.0" file="shared_pseudocode.xml" hover="accessor: SCRType SCR_GEN[]">SCR_GEN</a>[].EA == '0' then PSTATE.A = '1';
    if !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) || <a link="impl-shared.SCR_GEN.read.0" file="shared_pseudocode.xml" hover="accessor: SCRType SCR_GEN[]">SCR_GEN</a>[].IRQ == '0' then PSTATE.I = '1';
    if !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) || <a link="impl-shared.SCR_GEN.read.0" file="shared_pseudocode.xml" hover="accessor: SCRType SCR_GEN[]">SCR_GEN</a>[].FIQ == '0' then PSTATE.F = '1';
    PSTATE.E = HSCTLR.EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    if <a link="impl-shared.HaveSSBSExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = HSCTLR.DSSBS;
    boolean branch_conditional = FALSE;
    <a link="impl-shared.BranchTo.3" file="shared_pseudocode.xml" hover="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(HVBAR&lt;31:5&gt;:vect_offset&lt;4:0&gt;, <a link="BranchType_EXCEPTION" file="shared_pseudocode.xml" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType_EXCEPTION</a>, branch_conditional);

    <a link="impl-shared.CheckExceptionCatch.1" file="shared_pseudocode.xml" hover="function: CheckExceptionCatch(boolean exception_entry)">CheckExceptionCatch</a>(TRUE);                  // Check for debug event on exception entry

    <a link="impl-shared.EndOfInstruction.0" file="shared_pseudocode.xml" hover="function: EndOfInstruction()">EndOfInstruction</a>();</pstext>
    </ps>
    <ps name="aarch32/exceptions/takeexception/AArch32.EnterMode" mylink="aarch32.exceptions.takeexception.AArch32.EnterMode" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.EnterMode()
// ===================
// Take an exception to a mode other than Monitor and Hyp mode.

<anchor link="AArch32.EnterMode.4" hover="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</anchor>(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,
                  integer vect_offset)
    <a link="impl-shared.SynchronizeContext.0" file="shared_pseudocode.xml" hover="function: SynchronizeContext()">SynchronizeContext</a>();
    assert <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; PSTATE.EL != <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;

    bits(32) spsr = <a link="impl-shared.GetPSRFromPSTATE.1" file="shared_pseudocode.xml" hover="function: bits(N) GetPSRFromPSTATE(ExceptionalOccurrenceTargetState targetELState)">GetPSRFromPSTATE</a>(<a link="AArch32_NonDebugState" file="shared_pseudocode.xml" hover="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">AArch32_NonDebugState</a>);
    if PSTATE.M == <a link="M32_Monitor" file="shared_pseudocode.xml" hover="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then SCR.NS = '0';
    <a link="AArch32.WriteMode.1" file="shared_pseudocode.xml" hover="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(target_mode);
    <a link="impl-shared.SPSR.write.0" file="shared_pseudocode.xml" hover="accessor: SPSR[] = bits(N) value">SPSR</a>[] = spsr;
    <a link="impl-aarch32.R.write.1" file="shared_pseudocode.xml" hover="accessor: R[integer n] = bits(32) value">R</a>[14] = preferred_exception_return + lr_offset;
    PSTATE.T = SCTLR.TE;                        // PSTATE.J is RES0
    PSTATE.SS = '0';
    if target_mode == <a link="M32_FIQ" file="shared_pseudocode.xml" hover="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a> then
        PSTATE.&lt;A,I,F&gt; = '111';
    elsif target_mode IN {<a link="M32_Abort" file="shared_pseudocode.xml" hover="constant bits(5) M32_Abort = '10111'">M32_Abort</a>, <a link="M32_IRQ" file="shared_pseudocode.xml" hover="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>} then
        PSTATE.&lt;A,I&gt; = '11';
    else
        PSTATE.I = '1';
    PSTATE.E = SCTLR.EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    if <a link="impl-shared.HavePANExt.0" file="shared_pseudocode.xml" hover="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; SCTLR.SPAN == '0' then PSTATE.PAN = '1';
    if <a link="impl-shared.HaveSSBSExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = SCTLR.DSSBS;
    boolean branch_conditional = FALSE;
    <a link="impl-shared.BranchTo.3" file="shared_pseudocode.xml" hover="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(<a link="impl-aarch32.ExcVectorBase.0" file="shared_pseudocode.xml" hover="function: bits(32) ExcVectorBase()">ExcVectorBase</a>()&lt;31:5&gt;:vect_offset&lt;4:0&gt;, <a link="BranchType_EXCEPTION" file="shared_pseudocode.xml" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType_EXCEPTION</a>, branch_conditional);

    <a link="impl-shared.CheckExceptionCatch.1" file="shared_pseudocode.xml" hover="function: CheckExceptionCatch(boolean exception_entry)">CheckExceptionCatch</a>(TRUE);                  // Check for debug event on exception entry

    <a link="impl-shared.EndOfInstruction.0" file="shared_pseudocode.xml" hover="function: EndOfInstruction()">EndOfInstruction</a>();</pstext>
    </ps>
    <ps name="aarch32/exceptions/takeexception/AArch32.EnterMonitorMode" mylink="aarch32.exceptions.takeexception.AArch32.EnterMonitorMode" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.EnterMonitorMode()
// ==========================
// Take an exception to Monitor mode.

<anchor link="AArch32.EnterMonitorMode.3" hover="function: AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMonitorMode</anchor>(bits(32) preferred_exception_return, integer lr_offset,
                         integer vect_offset)
    <a link="impl-shared.SynchronizeContext.0" file="shared_pseudocode.xml" hover="function: SynchronizeContext()">SynchronizeContext</a>();
    assert <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>);
    from_secure = <a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>();
    bits(32) spsr = <a link="impl-shared.GetPSRFromPSTATE.1" file="shared_pseudocode.xml" hover="function: bits(N) GetPSRFromPSTATE(ExceptionalOccurrenceTargetState targetELState)">GetPSRFromPSTATE</a>(<a link="AArch32_NonDebugState" file="shared_pseudocode.xml" hover="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">AArch32_NonDebugState</a>);
    if PSTATE.M == <a link="M32_Monitor" file="shared_pseudocode.xml" hover="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then SCR.NS = '0';
    <a link="AArch32.WriteMode.1" file="shared_pseudocode.xml" hover="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a link="M32_Monitor" file="shared_pseudocode.xml" hover="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>);
    <a link="impl-shared.SPSR.write.0" file="shared_pseudocode.xml" hover="accessor: SPSR[] = bits(N) value">SPSR</a>[] = spsr;
    <a link="impl-aarch32.R.write.1" file="shared_pseudocode.xml" hover="accessor: R[integer n] = bits(32) value">R</a>[14] = preferred_exception_return + lr_offset;
    PSTATE.T = SCTLR.TE;                        // PSTATE.J is RES0
    PSTATE.SS = '0';
    PSTATE.&lt;A,I,F&gt; = '111';
    PSTATE.E = SCTLR.EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    if <a link="impl-shared.HavePANExt.0" file="shared_pseudocode.xml" hover="function: boolean HavePANExt()">HavePANExt</a>() then
        if !from_secure then
            PSTATE.PAN = '0';
        elsif SCTLR.SPAN == '0' then
            PSTATE.PAN = '1';
    if <a link="impl-shared.HaveSSBSExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = SCTLR.DSSBS;
    boolean branch_conditional = FALSE;
    <a link="impl-shared.BranchTo.3" file="shared_pseudocode.xml" hover="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(MVBAR&lt;31:5&gt;:vect_offset&lt;4:0&gt;, <a link="BranchType_EXCEPTION" file="shared_pseudocode.xml" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType_EXCEPTION</a>, branch_conditional);

    <a link="impl-shared.CheckExceptionCatch.1" file="shared_pseudocode.xml" hover="function: CheckExceptionCatch(boolean exception_entry)">CheckExceptionCatch</a>(TRUE);                  // Check for debug event on exception entry

    <a link="impl-shared.EndOfInstruction.0" file="shared_pseudocode.xml" hover="function: EndOfInstruction()">EndOfInstruction</a>();</pstext>
    </ps>
    <ps name="aarch32/exceptions/traps/AArch32.CheckAdvSIMDOrFPEnabled" mylink="aarch32.exceptions.traps.AArch32.CheckAdvSIMDOrFPEnabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.CheckAdvSIMDOrFPEnabled()
// =================================
// Check against CPACR, FPEXC, HCPTR, NSACR, and CPTR_EL3.

<anchor link="AArch32.CheckAdvSIMDOrFPEnabled.2" hover="function: AArch32.CheckAdvSIMDOrFPEnabled(boolean fpexc_check, boolean advsimd)">AArch32.CheckAdvSIMDOrFPEnabled</anchor>(boolean fpexc_check, boolean advsimd)
    if PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; (!<a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() || (!<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR_EL2.TGE == '0')) &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then
        // The PE behaves as if FPEXC.EN is 1
        <a link="AArch64.CheckFPEnabled.0" file="shared_pseudocode.xml" hover="function: AArch64.CheckFPEnabled()">AArch64.CheckFPEnabled</a>();
        <a link="AArch64.CheckFPAdvSIMDEnabled.0" file="shared_pseudocode.xml" hover="function: AArch64.CheckFPAdvSIMDEnabled()">AArch64.CheckFPAdvSIMDEnabled</a>();
    elsif PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR_EL2.TGE == '1' &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then
        if fpexc_check &amp;&amp; HCR_EL2.RW == '0' then
            fpexc_en = bits(1) IMPLEMENTATION_DEFINED "FPEXC.EN value when TGE==1 and RW==0";
            if fpexc_en == '0' then UNDEFINED;
        <a link="AArch64.CheckFPEnabled.0" file="shared_pseudocode.xml" hover="function: AArch64.CheckFPEnabled()">AArch64.CheckFPEnabled</a>();
    else
        cpacr_asedis = CPACR.ASEDIS;
        cpacr_cp10 = CPACR.cp10;

        if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>() then
            // Check if access disabled in NSACR
            if NSACR.NSASEDIS == '1' then cpacr_asedis = '1';
            if NSACR.cp10 == '0' then cpacr_cp10 = '00';

        if PSTATE.EL != <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then
            // Check if Advanced SIMD disabled in CPACR
            if advsimd &amp;&amp; cpacr_asedis == '1' then UNDEFINED;

            // Check if access disabled in CPACR
            boolean disabled;
            case cpacr_cp10 of
                when '00' disabled = TRUE;
                when '01' disabled = PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>;
                when '10' disabled = <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_RESCPACR" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESCPACR</a>);
                when '11' disabled = FALSE;
            if disabled then UNDEFINED;

        // If required, check FPEXC enabled bit.
        if fpexc_check &amp;&amp; FPEXC.EN == '0' then UNDEFINED;

        <a link="AArch32.CheckFPAdvSIMDTrap.1" file="shared_pseudocode.xml" hover="function: AArch32.CheckFPAdvSIMDTrap(boolean advsimd)">AArch32.CheckFPAdvSIMDTrap</a>(advsimd);    // Also check against HCPTR and CPTR_EL3</pstext>
    </ps>
    <ps name="aarch32/exceptions/traps/AArch32.CheckFPAdvSIMDTrap" mylink="aarch32.exceptions.traps.AArch32.CheckFPAdvSIMDTrap" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.CheckFPAdvSIMDTrap()
// ============================
// Check against CPTR_EL2 and CPTR_EL3.

<anchor link="AArch32.CheckFPAdvSIMDTrap.1" hover="function: AArch32.CheckFPAdvSIMDTrap(boolean advsimd)">AArch32.CheckFPAdvSIMDTrap</anchor>(boolean advsimd)
    if <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
        <a link="AArch64.CheckFPAdvSIMDTrap.0" file="shared_pseudocode.xml" hover="function: AArch64.CheckFPAdvSIMDTrap()">AArch64.CheckFPAdvSIMDTrap</a>();
    else
        if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; !<a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>() then
            hcptr_tase = HCPTR.TASE;
            hcptr_cp10 = HCPTR.TCP10;

            if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>() then
                // Check if access disabled in NSACR
                if NSACR.NSASEDIS == '1' then hcptr_tase = '1';
                if NSACR.cp10 == '0' then hcptr_cp10 = '1';

            // Check if access disabled in HCPTR
            if (advsimd &amp;&amp; hcptr_tase == '1') || hcptr_cp10 == '1' then
                exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_AdvSIMDFPAccessTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>);
                exception.syndrome&lt;24:20&gt; = <a link="impl-shared.ConditionSyndrome.0" file="shared_pseudocode.xml" hover="function: bits(5) ConditionSyndrome()">ConditionSyndrome</a>();

                if advsimd then
                    exception.syndrome&lt;5&gt; = '1';
                else
                    exception.syndrome&lt;5&gt; = '0';
                    exception.syndrome&lt;3:0&gt; = '1010';         // coproc field, always 0xA

                if PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then
                    <a link="AArch32.TakeUndefInstrException.1" file="shared_pseudocode.xml" hover="function: AArch32.TakeUndefInstrException(ExceptionRecord exception)">AArch32.TakeUndefInstrException</a>(exception);
                else
                    <a link="AArch32.TakeHypTrapException.1" file="shared_pseudocode.xml" hover="function: AArch32.TakeHypTrapException(integer ec)">AArch32.TakeHypTrapException</a>(exception);

        if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
            // Check if access disabled in CPTR_EL3
            if CPTR_EL3.TFP == '1' then <a link="AArch64.AdvSIMDFPAccessTrap.1" file="shared_pseudocode.xml" hover="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>);
    return;</pstext>
    </ps>
    <ps name="aarch32/exceptions/traps/AArch32.CheckForSMCUndefOrTrap" mylink="aarch32.exceptions.traps.AArch32.CheckForSMCUndefOrTrap" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.CheckForSMCUndefOrTrap()
// ================================
// Check for UNDEFINED or trap on SMC instruction

<anchor link="AArch32.CheckForSMCUndefOrTrap.0" hover="function: AArch32.CheckForSMCUndefOrTrap()">AArch32.CheckForSMCUndefOrTrap</anchor>()
    if !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) || PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then
        UNDEFINED;

    if <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
        <a link="AArch64.CheckForSMCUndefOrTrap.1" file="shared_pseudocode.xml" hover="function: AArch64.CheckForSMCUndefOrTrap(bits(16) imm)">AArch64.CheckForSMCUndefOrTrap</a>(<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(16));
    else
        route_to_hyp = <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; HCR.TSC == '1';
        if route_to_hyp then
            exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_MonitorCall" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_MonitorCall</a>);
            <a link="AArch32.TakeHypTrapException.1" file="shared_pseudocode.xml" hover="function: AArch32.TakeHypTrapException(integer ec)">AArch32.TakeHypTrapException</a>(exception);</pstext>
    </ps>
    <ps name="aarch32/exceptions/traps/AArch32.CheckForSVCTrap" mylink="aarch32.exceptions.traps.AArch32.CheckForSVCTrap" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.CheckForSVCTrap()
// =========================
// Check for trap on SVC instruction

<anchor link="AArch32.CheckForSVCTrap.1" hover="function: AArch32.CheckForSVCTrap(bits(16) immediate)">AArch32.CheckForSVCTrap</anchor>(bits(16) immediate)
    if <a link="impl-shared.HaveFGTExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveFGTExt()">HaveFGTExt</a>() then
        route_to_el2 = FALSE;
        if PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then
            route_to_el2 = (!<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HFGITR_EL2.SVC_EL0 == '1' &amp;&amp;
                           (HCR_EL2.&lt;E2H, TGE&gt; != '11' &amp;&amp; (!<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) || SCR_EL3.FGTEn == '1')));

        if route_to_el2 then
            exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_SupervisorCall" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SupervisorCall</a>);
            exception.syndrome&lt;15:0&gt; = immediate;
            exception.trappedsyscallinst = TRUE;
            bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
            vect_offset = 0x0;

            <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch32/exceptions/traps/AArch32.CheckForWFxTrap" mylink="aarch32.exceptions.traps.AArch32.CheckForWFxTrap" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.CheckForWFxTrap()
// =========================
// Check for trap on WFE or WFI instruction

<anchor link="AArch32.CheckForWFxTrap.2" hover="function: AArch32.CheckForWFxTrap(bits(2) target_el, WFxType wfxtype)">AArch32.CheckForWFxTrap</anchor>(bits(2) target_el, <a link="WFxType" file="shared_pseudocode.xml" hover="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType</a> wfxtype)
    assert <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(target_el);

    // Check for routing to AArch64
    if !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(target_el) then
        <a link="AArch64.CheckForWFxTrap.2" file="shared_pseudocode.xml" hover="function: AArch64.CheckForWFxTrap(bits(2) target_el, WFxType wfxtype)">AArch64.CheckForWFxTrap</a>(target_el, wfxtype);
        return;

    boolean is_wfe = wfxtype == <a link="WFxType_WFE" file="shared_pseudocode.xml" hover="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFE</a>;
    boolean trap;
    case target_el of
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>
            trap = (if is_wfe then SCTLR.nTWE else SCTLR.nTWI) == '0';
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>
            trap = (if is_wfe then HCR.TWE else HCR.TWI) == '1';
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>
            trap = (if is_wfe then SCR.TWE else SCR.TWI) == '1';

    if trap then
        if target_el == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR_EL2.TGE == '1' then
            <a link="AArch64.WFxTrap.2" file="shared_pseudocode.xml" hover="function: AArch64.WFxTrap(WFxType wfxtype, bits(2) target_el)">AArch64.WFxTrap</a>(wfxtype, target_el);

        if target_el == <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> then
            <a link="AArch32.TakeMonitorTrapException.0" file="shared_pseudocode.xml" hover="function: AArch32.TakeMonitorTrapException()">AArch32.TakeMonitorTrapException</a>();
        elsif target_el == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then
            exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_WFxTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_WFxTrap</a>);
            exception.syndrome&lt;24:20&gt; = <a link="impl-shared.ConditionSyndrome.0" file="shared_pseudocode.xml" hover="function: bits(5) ConditionSyndrome()">ConditionSyndrome</a>();

            case wfxtype of
                when <a link="WFxType_WFI" file="shared_pseudocode.xml" hover="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFI</a>
                    exception.syndrome&lt;0&gt; = '0';
                when <a link="WFxType_WFE" file="shared_pseudocode.xml" hover="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFE</a>
                    exception.syndrome&lt;0&gt; = '1';

            <a link="AArch32.TakeHypTrapException.1" file="shared_pseudocode.xml" hover="function: AArch32.TakeHypTrapException(integer ec)">AArch32.TakeHypTrapException</a>(exception);
        else
            <a link="AArch32.TakeUndefInstrException.0" file="shared_pseudocode.xml" hover="function: AArch32.TakeUndefInstrException()">AArch32.TakeUndefInstrException</a>();</pstext>
    </ps>
    <ps name="aarch32/exceptions/traps/AArch32.CheckITEnabled" mylink="aarch32.exceptions.traps.AArch32.CheckITEnabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.CheckITEnabled()
// ========================
// Check whether the T32 IT instruction is disabled.

<anchor link="AArch32.CheckITEnabled.1" hover="function: AArch32.CheckITEnabled(bits(4) mask)">AArch32.CheckITEnabled</anchor>(bits(4) mask)
    bit it_disabled;
    if PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then
        it_disabled = HSCTLR.ITD;
    else
        it_disabled = (if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then SCTLR.ITD else SCTLR[].ITD);
    if it_disabled == '1' then
        if mask != '1000' then UNDEFINED;

        // Otherwise whether the IT block is allowed depends on hw1 of the next instruction.
        next_instr = <a link="AArch32.MemSingle.read.4" file="shared_pseudocode.xml" hover="accessor: bits(size*8) AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean aligned]">AArch32.MemSingle</a>[<a link="impl-shared.NextInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) NextInstrAddr()">NextInstrAddr</a>(), 2, <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a>, TRUE];

        if next_instr IN {'11xxxxxxxxxxxxxx', '1011xxxxxxxxxxxx', '10100xxxxxxxxxxx',
                          '01001xxxxxxxxxxx', '010001xxx1111xxx', '010001xx1xxxx111'} then
            // It is IMPLEMENTATION DEFINED whether the Undefined Instruction exception is
            // taken on the IT instruction or the next instruction. This is not reflected in
            // the pseudocode, which always takes the exception on the IT instruction. This
            // also does not take into account cases where the next instruction is UNPREDICTABLE.
            UNDEFINED;

    return;</pstext>
    </ps>
    <ps name="aarch32/exceptions/traps/AArch32.CheckIllegalState" mylink="aarch32.exceptions.traps.AArch32.CheckIllegalState" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.CheckIllegalState()
// ===========================
// Check PSTATE.IL bit and generate Illegal Execution state exception if set.

<anchor link="AArch32.CheckIllegalState.0" hover="function: AArch32.CheckIllegalState()">AArch32.CheckIllegalState</anchor>()
    if <a link="AArch32.GeneralExceptionsToAArch64.0" file="shared_pseudocode.xml" hover="function: boolean AArch32.GeneralExceptionsToAArch64()">AArch32.GeneralExceptionsToAArch64</a>() then
        <a link="AArch64.CheckIllegalState.0" file="shared_pseudocode.xml" hover="function: AArch64.CheckIllegalState()">AArch64.CheckIllegalState</a>();
    elsif PSTATE.IL == '1' then
        route_to_hyp = PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR.TGE == '1';

        bits(32) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
        vect_offset = 0x04;

        if PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> || route_to_hyp then
            exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_IllegalState" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IllegalState</a>);
            if PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then
                <a link="AArch32.EnterHypMode.3" file="shared_pseudocode.xml" hover="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
            else
                <a link="AArch32.EnterHypMode.3" file="shared_pseudocode.xml" hover="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, 0x14);
        else
            <a link="AArch32.TakeUndefInstrException.0" file="shared_pseudocode.xml" hover="function: AArch32.TakeUndefInstrException()">AArch32.TakeUndefInstrException</a>();</pstext>
    </ps>
    <ps name="aarch32/exceptions/traps/AArch32.CheckSETENDEnabled" mylink="aarch32.exceptions.traps.AArch32.CheckSETENDEnabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.CheckSETENDEnabled()
// ============================
// Check whether the AArch32 SETEND instruction is disabled.

<anchor link="AArch32.CheckSETENDEnabled.0" hover="function: AArch32.CheckSETENDEnabled()">AArch32.CheckSETENDEnabled</anchor>()
    bit setend_disabled;
    if PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then
        setend_disabled = HSCTLR.SED;
    else
        setend_disabled = (if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then SCTLR.SED else SCTLR[].SED);
    if setend_disabled == '1' then
        UNDEFINED;

    return;</pstext>
    </ps>
    <ps name="aarch32/exceptions/traps/AArch32.SystemAccessTrap" mylink="aarch32.exceptions.traps.AArch32.SystemAccessTrap" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.SystemAccessTrap()
// ==========================
// Trapped  system register access.

<anchor link="AArch32.SystemAccessTrap.2" hover="function: AArch32.SystemAccessTrap(bits(5) mode, integer ec)">AArch32.SystemAccessTrap</anchor>(bits(5) mode, integer ec)
    (valid, target_el) = <a link="impl-shared.ELFromM32.1" file="shared_pseudocode.xml" hover="function: (boolean,bits(2)) ELFromM32(bits(5) mode)">ELFromM32</a>(mode);
    assert valid &amp;&amp; <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(target_el) &amp;&amp; target_el != <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt;= <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL);

    if target_el == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then
        exception = <a link="AArch32.SystemAccessTrapSyndrome.2" file="shared_pseudocode.xml" hover="function: ExceptionRecord AArch32.SystemAccessTrapSyndrome(bits(32) instr, integer ec)">AArch32.SystemAccessTrapSyndrome</a>(<a link="impl-shared.ThisInstr.0" file="shared_pseudocode.xml" hover="function: bits(32) ThisInstr()">ThisInstr</a>(), ec);
        <a link="AArch32.TakeHypTrapException.1" file="shared_pseudocode.xml" hover="function: AArch32.TakeHypTrapException(integer ec)">AArch32.TakeHypTrapException</a>(exception);
    else
        <a link="AArch32.TakeUndefInstrException.0" file="shared_pseudocode.xml" hover="function: AArch32.TakeUndefInstrException()">AArch32.TakeUndefInstrException</a>();</pstext>
    </ps>
    <ps name="aarch32/exceptions/traps/AArch32.SystemAccessTrapSyndrome" mylink="aarch32.exceptions.traps.AArch32.SystemAccessTrapSyndrome" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.SystemAccessTrapSyndrome()
// ==================================
// Returns the syndrome information for traps on AArch32 MCR, MCRR, MRC, MRRC, and VMRS, VMSR instructions,
// other than traps that are due to HCPTR or CPACR.

ExceptionRecord <anchor link="AArch32.SystemAccessTrapSyndrome.2" hover="function: ExceptionRecord AArch32.SystemAccessTrapSyndrome(bits(32) instr, integer ec)">AArch32.SystemAccessTrapSyndrome</anchor>(bits(32) instr, integer ec)
    <a link="ExceptionRecord" file="shared_pseudocode.xml" hover="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception;

    case ec of
        when 0x0    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_Uncategorized" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a>);
        when 0x3    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_CP15RTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RTTrap</a>);
        when 0x4    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_CP15RRTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RRTTrap</a>);
        when 0x5    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_CP14RTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RTTrap</a>);
        when 0x6    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_CP14DTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14DTTrap</a>);
        when 0x7    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_AdvSIMDFPAccessTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>);
        when 0x8    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_FPIDTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPIDTrap</a>);
        when 0xC    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_CP14RRTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RRTTrap</a>);
        otherwise   <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();

    bits(20) iss = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();

    if exception.exceptype == <a link="Exception_Uncategorized" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a> then
        return exception;
    elsif exception.exceptype IN {<a link="Exception_FPIDTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPIDTrap</a>, <a link="Exception_CP14RTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RTTrap</a>, <a link="Exception_CP15RTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RTTrap</a>} then
        // Trapped MRC/MCR, VMRS on FPSID
        iss&lt;13:10&gt; = instr&lt;19:16&gt;;        // CRn, Reg in case of VMRS
        iss&lt;8:5&gt;   = instr&lt;15:12&gt;;        // Rt
        iss&lt;9&gt;     = '0';                 // RES0

        if exception.exceptype != <a link="Exception_FPIDTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPIDTrap</a> then    // When trap is not for VMRS
            iss&lt;19:17&gt; = instr&lt;7:5&gt;;          // opc2
            iss&lt;16:14&gt; = instr&lt;23:21&gt;;        // opc1
            iss&lt;4:1&gt;   = instr&lt;3:0&gt;;          //CRm
        else //VMRS Access
            iss&lt;19:17&gt; = '000';               //opc2 - Hardcoded for VMRS
            iss&lt;16:14&gt; = '111';               //opc1 - Hardcoded for VMRS
            iss&lt;4:1&gt;   = '0000';              //CRm  - Hardcoded for VMRS
    elsif exception.exceptype IN {<a link="Exception_CP14RRTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RRTTrap</a>, <a link="Exception_AdvSIMDFPAccessTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>, <a link="Exception_CP15RRTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RRTTrap</a>} then
        // Trapped MRRC/MCRR, VMRS/VMSR
        iss&lt;19:16&gt; = instr&lt;7:4&gt;;          // opc1
        iss&lt;13:10&gt; = instr&lt;19:16&gt;;        // Rt2
        iss&lt;8:5&gt; = instr&lt;15:12&gt;;          // Rt
        iss&lt;4:1&gt;   = instr&lt;3:0&gt;;         // CRm
    elsif exception.exceptype == <a link="Exception_CP14DTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14DTTrap</a> then
        // Trapped LDC/STC
        iss&lt;19:12&gt; = instr&lt;7:0&gt;;         // imm8
        iss&lt;4&gt;     = instr&lt;23&gt;;          // U
        iss&lt;2:1&gt;   = instr&lt;24,21&gt;;       // P,W
        if instr&lt;19:16&gt; == '1111' then   // Rn==15, LDC(Literal addressing)/STC
            iss&lt;8:5&gt; = bits(4) UNKNOWN;
            iss&lt;3&gt;   = '1';
    iss&lt;0&gt; = instr&lt;20&gt;;                  // Direction

    exception.syndrome&lt;24:20&gt; = <a link="impl-shared.ConditionSyndrome.0" file="shared_pseudocode.xml" hover="function: bits(5) ConditionSyndrome()">ConditionSyndrome</a>();
    exception.syndrome&lt;19:0&gt;  = iss;

    return exception;</pstext>
    </ps>
    <ps name="aarch32/exceptions/traps/AArch32.TakeHypTrapException" mylink="aarch32.exceptions.traps.AArch32.TakeHypTrapException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.TakeHypTrapException()
// ==============================
// Exceptions routed to Hyp mode as a Hyp Trap exception.

<anchor link="AArch32.TakeHypTrapException.1" hover="function: AArch32.TakeHypTrapException(integer ec)">AArch32.TakeHypTrapException</anchor>(integer ec)
    exception = <a link="AArch32.SystemAccessTrapSyndrome.2" file="shared_pseudocode.xml" hover="function: ExceptionRecord AArch32.SystemAccessTrapSyndrome(bits(32) instr, integer ec)">AArch32.SystemAccessTrapSyndrome</a>(<a link="impl-shared.ThisInstr.0" file="shared_pseudocode.xml" hover="function: bits(32) ThisInstr()">ThisInstr</a>(), ec);
    <a link="AArch32.TakeHypTrapException.1" file="shared_pseudocode.xml" hover="function: AArch32.TakeHypTrapException(integer ec)">AArch32.TakeHypTrapException</a>(exception);

// AArch32.TakeHypTrapException()
// ==============================
// Exceptions routed to Hyp mode as a Hyp Trap exception.

<a link="AArch32.TakeHypTrapException.1" file="shared_pseudocode.xml" hover="function: AArch32.TakeHypTrapException(integer ec)">AArch32.TakeHypTrapException</a>(<a link="ExceptionRecord" file="shared_pseudocode.xml" hover="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception)
    assert <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; !<a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>() &amp;&amp; <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>);

    bits(32) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x14;

    <a link="AArch32.EnterHypMode.3" file="shared_pseudocode.xml" hover="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch32/exceptions/traps/AArch32.TakeMonitorTrapException" mylink="aarch32.exceptions.traps.AArch32.TakeMonitorTrapException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.TakeMonitorTrapException()
// ==================================
// Exceptions routed to Monitor mode as a Monitor Trap exception.

<anchor link="AArch32.TakeMonitorTrapException.0" hover="function: AArch32.TakeMonitorTrapException()">AArch32.TakeMonitorTrapException</anchor>()
    assert <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>);

    bits(32) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x04;
    lr_offset = if <a link="impl-shared.CurrentInstrSet.0" file="shared_pseudocode.xml" hover="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() == <a link="InstrSet_A32" file="shared_pseudocode.xml" hover="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> then 4 else 2;

    <a link="AArch32.EnterMonitorMode.3" file="shared_pseudocode.xml" hover="function: AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMonitorMode</a>(preferred_exception_return, lr_offset, vect_offset);</pstext>
    </ps>
    <ps name="aarch32/exceptions/traps/AArch32.TakeUndefInstrException" mylink="aarch32.exceptions.traps.AArch32.TakeUndefInstrException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.TakeUndefInstrException()
// =================================

<anchor link="AArch32.TakeUndefInstrException.0" hover="function: AArch32.TakeUndefInstrException()">AArch32.TakeUndefInstrException</anchor>()
    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_Uncategorized" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a>);
    <a link="AArch32.TakeUndefInstrException.1" file="shared_pseudocode.xml" hover="function: AArch32.TakeUndefInstrException(ExceptionRecord exception)">AArch32.TakeUndefInstrException</a>(exception);

// AArch32.TakeUndefInstrException()
// =================================

<anchor link="AArch32.TakeUndefInstrException.1" hover="function: AArch32.TakeUndefInstrException(ExceptionRecord exception)">AArch32.TakeUndefInstrException</anchor>(<a link="ExceptionRecord" file="shared_pseudocode.xml" hover="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception)

    route_to_hyp = PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR.TGE == '1';
    bits(32) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x04;
    lr_offset = if <a link="impl-shared.CurrentInstrSet.0" file="shared_pseudocode.xml" hover="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() == <a link="InstrSet_A32" file="shared_pseudocode.xml" hover="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> then 4 else 2;

    if PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then
        <a link="AArch32.EnterHypMode.3" file="shared_pseudocode.xml" hover="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
    elsif route_to_hyp then
        <a link="AArch32.EnterHypMode.3" file="shared_pseudocode.xml" hover="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, 0x14);
    else
        <a link="AArch32.EnterMode.4" file="shared_pseudocode.xml" hover="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a link="M32_Undef" file="shared_pseudocode.xml" hover="constant bits(5) M32_Undef = '11011'">M32_Undef</a>, preferred_exception_return, lr_offset, vect_offset);</pstext>
    </ps>
    <ps name="aarch32/exceptions/traps/AArch32.UndefinedFault" mylink="aarch32.exceptions.traps.AArch32.UndefinedFault" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.UndefinedFault()
// ========================

<anchor link="AArch32.UndefinedFault.0" hover="function: AArch32.UndefinedFault()">AArch32.UndefinedFault</anchor>()

    if <a link="AArch32.GeneralExceptionsToAArch64.0" file="shared_pseudocode.xml" hover="function: boolean AArch32.GeneralExceptionsToAArch64()">AArch32.GeneralExceptionsToAArch64</a>() then <a link="AArch64.UndefinedFault.0" file="shared_pseudocode.xml" hover="function: AArch64.UndefinedFault()">AArch64.UndefinedFault</a>();
    <a link="AArch32.TakeUndefInstrException.0" file="shared_pseudocode.xml" hover="function: AArch32.TakeUndefInstrException()">AArch32.TakeUndefInstrException</a>();</pstext>
    </ps>
    <ps name="aarch32/functions/aborts/AArch32.DomainValid" mylink="aarch32.functions.aborts.AArch32.DomainValid" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.DomainValid()
// =====================
// Returns TRUE if the Domain is valid for a Short-descriptor translation scheme.

boolean <anchor link="AArch32.DomainValid.2" hover="function: boolean AArch32.DomainValid(Fault statuscode, integer level)">AArch32.DomainValid</anchor>(<a link="Fault" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> statuscode, integer level)
    assert statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    case statuscode of
        when <a link="Fault_Domain" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Domain</a>
            return TRUE;
        when <a link="Fault_Translation" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>, <a link="Fault_AccessFlag" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>, <a link="Fault_SyncExternalOnWalk" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternalOnWalk</a>, <a link="Fault_SyncParityOnWalk" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParityOnWalk</a>
            return level == 2;
        otherwise
            return FALSE;</pstext>
    </ps>
    <ps name="aarch32/functions/aborts/AArch32.FaultStatusLD" mylink="aarch32.functions.aborts.AArch32.FaultStatusLD" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.FaultStatusLD()
// =======================
// Creates an exception fault status value for Abort and Watchpoint exceptions taken
// to Abort mode using AArch32 and Long-descriptor format.

bits(32) <anchor link="AArch32.FaultStatusLD.2" hover="function: bits(32) AArch32.FaultStatusLD(boolean d_side, FaultRecord fault)">AArch32.FaultStatusLD</anchor>(boolean d_side, <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    assert fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    bits(32) fsr = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();
    if <a link="impl-shared.HaveRASExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; <a link="impl-shared.IsAsyncAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsAsyncAbort(Fault statuscode)">IsAsyncAbort</a>(fault) then fsr&lt;15:14&gt; = fault.errortype;
    if d_side then
        if fault.acctype IN {<a link="AccType_DC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>, <a link="AccType_IC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>,
            <a link="AccType_AT" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</a>, <a link="AccType_ATPAN" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATPAN</a>} then
            fsr&lt;13&gt; = '1'; fsr&lt;11&gt; = '1';
        else
            fsr&lt;11&gt; = if fault.write then '1' else '0';
    if <a link="impl-shared.IsExternalAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) then fsr&lt;12&gt; = fault.extflag;
    fsr&lt;9&gt; = '1';
    fsr&lt;5:0&gt; = <a link="impl-shared.EncodeLDFSC.2" file="shared_pseudocode.xml" hover="function: bits(6) EncodeLDFSC(Fault statuscode, integer level)">EncodeLDFSC</a>(fault.statuscode, fault.level);

    return fsr;</pstext>
    </ps>
    <ps name="aarch32/functions/aborts/AArch32.FaultStatusSD" mylink="aarch32.functions.aborts.AArch32.FaultStatusSD" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.FaultStatusSD()
// =======================
// Creates an exception fault status value for Abort and Watchpoint exceptions taken
// to Abort mode using AArch32 and Short-descriptor format.

bits(32) <anchor link="AArch32.FaultStatusSD.2" hover="function: bits(32) AArch32.FaultStatusSD(boolean d_side, FaultRecord fault)">AArch32.FaultStatusSD</anchor>(boolean d_side, <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    assert fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    bits(32) fsr = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();
    if <a link="impl-shared.HaveRASExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; <a link="impl-shared.IsAsyncAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsAsyncAbort(Fault statuscode)">IsAsyncAbort</a>(fault) then fsr&lt;15:14&gt; = fault.errortype;
    if d_side then
        if fault.acctype IN {<a link="AccType_DC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>, <a link="AccType_IC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>,
            <a link="AccType_AT" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</a>, <a link="AccType_ATPAN" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATPAN</a>} then
            fsr&lt;13&gt; = '1'; fsr&lt;11&gt; = '1';
        else
            fsr&lt;11&gt; = if fault.write then '1' else '0';
    if <a link="impl-shared.IsExternalAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) then fsr&lt;12&gt; = fault.extflag;
    fsr&lt;9&gt; = '0';
    fsr&lt;10,3:0&gt; = <a link="impl-aarch32.EncodeSDFSC.2" file="shared_pseudocode.xml" hover="function: bits(5) EncodeSDFSC(Fault statuscode, integer level)">EncodeSDFSC</a>(fault.statuscode, fault.level);
    if d_side then
        fsr&lt;7:4&gt; = fault.domain;               // Domain field (data fault only)

    return fsr;</pstext>
    </ps>
    <ps name="aarch32/functions/aborts/AArch32.FaultSyndrome" mylink="aarch32.functions.aborts.AArch32.FaultSyndrome" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.FaultSyndrome()
// =======================
// Creates an exception syndrome value for Abort and Watchpoint exceptions taken to
// AArch32 Hyp mode.

bits(25) <anchor link="AArch32.FaultSyndrome.2" hover="function: bits(25) AArch32.FaultSyndrome(boolean d_side, FaultRecord fault)">AArch32.FaultSyndrome</anchor>(boolean d_side, <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    assert fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    bits(25) iss = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();

    if <a link="impl-shared.HaveRASExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; <a link="impl-shared.IsAsyncAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsAsyncAbort(Fault statuscode)">IsAsyncAbort</a>(fault) then
        iss&lt;11:10&gt; = fault.errortype; // AET

    if d_side then
        if (<a link="impl-shared.IsSecondStage.1" file="shared_pseudocode.xml" hover="function: boolean IsSecondStage(FaultRecord fault)">IsSecondStage</a>(fault) &amp;&amp; !fault.s2fs1walk &amp;&amp;
            (!<a link="impl-shared.IsExternalSyncAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(fault) ||
            (!<a link="impl-shared.HaveRASExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; fault.acctype == <a link="AccType_TTW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_TTW</a> &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "ISV on second stage translation table walk"))) then
            iss&lt;24:14&gt; = <a link="impl-shared.LSInstructionSyndrome.0" file="shared_pseudocode.xml" hover="function: bits(11) LSInstructionSyndrome()">LSInstructionSyndrome</a>();

        if fault.acctype IN {<a link="AccType_DC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>, <a link="AccType_IC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>, <a link="AccType_AT" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</a>, <a link="AccType_ATPAN" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATPAN</a>} then
            iss&lt;8&gt; = '1';  iss&lt;6&gt; = '1';
        else
            iss&lt;6&gt; = if fault.write then '1' else '0';

    if <a link="impl-shared.IsExternalAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) then iss&lt;9&gt; = fault.extflag;
    iss&lt;7&gt; = if fault.s2fs1walk then '1' else '0';
    iss&lt;5:0&gt; = <a link="impl-shared.EncodeLDFSC.2" file="shared_pseudocode.xml" hover="function: bits(6) EncodeLDFSC(Fault statuscode, integer level)">EncodeLDFSC</a>(fault.statuscode, fault.level);

    return iss;</pstext>
    </ps>
    <ps name="aarch32/functions/aborts/EncodeSDFSC" mylink="aarch32.functions.aborts.EncodeSDFSC" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// EncodeSDFSC()
// =============
// Function that gives the Short-descriptor FSR code for different types of Fault

bits(5) <anchor link="impl-aarch32.EncodeSDFSC.2" hover="function: bits(5) EncodeSDFSC(Fault statuscode, integer level)">EncodeSDFSC</anchor>(<a link="Fault" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> statuscode, integer level)

    bits(5) result;
    case statuscode of
        when <a link="Fault_AccessFlag" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>
            assert level IN {1,2};
            result = if level == 1 then '00011' else '00110';
        when <a link="Fault_Alignment" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>
            result = '00001';
        when <a link="Fault_Permission" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>
            assert level IN {1,2};
            result = if level == 1 then '01101' else '01111';
        when <a link="Fault_Domain" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Domain</a>
            assert level IN {1,2};
            result = if level == 1 then '01001' else '01011';
        when <a link="Fault_Translation" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>
            assert level IN {1,2};
            result = if level == 1 then '00101' else '00111';
        when <a link="Fault_SyncExternal" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternal</a>
            result = '01000';
        when <a link="Fault_SyncExternalOnWalk" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternalOnWalk</a>
            assert level IN {1,2};
            result = if level == 1 then '01100' else '01110';
        when <a link="Fault_SyncParity" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParity</a>
            result = '11001';
        when <a link="Fault_SyncParityOnWalk" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParityOnWalk</a>
            assert level IN {1,2};
            result = if level == 1 then '11100' else '11110';
        when <a link="Fault_AsyncParity" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncParity</a>
            result = '11000';
        when <a link="Fault_AsyncExternal" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>
            result = '10110';
        when <a link="Fault_Debug" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Debug</a>
            result = '00010';
        when <a link="Fault_TLBConflict" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_TLBConflict</a>
            result = '10000';
        when <a link="Fault_Lockdown" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Lockdown</a>
            result = '10100';   // IMPLEMENTATION DEFINED
        when <a link="Fault_Exclusive" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Exclusive</a>
            result = '10101';   // IMPLEMENTATION DEFINED
        when <a link="Fault_ICacheMaint" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_ICacheMaint</a>
            result = '00100';
        otherwise
            <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();

    return result;</pstext>
    </ps>
    <ps name="aarch32/functions/common/A32ExpandImm" mylink="aarch32.functions.common.A32ExpandImm" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// A32ExpandImm()
// ==============

bits(32) <anchor link="impl-aarch32.A32ExpandImm.1" hover="function: bits(32) A32ExpandImm(bits(12) imm12)">A32ExpandImm</anchor>(bits(12) imm12)

    // PSTATE.C argument to following function call does not affect the imm32 result.
    (imm32, -) = <a link="impl-aarch32.A32ExpandImm_C.2" file="shared_pseudocode.xml" hover="function: (bits(32), bit) A32ExpandImm_C(bits(12) imm12, bit carry_in)">A32ExpandImm_C</a>(imm12, PSTATE.C);

    return imm32;</pstext>
    </ps>
    <ps name="aarch32/functions/common/A32ExpandImm_C" mylink="aarch32.functions.common.A32ExpandImm_C" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// A32ExpandImm_C()
// ================

(bits(32), bit) <anchor link="impl-aarch32.A32ExpandImm_C.2" hover="function: (bits(32), bit) A32ExpandImm_C(bits(12) imm12, bit carry_in)">A32ExpandImm_C</anchor>(bits(12) imm12, bit carry_in)

    unrotated_value = <a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(imm12&lt;7:0&gt;, 32);
    (imm32, carry_out) = <a link="impl-aarch32.Shift_C.4" file="shared_pseudocode.xml" hover="function: (bits(N), bit) Shift_C(bits(N) value, SRType srtype, integer amount, bit carry_in)">Shift_C</a>(unrotated_value, <a link="SRType_ROR" file="shared_pseudocode.xml" hover="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ROR</a>, 2*<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(imm12&lt;11:8&gt;), carry_in);

    return (imm32, carry_out);</pstext>
    </ps>
    <ps name="aarch32/functions/common/DecodeImmShift" mylink="aarch32.functions.common.DecodeImmShift" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// DecodeImmShift()
// ================

(SRType, integer) <anchor link="impl-aarch32.DecodeImmShift.2" hover="function: (SRType, integer) DecodeImmShift(bits(2) srtype, bits(5) imm5)">DecodeImmShift</anchor>(bits(2) srtype, bits(5) imm5)

    <a link="SRType" file="shared_pseudocode.xml" hover="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType</a> shift_t;
    integer shift_n;
    case srtype of
        when '00'
            shift_t = <a link="SRType_LSL" file="shared_pseudocode.xml" hover="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_LSL</a>;  shift_n = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(imm5);
        when '01'
            shift_t = <a link="SRType_LSR" file="shared_pseudocode.xml" hover="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_LSR</a>;  shift_n = if imm5 == '00000' then 32 else <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(imm5);
        when '10'
            shift_t = <a link="SRType_ASR" file="shared_pseudocode.xml" hover="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ASR</a>;  shift_n = if imm5 == '00000' then 32 else <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(imm5);
        when '11'
            if imm5 == '00000' then
                shift_t = <a link="SRType_RRX" file="shared_pseudocode.xml" hover="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_RRX</a>;  shift_n = 1;
            else
                shift_t = <a link="SRType_ROR" file="shared_pseudocode.xml" hover="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ROR</a>;  shift_n = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(imm5);

    return (shift_t, shift_n);</pstext>
    </ps>
    <ps name="aarch32/functions/common/DecodeRegShift" mylink="aarch32.functions.common.DecodeRegShift" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// DecodeRegShift()
// ================

SRType <anchor link="impl-aarch32.DecodeRegShift.1" hover="function: SRType DecodeRegShift(bits(2) srtype)">DecodeRegShift</anchor>(bits(2) srtype)
    <a link="SRType" file="shared_pseudocode.xml" hover="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType</a> shift_t;
    case srtype of
        when '00'  shift_t = <a link="SRType_LSL" file="shared_pseudocode.xml" hover="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_LSL</a>;
        when '01'  shift_t = <a link="SRType_LSR" file="shared_pseudocode.xml" hover="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_LSR</a>;
        when '10'  shift_t = <a link="SRType_ASR" file="shared_pseudocode.xml" hover="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ASR</a>;
        when '11'  shift_t = <a link="SRType_ROR" file="shared_pseudocode.xml" hover="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ROR</a>;
    return shift_t;</pstext>
    </ps>
    <ps name="aarch32/functions/common/RRX" mylink="aarch32.functions.common.RRX" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// RRX()
// =====

bits(N) <anchor link="impl-aarch32.RRX.2" hover="function: bits(N) RRX(bits(N) x, bit carry_in)">RRX</anchor>(bits(N) x, bit carry_in)
    (result, -) = <a link="impl-aarch32.RRX_C.2" file="shared_pseudocode.xml" hover="function: (bits(N), bit) RRX_C(bits(N) x, bit carry_in)">RRX_C</a>(x, carry_in);
    return result;</pstext>
    </ps>
    <ps name="aarch32/functions/common/RRX_C" mylink="aarch32.functions.common.RRX_C" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// RRX_C()
// =======

(bits(N), bit) <anchor link="impl-aarch32.RRX_C.2" hover="function: (bits(N), bit) RRX_C(bits(N) x, bit carry_in)">RRX_C</anchor>(bits(N) x, bit carry_in)
    result = carry_in : x&lt;N-1:1&gt;;
    carry_out = x&lt;0&gt;;
    return (result, carry_out);</pstext>
    </ps>
    <ps name="aarch32/functions/common/SRType" mylink="aarch32.functions.common.SRType" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="SRType" hover="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType</anchor> {<anchor link="SRType_LSL" hover="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_LSL</anchor>, <anchor link="SRType_LSR" hover="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_LSR</anchor>, <anchor link="SRType_ASR" hover="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ASR</anchor>, <anchor link="SRType_ROR" hover="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ROR</anchor>, <anchor link="SRType_RRX" hover="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_RRX</anchor>};</pstext>
    </ps>
    <ps name="aarch32/functions/common/Shift" mylink="aarch32.functions.common.Shift" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Shift()
// =======

bits(N) <anchor link="impl-aarch32.Shift.4" hover="function: bits(N) Shift(bits(N) value, SRType srtype, integer amount, bit carry_in)">Shift</anchor>(bits(N) value, <a link="SRType" file="shared_pseudocode.xml" hover="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType</a> srtype, integer amount, bit carry_in)
    (result, -) = <a link="impl-aarch32.Shift_C.4" file="shared_pseudocode.xml" hover="function: (bits(N), bit) Shift_C(bits(N) value, SRType srtype, integer amount, bit carry_in)">Shift_C</a>(value, srtype, amount, carry_in);
    return result;</pstext>
    </ps>
    <ps name="aarch32/functions/common/Shift_C" mylink="aarch32.functions.common.Shift_C" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Shift_C()
// =========

(bits(N), bit) <anchor link="impl-aarch32.Shift_C.4" hover="function: (bits(N), bit) Shift_C(bits(N) value, SRType srtype, integer amount, bit carry_in)">Shift_C</anchor>(bits(N) value, <a link="SRType" file="shared_pseudocode.xml" hover="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType</a> srtype, integer amount, bit carry_in)
    assert !(srtype == <a link="SRType_RRX" file="shared_pseudocode.xml" hover="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_RRX</a> &amp;&amp; amount != 1);

    bits(N) result;
    bit carry_out;
    if amount == 0 then
        (result, carry_out) = (value, carry_in);
    else
        case srtype of
            when <a link="SRType_LSL" file="shared_pseudocode.xml" hover="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_LSL</a>
                (result, carry_out) = <a link="impl-shared.LSL_C.2" file="shared_pseudocode.xml" hover="function: (bits(N), bit) LSL_C(bits(N) x, integer shift)">LSL_C</a>(value, amount);
            when <a link="SRType_LSR" file="shared_pseudocode.xml" hover="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_LSR</a>
                (result, carry_out) = <a link="impl-shared.LSR_C.2" file="shared_pseudocode.xml" hover="function: (bits(N), bit) LSR_C(bits(N) x, integer shift)">LSR_C</a>(value, amount);
            when <a link="SRType_ASR" file="shared_pseudocode.xml" hover="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ASR</a>
                (result, carry_out) = <a link="impl-shared.ASR_C.2" file="shared_pseudocode.xml" hover="function: (bits(N), bit) ASR_C(bits(N) x, integer shift)">ASR_C</a>(value, amount);
            when <a link="SRType_ROR" file="shared_pseudocode.xml" hover="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ROR</a>
                (result, carry_out) = <a link="impl-shared.ROR_C.2" file="shared_pseudocode.xml" hover="function: (bits(N), bit) ROR_C(bits(N) x, integer shift)">ROR_C</a>(value, amount);
            when <a link="SRType_RRX" file="shared_pseudocode.xml" hover="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_RRX</a>
                (result, carry_out) = <a link="impl-aarch32.RRX_C.2" file="shared_pseudocode.xml" hover="function: (bits(N), bit) RRX_C(bits(N) x, bit carry_in)">RRX_C</a>(value, carry_in);

    return (result, carry_out);</pstext>
    </ps>
    <ps name="aarch32/functions/common/T32ExpandImm" mylink="aarch32.functions.common.T32ExpandImm" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// T32ExpandImm()
// ==============

bits(32) <anchor link="impl-aarch32.T32ExpandImm.1" hover="function: bits(32) T32ExpandImm(bits(12) imm12)">T32ExpandImm</anchor>(bits(12) imm12)

    // PSTATE.C argument to following function call does not affect the imm32 result.
    (imm32, -) = <a link="impl-aarch32.T32ExpandImm_C.2" file="shared_pseudocode.xml" hover="function: (bits(32), bit) T32ExpandImm_C(bits(12) imm12, bit carry_in)">T32ExpandImm_C</a>(imm12, PSTATE.C);

    return imm32;</pstext>
    </ps>
    <ps name="aarch32/functions/common/T32ExpandImm_C" mylink="aarch32.functions.common.T32ExpandImm_C" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// T32ExpandImm_C()
// ================

(bits(32), bit) <anchor link="impl-aarch32.T32ExpandImm_C.2" hover="function: (bits(32), bit) T32ExpandImm_C(bits(12) imm12, bit carry_in)">T32ExpandImm_C</anchor>(bits(12) imm12, bit carry_in)
    bits(32) imm32;
    bit carry_out;
    if imm12&lt;11:10&gt; == '00' then
        case imm12&lt;9:8&gt; of
            when '00'
                imm32 = <a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(imm12&lt;7:0&gt;, 32);
            when '01'
                imm32 = '00000000' : imm12&lt;7:0&gt; : '00000000' : imm12&lt;7:0&gt;;
            when '10'
                imm32 = imm12&lt;7:0&gt; : '00000000' : imm12&lt;7:0&gt; : '00000000';
            when '11'
                imm32 = imm12&lt;7:0&gt; : imm12&lt;7:0&gt; : imm12&lt;7:0&gt; : imm12&lt;7:0&gt;;
        carry_out = carry_in;
    else
        unrotated_value = <a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>('1':imm12&lt;6:0&gt;, 32);
        (imm32, carry_out) = <a link="impl-shared.ROR_C.2" file="shared_pseudocode.xml" hover="function: (bits(N), bit) ROR_C(bits(N) x, integer shift)">ROR_C</a>(unrotated_value, <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(imm12&lt;11:7&gt;));

    return (imm32, carry_out);</pstext>
    </ps>
    <ps name="aarch32/functions/common/VBitOps" mylink="aarch32.functions.common.VBitOps" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="VBitOps" hover="enumeration VBitOps {VBitOps_VBIF, VBitOps_VBIT, VBitOps_VBSL}">VBitOps</anchor> {<anchor link="VBitOps_VBIF" hover="enumeration VBitOps {VBitOps_VBIF, VBitOps_VBIT, VBitOps_VBSL}">VBitOps_VBIF</anchor>, <anchor link="VBitOps_VBIT" hover="enumeration VBitOps {VBitOps_VBIF, VBitOps_VBIT, VBitOps_VBSL}">VBitOps_VBIT</anchor>, <anchor link="VBitOps_VBSL" hover="enumeration VBitOps {VBitOps_VBIF, VBitOps_VBIT, VBitOps_VBSL}">VBitOps_VBSL</anchor>};</pstext>
    </ps>
    <ps name="aarch32/functions/common/VCGEType" mylink="aarch32.functions.common.VCGEType" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="VCGEType" hover="enumeration VCGEType {VCGEType_signed, VCGEType_unsigned, VCGEType_fp}">VCGEType</anchor> {<anchor link="VCGEType_signed" hover="enumeration VCGEType {VCGEType_signed, VCGEType_unsigned, VCGEType_fp}">VCGEType_signed</anchor>, <anchor link="VCGEType_unsigned" hover="enumeration VCGEType {VCGEType_signed, VCGEType_unsigned, VCGEType_fp}">VCGEType_unsigned</anchor>, <anchor link="VCGEType_fp" hover="enumeration VCGEType {VCGEType_signed, VCGEType_unsigned, VCGEType_fp}">VCGEType_fp</anchor>};</pstext>
    </ps>
    <ps name="aarch32/functions/common/VCGTtype" mylink="aarch32.functions.common.VCGTtype" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="VCGTtype" hover="enumeration VCGTtype {VCGTtype_signed, VCGTtype_unsigned, VCGTtype_fp}">VCGTtype</anchor> {<anchor link="VCGTtype_signed" hover="enumeration VCGTtype {VCGTtype_signed, VCGTtype_unsigned, VCGTtype_fp}">VCGTtype_signed</anchor>, <anchor link="VCGTtype_unsigned" hover="enumeration VCGTtype {VCGTtype_signed, VCGTtype_unsigned, VCGTtype_fp}">VCGTtype_unsigned</anchor>, <anchor link="VCGTtype_fp" hover="enumeration VCGTtype {VCGTtype_signed, VCGTtype_unsigned, VCGTtype_fp}">VCGTtype_fp</anchor>};</pstext>
    </ps>
    <ps name="aarch32/functions/common/VFPNegMul" mylink="aarch32.functions.common.VFPNegMul" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="VFPNegMul" hover="enumeration VFPNegMul {VFPNegMul_VNMLA, VFPNegMul_VNMLS, VFPNegMul_VNMUL}">VFPNegMul</anchor> {<anchor link="VFPNegMul_VNMLA" hover="enumeration VFPNegMul {VFPNegMul_VNMLA, VFPNegMul_VNMLS, VFPNegMul_VNMUL}">VFPNegMul_VNMLA</anchor>, <anchor link="VFPNegMul_VNMLS" hover="enumeration VFPNegMul {VFPNegMul_VNMLA, VFPNegMul_VNMLS, VFPNegMul_VNMUL}">VFPNegMul_VNMLS</anchor>, <anchor link="VFPNegMul_VNMUL" hover="enumeration VFPNegMul {VFPNegMul_VNMLA, VFPNegMul_VNMLS, VFPNegMul_VNMUL}">VFPNegMul_VNMUL</anchor>};</pstext>
    </ps>
    <ps name="aarch32/functions/coproc/AArch32.CheckCP15InstrCoarseTraps" mylink="aarch32.functions.coproc.AArch32.CheckCP15InstrCoarseTraps" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.CheckCP15InstrCoarseTraps()
// ===================================
// Check for coarse-grained  traps to System registers in the
// coproc=0b1111 encoding space by HSTR and HCR.

<anchor link="AArch32.CheckCP15InstrCoarseTraps.3" hover="function: AArch32.CheckCP15InstrCoarseTraps(integer CRn, integer nreg, integer CRm)">AArch32.CheckCP15InstrCoarseTraps</anchor>(integer CRn, integer nreg, integer CRm)
    if PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; (!<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) ||
            (<a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>))) then
        <a link="AArch64.CheckCP15InstrCoarseTraps.3" file="shared_pseudocode.xml" hover="function: AArch64.CheckCP15InstrCoarseTraps(integer CRn, integer nreg, integer CRm)">AArch64.CheckCP15InstrCoarseTraps</a>(CRn, nreg, CRm);

    trapped_encoding = ((CRn == 9  &amp;&amp; CRm IN {0,1,2,    5,6,7,8   }) ||
                        (CRn == 10 &amp;&amp; CRm IN {0,1,    4,      8   }) ||
                        (CRn == 11 &amp;&amp; CRm IN {0,1,2,3,4,5,6,7,8,15}));

    // Check for coarse-grained Hyp traps
    if PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() then
        major = if nreg == 1 then CRn else CRm;
        // Check for MCR, MRC, MCRR, and MRRC disabled by HSTR&lt;CRn/CRm&gt;
        // and MRC and MCR disabled by HCR.TIDCP.
        if ((!(major IN {4,14}) &amp;&amp; HSTR&lt;major&gt; == '1') ||
                (HCR.TIDCP == '1' &amp;&amp; nreg == 1 &amp;&amp; trapped_encoding)) then
            if (PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp;
                    boolean IMPLEMENTATION_DEFINED "UNDEF unallocated CP15 access at <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>") then
                UNDEFINED;
            if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
                <a link="AArch32.SystemAccessTrap.2" file="shared_pseudocode.xml" hover="function: AArch32.SystemAccessTrap(bits(5) mode, integer ec)">AArch32.SystemAccessTrap</a>(<a link="M32_Hyp" file="shared_pseudocode.xml" hover="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>, 0x3);
            else
                <a link="AArch64.AArch32SystemAccessTrap.2" file="shared_pseudocode.xml" hover="function: AArch64.AArch32SystemAccessTrap(bits(2) target_el, integer ec)">AArch64.AArch32SystemAccessTrap</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, 0x3);</pstext>
    </ps>
    <ps name="aarch32/functions/exclusive/AArch32.ExclusiveMonitorsPass" mylink="aarch32.functions.exclusive.AArch32.ExclusiveMonitorsPass" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.ExclusiveMonitorsPass()
// ===============================
// Return TRUE if the Exclusives monitors for the current PE include all of the addresses
// associated with the virtual address region of size bytes starting at address.
// The immediately following memory write must be to the same addresses.

boolean <anchor link="AArch32.ExclusiveMonitorsPass.2" hover="function: boolean AArch32.ExclusiveMonitorsPass(bits(32) address, integer size)">AArch32.ExclusiveMonitorsPass</anchor>(bits(32) address, integer size)

    // It is IMPLEMENTATION DEFINED whether the detection of memory aborts happens
    // before or after the check on the local Exclusives monitor. As a result a failure
    // of the local monitor can occur on some implementations even if the memory
    // access would give an memory abort.

    acctype = <a link="AccType_ATOMIC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMIC</a>;
    iswrite = TRUE;

    aligned = <a link="AArch32.CheckAlignment.4" file="shared_pseudocode.xml" hover="function: boolean AArch32.CheckAlignment(bits(32) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch32.CheckAlignment</a>(address, size, acctype, iswrite);

    passed = <a link="AArch32.IsExclusiveVA.3" file="shared_pseudocode.xml" hover="function: boolean AArch32.IsExclusiveVA(bits(32) address, integer processorid, integer size)">AArch32.IsExclusiveVA</a>(address, <a link="impl-shared.ProcessorID.0" file="shared_pseudocode.xml" hover="function: integer ProcessorID()">ProcessorID</a>(), size);
    if !passed then
        return FALSE;

    memaddrdesc = <a link="AArch32.TranslateAddress.5" file="shared_pseudocode.xml" hover="function: AddressDescriptor AArch32.TranslateAddress(bits(32) va, AccType acctype,&#13; boolean iswrite, boolean aligned,&#13; integer size)">AArch32.TranslateAddress</a>(address, acctype, iswrite, aligned, size);
    // Check for aborts or debug exceptions
    if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a link="AArch32.Abort.2" file="shared_pseudocode.xml" hover="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(address, memaddrdesc.fault);

    passed = <a link="impl-shared.IsExclusiveLocal.3" file="shared_pseudocode.xml" hover="function: boolean IsExclusiveLocal(FullAddress paddress, integer processorid, integer size)">IsExclusiveLocal</a>(memaddrdesc.paddress, <a link="impl-shared.ProcessorID.0" file="shared_pseudocode.xml" hover="function: integer ProcessorID()">ProcessorID</a>(), size);
    <a link="impl-shared.ClearExclusiveLocal.1" file="shared_pseudocode.xml" hover="function: ClearExclusiveLocal(integer processorid)">ClearExclusiveLocal</a>(<a link="impl-shared.ProcessorID.0" file="shared_pseudocode.xml" hover="function: integer ProcessorID()">ProcessorID</a>());

    if passed then
        if memaddrdesc.memattrs.shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then
            passed = <a link="impl-shared.IsExclusiveGlobal.3" file="shared_pseudocode.xml" hover="function: boolean IsExclusiveGlobal(FullAddress paddress, integer processorid, integer size)">IsExclusiveGlobal</a>(memaddrdesc.paddress, <a link="impl-shared.ProcessorID.0" file="shared_pseudocode.xml" hover="function: integer ProcessorID()">ProcessorID</a>(), size);

    return passed;</pstext>
    </ps>
    <ps name="aarch32/functions/exclusive/AArch32.IsExclusiveVA" mylink="aarch32.functions.exclusive.AArch32.IsExclusiveVA" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// An optional IMPLEMENTATION DEFINED test for an exclusive access to a virtual
// address region of size bytes starting at address.
//
// It is permitted (but not required) for this function to return FALSE and
// cause a store exclusive to fail if the virtual address region is not
// totally included within the region recorded by MarkExclusiveVA().
//
// It is always safe to return TRUE which will check the physical address only.
boolean <anchor link="AArch32.IsExclusiveVA.3" hover="function: boolean AArch32.IsExclusiveVA(bits(32) address, integer processorid, integer size)">AArch32.IsExclusiveVA</anchor>(bits(32) address, integer processorid, integer size);</pstext>
    </ps>
    <ps name="aarch32/functions/exclusive/AArch32.MarkExclusiveVA" mylink="aarch32.functions.exclusive.AArch32.MarkExclusiveVA" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Optionally record an exclusive access to the virtual address region of size bytes
// starting at address for processorid.
<anchor link="AArch32.MarkExclusiveVA.3" hover="function: AArch32.MarkExclusiveVA(bits(32) address, integer processorid, integer size)">AArch32.MarkExclusiveVA</anchor>(bits(32) address, integer processorid, integer size);</pstext>
    </ps>
    <ps name="aarch32/functions/exclusive/AArch32.SetExclusiveMonitors" mylink="aarch32.functions.exclusive.AArch32.SetExclusiveMonitors" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.SetExclusiveMonitors()
// ==============================
// Sets the Exclusives monitors for the current PE to record the addresses associated
// with the virtual address region of size bytes starting at address.

<anchor link="AArch32.SetExclusiveMonitors.2" hover="function: AArch32.SetExclusiveMonitors(bits(32) address, integer size)">AArch32.SetExclusiveMonitors</anchor>(bits(32) address, integer size)
    acctype = <a link="AccType_ATOMIC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMIC</a>;
    iswrite = FALSE;

    aligned = <a link="AArch32.CheckAlignment.4" file="shared_pseudocode.xml" hover="function: boolean AArch32.CheckAlignment(bits(32) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch32.CheckAlignment</a>(address, size, acctype, iswrite);

    memaddrdesc = <a link="AArch32.TranslateAddress.5" file="shared_pseudocode.xml" hover="function: AddressDescriptor AArch32.TranslateAddress(bits(32) va, AccType acctype,&#13; boolean iswrite, boolean aligned,&#13; integer size)">AArch32.TranslateAddress</a>(address, acctype, iswrite, aligned, size);
    // Check for aborts or debug exceptions
    if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        return;

    if memaddrdesc.memattrs.shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then
        <a link="impl-shared.MarkExclusiveGlobal.3" file="shared_pseudocode.xml" hover="function: MarkExclusiveGlobal(FullAddress paddress, integer processorid, integer size)">MarkExclusiveGlobal</a>(memaddrdesc.paddress, <a link="impl-shared.ProcessorID.0" file="shared_pseudocode.xml" hover="function: integer ProcessorID()">ProcessorID</a>(), size);

    <a link="impl-shared.MarkExclusiveLocal.3" file="shared_pseudocode.xml" hover="function: MarkExclusiveLocal(FullAddress paddress, integer processorid, integer size)">MarkExclusiveLocal</a>(memaddrdesc.paddress, <a link="impl-shared.ProcessorID.0" file="shared_pseudocode.xml" hover="function: integer ProcessorID()">ProcessorID</a>(), size);

    <a link="AArch32.MarkExclusiveVA.3" file="shared_pseudocode.xml" hover="function: AArch32.MarkExclusiveVA(bits(32) address, integer processorid, integer size)">AArch32.MarkExclusiveVA</a>(address, <a link="impl-shared.ProcessorID.0" file="shared_pseudocode.xml" hover="function: integer ProcessorID()">ProcessorID</a>(), size);</pstext>
    </ps>
    <ps name="aarch32/functions/float/CheckAdvSIMDEnabled" mylink="aarch32.functions.float.CheckAdvSIMDEnabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CheckAdvSIMDEnabled()
// =====================

<anchor link="impl-aarch32.CheckAdvSIMDEnabled.0" hover="function: CheckAdvSIMDEnabled()">CheckAdvSIMDEnabled</anchor>()

    fpexc_check = TRUE;
    advsimd = TRUE;

    <a link="AArch32.CheckAdvSIMDOrFPEnabled.2" file="shared_pseudocode.xml" hover="function: AArch32.CheckAdvSIMDOrFPEnabled(boolean fpexc_check, boolean advsimd)">AArch32.CheckAdvSIMDOrFPEnabled</a>(fpexc_check, advsimd);
    // Return from CheckAdvSIMDOrFPEnabled() occurs only if Advanced SIMD access is permitted

    // Make temporary copy of D registers
    // _Dclone[] is used as input data for instruction pseudocode
    for i = 0 to 31
        _Dclone[i] = <a link="impl-aarch32.D.read.1" file="shared_pseudocode.xml" hover="accessor: bits(64) D[integer n]">D</a>[i];

    return;</pstext>
    </ps>
    <ps name="aarch32/functions/float/CheckAdvSIMDOrVFPEnabled" mylink="aarch32.functions.float.CheckAdvSIMDOrVFPEnabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CheckAdvSIMDOrVFPEnabled()
// ==========================

<anchor link="impl-aarch32.CheckAdvSIMDOrVFPEnabled.2" hover="function: CheckAdvSIMDOrVFPEnabled(boolean include_fpexc_check, boolean advsimd)">CheckAdvSIMDOrVFPEnabled</anchor>(boolean include_fpexc_check, boolean advsimd)
    <a link="AArch32.CheckAdvSIMDOrFPEnabled.2" file="shared_pseudocode.xml" hover="function: AArch32.CheckAdvSIMDOrFPEnabled(boolean fpexc_check, boolean advsimd)">AArch32.CheckAdvSIMDOrFPEnabled</a>(include_fpexc_check, advsimd);
    // Return from CheckAdvSIMDOrFPEnabled() occurs only if VFP access is permitted
    return;</pstext>
    </ps>
    <ps name="aarch32/functions/float/CheckCryptoEnabled32" mylink="aarch32.functions.float.CheckCryptoEnabled32" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CheckCryptoEnabled32()
// ======================

<anchor link="impl-aarch32.CheckCryptoEnabled32.0" hover="function: CheckCryptoEnabled32()">CheckCryptoEnabled32</anchor>()
    <a link="impl-aarch32.CheckAdvSIMDEnabled.0" file="shared_pseudocode.xml" hover="function: CheckAdvSIMDEnabled()">CheckAdvSIMDEnabled</a>();
    // Return from CheckAdvSIMDEnabled() occurs only if access is permitted
    return;</pstext>
    </ps>
    <ps name="aarch32/functions/float/CheckVFPEnabled" mylink="aarch32.functions.float.CheckVFPEnabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CheckVFPEnabled()
// =================

<anchor link="impl-aarch32.CheckVFPEnabled.1" hover="function: CheckVFPEnabled(boolean include_fpexc_check)">CheckVFPEnabled</anchor>(boolean include_fpexc_check)
    advsimd = FALSE;
    <a link="AArch32.CheckAdvSIMDOrFPEnabled.2" file="shared_pseudocode.xml" hover="function: AArch32.CheckAdvSIMDOrFPEnabled(boolean fpexc_check, boolean advsimd)">AArch32.CheckAdvSIMDOrFPEnabled</a>(include_fpexc_check, advsimd);
    // Return from CheckAdvSIMDOrFPEnabled() occurs only if VFP access is permitted
    return;</pstext>
    </ps>
    <ps name="aarch32/functions/float/FPHalvedSub" mylink="aarch32.functions.float.FPHalvedSub" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPHalvedSub()
// =============

bits(N) <anchor link="impl-aarch32.FPHalvedSub.3" hover="function: bits(N) FPHalvedSub(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPHalvedSub</anchor>(bits(N) op1, bits(N) op2, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)
    assert N IN {16,32,64};
    rounding = <a link="impl-shared.FPRoundingMode.1" file="shared_pseudocode.xml" hover="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);
    (type1,sign1,value1) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);
    (done,result) = <a link="impl-shared.FPProcessNaNs.5" file="shared_pseudocode.xml" hover="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1,&#13; bits(N) op2, FPCRType fpcr)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);  inf2 = (type2 == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);     zero2 = (type2 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        if inf1 &amp;&amp; inf2 &amp;&amp; sign1 == sign2 then
            result = <a link="impl-shared.FPDefaultNaN.1" file="shared_pseudocode.xml" hover="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
            <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InvalidOp" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        elsif (inf1 &amp;&amp; sign1 == '0') || (inf2 &amp;&amp; sign2 == '1') then
            result = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('0');
        elsif (inf1 &amp;&amp; sign1 == '1') || (inf2 &amp;&amp; sign2 == '0') then
            result = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('1');
        elsif zero1 &amp;&amp; zero2 &amp;&amp; sign1 != sign2 then
            result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(sign1);
        else
            result_value = (value1 - value2) / 2.0;
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                result_sign = if rounding == <a link="FPRounding_NEGINF" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a> then '1' else '0';
                result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(result_sign);
            else
                result = <a link="impl-shared.FPRound.2" file="shared_pseudocode.xml" hover="function: bits(N) FPRound(real op, FPCRType fpcr)">FPRound</a>(result_value, fpcr);
    return result;</pstext>
    </ps>
    <ps name="aarch32/functions/float/FPRSqrtStep" mylink="aarch32.functions.float.FPRSqrtStep" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPRSqrtStep()
// =============

bits(N) <anchor link="impl-aarch32.FPRSqrtStep.2" hover="function: bits(N) FPRSqrtStep(bits(N) op1, bits(N) op2)">FPRSqrtStep</anchor>(bits(N) op1, bits(N) op2)
    assert N IN {16,32};
    <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr = <a link="impl-aarch32.StandardFPSCRValue.0" file="shared_pseudocode.xml" hover="function: FPCRType StandardFPSCRValue()">StandardFPSCRValue</a>();
    (type1,sign1,value1) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);
    (done,result) = <a link="impl-shared.FPProcessNaNs.5" file="shared_pseudocode.xml" hover="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1,&#13; bits(N) op2, FPCRType fpcr)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);  inf2 = (type2 == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);     zero2 = (type2 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        bits(N) product;
        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            product = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>('0');
        else
            product = <a link="impl-shared.FPMul.3" file="shared_pseudocode.xml" hover="function: bits(N) FPMul(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPMul</a>(op1, op2, fpcr);
        bits(N) three = <a link="impl-shared.FPThree.1" file="shared_pseudocode.xml" hover="function: bits(N) FPThree(bit sign)">FPThree</a>('0');
        result = <a link="impl-aarch32.FPHalvedSub.3" file="shared_pseudocode.xml" hover="function: bits(N) FPHalvedSub(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPHalvedSub</a>(three, product, fpcr);
    return result;</pstext>
    </ps>
    <ps name="aarch32/functions/float/FPRecipStep" mylink="aarch32.functions.float.FPRecipStep" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPRecipStep()
// =============

bits(N) <anchor link="impl-aarch32.FPRecipStep.2" hover="function: bits(N) FPRecipStep(bits(N) op1, bits(N) op2)">FPRecipStep</anchor>(bits(N) op1, bits(N) op2)
    assert N IN {16,32};
    <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr = <a link="impl-aarch32.StandardFPSCRValue.0" file="shared_pseudocode.xml" hover="function: FPCRType StandardFPSCRValue()">StandardFPSCRValue</a>();
    (type1,sign1,value1) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);
    (done,result) = <a link="impl-shared.FPProcessNaNs.5" file="shared_pseudocode.xml" hover="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1,&#13; bits(N) op2, FPCRType fpcr)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);  inf2 = (type2 == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);     zero2 = (type2 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        bits(N) product;
        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            product = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>('0');
        else
            product = <a link="impl-shared.FPMul.3" file="shared_pseudocode.xml" hover="function: bits(N) FPMul(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPMul</a>(op1, op2, fpcr);
        bits(N) two = <a link="impl-shared.FPTwo.1" file="shared_pseudocode.xml" hover="function: bits(N) FPTwo(bit sign)">FPTwo</a>('0');
        result = <a link="impl-shared.FPSub.3" file="shared_pseudocode.xml" hover="function: bits(N) FPSub(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPSub</a>(two, product, fpcr);
    return result;</pstext>
    </ps>
    <ps name="aarch32/functions/float/StandardFPSCRValue" mylink="aarch32.functions.float.StandardFPSCRValue" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// StandardFPSCRValue()
// ====================

FPCRType <anchor link="impl-aarch32.StandardFPSCRValue.0" hover="function: FPCRType StandardFPSCRValue()">StandardFPSCRValue</anchor>()
    bits(32) upper = '00000000000000000000000000000000';
    bits(32) lower = '00000' : FPSCR.AHP : '110000' : FPSCR.FZ16 : '0000000000000000000';
    return upper : lower;</pstext>
    </ps>
    <ps name="aarch32/functions/memory/AArch32.CheckAlignment" mylink="aarch32.functions.memory.AArch32.CheckAlignment" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.CheckAlignment()
// ========================

boolean <anchor link="AArch32.CheckAlignment.4" hover="function: boolean AArch32.CheckAlignment(bits(32) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch32.CheckAlignment</anchor>(bits(32) address, integer alignment, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype,
                               boolean iswrite)

    bit A;
    if PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>()) then
        A = SCTLR[].A; //use AArch64 register, when higher Exception level is using AArch64
    elsif PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then
        A = HSCTLR.A;
    else
        A = SCTLR.A;
    aligned = (address == <a link="impl-shared.Align.2" file="shared_pseudocode.xml" hover="function: integer Align(integer x, integer y)">Align</a>(address, alignment));
    atomic  = acctype IN { <a link="AccType_ATOMIC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMIC</a>, <a link="AccType_ATOMICRW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a>, <a link="AccType_ORDEREDATOMIC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMIC</a>,
                           <a link="AccType_ORDEREDATOMICRW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMICRW</a>, <a link="AccType_ATOMICLS64" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICLS64</a>, <a link="AccType_A32LSMD" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_A32LSMD</a>};
    ordered = acctype IN { <a link="AccType_ORDERED" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDERED</a>, <a link="AccType_ORDEREDRW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDRW</a>, <a link="AccType_LIMITEDORDERED" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_LIMITEDORDERED</a>,
                           <a link="AccType_ORDEREDATOMIC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMIC</a>, <a link="AccType_ORDEREDATOMICRW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMICRW</a> };
    vector  = acctype == <a link="AccType_VEC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VEC</a>;

    // AccType_VEC is used for SIMD element alignment checks only
    check = (atomic || ordered || vector || A == '1');

    if check &amp;&amp; !aligned then
        secondstage = FALSE;
        <a link="AArch32.Abort.2" file="shared_pseudocode.xml" hover="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(address, <a link="impl-shared.AlignmentFault.3" file="shared_pseudocode.xml" hover="function: FaultRecord AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)">AlignmentFault</a>(acctype, iswrite, secondstage));

    return aligned;</pstext>
    </ps>
    <ps name="aarch32/functions/memory/AArch32.MemSingle" mylink="aarch32.functions.memory.AArch32.MemSingle" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.MemSingle[] - non-assignment (read) form
// ================================================
// Perform an atomic, little-endian read of 'size' bytes.

bits(size*8) <anchor link="AArch32.MemSingle.read.4" hover="accessor: bits(size*8) AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean aligned]">AArch32.MemSingle</anchor>[bits(32) address, integer size, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned]
    boolean ispair = FALSE;
    return <a link="AArch32.MemSingle.read.5" file="shared_pseudocode.xml" hover="accessor: bits(size*8) AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean aligned, boolean ispair]">AArch32.MemSingle</a>[address, size, acctype, aligned, ispair];

// AArch32.MemSingle[] - non-assignment (read) form
// ================================================
// Perform an atomic, little-endian read of 'size' bytes.

bits(size*8) <anchor link="AArch32.MemSingle.read.5" hover="accessor: bits(size*8) AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean aligned, boolean ispair]">AArch32.MemSingle</anchor>[bits(32) address, integer size, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned, boolean ispair]
    assert size IN {1, 2, 4, 8, 16};
    assert address == <a link="impl-shared.Align.2" file="shared_pseudocode.xml" hover="function: integer Align(integer x, integer y)">Align</a>(address, size);

    <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc;
    bits(size*8) value;
    iswrite = FALSE;

    memaddrdesc = <a link="AArch32.TranslateAddress.5" file="shared_pseudocode.xml" hover="function: AddressDescriptor AArch32.TranslateAddress(bits(32) va, AccType acctype,&#13; boolean iswrite, boolean aligned,&#13; integer size)">AArch32.TranslateAddress</a>(address, acctype, iswrite, aligned, size);
    // Check for aborts or debug exceptions
    if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a link="AArch32.Abort.2" file="shared_pseudocode.xml" hover="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(address, memaddrdesc.fault);

    // Memory array access
    accdesc = <a link="impl-shared.CreateAccessDescriptor.1" file="shared_pseudocode.xml" hover="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(acctype);

    <a link="PhysMemRetStatus" file="shared_pseudocode.xml" hover="type PhysMemRetStatus is (Fault statuscode, bit extflag, bits(2) errortype, bits(64) store64bstatus, AccType acctype)">PhysMemRetStatus</a> memstatus;
    (memstatus, value) = <a link="impl-shared.PhysMemRead.3" file="shared_pseudocode.xml" hover="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(memaddrdesc, size, accdesc);
    if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        <a link="impl-shared.HandleExternalReadAbort.4" file="shared_pseudocode.xml" hover="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, size, accdesc);
    return value;

// AArch32.MemSingle[] - assignment (write) form
// =============================================

<anchor link="AArch32.MemSingle.write.4" hover="accessor: AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean aligned] = bits(size*8) value">AArch32.MemSingle</anchor>[bits(32) address, integer size, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned] = bits(size*8) value
    boolean ispair = FALSE;
    <a link="AArch32.MemSingle.write.5" file="shared_pseudocode.xml" hover="accessor: AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean aligned, boolean ispair] = bits(size*8) value">AArch32.MemSingle</a>[address, size, acctype, aligned, ispair] = value;
    return;

// AArch32.MemSingle[] - assignment (write) form
// =============================================
// Perform an atomic, little-endian write of 'size' bytes.

<anchor link="AArch32.MemSingle.write.5" hover="accessor: AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean aligned, boolean ispair] = bits(size*8) value">AArch32.MemSingle</anchor>[bits(32) address, integer size, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned, boolean ispair] = bits(size*8) value
    assert size IN {1, 2, 4, 8, 16};
    assert address == <a link="impl-shared.Align.2" file="shared_pseudocode.xml" hover="function: integer Align(integer x, integer y)">Align</a>(address, size);

    <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc;
    iswrite = TRUE;

    memaddrdesc = <a link="AArch32.TranslateAddress.5" file="shared_pseudocode.xml" hover="function: AddressDescriptor AArch32.TranslateAddress(bits(32) va, AccType acctype,&#13; boolean iswrite, boolean aligned,&#13; integer size)">AArch32.TranslateAddress</a>(address, acctype, iswrite, aligned, size);
    // Check for aborts or debug exceptions
    if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a link="AArch32.Abort.2" file="shared_pseudocode.xml" hover="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(address, memaddrdesc.fault);

    // Effect on exclusives
    if memaddrdesc.memattrs.shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then
        <a link="impl-shared.ClearExclusiveByAddress.3" file="shared_pseudocode.xml" hover="function: ClearExclusiveByAddress(FullAddress paddress, integer processorid, integer size)">ClearExclusiveByAddress</a>(memaddrdesc.paddress, <a link="impl-shared.ProcessorID.0" file="shared_pseudocode.xml" hover="function: integer ProcessorID()">ProcessorID</a>(), size);

    // Memory array access
    accdesc = <a link="impl-shared.CreateAccessDescriptor.1" file="shared_pseudocode.xml" hover="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(acctype);

    memstatus = <a link="impl-shared.PhysMemWrite.4" file="shared_pseudocode.xml" hover="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(memaddrdesc, size, accdesc, value);
    if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        <a link="impl-shared.HandleExternalWriteAbort.4" file="shared_pseudocode.xml" hover="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, size, accdesc);
    return;</pstext>
    </ps>
    <ps name="aarch32/functions/memory/Hint_PreloadData" mylink="aarch32.functions.memory.Hint_PreloadData" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions"><anchor link="impl-aarch32.Hint_PreloadData.1" hover="function: Hint_PreloadData(bits(32) address)">Hint_PreloadData</anchor>(bits(32) address);</pstext>
    </ps>
    <ps name="aarch32/functions/memory/Hint_PreloadDataForWrite" mylink="aarch32.functions.memory.Hint_PreloadDataForWrite" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions"><anchor link="impl-aarch32.Hint_PreloadDataForWrite.1" hover="function: Hint_PreloadDataForWrite(bits(32) address)">Hint_PreloadDataForWrite</anchor>(bits(32) address);</pstext>
    </ps>
    <ps name="aarch32/functions/memory/Hint_PreloadInstr" mylink="aarch32.functions.memory.Hint_PreloadInstr" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions"><anchor link="impl-aarch32.Hint_PreloadInstr.1" hover="function: Hint_PreloadInstr(bits(32) address)">Hint_PreloadInstr</anchor>(bits(32) address);</pstext>
    </ps>
    <ps name="aarch32/functions/memory/MemA" mylink="aarch32.functions.memory.MemA" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// MemA[] - non-assignment form
// ============================

bits(8*size) <anchor link="impl-aarch32.MemA.read.2" hover="accessor: bits(8*size) MemA[bits(32) address, integer size]">MemA</anchor>[bits(32) address, integer size]
    acctype = <a link="AccType_ATOMIC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMIC</a>;
    return <a link="impl-aarch32.Mem_with_type.read.3" file="shared_pseudocode.xml" hover="accessor: bits(size*8) Mem_with_type[bits(32) address, integer size, AccType acctype]">Mem_with_type</a>[address, size, acctype];

// MemA[] - assignment form
// ========================

<anchor link="impl-aarch32.MemA.write.2" hover="accessor: MemA[bits(32) address, integer size] = bits(8*size) value">MemA</anchor>[bits(32) address, integer size] = bits(8*size) value
    acctype = <a link="AccType_ATOMIC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMIC</a>;
    Mem_with_type[address, size, acctype] = value;
    return;</pstext>
    </ps>
    <ps name="aarch32/functions/memory/MemO" mylink="aarch32.functions.memory.MemO" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// MemO[] - non-assignment form
// ============================

bits(8*size) <anchor link="impl-aarch32.MemO.read.2" hover="accessor: bits(8*size) MemO[bits(32) address, integer size]">MemO</anchor>[bits(32) address, integer size]
    acctype = <a link="AccType_ORDERED" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDERED</a>;
    return <a link="impl-aarch32.Mem_with_type.read.3" file="shared_pseudocode.xml" hover="accessor: bits(size*8) Mem_with_type[bits(32) address, integer size, AccType acctype]">Mem_with_type</a>[address, size, acctype];

// MemO[] - assignment form
// ========================

<anchor link="impl-aarch32.MemO.write.2" hover="accessor: MemO[bits(32) address, integer size] = bits(8*size) value">MemO</anchor>[bits(32) address, integer size] = bits(8*size) value
    acctype = <a link="AccType_ORDERED" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDERED</a>;
    Mem_with_type[address, size, acctype] = value;
    return;</pstext>
    </ps>
    <ps name="aarch32/functions/memory/MemS" mylink="aarch32.functions.memory.MemS" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// MemS[] - non-assignment form
// ============================
// Memory accessor for streaming load multiple instructions

bits(8*size) <anchor link="impl-aarch32.MemS.read.2" hover="accessor: bits(8*size) MemS[bits(32) address, integer size]">MemS</anchor>[bits(32) address, integer size]
    acctype = <a link="AccType_A32LSMD" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_A32LSMD</a>;
    return <a link="impl-aarch32.Mem_with_type.read.3" file="shared_pseudocode.xml" hover="accessor: bits(size*8) Mem_with_type[bits(32) address, integer size, AccType acctype]">Mem_with_type</a>[address, size, acctype];

// MemS[] - assignment form
// ========================
// Memory accessor for streaming store multiple instructions

<anchor link="impl-aarch32.MemS.write.2" hover="accessor: MemS[bits(32) address, integer size] = bits(8*size) value">MemS</anchor>[bits(32) address, integer size] = bits(8*size) value
    acctype = <a link="AccType_A32LSMD" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_A32LSMD</a>;
    Mem_with_type[address, size, acctype] = value;
    return;</pstext>
    </ps>
    <ps name="aarch32/functions/memory/MemU" mylink="aarch32.functions.memory.MemU" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// MemU[] - non-assignment form
// ============================

bits(8*size) <anchor link="impl-aarch32.MemU.read.2" hover="accessor: bits(8*size) MemU[bits(32) address, integer size]">MemU</anchor>[bits(32) address, integer size]
    acctype = <a link="AccType_NORMAL" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NORMAL</a>;
    return <a link="impl-aarch32.Mem_with_type.read.3" file="shared_pseudocode.xml" hover="accessor: bits(size*8) Mem_with_type[bits(32) address, integer size, AccType acctype]">Mem_with_type</a>[address, size, acctype];

// MemU[] - assignment form
// ========================

<anchor link="impl-aarch32.MemU.write.2" hover="accessor: MemU[bits(32) address, integer size] = bits(8*size) value">MemU</anchor>[bits(32) address, integer size] = bits(8*size) value
    acctype = <a link="AccType_NORMAL" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NORMAL</a>;
    Mem_with_type[address, size, acctype] = value;
    return;</pstext>
    </ps>
    <ps name="aarch32/functions/memory/MemU_unpriv" mylink="aarch32.functions.memory.MemU_unpriv" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// MemU_unpriv[] - non-assignment form
// ===================================

bits(8*size) <anchor link="impl-aarch32.MemU_unpriv.read.2" hover="accessor: bits(8*size) MemU_unpriv[bits(32) address, integer size]">MemU_unpriv</anchor>[bits(32) address, integer size]
    acctype = <a link="AccType_UNPRIV" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_UNPRIV</a>;
    return <a link="impl-aarch32.Mem_with_type.read.3" file="shared_pseudocode.xml" hover="accessor: bits(size*8) Mem_with_type[bits(32) address, integer size, AccType acctype]">Mem_with_type</a>[address, size, acctype];

// MemU_unpriv[] - assignment form
// ===============================

<anchor link="impl-aarch32.MemU_unpriv.write.2" hover="accessor: MemU_unpriv[bits(32) address, integer size] = bits(8*size) value">MemU_unpriv</anchor>[bits(32) address, integer size] = bits(8*size) value
    acctype = <a link="AccType_UNPRIV" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_UNPRIV</a>;
    Mem_with_type[address, size, acctype] = value;
    return;</pstext>
    </ps>
    <ps name="aarch32/functions/memory/Mem_with_type" mylink="aarch32.functions.memory.Mem_with_type" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Mem_with_type[] - non-assignment (read) form
// ============================================
// Perform a read of 'size' bytes. The access byte order is reversed for a big-endian access.
// Instruction fetches would call AArch32.MemSingle directly.

bits(size*8) <anchor link="impl-aarch32.Mem_with_type.read.3" hover="accessor: bits(size*8) Mem_with_type[bits(32) address, integer size, AccType acctype]">Mem_with_type</anchor>[bits(32) address, integer size, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype]
    boolean ispair = FALSE;
    return <a link="impl-aarch32.Mem_with_type.read.4" file="shared_pseudocode.xml" hover="accessor: bits(size*8) Mem_with_type[bits(32) address, integer size, AccType acctype, boolean ispair]">Mem_with_type</a>[address, size, acctype, ispair];

bits(size*8) <anchor link="impl-aarch32.Mem_with_type.read.4" hover="accessor: bits(size*8) Mem_with_type[bits(32) address, integer size, AccType acctype, boolean ispair]">Mem_with_type</anchor>[bits(32) address, integer size, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean ispair]
    assert size IN {1, 2, 4, 8, 16};
    constant halfsize = size DIV 2;
    bits(size * 8) value;
    boolean iswrite = FALSE;
    boolean aligned;
    if ispair then
        // check alignment on size of element accessed, not overall access size
        aligned = <a link="AArch32.CheckAlignment.4" file="shared_pseudocode.xml" hover="function: boolean AArch32.CheckAlignment(bits(32) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch32.CheckAlignment</a>(address, halfsize, acctype, iswrite);
    else
        aligned = <a link="AArch32.CheckAlignment.4" file="shared_pseudocode.xml" hover="function: boolean AArch32.CheckAlignment(bits(32) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch32.CheckAlignment</a>(address, size, acctype, iswrite);

    if !aligned then

        assert size &gt; 1;
        value&lt;7:0&gt; = <a link="AArch32.MemSingle.read.4" file="shared_pseudocode.xml" hover="accessor: bits(size*8) AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean aligned]">AArch32.MemSingle</a>[address, 1, acctype, aligned];

        // For subsequent bytes it is CONSTRAINED UNPREDICTABLE whether an unaligned Device memory
        // access will generate an Alignment Fault, as to get this far means the first byte did
        // not, so we must be changing to a new translation page.
        c = <a link="impl-shared.ConstrainUnpredictable.1" file="shared_pseudocode.xml" hover="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a link="Unpredictable_DEVPAGE2" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_DEVPAGE2</a>);
        assert c IN {<a link="Constraint_FAULT" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a>, <a link="Constraint_NONE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>};
        if c == <a link="Constraint_NONE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a> then aligned = TRUE;

        for i = 1 to size-1
            value&lt;8*i+7:8*i&gt; = <a link="AArch32.MemSingle.read.4" file="shared_pseudocode.xml" hover="accessor: bits(size*8) AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean aligned]">AArch32.MemSingle</a>[address+i, 1, acctype, aligned];
    else
        value = <a link="AArch32.MemSingle.read.5" file="shared_pseudocode.xml" hover="accessor: bits(size*8) AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean aligned, boolean ispair]">AArch32.MemSingle</a>[address, size, acctype, aligned, ispair];

    if <a link="impl-shared.BigEndian.1" file="shared_pseudocode.xml" hover="function: boolean BigEndian(AccType acctype)">BigEndian</a>(acctype) then
        value = <a link="impl-shared.BigEndianReverse.1" file="shared_pseudocode.xml" hover="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(value);

    return value;

// Mem_with_type[] - assignment (write) form
// =========================================
// Perform a write of 'size' bytes. The byte order is reversed for a big-endian access.

Mem_with_type[bits(32) address, integer size, AccType acctype] = bits(size*8) value_in
    boolean ispair = FALSE;
    Mem_with_type[address, size, acctype, ispair] = value_in;

Mem_with_type[bits(32) address, integer size, AccType acctype, boolean ispair] = bits(size*8) value_in
    boolean iswrite = TRUE;
    constant halfsize = size DIV 2;
    bits(size*8) value = value_in;
    boolean aligned;
    if <a link="impl-shared.BigEndian.1" file="shared_pseudocode.xml" hover="function: boolean BigEndian(AccType acctype)">BigEndian</a>(acctype) then
        value = <a link="impl-shared.BigEndianReverse.1" file="shared_pseudocode.xml" hover="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(value);

    if ispair then
        // check alignment on size of element accessed, not overall access size
        aligned = <a link="AArch32.CheckAlignment.4" file="shared_pseudocode.xml" hover="function: boolean AArch32.CheckAlignment(bits(32) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch32.CheckAlignment</a>(address, halfsize, acctype, iswrite);
    else
        aligned = <a link="AArch32.CheckAlignment.4" file="shared_pseudocode.xml" hover="function: boolean AArch32.CheckAlignment(bits(32) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch32.CheckAlignment</a>(address, size, acctype, iswrite);

    if !aligned then
        assert size &gt; 1;
        <a link="AArch32.MemSingle.write.4" file="shared_pseudocode.xml" hover="accessor: AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean aligned] = bits(size*8) value">AArch32.MemSingle</a>[address, 1, acctype, aligned] = value&lt;7:0&gt;;

        // For subsequent bytes it is CONSTRAINED UNPREDICTABLE whether an unaligned Device memory
        // access will generate an Alignment Fault, as to get this far means the first byte did
        // not, so we must be changing to a new translation page.
        c = <a link="impl-shared.ConstrainUnpredictable.1" file="shared_pseudocode.xml" hover="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a link="Unpredictable_DEVPAGE2" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_DEVPAGE2</a>);
        assert c IN {<a link="Constraint_FAULT" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a>, <a link="Constraint_NONE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>};
        if c == <a link="Constraint_NONE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a> then aligned = TRUE;

        for i = 1 to size-1
            <a link="AArch32.MemSingle.write.4" file="shared_pseudocode.xml" hover="accessor: AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean aligned] = bits(size*8) value">AArch32.MemSingle</a>[address+i, 1, acctype, aligned] = value&lt;8*i+7:8*i&gt;;
    else
        <a link="AArch32.MemSingle.write.5" file="shared_pseudocode.xml" hover="accessor: AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean aligned, boolean ispair] = bits(size*8) value">AArch32.MemSingle</a>[address, size, acctype, aligned, ispair] = value;
    return;</pstext>
    </ps>
    <ps name="aarch32/functions/ras/AArch32.ESBOperation" mylink="aarch32.functions.ras.AArch32.ESBOperation" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.ESBOperation()
// ======================
// Perform the AArch32 ESB operation for ESB executed in AArch32 state

<anchor link="AArch32.ESBOperation.0" hover="function: AArch32.ESBOperation()">AArch32.ESBOperation</anchor>()

    // Check if routed to AArch64 state
    route_to_aarch64 = PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>);
    if !route_to_aarch64 &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
        route_to_aarch64 = HCR_EL2.TGE == '1' || HCR_EL2.AMO == '1';
    if !route_to_aarch64 &amp;&amp; <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
        route_to_aarch64 = SCR_EL3.EA == '1';

    if route_to_aarch64 then
        <a link="AArch64.ESBOperation.0" file="shared_pseudocode.xml" hover="function: AArch64.ESBOperation()">AArch64.ESBOperation</a>();
        return;

    route_to_monitor = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR.EA == '1';
    route_to_hyp = PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; (HCR.TGE == '1' || HCR.AMO == '1');

    bits(5) target;
    if route_to_monitor then
        target = <a link="M32_Monitor" file="shared_pseudocode.xml" hover="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>;
    elsif route_to_hyp || PSTATE.M == <a link="M32_Hyp" file="shared_pseudocode.xml" hover="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a> then
        target = <a link="M32_Hyp" file="shared_pseudocode.xml" hover="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>;
    else
        target = <a link="M32_Abort" file="shared_pseudocode.xml" hover="constant bits(5) M32_Abort = '10111'">M32_Abort</a>;

    boolean mask_active;
    if <a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>() then
        mask_active = TRUE;
    elsif target == <a link="M32_Monitor" file="shared_pseudocode.xml" hover="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then
        mask_active = SCR.AW == '1' &amp;&amp; (!<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) || (HCR.TGE == '0' &amp;&amp; HCR.AMO == '0'));
    else
        mask_active = target == <a link="M32_Abort" file="shared_pseudocode.xml" hover="constant bits(5) M32_Abort = '10111'">M32_Abort</a> || PSTATE.M == <a link="M32_Hyp" file="shared_pseudocode.xml" hover="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>;

    mask_set = PSTATE.A == '1';
    (-, el)  = <a link="impl-shared.ELFromM32.1" file="shared_pseudocode.xml" hover="function: (boolean,bits(2)) ELFromM32(bits(5) mode)">ELFromM32</a>(target);
    intdis   = <a link="impl-shared.Halted.0" file="shared_pseudocode.xml" hover="function: boolean Halted()">Halted</a>() || <a link="impl-shared.ExternalDebugInterruptsDisabled.1" file="shared_pseudocode.xml" hover="function: boolean ExternalDebugInterruptsDisabled(bits(2) target)">ExternalDebugInterruptsDisabled</a>(el);
    masked   = intdis || (mask_active &amp;&amp; mask_set);

    // Check for a masked Physical SError pending that can be synchronized
    // by an Error synchronization event.
    if masked &amp;&amp; <a link="impl-shared.IsSynchronizablePhysicalSErrorPending.0" file="shared_pseudocode.xml" hover="function: boolean IsSynchronizablePhysicalSErrorPending()">IsSynchronizablePhysicalSErrorPending</a>() then
        syndrome32 = <a link="AArch32.PhysicalSErrorSyndrome.0" file="shared_pseudocode.xml" hover="function: AArch32.SErrorSyndrome AArch32.PhysicalSErrorSyndrome()">AArch32.PhysicalSErrorSyndrome</a>();
        DISR = <a link="AArch32.ReportDeferredSError.2" file="shared_pseudocode.xml" hover="function: bits(32) AArch32.ReportDeferredSError(bits(2) AET, bit ExT)">AArch32.ReportDeferredSError</a>(syndrome32.AET, syndrome32.ExT);
        <a link="impl-shared.ClearPendingPhysicalSError.0" file="shared_pseudocode.xml" hover="function: ClearPendingPhysicalSError()">ClearPendingPhysicalSError</a>();

    return;</pstext>
    </ps>
    <ps name="aarch32/functions/ras/AArch32.PhysicalSErrorSyndrome" mylink="aarch32.functions.ras.AArch32.PhysicalSErrorSyndrome" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Return the SError syndrome
AArch32.SErrorSyndrome <anchor link="AArch32.PhysicalSErrorSyndrome.0" hover="function: AArch32.SErrorSyndrome AArch32.PhysicalSErrorSyndrome()">AArch32.PhysicalSErrorSyndrome</anchor>();</pstext>
    </ps>
    <ps name="aarch32/functions/ras/AArch32.ReportDeferredSError" mylink="aarch32.functions.ras.AArch32.ReportDeferredSError" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.ReportDeferredSError()
// ==============================
// Return deferred SError syndrome

bits(32) <anchor link="AArch32.ReportDeferredSError.2" hover="function: bits(32) AArch32.ReportDeferredSError(bits(2) AET, bit ExT)">AArch32.ReportDeferredSError</anchor>(bits(2) AET, bit ExT)
    bits(32) target;
    target&lt;31&gt; = '1';                       // A
    syndrome = <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(16);
    if PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then
        syndrome&lt;11:10&gt; = AET;              // AET
        syndrome&lt;9&gt;     = ExT;              // EA
        syndrome&lt;5:0&gt;   = '010001';         // DFSC
    else
        syndrome&lt;15:14&gt; = AET;              // AET
        syndrome&lt;12&gt;    = ExT;              // ExT
        syndrome&lt;9&gt;     = TTBCR.EAE;        // LPAE
        if TTBCR.EAE == '1' then            // Long-descriptor format
            syndrome&lt;5:0&gt;    = '010001';    // STATUS
        else                                // Short-descriptor format
            syndrome&lt;10,3:0&gt; = '10110';     // FS
    if <a link="impl-shared.HaveAArch64.0" file="shared_pseudocode.xml" hover="function: boolean HaveAArch64()">HaveAArch64</a>() then
        target&lt;24:0&gt; = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(syndrome);// Any RES0 fields must be set to zero
    else
        target&lt;15:0&gt; = syndrome;
    return target;</pstext>
    </ps>
    <ps name="aarch32/functions/ras/AArch32.SErrorSyndrome" mylink="aarch32.functions.ras.AArch32.SErrorSyndrome" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">type <anchor link="AArch32.SErrorSyndrome" hover="type AArch32.SErrorSyndrome is ( bits(2) AET, bit ExT )">AArch32.SErrorSyndrome</anchor> is (
    bits(2) AET,
    bit ExT
)</pstext>
    </ps>
    <ps name="aarch32/functions/ras/AArch32.vESBOperation" mylink="aarch32.functions.ras.AArch32.vESBOperation" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.vESBOperation()
// =======================
// Perform the ESB operation for virtual SError interrupts executed in AArch32 state

<anchor link="AArch32.vESBOperation.0" hover="function: AArch32.vESBOperation()">AArch32.vESBOperation</anchor>()
    assert PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>();

    // Check for EL2 using AArch64 state
    if !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
        <a link="AArch64.vESBOperation.0" file="shared_pseudocode.xml" hover="function: AArch64.vESBOperation()">AArch64.vESBOperation</a>();
        return;

    // If physical SError interrupts are routed to Hyp mode, and TGE is not set, then a
    // virtual SError interrupt might be pending
    vSEI_enabled = HCR.TGE == '0' &amp;&amp; HCR.AMO == '1';
    vSEI_pending = vSEI_enabled &amp;&amp; HCR.VA == '1';
    vintdis      = <a link="impl-shared.Halted.0" file="shared_pseudocode.xml" hover="function: boolean Halted()">Halted</a>() || <a link="impl-shared.ExternalDebugInterruptsDisabled.1" file="shared_pseudocode.xml" hover="function: boolean ExternalDebugInterruptsDisabled(bits(2) target)">ExternalDebugInterruptsDisabled</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>);
    vmasked      = vintdis || PSTATE.A == '1';

    // Check for a masked virtual SError pending
    if vSEI_pending &amp;&amp; vmasked then
        VDISR = <a link="AArch32.ReportDeferredSError.2" file="shared_pseudocode.xml" hover="function: bits(32) AArch32.ReportDeferredSError(bits(2) AET, bit ExT)">AArch32.ReportDeferredSError</a>(VDFSR&lt;15:14&gt;, VDFSR&lt;12&gt;);
        HCR.VA = '0';                       // Clear pending virtual SError

    return;</pstext>
    </ps>
    <ps name="aarch32/functions/registers/AArch32.ResetGeneralRegisters" mylink="aarch32.functions.registers.AArch32.ResetGeneralRegisters" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.ResetGeneralRegisters()
// ===============================

<anchor link="AArch32.ResetGeneralRegisters.0" hover="function: AArch32.ResetGeneralRegisters()">AArch32.ResetGeneralRegisters</anchor>()

    for i = 0 to 7
        <a link="impl-aarch32.R.write.1" file="shared_pseudocode.xml" hover="accessor: R[integer n] = bits(32) value">R</a>[i] = bits(32) UNKNOWN;
    for i = 8 to 12
        <a link="impl-aarch32.Rmode.write.2" file="shared_pseudocode.xml" hover="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[i, <a link="M32_User" file="shared_pseudocode.xml" hover="constant bits(5) M32_User = '10000'">M32_User</a>] = bits(32) UNKNOWN;
        <a link="impl-aarch32.Rmode.write.2" file="shared_pseudocode.xml" hover="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[i, <a link="M32_FIQ" file="shared_pseudocode.xml" hover="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>] = bits(32) UNKNOWN;
    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then <a link="impl-aarch32.Rmode.write.2" file="shared_pseudocode.xml" hover="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[13, <a link="M32_Hyp" file="shared_pseudocode.xml" hover="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>] = bits(32) UNKNOWN;   // No R14_hyp
    for i = 13 to 14
        <a link="impl-aarch32.Rmode.write.2" file="shared_pseudocode.xml" hover="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[i, <a link="M32_User" file="shared_pseudocode.xml" hover="constant bits(5) M32_User = '10000'">M32_User</a>] = bits(32) UNKNOWN;
        <a link="impl-aarch32.Rmode.write.2" file="shared_pseudocode.xml" hover="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[i, <a link="M32_FIQ" file="shared_pseudocode.xml" hover="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>] = bits(32) UNKNOWN;
        <a link="impl-aarch32.Rmode.write.2" file="shared_pseudocode.xml" hover="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[i, <a link="M32_IRQ" file="shared_pseudocode.xml" hover="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>] = bits(32) UNKNOWN;
        <a link="impl-aarch32.Rmode.write.2" file="shared_pseudocode.xml" hover="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[i, <a link="M32_Svc" file="shared_pseudocode.xml" hover="constant bits(5) M32_Svc = '10011'">M32_Svc</a>] = bits(32) UNKNOWN;
        <a link="impl-aarch32.Rmode.write.2" file="shared_pseudocode.xml" hover="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[i, <a link="M32_Abort" file="shared_pseudocode.xml" hover="constant bits(5) M32_Abort = '10111'">M32_Abort</a>] = bits(32) UNKNOWN;
        <a link="impl-aarch32.Rmode.write.2" file="shared_pseudocode.xml" hover="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[i, <a link="M32_Undef" file="shared_pseudocode.xml" hover="constant bits(5) M32_Undef = '11011'">M32_Undef</a>] = bits(32) UNKNOWN;
        if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then <a link="impl-aarch32.Rmode.write.2" file="shared_pseudocode.xml" hover="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[i, <a link="M32_Monitor" file="shared_pseudocode.xml" hover="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>] = bits(32) UNKNOWN;

    return;</pstext>
    </ps>
    <ps name="aarch32/functions/registers/AArch32.ResetSIMDFPRegisters" mylink="aarch32.functions.registers.AArch32.ResetSIMDFPRegisters" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.ResetSIMDFPRegisters()
// ==============================

<anchor link="AArch32.ResetSIMDFPRegisters.0" hover="function: AArch32.ResetSIMDFPRegisters()">AArch32.ResetSIMDFPRegisters</anchor>()

    for i = 0 to 15
        <a link="impl-aarch32.Q.write.1" file="shared_pseudocode.xml" hover="accessor: Q[integer n] = bits(128) value">Q</a>[i] = bits(128) UNKNOWN;

    return;</pstext>
    </ps>
    <ps name="aarch32/functions/registers/AArch32.ResetSpecialRegisters" mylink="aarch32.functions.registers.AArch32.ResetSpecialRegisters" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.ResetSpecialRegisters()
// ===============================

<anchor link="AArch32.ResetSpecialRegisters.0" hover="function: AArch32.ResetSpecialRegisters()">AArch32.ResetSpecialRegisters</anchor>()

    // AArch32 special registers
    SPSR_fiq&lt;31:0&gt; = bits(32) UNKNOWN;
    SPSR_irq&lt;31:0&gt; = bits(32) UNKNOWN;
    SPSR_svc&lt;31:0&gt; = bits(32) UNKNOWN;
    SPSR_abt&lt;31:0&gt; = bits(32) UNKNOWN;
    SPSR_und&lt;31:0&gt; = bits(32) UNKNOWN;
    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
        SPSR_hyp = bits(32) UNKNOWN;
        ELR_hyp = bits(32) UNKNOWN;
    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
        SPSR_mon = bits(32) UNKNOWN;

    // External debug special registers
    DLR = bits(32) UNKNOWN;
    DSPSR = bits(32) UNKNOWN;

    return;</pstext>
    </ps>
    <ps name="aarch32/functions/registers/AArch32.ResetSystemRegisters" mylink="aarch32.functions.registers.AArch32.ResetSystemRegisters" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions"><anchor link="AArch32.ResetSystemRegisters.1" hover="function: AArch32.ResetSystemRegisters(boolean cold_reset)">AArch32.ResetSystemRegisters</anchor>(boolean cold_reset);</pstext>
    </ps>
    <ps name="aarch32/functions/registers/ALUExceptionReturn" mylink="aarch32.functions.registers.ALUExceptionReturn" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ALUExceptionReturn()
// ====================

<anchor link="impl-aarch32.ALUExceptionReturn.1" hover="function: ALUExceptionReturn(bits(32) address)">ALUExceptionReturn</anchor>(bits(32) address)
    if PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then
        UNDEFINED;
    elsif PSTATE.M IN {<a link="M32_User" file="shared_pseudocode.xml" hover="constant bits(5) M32_User = '10000'">M32_User</a>,<a link="M32_System" file="shared_pseudocode.xml" hover="constant bits(5) M32_System = '11111'">M32_System</a>} then
        <a link="Constraint" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint</a> c = <a link="impl-shared.ConstrainUnpredictable.1" file="shared_pseudocode.xml" hover="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a link="Unpredictable_ALUEXCEPTIONRETURN" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_ALUEXCEPTIONRETURN</a>);
        assert c IN {<a link="Constraint_UNDEF" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNDEF</a>, <a link="Constraint_NOP" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NOP</a>};
        case c of
            when <a link="Constraint_UNDEF" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNDEF</a>
                UNDEFINED;
            when <a link="Constraint_NOP" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NOP</a>
                <a link="impl-shared.EndOfInstruction.0" file="shared_pseudocode.xml" hover="function: EndOfInstruction()">EndOfInstruction</a>();
    else
        <a link="AArch32.ExceptionReturn.2" file="shared_pseudocode.xml" hover="function: AArch32.ExceptionReturn(bits(32) new_pc_in, bits(32) spsr)">AArch32.ExceptionReturn</a>(address, <a link="impl-shared.SPSR.read.0" file="shared_pseudocode.xml" hover="accessor: bits(N) SPSR[]">SPSR</a>[]);</pstext>
    </ps>
    <ps name="aarch32/functions/registers/ALUWritePC" mylink="aarch32.functions.registers.ALUWritePC" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ALUWritePC()
// ============

<anchor link="impl-aarch32.ALUWritePC.1" hover="function: ALUWritePC(bits(32) address)">ALUWritePC</anchor>(bits(32) address)
    if <a link="impl-shared.CurrentInstrSet.0" file="shared_pseudocode.xml" hover="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() == <a link="InstrSet_A32" file="shared_pseudocode.xml" hover="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> then
        <a link="impl-aarch32.BXWritePC.2" file="shared_pseudocode.xml" hover="function: BXWritePC(bits(32) address_in, BranchType branch_type)">BXWritePC</a>(address, <a link="BranchType_INDIR" file="shared_pseudocode.xml" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType_INDIR</a>);
    else
        <a link="impl-aarch32.BranchWritePC.2" file="shared_pseudocode.xml" hover="function: BranchWritePC(bits(32) address_in, BranchType branch_type)">BranchWritePC</a>(address, <a link="BranchType_INDIR" file="shared_pseudocode.xml" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType_INDIR</a>);</pstext>
    </ps>
    <ps name="aarch32/functions/registers/BXWritePC" mylink="aarch32.functions.registers.BXWritePC" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// BXWritePC()
// ===========

<anchor link="impl-aarch32.BXWritePC.2" hover="function: BXWritePC(bits(32) address_in, BranchType branch_type)">BXWritePC</anchor>(bits(32) address_in, <a link="BranchType" file="shared_pseudocode.xml" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType</a> branch_type)
    bits(32) address = address_in;
    if address&lt;0&gt; == '1' then
        <a link="impl-aarch32.SelectInstrSet.1" file="shared_pseudocode.xml" hover="function: SelectInstrSet(InstrSet iset)">SelectInstrSet</a>(<a link="InstrSet_T32" file="shared_pseudocode.xml" hover="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_T32</a>);
        address&lt;0&gt; = '0';
    else
        <a link="impl-aarch32.SelectInstrSet.1" file="shared_pseudocode.xml" hover="function: SelectInstrSet(InstrSet iset)">SelectInstrSet</a>(<a link="InstrSet_A32" file="shared_pseudocode.xml" hover="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a>);
        // For branches to an unaligned PC counter in A32 state, the processor takes the branch
        // and does one of:
        // * Forces the address to be aligned
        // * Leaves the PC unaligned, meaning the target generates a PC Alignment fault.
        if address&lt;1&gt; == '1' &amp;&amp; <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_A32FORCEALIGNPC" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_A32FORCEALIGNPC</a>) then
            address&lt;1&gt; = '0';
    boolean branch_conditional = <a link="AArch32.CurrentCond.0" file="shared_pseudocode.xml" hover="function: bits(4) AArch32.CurrentCond()">AArch32.CurrentCond</a>() != '111x';
    <a link="impl-shared.BranchTo.3" file="shared_pseudocode.xml" hover="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(address, branch_type, branch_conditional);</pstext>
    </ps>
    <ps name="aarch32/functions/registers/BranchWritePC" mylink="aarch32.functions.registers.BranchWritePC" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// BranchWritePC()
// ===============

<anchor link="impl-aarch32.BranchWritePC.2" hover="function: BranchWritePC(bits(32) address_in, BranchType branch_type)">BranchWritePC</anchor>(bits(32) address_in, <a link="BranchType" file="shared_pseudocode.xml" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType</a> branch_type)
    bits(32) address = address_in;
    if <a link="impl-shared.CurrentInstrSet.0" file="shared_pseudocode.xml" hover="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() == <a link="InstrSet_A32" file="shared_pseudocode.xml" hover="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> then
        address&lt;1:0&gt; = '00';
    else
        address&lt;0&gt; = '0';
    boolean branch_conditional = <a link="AArch32.CurrentCond.0" file="shared_pseudocode.xml" hover="function: bits(4) AArch32.CurrentCond()">AArch32.CurrentCond</a>() != '111x';
    <a link="impl-shared.BranchTo.3" file="shared_pseudocode.xml" hover="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(address, branch_type, branch_conditional);</pstext>
    </ps>
    <ps name="aarch32/functions/registers/CBWritePC" mylink="aarch32.functions.registers.CBWritePC" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CBWritePC()
// ===========
// Takes a branch from a CBNZ/CBZ instruction.

<anchor link="impl-aarch32.CBWritePC.1" hover="function: CBWritePC(bits(32) address_in)">CBWritePC</anchor>(bits(32) address_in)
    bits(32) address = address_in;
    assert <a link="impl-shared.CurrentInstrSet.0" file="shared_pseudocode.xml" hover="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() == <a link="InstrSet_T32" file="shared_pseudocode.xml" hover="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_T32</a>;
    address&lt;0&gt; = '0';
    boolean branch_conditional = TRUE;
    <a link="impl-shared.BranchTo.3" file="shared_pseudocode.xml" hover="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(address, <a link="BranchType_DIR" file="shared_pseudocode.xml" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType_DIR</a>, branch_conditional);</pstext>
    </ps>
    <ps name="aarch32/functions/registers/D" mylink="aarch32.functions.registers.D" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// D[] - non-assignment form
// =========================

bits(64) <anchor link="impl-aarch32.D.read.1" hover="accessor: bits(64) D[integer n]">D</anchor>[integer n]
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    base = (n MOD 2) * 64;
    bits(128) vreg = V[n DIV 2];
    return vreg&lt;base+63:base&gt;;

// D[] - assignment form
// =====================

<anchor link="impl-aarch32.D.write.1" hover="accessor: D[integer n] = bits(64) value">D</anchor>[integer n] = bits(64) value
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    base = (n MOD 2) * 64;
    bits(128) vreg = V[n DIV 2];
    vreg&lt;base+63:base&gt; = value;
    V[n DIV 2] = vreg;
    return;</pstext>
    </ps>
    <ps name="aarch32/functions/registers/Din" mylink="aarch32.functions.registers.Din" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Din[] - non-assignment form
// ===========================

bits(64) <anchor link="impl-aarch32.Din.read.1" hover="accessor: bits(64) Din[integer n]">Din</anchor>[integer n]
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    return _Dclone[n];</pstext>
    </ps>
    <ps name="aarch32/functions/registers/LR" mylink="aarch32.functions.registers.LR" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// LR - assignment form
// ====================

<anchor link="impl-aarch32.LR.write.none" hover="accessor: LR = bits(32) value">LR</anchor> = bits(32) value
    <a link="impl-aarch32.R.write.1" file="shared_pseudocode.xml" hover="accessor: R[integer n] = bits(32) value">R</a>[14] = value;
    return;

// LR - non-assignment form
// ========================

bits(32) <anchor link="impl-aarch32.LR.read.none" hover="accessor: bits(32) LR">LR</anchor>
    return <a link="impl-aarch32.R.read.1" file="shared_pseudocode.xml" hover="accessor: bits(32) R[integer n]">R</a>[14];</pstext>
    </ps>
    <ps name="aarch32/functions/registers/LoadWritePC" mylink="aarch32.functions.registers.LoadWritePC" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// LoadWritePC()
// =============

<anchor link="impl-aarch32.LoadWritePC.1" hover="function: LoadWritePC(bits(32) address)">LoadWritePC</anchor>(bits(32) address)
    <a link="impl-aarch32.BXWritePC.2" file="shared_pseudocode.xml" hover="function: BXWritePC(bits(32) address_in, BranchType branch_type)">BXWritePC</a>(address, <a link="BranchType_INDIR" file="shared_pseudocode.xml" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType_INDIR</a>);</pstext>
    </ps>
    <ps name="aarch32/functions/registers/LookUpRIndex" mylink="aarch32.functions.registers.LookUpRIndex" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// LookUpRIndex()
// ==============

integer <anchor link="impl-aarch32.LookUpRIndex.2" hover="function: integer LookUpRIndex(integer n, bits(5) mode)">LookUpRIndex</anchor>(integer n, bits(5) mode)
    assert n &gt;= 0 &amp;&amp; n &lt;= 14;

    integer result;
    case n of  // Select  index by mode:     usr fiq irq svc abt und hyp
        when 8     result = <a link="impl-aarch32.RBankSelect.8" file="shared_pseudocode.xml" hover="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq,&#13; integer svc, integer abt, integer und, integer hyp)">RBankSelect</a>(mode,  8, 24,  8,  8,  8,  8,  8);
        when 9     result = <a link="impl-aarch32.RBankSelect.8" file="shared_pseudocode.xml" hover="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq,&#13; integer svc, integer abt, integer und, integer hyp)">RBankSelect</a>(mode,  9, 25,  9,  9,  9,  9,  9);
        when 10    result = <a link="impl-aarch32.RBankSelect.8" file="shared_pseudocode.xml" hover="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq,&#13; integer svc, integer abt, integer und, integer hyp)">RBankSelect</a>(mode, 10, 26, 10, 10, 10, 10, 10);
        when 11    result = <a link="impl-aarch32.RBankSelect.8" file="shared_pseudocode.xml" hover="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq,&#13; integer svc, integer abt, integer und, integer hyp)">RBankSelect</a>(mode, 11, 27, 11, 11, 11, 11, 11);
        when 12    result = <a link="impl-aarch32.RBankSelect.8" file="shared_pseudocode.xml" hover="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq,&#13; integer svc, integer abt, integer und, integer hyp)">RBankSelect</a>(mode, 12, 28, 12, 12, 12, 12, 12);
        when 13    result = <a link="impl-aarch32.RBankSelect.8" file="shared_pseudocode.xml" hover="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq,&#13; integer svc, integer abt, integer und, integer hyp)">RBankSelect</a>(mode, 13, 29, 17, 19, 21, 23, 15);
        when 14    result = <a link="impl-aarch32.RBankSelect.8" file="shared_pseudocode.xml" hover="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq,&#13; integer svc, integer abt, integer und, integer hyp)">RBankSelect</a>(mode, 14, 30, 16, 18, 20, 22, 14);
        otherwise  result = n;

    return result;</pstext>
    </ps>
    <ps name="aarch32/functions/registers/Monitor_mode_registers" mylink="aarch32.functions.registers.Monitor_mode_registers" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">bits(32) <anchor link="impl-aarch32.SP.read.none" hover="accessor: bits(32) SP">SP</anchor>_mon;
bits(32) <anchor link="impl-aarch32.LR.read.none_2" hover="accessor: bits(32) LR">LR</anchor>_mon;</pstext>
    </ps>
    <ps name="aarch32/functions/registers/PC" mylink="aarch32.functions.registers.PC" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// PC - non-assignment form
// ========================

bits(32) <anchor link="impl-aarch32.PC.read.none" hover="accessor: bits(32) PC">PC</anchor>
    return <a link="impl-aarch32.R.read.1" file="shared_pseudocode.xml" hover="accessor: bits(32) R[integer n]">R</a>[15];               // This includes the offset from AArch32 state</pstext>
    </ps>
    <ps name="aarch32/functions/registers/PCStoreValue" mylink="aarch32.functions.registers.PCStoreValue" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// PCStoreValue()
// ==============

bits(32) <anchor link="impl-aarch32.PCStoreValue.0" hover="function: bits(32) PCStoreValue()">PCStoreValue</anchor>()
    // This function returns the PC value. On architecture versions before Armv7, it
    // is permitted to instead return PC+4, provided it does so consistently. It is
    // used only to describe A32 instructions, so it returns the address of the current
    // instruction plus 8 (normally) or 12 (when the alternative is permitted).
    return <a link="impl-aarch32.PC.read.none" file="shared_pseudocode.xml" hover="accessor: bits(32) PC">PC</a>;</pstext>
    </ps>
    <ps name="aarch32/functions/registers/Q" mylink="aarch32.functions.registers.Q" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Q[] - non-assignment form
// =========================

bits(128) <anchor link="impl-aarch32.Q.read.1" hover="accessor: bits(128) Q[integer n]">Q</anchor>[integer n]
    assert n &gt;= 0 &amp;&amp; n &lt;= 15;
    return V[n];

// Q[] - assignment form
// =====================

<anchor link="impl-aarch32.Q.write.1" hover="accessor: Q[integer n] = bits(128) value">Q</anchor>[integer n] = bits(128) value
    assert n &gt;= 0 &amp;&amp; n &lt;= 15;
    V[n] = value;
    return;</pstext>
    </ps>
    <ps name="aarch32/functions/registers/Qin" mylink="aarch32.functions.registers.Qin" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Qin[] - non-assignment form
// ===========================

bits(128) <anchor link="impl-aarch32.Qin.read.1" hover="accessor: bits(128) Qin[integer n]">Qin</anchor>[integer n]
    assert n &gt;= 0 &amp;&amp; n &lt;= 15;
    return <a link="impl-aarch32.Din.read.1" file="shared_pseudocode.xml" hover="accessor: bits(64) Din[integer n]">Din</a>[2*n+1]:<a link="impl-aarch32.Din.read.1" file="shared_pseudocode.xml" hover="accessor: bits(64) Din[integer n]">Din</a>[2*n];</pstext>
    </ps>
    <ps name="aarch32/functions/registers/R" mylink="aarch32.functions.registers.R" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// R[] - assignment form
// =====================

<anchor link="impl-aarch32.R.write.1" hover="accessor: R[integer n] = bits(32) value">R</anchor>[integer n] = bits(32) value
    <a link="impl-aarch32.Rmode.write.2" file="shared_pseudocode.xml" hover="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[n, PSTATE.M] = value;
    return;

// R[] - non-assignment form
// =========================

bits(32) <anchor link="impl-aarch32.R.read.1" hover="accessor: bits(32) R[integer n]">R</anchor>[integer n]
    if n == 15 then
        offset = (if <a link="impl-shared.CurrentInstrSet.0" file="shared_pseudocode.xml" hover="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() == <a link="InstrSet_A32" file="shared_pseudocode.xml" hover="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> then 8 else 4);
        return _PC&lt;31:0&gt; + offset;
    else
        return <a link="impl-aarch32.Rmode.read.2" file="shared_pseudocode.xml" hover="accessor: bits(32) Rmode[integer n, bits(5) mode]">Rmode</a>[n, PSTATE.M];</pstext>
    </ps>
    <ps name="aarch32/functions/registers/RBankSelect" mylink="aarch32.functions.registers.RBankSelect" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// RBankSelect()
// =============

integer <anchor link="impl-aarch32.RBankSelect.8" hover="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq,&#13; integer svc, integer abt, integer und, integer hyp)">RBankSelect</anchor>(bits(5) mode, integer usr, integer fiq, integer irq,
                    integer svc, integer abt, integer und, integer hyp)

    integer result;
    case mode of
        when <a link="M32_User" file="shared_pseudocode.xml" hover="constant bits(5) M32_User = '10000'">M32_User</a>    result = usr;  // User mode
        when <a link="M32_FIQ" file="shared_pseudocode.xml" hover="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>     result = fiq;  // FIQ mode
        when <a link="M32_IRQ" file="shared_pseudocode.xml" hover="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>     result = irq;  // IRQ mode
        when <a link="M32_Svc" file="shared_pseudocode.xml" hover="constant bits(5) M32_Svc = '10011'">M32_Svc</a>     result = svc;  // Supervisor mode
        when <a link="M32_Abort" file="shared_pseudocode.xml" hover="constant bits(5) M32_Abort = '10111'">M32_Abort</a>   result = abt;  // Abort mode
        when <a link="M32_Hyp" file="shared_pseudocode.xml" hover="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>     result = hyp;  // Hyp mode
        when <a link="M32_Undef" file="shared_pseudocode.xml" hover="constant bits(5) M32_Undef = '11011'">M32_Undef</a>   result = und;  // Undefined mode
        when <a link="M32_System" file="shared_pseudocode.xml" hover="constant bits(5) M32_System = '11111'">M32_System</a>  result = usr;  // System mode uses User mode registers
        otherwise        <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>(); // Monitor mode

    return result;</pstext>
    </ps>
    <ps name="aarch32/functions/registers/Rmode" mylink="aarch32.functions.registers.Rmode" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Rmode[] - non-assignment form
// =============================

bits(32) <anchor link="impl-aarch32.Rmode.read.2" hover="accessor: bits(32) Rmode[integer n, bits(5) mode]">Rmode</anchor>[integer n, bits(5) mode]
    assert n &gt;= 0 &amp;&amp; n &lt;= 14;

    // Check for attempted use of Monitor mode in Non-secure state.
    if !<a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>() then assert mode != <a link="M32_Monitor" file="shared_pseudocode.xml" hover="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>;
    assert !<a link="impl-aarch32.BadMode.1" file="shared_pseudocode.xml" hover="function: boolean BadMode(bits(5) mode)">BadMode</a>(mode);

    if mode == <a link="M32_Monitor" file="shared_pseudocode.xml" hover="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then
        if n == 13 then return SP_mon;
        elsif n == 14 then return LR_mon;
        else return _R[n]&lt;31:0&gt;;
    else
        return _R[<a link="impl-aarch32.LookUpRIndex.2" file="shared_pseudocode.xml" hover="function: integer LookUpRIndex(integer n, bits(5) mode)">LookUpRIndex</a>(n, mode)]&lt;31:0&gt;;

// Rmode[] - assignment form
// =========================

<anchor link="impl-aarch32.Rmode.write.2" hover="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</anchor>[integer n, bits(5) mode] = bits(32) value
    assert n &gt;= 0 &amp;&amp; n &lt;= 14;

    // Check for attempted use of Monitor mode in Non-secure state.
    if !<a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>() then assert mode != <a link="M32_Monitor" file="shared_pseudocode.xml" hover="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>;
    assert !<a link="impl-aarch32.BadMode.1" file="shared_pseudocode.xml" hover="function: boolean BadMode(bits(5) mode)">BadMode</a>(mode);

    if mode == <a link="M32_Monitor" file="shared_pseudocode.xml" hover="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then
        if n == 13 then SP_mon = value;
        elsif n == 14 then LR_mon = value;
        else _R[n]&lt;31:0&gt; = value;
    else
        // It is CONSTRAINED UNPREDICTABLE whether the upper 32 bits of the X
        // register are unchanged or set to zero. This is also tested for on
        // exception entry, as this applies to all AArch32 registers.
        if <a link="impl-shared.HaveAArch64.0" file="shared_pseudocode.xml" hover="function: boolean HaveAArch64()">HaveAArch64</a>() &amp;&amp; <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_ZEROUPPER" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_ZEROUPPER</a>) then
            _R[<a link="impl-aarch32.LookUpRIndex.2" file="shared_pseudocode.xml" hover="function: integer LookUpRIndex(integer n, bits(5) mode)">LookUpRIndex</a>(n, mode)] = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
        else
            _R[<a link="impl-aarch32.LookUpRIndex.2" file="shared_pseudocode.xml" hover="function: integer LookUpRIndex(integer n, bits(5) mode)">LookUpRIndex</a>(n, mode)]&lt;31:0&gt; = value;

    return;</pstext>
    </ps>
    <ps name="aarch32/functions/registers/S" mylink="aarch32.functions.registers.S" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// S[] - non-assignment form
// =========================

bits(32) <anchor link="impl-aarch32.S.read.1" hover="accessor: bits(32) S[integer n]">S</anchor>[integer n]
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    base = (n MOD 4) * 32;
    bits(128) vreg = V[n DIV 4];
    return vreg&lt;base+31:base&gt;;

// S[] - assignment form
// =====================

<anchor link="impl-aarch32.S.write.1" hover="accessor: S[integer n] = bits(32) value">S</anchor>[integer n] = bits(32) value
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    base = (n MOD 4) * 32;
    bits(128) vreg = V[n DIV 4];
    vreg&lt;base+31:base&gt; = value;
    V[n DIV 4] = vreg;
    return;</pstext>
    </ps>
    <ps name="aarch32/functions/registers/SP" mylink="aarch32.functions.registers.SP" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SP - assignment form
// ====================

<anchor link="impl-aarch32.SP.write.none" hover="accessor: SP = bits(32) value">SP</anchor> = bits(32) value
    <a link="impl-aarch32.R.write.1" file="shared_pseudocode.xml" hover="accessor: R[integer n] = bits(32) value">R</a>[13] = value;
    return;

// SP - non-assignment form
// ========================

bits(32) <anchor link="impl-aarch32.SP.read.none_2" hover="accessor: bits(32) SP">SP</anchor>
    return <a link="impl-aarch32.R.read.1" file="shared_pseudocode.xml" hover="accessor: bits(32) R[integer n]">R</a>[13];</pstext>
    </ps>
    <ps name="aarch32/functions/registers/_Dclone" mylink="aarch32.functions.registers._Dclone" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">array bits(64) _Dclone[0..31];</pstext>
    </ps>
    <ps name="aarch32/functions/system/AArch32.ExceptionReturn" mylink="aarch32.functions.system.AArch32.ExceptionReturn" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.ExceptionReturn()
// =========================

<anchor link="AArch32.ExceptionReturn.2" hover="function: AArch32.ExceptionReturn(bits(32) new_pc_in, bits(32) spsr)">AArch32.ExceptionReturn</anchor>(bits(32) new_pc_in, bits(32) spsr)
    bits(32) new_pc = new_pc_in;
    <a link="impl-shared.SynchronizeContext.0" file="shared_pseudocode.xml" hover="function: SynchronizeContext()">SynchronizeContext</a>();
    // Attempts to change to an illegal mode or state will invoke the Illegal Execution state
    // mechanism
    <a link="impl-shared.SetPSTATEFromPSR.1" file="shared_pseudocode.xml" hover="function: SetPSTATEFromPSR(bits(N) spsr)">SetPSTATEFromPSR</a>(spsr);
    <a link="impl-shared.ClearExclusiveLocal.1" file="shared_pseudocode.xml" hover="function: ClearExclusiveLocal(integer processorid)">ClearExclusiveLocal</a>(<a link="impl-shared.ProcessorID.0" file="shared_pseudocode.xml" hover="function: integer ProcessorID()">ProcessorID</a>());
    <a link="impl-shared.SendEventLocal.0" file="shared_pseudocode.xml" hover="function: SendEventLocal()">SendEventLocal</a>();

    if PSTATE.IL == '1' then
        // If the exception return is illegal, PC[1:0] are UNKNOWN
        new_pc&lt;1:0&gt; = bits(2) UNKNOWN;
    else
        // LR[1:0] or LR[0] are treated as being 0, depending on the target instruction set state
        if PSTATE.T == '1' then
            new_pc&lt;0&gt; = '0';                 // T32
        else
            new_pc&lt;1:0&gt; = '00';              // A32

    boolean branch_conditional = <a link="AArch32.CurrentCond.0" file="shared_pseudocode.xml" hover="function: bits(4) AArch32.CurrentCond()">AArch32.CurrentCond</a>() != '111x';
    <a link="impl-shared.BranchTo.3" file="shared_pseudocode.xml" hover="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(new_pc, <a link="BranchType_ERET" file="shared_pseudocode.xml" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType_ERET</a>, branch_conditional);

    <a link="impl-shared.CheckExceptionCatch.1" file="shared_pseudocode.xml" hover="function: CheckExceptionCatch(boolean exception_entry)">CheckExceptionCatch</a>(FALSE);              // Check for debug event on exception return</pstext>
    </ps>
    <ps name="aarch32/functions/system/AArch32.ExecutingCP10or11Instr" mylink="aarch32.functions.system.AArch32.ExecutingCP10or11Instr" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.ExecutingCP10or11Instr()
// ================================

boolean <anchor link="AArch32.ExecutingCP10or11Instr.0" hover="function: boolean AArch32.ExecutingCP10or11Instr()">AArch32.ExecutingCP10or11Instr</anchor>()
    instr =  <a link="impl-shared.ThisInstr.0" file="shared_pseudocode.xml" hover="function: bits(32) ThisInstr()">ThisInstr</a>();
    instr_set = <a link="impl-shared.CurrentInstrSet.0" file="shared_pseudocode.xml" hover="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>();
    assert instr_set IN {<a link="InstrSet_A32" file="shared_pseudocode.xml" hover="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a>, <a link="InstrSet_T32" file="shared_pseudocode.xml" hover="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_T32</a>};

    if instr_set == <a link="InstrSet_A32" file="shared_pseudocode.xml" hover="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> then
        return ((instr&lt;27:24&gt; == '1110' || instr&lt;27:25&gt; == '110') &amp;&amp; instr&lt;11:8&gt; == '101x');
    else // InstrSet_T32
        return (instr&lt;31:28&gt; == '111x' &amp;&amp; (instr&lt;27:24&gt; == '1110' || instr&lt;27:25&gt; == '110') &amp;&amp; instr&lt;11:8&gt; == '101x');</pstext>
    </ps>
    <ps name="aarch32/functions/system/AArch32.ITAdvance" mylink="aarch32.functions.system.AArch32.ITAdvance" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.ITAdvance()
// ===================

<anchor link="AArch32.ITAdvance.0" hover="function: AArch32.ITAdvance()">AArch32.ITAdvance</anchor>()
    if PSTATE.IT&lt;2:0&gt; == '000' then
        PSTATE.IT = '00000000';
    else
        PSTATE.IT&lt;4:0&gt; = <a link="impl-shared.LSL.2" file="shared_pseudocode.xml" hover="function: bits(N) LSL(bits(N) x, integer shift)">LSL</a>(PSTATE.IT&lt;4:0&gt;, 1);
    return;</pstext>
    </ps>
    <ps name="aarch32/functions/system/AArch32.SysRegRead" mylink="aarch32.functions.system.AArch32.SysRegRead" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Read from a 32-bit AArch32 System register and write the register's contents to R[t].
<anchor link="AArch32.SysRegRead.3" hover="function: AArch32.SysRegRead(integer cp_num, bits(32) instr, integer t)">AArch32.SysRegRead</anchor>(integer cp_num, bits(32) instr, integer t);</pstext>
    </ps>
    <ps name="aarch32/functions/system/AArch32.SysRegRead64" mylink="aarch32.functions.system.AArch32.SysRegRead64" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Read from a 64-bit AArch32 System register and write the register's contents to R[t] and R[t2].
<anchor link="AArch32.SysRegRead64.4" hover="function: AArch32.SysRegRead64(integer cp_num, bits(32) instr, integer t, integer t2)">AArch32.SysRegRead64</anchor>(integer cp_num, bits(32) instr, integer t, integer t2);</pstext>
    </ps>
    <ps name="aarch32/functions/system/AArch32.SysRegReadCanWriteAPSR" mylink="aarch32.functions.system.AArch32.SysRegReadCanWriteAPSR" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.SysRegReadCanWriteAPSR()
// ================================
// Determines whether the AArch32 System register read instruction can write to APSR flags.

boolean <anchor link="AArch32.SysRegReadCanWriteAPSR.2" hover="function: boolean AArch32.SysRegReadCanWriteAPSR(integer cp_num, bits(32) instr)">AArch32.SysRegReadCanWriteAPSR</anchor>(integer cp_num, bits(32) instr)
    assert <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>();
    assert (cp_num IN {14,15});
    assert cp_num == <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(instr&lt;11:8&gt;);

    opc1 = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(instr&lt;23:21&gt;);
    opc2 = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(instr&lt;7:5&gt;);
    CRn  = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(instr&lt;19:16&gt;);
    CRm  = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(instr&lt;3:0&gt;);

    if cp_num == 14 &amp;&amp; opc1 == 0 &amp;&amp; CRn == 0 &amp;&amp; CRm == 1 &amp;&amp; opc2 == 0 then // DBGDSCRint
        return TRUE;

    return FALSE;</pstext>
    </ps>
    <ps name="aarch32/functions/system/AArch32.SysRegWrite" mylink="aarch32.functions.system.AArch32.SysRegWrite" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Read the contents of R[t] and write to a 32-bit AArch32 System register.
<anchor link="AArch32.SysRegWrite.3" hover="function: AArch32.SysRegWrite(integer cp_num, bits(32) instr, integer t)">AArch32.SysRegWrite</anchor>(integer cp_num, bits(32) instr, integer t);</pstext>
    </ps>
    <ps name="aarch32/functions/system/AArch32.SysRegWrite64" mylink="aarch32.functions.system.AArch32.SysRegWrite64" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Read the contents of R[t] and R[t2] and write to a 64-bit AArch32 System register.
<anchor link="AArch32.SysRegWrite64.4" hover="function: AArch32.SysRegWrite64(integer cp_num, bits(32) instr, integer t, integer t2)">AArch32.SysRegWrite64</anchor>(integer cp_num, bits(32) instr, integer t, integer t2);</pstext>
    </ps>
    <ps name="aarch32/functions/system/AArch32.SysRegWriteM" mylink="aarch32.functions.system.AArch32.SysRegWriteM" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Read a value from a virtual address and write it to an AArch32 System register.
<anchor link="AArch32.SysRegWriteM.3" hover="function: AArch32.SysRegWriteM(integer cp_num, bits(32) instr, bits(32) address)">AArch32.SysRegWriteM</anchor>(integer cp_num, bits(32) instr, bits(32) address);</pstext>
    </ps>
    <ps name="aarch32/functions/system/AArch32.WriteMode" mylink="aarch32.functions.system.AArch32.WriteMode" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.WriteMode()
// ===================
// Function for dealing with writes to PSTATE.M from AArch32 state only.
// This ensures that PSTATE.EL and PSTATE.SP are always valid.

<anchor link="AArch32.WriteMode.1" hover="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</anchor>(bits(5) mode)
    (valid,el) = <a link="impl-shared.ELFromM32.1" file="shared_pseudocode.xml" hover="function: (boolean,bits(2)) ELFromM32(bits(5) mode)">ELFromM32</a>(mode);
    assert valid;
    PSTATE.M   = mode;
    PSTATE.EL  = el;
    PSTATE.nRW = '1';
    PSTATE.SP  = (if mode IN {<a link="M32_User" file="shared_pseudocode.xml" hover="constant bits(5) M32_User = '10000'">M32_User</a>,<a link="M32_System" file="shared_pseudocode.xml" hover="constant bits(5) M32_System = '11111'">M32_System</a>} then '0' else '1');
    return;</pstext>
    </ps>
    <ps name="aarch32/functions/system/AArch32.WriteModeByInstr" mylink="aarch32.functions.system.AArch32.WriteModeByInstr" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.WriteModeByInstr()
// ==========================
// Function for dealing with writes to PSTATE.M from an AArch32 instruction, and ensuring that
// illegal state changes are correctly flagged in PSTATE.IL.

<anchor link="AArch32.WriteModeByInstr.1" hover="function: AArch32.WriteModeByInstr(bits(5) mode)">AArch32.WriteModeByInstr</anchor>(bits(5) mode)
    (valid,el) = <a link="impl-shared.ELFromM32.1" file="shared_pseudocode.xml" hover="function: (boolean,bits(2)) ELFromM32(bits(5) mode)">ELFromM32</a>(mode);

    // 'valid' is set to FALSE if' mode' is invalid for this implementation or the current value
    // of SCR.NS/SCR_EL3.NS. Additionally, it is illegal for an instruction to write 'mode' to
    // PSTATE.EL if it would result in any of:
    // * A change to a mode that would cause entry to a higher Exception level.
    if <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(el) &gt; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) then
        valid = FALSE;

    // * A change to or from Hyp mode.
    if (PSTATE.M == <a link="M32_Hyp" file="shared_pseudocode.xml" hover="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a> || mode == <a link="M32_Hyp" file="shared_pseudocode.xml" hover="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>) &amp;&amp; PSTATE.M != mode then
        valid = FALSE;

    // * When EL2 is implemented, the value of HCR.TGE is '1', a change to a Non-secure EL1 mode.
    if PSTATE.M == <a link="M32_Monitor" file="shared_pseudocode.xml" hover="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> &amp;&amp; <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; el == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; SCR.NS == '1' &amp;&amp; HCR.TGE == '1' then
        valid = FALSE;

    if !valid then
        PSTATE.IL = '1';
    else
        <a link="AArch32.WriteMode.1" file="shared_pseudocode.xml" hover="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(mode);</pstext>
    </ps>
    <ps name="aarch32/functions/system/BadMode" mylink="aarch32.functions.system.BadMode" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// BadMode()
// =========

boolean <anchor link="impl-aarch32.BadMode.1" hover="function: boolean BadMode(bits(5) mode)">BadMode</anchor>(bits(5) mode)
    // Return TRUE if 'mode' encodes a mode that is not valid for this implementation
    boolean valid;
    case mode of
        when <a link="M32_Monitor" file="shared_pseudocode.xml" hover="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>
            valid = <a link="impl-shared.HaveAArch32EL.1" file="shared_pseudocode.xml" hover="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>);
        when <a link="M32_Hyp" file="shared_pseudocode.xml" hover="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>
            valid = <a link="impl-shared.HaveAArch32EL.1" file="shared_pseudocode.xml" hover="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>);
        when <a link="M32_FIQ" file="shared_pseudocode.xml" hover="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>, <a link="M32_IRQ" file="shared_pseudocode.xml" hover="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>, <a link="M32_Svc" file="shared_pseudocode.xml" hover="constant bits(5) M32_Svc = '10011'">M32_Svc</a>, <a link="M32_Abort" file="shared_pseudocode.xml" hover="constant bits(5) M32_Abort = '10111'">M32_Abort</a>, <a link="M32_Undef" file="shared_pseudocode.xml" hover="constant bits(5) M32_Undef = '11011'">M32_Undef</a>, <a link="M32_System" file="shared_pseudocode.xml" hover="constant bits(5) M32_System = '11111'">M32_System</a>
            // If EL3 is implemented and using AArch32, then these modes are EL3 modes in Secure
            // state, and EL1 modes in Non-secure state. If EL3 is not implemented or is using
            // AArch64, then these modes are EL1 modes.
            // Therefore it is sufficient to test this implementation supports EL1 using AArch32.
            valid = <a link="impl-shared.HaveAArch32EL.1" file="shared_pseudocode.xml" hover="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>);
        when <a link="M32_User" file="shared_pseudocode.xml" hover="constant bits(5) M32_User = '10000'">M32_User</a>
            valid = <a link="impl-shared.HaveAArch32EL.1" file="shared_pseudocode.xml" hover="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>);
        otherwise
            valid = FALSE;           // Passed an illegal mode value
    return !valid;</pstext>
    </ps>
    <ps name="aarch32/functions/system/BankedRegisterAccessValid" mylink="aarch32.functions.system.BankedRegisterAccessValid" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// BankedRegisterAccessValid()
// ===========================
// Checks for MRS (Banked register) or MSR (Banked register) accesses to registers
// other than the SPSRs that are invalid. This includes ELR_hyp accesses.

<anchor link="impl-aarch32.BankedRegisterAccessValid.2" hover="function: BankedRegisterAccessValid(bits(5) SYSm, bits(5) mode)">BankedRegisterAccessValid</anchor>(bits(5) SYSm, bits(5) mode)

    case SYSm of
        when '000xx', '00100'                          // R8_usr to R12_usr
            if mode != <a link="M32_FIQ" file="shared_pseudocode.xml" hover="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a> then UNPREDICTABLE;
        when '00101'                                   // SP_usr
            if mode == <a link="M32_System" file="shared_pseudocode.xml" hover="constant bits(5) M32_System = '11111'">M32_System</a> then UNPREDICTABLE;
        when '00110'                                   // LR_usr
            if mode IN {<a link="M32_Hyp" file="shared_pseudocode.xml" hover="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>,<a link="M32_System" file="shared_pseudocode.xml" hover="constant bits(5) M32_System = '11111'">M32_System</a>} then UNPREDICTABLE;
        when '010xx', '0110x', '01110'                 // R8_fiq to R12_fiq, SP_fiq, LR_fiq
            if mode == <a link="M32_FIQ" file="shared_pseudocode.xml" hover="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a> then UNPREDICTABLE;
        when '1000x'                                   // LR_irq, SP_irq
            if mode == <a link="M32_IRQ" file="shared_pseudocode.xml" hover="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a> then UNPREDICTABLE;
        when '1001x'                                   // LR_svc, SP_svc
            if mode == <a link="M32_Svc" file="shared_pseudocode.xml" hover="constant bits(5) M32_Svc = '10011'">M32_Svc</a> then UNPREDICTABLE;
        when '1010x'                                   // LR_abt, SP_abt
            if mode == <a link="M32_Abort" file="shared_pseudocode.xml" hover="constant bits(5) M32_Abort = '10111'">M32_Abort</a> then UNPREDICTABLE;
        when '1011x'                                   // LR_und, SP_und
            if mode == <a link="M32_Undef" file="shared_pseudocode.xml" hover="constant bits(5) M32_Undef = '11011'">M32_Undef</a> then UNPREDICTABLE;
        when '1110x'                                   // LR_mon, SP_mon
            if !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) || !<a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>() || mode == <a link="M32_Monitor" file="shared_pseudocode.xml" hover="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then UNPREDICTABLE;
        when '11110'                                   // ELR_hyp, only from Monitor or Hyp mode
            if !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) || !(mode IN {<a link="M32_Monitor" file="shared_pseudocode.xml" hover="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>,<a link="M32_Hyp" file="shared_pseudocode.xml" hover="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>}) then UNPREDICTABLE;
        when '11111'                                   // SP_hyp, only from Monitor mode
            if !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) || mode != <a link="M32_Monitor" file="shared_pseudocode.xml" hover="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then UNPREDICTABLE;
        otherwise
            UNPREDICTABLE;

    return;</pstext>
    </ps>
    <ps name="aarch32/functions/system/CPSRWriteByInstr" mylink="aarch32.functions.system.CPSRWriteByInstr" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CPSRWriteByInstr()
// ==================
// Update PSTATE.&lt;N,Z,C,V,Q,GE,E,A,I,F,M&gt; from a CPSR value written by an MSR instruction.

<anchor link="impl-aarch32.CPSRWriteByInstr.2" hover="function: CPSRWriteByInstr(bits(32) value, bits(4) bytemask)">CPSRWriteByInstr</anchor>(bits(32) value, bits(4) bytemask)
    privileged = PSTATE.EL != <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>;              // PSTATE.&lt;A,I,F,M&gt; are not writable at EL0

    // Write PSTATE from 'value', ignoring bytes masked by 'bytemask'
    if bytemask&lt;3&gt; == '1' then
        PSTATE.&lt;N,Z,C,V,Q&gt; = value&lt;31:27&gt;;
        // Bits &lt;26:24&gt; are ignored

    if bytemask&lt;2&gt; == '1' then
        if <a link="impl-shared.HaveSSBSExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then
            PSTATE.SSBS = value&lt;23&gt;;
        if privileged then
            PSTATE.PAN = value&lt;22&gt;;
        if <a link="impl-shared.HaveDITExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveDITExt()">HaveDITExt</a>() then
            PSTATE.DIT = value&lt;21&gt;;
        // Bit &lt;20&gt; is RES0
        PSTATE.GE = value&lt;19:16&gt;;

    if bytemask&lt;1&gt; == '1' then
        // Bits &lt;15:10&gt; are RES0
        PSTATE.E = value&lt;9&gt;;                    // PSTATE.E is writable at EL0
        if privileged then
            PSTATE.A = value&lt;8&gt;;

    if bytemask&lt;0&gt; == '1' then
        if privileged then
            PSTATE.&lt;I,F&gt; = value&lt;7:6&gt;;
            // Bit &lt;5&gt; is RES0
            // AArch32.WriteModeByInstr() sets PSTATE.IL to 1 if this is an illegal mode change.
            <a link="AArch32.WriteModeByInstr.1" file="shared_pseudocode.xml" hover="function: AArch32.WriteModeByInstr(bits(5) mode)">AArch32.WriteModeByInstr</a>(value&lt;4:0&gt;);
    return;</pstext>
    </ps>
    <ps name="aarch32/functions/system/ConditionPassed" mylink="aarch32.functions.system.ConditionPassed" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ConditionPassed()
// =================

boolean <anchor link="impl-aarch32.ConditionPassed.0" hover="function: boolean ConditionPassed()">ConditionPassed</anchor>()
    return <a link="impl-shared.ConditionHolds.1" file="shared_pseudocode.xml" hover="function: boolean ConditionHolds(bits(4) cond)">ConditionHolds</a>(<a link="AArch32.CurrentCond.0" file="shared_pseudocode.xml" hover="function: bits(4) AArch32.CurrentCond()">AArch32.CurrentCond</a>());</pstext>
    </ps>
    <ps name="aarch32/functions/system/CurrentCond" mylink="aarch32.functions.system.CurrentCond" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">bits(4) <anchor link="AArch32.CurrentCond.0" hover="function: bits(4) AArch32.CurrentCond()">AArch32.CurrentCond</anchor>();</pstext>
    </ps>
    <ps name="aarch32/functions/system/InITBlock" mylink="aarch32.functions.system.InITBlock" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// InITBlock()
// ===========

boolean <anchor link="impl-aarch32.InITBlock.0" hover="function: boolean InITBlock()">InITBlock</anchor>()
    if <a link="impl-shared.CurrentInstrSet.0" file="shared_pseudocode.xml" hover="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() == <a link="InstrSet_T32" file="shared_pseudocode.xml" hover="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_T32</a> then
        return PSTATE.IT&lt;3:0&gt; != '0000';
    else
        return FALSE;</pstext>
    </ps>
    <ps name="aarch32/functions/system/LastInITBlock" mylink="aarch32.functions.system.LastInITBlock" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// LastInITBlock()
// ===============

boolean <anchor link="impl-aarch32.LastInITBlock.0" hover="function: boolean LastInITBlock()">LastInITBlock</anchor>()
    return (PSTATE.IT&lt;3:0&gt; == '1000');</pstext>
    </ps>
    <ps name="aarch32/functions/system/SPSRWriteByInstr" mylink="aarch32.functions.system.SPSRWriteByInstr" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SPSRWriteByInstr()
// ==================

<anchor link="impl-aarch32.SPSRWriteByInstr.2" hover="function: SPSRWriteByInstr(bits(32) value, bits(4) bytemask)">SPSRWriteByInstr</anchor>(bits(32) value, bits(4) bytemask)

    bits(32) new_spsr = <a link="impl-shared.SPSR.read.0" file="shared_pseudocode.xml" hover="accessor: bits(N) SPSR[]">SPSR</a>[];

    if bytemask&lt;3&gt; == '1' then
        new_spsr&lt;31:24&gt; = value&lt;31:24&gt;;  // N,Z,C,V,Q flags, IT[1:0],J bits

    if bytemask&lt;2&gt; == '1' then
        new_spsr&lt;23:16&gt; = value&lt;23:16&gt;;  // IL bit, GE[3:0] flags

    if bytemask&lt;1&gt; == '1' then
        new_spsr&lt;15:8&gt; = value&lt;15:8&gt;;    // IT[7:2] bits, E bit, A interrupt mask

    if bytemask&lt;0&gt; == '1' then
        new_spsr&lt;7:0&gt; = value&lt;7:0&gt;;      // I,F interrupt masks, T bit, Mode bits

    <a link="impl-shared.SPSR.write.0" file="shared_pseudocode.xml" hover="accessor: SPSR[] = bits(N) value">SPSR</a>[] = new_spsr;                   // UNPREDICTABLE if User or System mode

    return;</pstext>
    </ps>
    <ps name="aarch32/functions/system/SPSRaccessValid" mylink="aarch32.functions.system.SPSRaccessValid" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SPSRaccessValid()
// =================
// Checks for MRS (Banked register) or MSR (Banked register) accesses to the SPSRs
// that are UNPREDICTABLE

<anchor link="impl-aarch32.SPSRaccessValid.2" hover="function: SPSRaccessValid(bits(5) SYSm, bits(5) mode)">SPSRaccessValid</anchor>(bits(5) SYSm, bits(5) mode)
    case SYSm of
        when '01110'                                                   // SPSR_fiq
            if mode == <a link="M32_FIQ" file="shared_pseudocode.xml" hover="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>   then UNPREDICTABLE;
        when '10000'                                                   // SPSR_irq
            if mode == <a link="M32_IRQ" file="shared_pseudocode.xml" hover="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>   then UNPREDICTABLE;
        when '10010'                                                   // SPSR_svc
            if mode == <a link="M32_Svc" file="shared_pseudocode.xml" hover="constant bits(5) M32_Svc = '10011'">M32_Svc</a>   then UNPREDICTABLE;
        when '10100'                                                   // SPSR_abt
            if mode == <a link="M32_Abort" file="shared_pseudocode.xml" hover="constant bits(5) M32_Abort = '10111'">M32_Abort</a> then UNPREDICTABLE;
        when '10110'                                                   // SPSR_und
            if mode == <a link="M32_Undef" file="shared_pseudocode.xml" hover="constant bits(5) M32_Undef = '11011'">M32_Undef</a> then UNPREDICTABLE;
        when '11100'                                                   // SPSR_mon
            if !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) || mode == <a link="M32_Monitor" file="shared_pseudocode.xml" hover="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> || !<a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>() then UNPREDICTABLE;
        when '11110'                                                   // SPSR_hyp
            if !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) || mode != <a link="M32_Monitor" file="shared_pseudocode.xml" hover="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then UNPREDICTABLE;
        otherwise
            UNPREDICTABLE;

    return;</pstext>
    </ps>
    <ps name="aarch32/functions/system/SelectInstrSet" mylink="aarch32.functions.system.SelectInstrSet" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SelectInstrSet()
// ================

<anchor link="impl-aarch32.SelectInstrSet.1" hover="function: SelectInstrSet(InstrSet iset)">SelectInstrSet</anchor>(<a link="InstrSet" file="shared_pseudocode.xml" hover="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet</a> iset)
    assert <a link="impl-shared.CurrentInstrSet.0" file="shared_pseudocode.xml" hover="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() IN {<a link="InstrSet_A32" file="shared_pseudocode.xml" hover="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a>, <a link="InstrSet_T32" file="shared_pseudocode.xml" hover="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_T32</a>};
    assert iset IN {<a link="InstrSet_A32" file="shared_pseudocode.xml" hover="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a>, <a link="InstrSet_T32" file="shared_pseudocode.xml" hover="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_T32</a>};

    PSTATE.T = if iset == <a link="InstrSet_A32" file="shared_pseudocode.xml" hover="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> then '0' else '1';

    return;</pstext>
    </ps>
    <ps name="aarch32/functions/v6simd/Sat" mylink="aarch32.functions.v6simd.Sat" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Sat()
// =====

bits(N) <anchor link="impl-aarch32.Sat.3" hover="function: bits(N) Sat(integer i, integer N, boolean unsigned)">Sat</anchor>(integer i, integer N, boolean unsigned)
    result = if unsigned then <a link="impl-aarch32.UnsignedSat.2" file="shared_pseudocode.xml" hover="function: bits(N) UnsignedSat(integer i, integer N)">UnsignedSat</a>(i, N) else <a link="impl-aarch32.SignedSat.2" file="shared_pseudocode.xml" hover="function: bits(N) SignedSat(integer i, integer N)">SignedSat</a>(i, N);
    return result;</pstext>
    </ps>
    <ps name="aarch32/functions/v6simd/SignedSat" mylink="aarch32.functions.v6simd.SignedSat" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SignedSat()
// ===========

bits(N) <anchor link="impl-aarch32.SignedSat.2" hover="function: bits(N) SignedSat(integer i, integer N)">SignedSat</anchor>(integer i, integer N)
    (result, -) = <a link="impl-shared.SignedSatQ.2" file="shared_pseudocode.xml" hover="function: (bits(N), boolean) SignedSatQ(integer i, integer N)">SignedSatQ</a>(i, N);
    return result;</pstext>
    </ps>
    <ps name="aarch32/functions/v6simd/UnsignedSat" mylink="aarch32.functions.v6simd.UnsignedSat" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// UnsignedSat()
// =============

bits(N) <anchor link="impl-aarch32.UnsignedSat.2" hover="function: bits(N) UnsignedSat(integer i, integer N)">UnsignedSat</anchor>(integer i, integer N)
    (result, -) = <a link="impl-shared.UnsignedSatQ.2" file="shared_pseudocode.xml" hover="function: (bits(N), boolean) UnsignedSatQ(integer i, integer N)">UnsignedSatQ</a>(i, N);
    return result;</pstext>
    </ps>
    <ps name="aarch32/ic/AArch32.IC" mylink="aarch32.ic.AArch32.IC" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.IC()
// ============
// Perform Instruction Cache Operation.

<anchor link="AArch32.IC.1" hover="function: AArch32.IC(CacheOpScope opscope)">AArch32.IC</anchor>(<a link="CacheOpScope" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a> opscope)
    regval = bits(32) UNKNOWN;
    <a link="AArch32.IC.2" file="shared_pseudocode.xml" hover="function: AArch32.IC(bits(32) regval, CacheOpScope opscope)">AArch32.IC</a>(regval, opscope);

// AArch32.IC()
// ============
// Perform Instruction Cache Operation.

<anchor link="AArch32.IC.2" hover="function: AArch32.IC(bits(32) regval, CacheOpScope opscope)">AArch32.IC</anchor>(bits(32) regval, <a link="CacheOpScope" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a> opscope)
    <a link="CacheRecord" file="shared_pseudocode.xml" hover="type CacheRecord is ( AccType acctype, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, bits(64) regval, FullAddress paddress, bits(64) vaddress, integer set, integer way, integer level, Shareability shareability, boolean translated, boolean is_vmid_valid, bits(16) vmid, boolean is_asid_valid, bits(16) asid, SecurityState security, CachePASpace cpas )">CacheRecord</a> cache;
    <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype = <a link="AccType_IC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>;

    cache.acctype = acctype;
    cache.cachetype = <a link="CacheType_Instruction" file="shared_pseudocode.xml" hover="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType_Instruction</a>;
    cache.cacheop = <a link="CacheOp_Invalidate" file="shared_pseudocode.xml" hover="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Invalidate</a>;
    cache.opscope = opscope;
    cache.security = <a link="impl-shared.SecurityStateAtEL.1" file="shared_pseudocode.xml" hover="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(PSTATE.EL);

    if opscope IN {<a link="CacheOpScope_ALLU" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_ALLU</a>, <a link="CacheOpScope_ALLUIS" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_ALLUIS</a>} then
        if opscope == <a link="CacheOpScope_ALLUIS" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_ALLUIS</a> || (opscope == <a link="CacheOpScope_ALLU" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_ALLU</a> &amp;&amp; PSTATE.EL == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>
            &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR.FB == '1') then
            cache.shareability = <a link="Shareability_ISH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_ISH</a>;
        else
            cache.shareability = <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        cache.regval = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(regval);
        <a link="impl-shared.CACHE_OP.1" file="shared_pseudocode.xml" hover="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
    else
        assert opscope == <a link="CacheOpScope_PoU" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoU</a>;

        if <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() then
            if PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} then
                cache.is_vmid_valid = TRUE;
                cache.vmid          = VMID[];
            else
                cache.is_vmid_valid = FALSE;
        else
            cache.is_vmid_valid = FALSE;

        if PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then
            cache.is_asid_valid = TRUE;
            cache.asid          = <a link="impl-shared.ASID.read.0" file="shared_pseudocode.xml" hover="accessor: bits(16) ASID[]">ASID</a>[];
        else
            cache.is_asid_valid = FALSE;

        need_translate = <a link="impl-shared.ICInstNeedsTranslation.1" file="shared_pseudocode.xml" hover="function: boolean ICInstNeedsTranslation(CacheOpScope opscope)">ICInstNeedsTranslation</a>(opscope);

        cache.shareability = <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        cache.vaddress = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(regval);
        cache.translated = need_translate;

        if !need_translate then
            cache.paddress = <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> UNKNOWN;
            <a link="impl-shared.CACHE_OP.1" file="shared_pseudocode.xml" hover="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
            return;

        wasaligned = TRUE;
        iswrite = FALSE;
        size = 0;
        memaddrdesc = <a link="AArch32.TranslateAddress.5" file="shared_pseudocode.xml" hover="function: AddressDescriptor AArch32.TranslateAddress(bits(32) va, AccType acctype,&#13; boolean iswrite, boolean aligned,&#13; integer size)">AArch32.TranslateAddress</a>(regval, acctype, iswrite, wasaligned, size);
        if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
            <a link="AArch32.Abort.2" file="shared_pseudocode.xml" hover="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(regval, memaddrdesc.fault);

        cache.paddress = memaddrdesc.paddress;
        <a link="impl-shared.CACHE_OP.1" file="shared_pseudocode.xml" hover="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
    return;</pstext>
    </ps>
    <ps name="aarch32/predictionrestrict/RestrictPrediction" mylink="aarch32.predictionrestrict.RestrictPrediction" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// RestrictPrediction()
// ====================
// Clear all predictions in the context.

<anchor link="AArch32.RestrictPrediction.2" hover="function: AArch32.RestrictPrediction(bits(32) val, RestrictType restriction)">AArch32.RestrictPrediction</anchor>(bits(32) val, <a link="RestrictType" file="shared_pseudocode.xml" hover="enumeration RestrictType {&#13; RestrictType_DataValue,&#13; RestrictType_ControlFlow,&#13; RestrictType_CachePrefetch&#13; }">RestrictType</a> restriction)

    <a link="ExecutionCntxt" file="shared_pseudocode.xml" hover="type ExecutionCntxt is ( boolean is_vmid_valid, boolean all_vmid, bits(16) vmid, boolean is_asid_valid, boolean all_asid, bits(16) asid, bits(2) target_el, SecurityState security, RestrictType restriction )">ExecutionCntxt</a> c;
    target_el    = val&lt;25:24&gt;;

    // If the instruction is executed at an EL lower than the specified
    // level, it is treated as a NOP.
    if <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) then return;

    bit ns  = val&lt;26&gt;;
    ss = <a link="impl-shared.TargetSecurityState.1" file="shared_pseudocode.xml" hover="function: SecurityState TargetSecurityState(bit NS)">TargetSecurityState</a>(ns);

    c.security  = ss;
    c.target_el = target_el;

    if <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} then
            c.is_vmid_valid = TRUE;
            c.all_vmid      = FALSE;
            c.vmid          = VMID[];

        elsif target_el IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} then
            c.is_vmid_valid = TRUE;
            c.all_vmid      = val&lt;27&gt; == '1';
            c.vmid          = <a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(val&lt;23:16&gt;, 16);           // Only valid if  val&lt;27&gt; == '0';
        else
            c.is_vmid_valid = FALSE;
    else
        c.is_vmid_valid = FALSE;

    if PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then
        c.is_asid_valid = TRUE;
        c.all_asid      = FALSE;
        c.asid          = <a link="impl-shared.ASID.read.0" file="shared_pseudocode.xml" hover="accessor: bits(16) ASID[]">ASID</a>[];

    elsif target_el == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then
        c.is_asid_valid = TRUE;
        c.all_asid      = val&lt;8&gt; == '1';
        c.asid          = <a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(val&lt;7:0&gt;, 16);                  // Only valid if  val&lt;8&gt; == '0';

    else
        c.is_asid_valid = FALSE;

    c.restriction = restriction;
    <a link="impl-shared.RESTRICT_PREDICTIONS.1" file="shared_pseudocode.xml" hover="function: RESTRICT_PREDICTIONS(ExecutionCntxt c)">RESTRICT_PREDICTIONS</a>(c);</pstext>
    </ps>
    <ps name="aarch32/translation/attrs/AArch32.DefaultTEXDecode" mylink="aarch32.translation.attrs.AArch32.DefaultTEXDecode" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.DefaultTEXDecode()
// ==========================
// Apply short-descriptor format memory region attributes, without TEX remap

MemoryAttributes <anchor link="AArch32.DefaultTEXDecode.4" hover="function: MemoryAttributes AArch32.DefaultTEXDecode(bits(3) TEX_in, bit C_in, bit B_in, bit S)">AArch32.DefaultTEXDecode</anchor>(bits(3) TEX_in, bit C_in, bit B_in, bit S)
    <a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs;
    bits(3) TEX = TEX_in;
    bit C = C_in;
    bit B = B_in;

    // Reserved values map to allocated values
    if (TEX == '001' &amp;&amp; C:B == '01') || (TEX == '010' &amp;&amp; C:B != '00') || TEX == '011' then
        bits(5) texcb;
        (-, texcb) = <a link="impl-shared.ConstrainUnpredictableBits.1" file="shared_pseudocode.xml" hover="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a link="Unpredictable_RESTEXCB" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESTEXCB</a>);
        TEX = texcb&lt;4:2&gt;;  C = texcb&lt;1&gt;;  B = texcb&lt;0&gt;;

    // Distinction between Inner Shareable and Outer Shareable is not supported in this format
    // A memory region is either Non-shareable or Outer Shareable
    case TEX:C:B of
        when '00000'
            // Device-nGnRnE
            memattrs.memtype      = <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
            memattrs.device       = <a link="DeviceType_nGnRnE" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a>;
            memattrs.shareability = <a link="Shareability_OSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        when '00001', '01000'
            // Device-nGnRE
            memattrs.memtype      = <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
            memattrs.device       = <a link="DeviceType_nGnRE" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRE</a>;
            memattrs.shareability = <a link="Shareability_OSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        when '00010'
            // Write-through Read allocate
            memattrs.memtype      = <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.inner.attrs  = <a link="MemAttr_WT" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
            memattrs.inner.hints  = <a link="MemHint_RA" file="shared_pseudocode.xml" hover="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
            memattrs.outer.attrs  = <a link="MemAttr_WT" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
            memattrs.outer.hints  = <a link="MemHint_RA" file="shared_pseudocode.xml" hover="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
            memattrs.shareability = if S == '1' then <a link="Shareability_OSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a> else <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        when '00011'
            // Write-back Read allocate
            memattrs.memtype      = <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.inner.attrs  = <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
            memattrs.inner.hints  = <a link="MemHint_RA" file="shared_pseudocode.xml" hover="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
            memattrs.outer.attrs  = <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
            memattrs.outer.hints  = <a link="MemHint_RA" file="shared_pseudocode.xml" hover="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
            memattrs.shareability = if S == '1' then <a link="Shareability_OSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a> else <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        when '00100'
            // Non-cacheable
            memattrs.memtype      = <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.inner.attrs  = <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;
            memattrs.outer.attrs  = <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;
            memattrs.shareability = <a link="Shareability_OSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        when '00110'
            memattrs = <a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> IMPLEMENTATION_DEFINED;
        when '00111'
            // Write-back Read and Write allocate
            memattrs.memtype      = <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.inner.attrs  = <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
            memattrs.inner.hints  = <a link="MemHint_RWA" file="shared_pseudocode.xml" hover="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
            memattrs.outer.attrs  = <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
            memattrs.outer.hints  = <a link="MemHint_RWA" file="shared_pseudocode.xml" hover="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
            memattrs.shareability = if S == '1' then <a link="Shareability_OSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a> else <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        when '1xxxx'
            // Cacheable, TEX&lt;1:0&gt; = Outer attrs, {C,B} = Inner attrs
            memattrs.memtype = <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.inner   = <a link="impl-shared.DecodeSDFAttr.1" file="shared_pseudocode.xml" hover="function: MemAttrHints DecodeSDFAttr(bits(2) rgn)">DecodeSDFAttr</a>(C:B);
            memattrs.outer   = <a link="impl-shared.DecodeSDFAttr.1" file="shared_pseudocode.xml" hover="function: MemAttrHints DecodeSDFAttr(bits(2) rgn)">DecodeSDFAttr</a>(TEX&lt;1:0&gt;);

            if memattrs.inner.attrs == <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> &amp;&amp; memattrs.outer.attrs == <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> then
                memattrs.shareability = <a link="Shareability_OSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
            else
                memattrs.shareability = if S == '1' then <a link="Shareability_OSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a> else <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        otherwise
            // Reserved, handled above
            <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();

    // The Transient hint is not supported in this format
    memattrs.inner.transient = FALSE;
    memattrs.outer.transient = FALSE;
    memattrs.tagged          = FALSE;

    if memattrs.inner.attrs == <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp; memattrs.outer.attrs == <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> then
        memattrs.xs = '0';
    else
        memattrs.xs = '1';

    return memattrs;</pstext>
    </ps>
    <ps name="aarch32/translation/attrs/AArch32.RemappedTEXDecode" mylink="aarch32.translation.attrs.AArch32.RemappedTEXDecode" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.RemappedTEXDecode()
// ===========================
// Apply short-descriptor format memory region attributes, with TEX remap

MemoryAttributes <anchor link="AArch32.RemappedTEXDecode.5" hover="function: MemoryAttributes AArch32.RemappedTEXDecode(Regime regime, bits(3) TEX, bit C, bit B, bit S)">AArch32.RemappedTEXDecode</anchor>(<a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(3) TEX, bit C, bit B, bit S)

    <a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs;
    PRRR_Type prrr;
    NMRR_Type nmrr;

    region = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(TEX&lt;0&gt;:C:B);         // TEX&lt;2:1&gt; are ignored in this mapping scheme
    if region == 6 then
        return <a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> IMPLEMENTATION_DEFINED;

    if regime == <a link="Regime_EL30" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> then
        prrr = PRRR_S;
        nmrr = NMRR_S;
    elsif <a link="impl-shared.HaveAArch32EL.1" file="shared_pseudocode.xml" hover="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
        prrr = PRRR_NS;
        nmrr = NMRR_NS;
    else
        prrr = PRRR;
        nmrr = NMRR;

    base = 2 * region;
    attrfield = prrr&lt;base+1:base&gt;;

    if attrfield == '11' then      // Reserved, maps to allocated value
        (-, attrfield) = <a link="impl-shared.ConstrainUnpredictableBits.1" file="shared_pseudocode.xml" hover="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a link="Unpredictable_RESPRRR" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESPRRR</a>);

    case attrfield of
        when '00'                  // Device-nGnRnE
            memattrs.memtype      = <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
            memattrs.device       = <a link="DeviceType_nGnRnE" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a>;
            memattrs.shareability = <a link="Shareability_OSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        when '01'                  // Device-nGnRE
            memattrs.memtype      = <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
            memattrs.device       = <a link="DeviceType_nGnRE" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRE</a>;
            memattrs.shareability = <a link="Shareability_OSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        when '10'
            NSn  = if S == '0' then prrr.NS0 else prrr.NS1;
            NOSm = prrr&lt;region+24&gt; AND NSn;
            IRn  = nmrr&lt;base+1:base&gt;;
            ORn  = nmrr&lt;base+17:base+16&gt;;

            memattrs.memtype = <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.inner   = <a link="impl-shared.DecodeSDFAttr.1" file="shared_pseudocode.xml" hover="function: MemAttrHints DecodeSDFAttr(bits(2) rgn)">DecodeSDFAttr</a>(IRn);
            memattrs.outer   = <a link="impl-shared.DecodeSDFAttr.1" file="shared_pseudocode.xml" hover="function: MemAttrHints DecodeSDFAttr(bits(2) rgn)">DecodeSDFAttr</a>(ORn);
            if memattrs.inner.attrs == <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> &amp;&amp; memattrs.outer.attrs == <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> then
                memattrs.shareability = <a link="Shareability_OSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
            else
                bits(2) sh = NSn:NOSm;
                memattrs.shareability = <a link="impl-shared.DecodeShareability.1" file="shared_pseudocode.xml" hover="function: Shareability DecodeShareability(bits(2) sh)">DecodeShareability</a>(sh);
        when '11'
            <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();

    // The Transient hint is not supported in this format
    memattrs.inner.transient = FALSE;
    memattrs.outer.transient = FALSE;
    memattrs.tagged          = FALSE;

    if memattrs.inner.attrs == <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp; memattrs.outer.attrs == <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> then
        memattrs.xs = '0';
    else
        memattrs.xs = '1';

    return memattrs;</pstext>
    </ps>
    <ps name="aarch32/translation/debug/AArch32.CheckBreakpoint" mylink="aarch32.translation.debug.AArch32.CheckBreakpoint" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.CheckBreakpoint()
// =========================
// Called before executing the instruction of length "size" bytes at "vaddress" in an AArch32
// translation regime, when either debug exceptions are enabled, or halting debug is enabled
// and halting is allowed.

FaultRecord <anchor link="AArch32.CheckBreakpoint.2" hover="function: FaultRecord AArch32.CheckBreakpoint(bits(32) vaddress,  integer size)">AArch32.CheckBreakpoint</anchor>(bits(32) vaddress,  integer size)
    assert <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());
    assert size IN {2,4};

    match = FALSE;
    mismatch = FALSE;

    for i = 0 to <a link="impl-shared.NumBreakpointsImplemented.0" file="shared_pseudocode.xml" hover="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() - 1
        (match_i, mismatch_i) = <a link="AArch32.BreakpointMatch.3" file="shared_pseudocode.xml" hover="function: (boolean,boolean) AArch32.BreakpointMatch(integer n, bits(32) vaddress,&#13; integer size)">AArch32.BreakpointMatch</a>(i, vaddress, size);
        match = match || match_i;
        mismatch = mismatch || mismatch_i;

    if match &amp;&amp; <a link="impl-shared.HaltOnBreakpointOrWatchpoint.0" file="shared_pseudocode.xml" hover="function: boolean HaltOnBreakpointOrWatchpoint()">HaltOnBreakpointOrWatchpoint</a>() then
        reason = <a link="DebugHalt_Breakpoint" file="shared_pseudocode.xml" hover="constant bits(6) DebugHalt_Breakpoint = '000111'">DebugHalt_Breakpoint</a>;
        <a link="impl-shared.Halt.1" file="shared_pseudocode.xml" hover="function: Halt(bits(6) reason)">Halt</a>(reason);
    elsif (match || mismatch) then
        acctype = <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a>;
        iswrite = FALSE;
        debugmoe = <a link="DebugException_Breakpoint" file="shared_pseudocode.xml" hover="constant bits(4) DebugException_Breakpoint = '0001'">DebugException_Breakpoint</a>;
        return <a link="AArch32.DebugFault.3" file="shared_pseudocode.xml" hover="function: FaultRecord AArch32.DebugFault(AccType acctype, boolean iswrite, bits(4) debugmoe)">AArch32.DebugFault</a>(acctype, iswrite, debugmoe);
    else
        return <a link="impl-shared.NoFault.0" file="shared_pseudocode.xml" hover="function: FaultRecord NoFault()">NoFault</a>();</pstext>
    </ps>
    <ps name="aarch32/translation/debug/AArch32.CheckDebug" mylink="aarch32.translation.debug.AArch32.CheckDebug" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.CheckDebug()
// ====================
// Called on each access to check for a debug exception or entry to Debug state.

FaultRecord <anchor link="AArch32.CheckDebug.4" hover="function: FaultRecord AArch32.CheckDebug(bits(32) vaddress, AccType acctype, boolean iswrite, integer size)">AArch32.CheckDebug</anchor>(bits(32) vaddress, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite, integer size)

    <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault = <a link="impl-shared.NoFault.0" file="shared_pseudocode.xml" hover="function: FaultRecord NoFault()">NoFault</a>();

    d_side = (acctype != <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a>);
    generate_exception = <a link="AArch32.GenerateDebugExceptions.0" file="shared_pseudocode.xml" hover="function: boolean AArch32.GenerateDebugExceptions()">AArch32.GenerateDebugExceptions</a>() &amp;&amp; DBGDSCRext.MDBGen == '1';
    halt = <a link="impl-shared.HaltOnBreakpointOrWatchpoint.0" file="shared_pseudocode.xml" hover="function: boolean HaltOnBreakpointOrWatchpoint()">HaltOnBreakpointOrWatchpoint</a>();
    // Relative priority of Vector Catch and Breakpoint exceptions not defined in the architecture
    vector_catch_first = <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_BPVECTORCATCHPRI" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_BPVECTORCATCHPRI</a>);

    if !d_side &amp;&amp; vector_catch_first &amp;&amp; generate_exception then
        fault = <a link="AArch32.CheckVectorCatch.2" file="shared_pseudocode.xml" hover="function: FaultRecord AArch32.CheckVectorCatch(bits(32) vaddress, integer size)">AArch32.CheckVectorCatch</a>(vaddress, size);

    if fault.statuscode == <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> &amp;&amp; (generate_exception || halt) then
        if d_side then
            fault = <a link="AArch32.CheckWatchpoint.4" file="shared_pseudocode.xml" hover="function: FaultRecord AArch32.CheckWatchpoint(bits(32) vaddress, AccType acctype,&#13; boolean iswrite, integer size)">AArch32.CheckWatchpoint</a>(vaddress, acctype, iswrite, size);
        else
            fault = <a link="AArch32.CheckBreakpoint.2" file="shared_pseudocode.xml" hover="function: FaultRecord AArch32.CheckBreakpoint(bits(32) vaddress,  integer size)">AArch32.CheckBreakpoint</a>(vaddress, size);

    if fault.statuscode == <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> &amp;&amp; !d_side &amp;&amp; !vector_catch_first &amp;&amp; generate_exception then
        return <a link="AArch32.CheckVectorCatch.2" file="shared_pseudocode.xml" hover="function: FaultRecord AArch32.CheckVectorCatch(bits(32) vaddress, integer size)">AArch32.CheckVectorCatch</a>(vaddress, size);

    return fault;</pstext>
    </ps>
    <ps name="aarch32/translation/debug/AArch32.CheckVectorCatch" mylink="aarch32.translation.debug.AArch32.CheckVectorCatch" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.CheckVectorCatch()
// ==========================
// Called before executing the instruction of length "size" bytes at "vaddress" in an AArch32
// translation regime, when debug exceptions are enabled.

FaultRecord <anchor link="AArch32.CheckVectorCatch.2" hover="function: FaultRecord AArch32.CheckVectorCatch(bits(32) vaddress, integer size)">AArch32.CheckVectorCatch</anchor>(bits(32) vaddress, integer size)
    assert <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());

    match = <a link="AArch32.VCRMatch.1" file="shared_pseudocode.xml" hover="function: boolean AArch32.VCRMatch(bits(32) vaddress)">AArch32.VCRMatch</a>(vaddress);
    if size == 4 &amp;&amp; !match &amp;&amp; <a link="AArch32.VCRMatch.1" file="shared_pseudocode.xml" hover="function: boolean AArch32.VCRMatch(bits(32) vaddress)">AArch32.VCRMatch</a>(vaddress + 2) then
        match = <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_VCMATCHHALF" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_VCMATCHHALF</a>);

    if match then
        acctype = <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a>;
        iswrite = FALSE;
        debugmoe = <a link="DebugException_VectorCatch" file="shared_pseudocode.xml" hover="constant bits(4) DebugException_VectorCatch = '0101'">DebugException_VectorCatch</a>;
        return <a link="AArch32.DebugFault.3" file="shared_pseudocode.xml" hover="function: FaultRecord AArch32.DebugFault(AccType acctype, boolean iswrite, bits(4) debugmoe)">AArch32.DebugFault</a>(acctype, iswrite, debugmoe);
    else
        return <a link="impl-shared.NoFault.0" file="shared_pseudocode.xml" hover="function: FaultRecord NoFault()">NoFault</a>();</pstext>
    </ps>
    <ps name="aarch32/translation/debug/AArch32.CheckWatchpoint" mylink="aarch32.translation.debug.AArch32.CheckWatchpoint" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.CheckWatchpoint()
// =========================
// Called before accessing the memory location of "size" bytes at "address",
// when either debug exceptions are enabled for the access, or halting debug
// is enabled and halting is allowed.

FaultRecord <anchor link="AArch32.CheckWatchpoint.4" hover="function: FaultRecord AArch32.CheckWatchpoint(bits(32) vaddress, AccType acctype,&#13; boolean iswrite, integer size)">AArch32.CheckWatchpoint</anchor>(bits(32) vaddress, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype,
                                    boolean iswrite, integer size)
    assert <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());

    if acctype IN {<a link="AccType_TTW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_TTW</a>, <a link="AccType_IC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>, <a link="AccType_AT" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</a>, <a link="AccType_ATPAN" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATPAN</a>} then
        return <a link="impl-shared.NoFault.0" file="shared_pseudocode.xml" hover="function: FaultRecord NoFault()">NoFault</a>();
    if acctype == <a link="AccType_DC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a> then
        if !iswrite then
            return <a link="impl-shared.NoFault.0" file="shared_pseudocode.xml" hover="function: FaultRecord NoFault()">NoFault</a>();
        elsif !(boolean IMPLEMENTATION_DEFINED "DCIMVAC generates watchpoint") then
            return <a link="impl-shared.NoFault.0" file="shared_pseudocode.xml" hover="function: FaultRecord NoFault()">NoFault</a>();

    match = FALSE;
    ispriv = <a link="AArch32.AccessUsesEL.1" file="shared_pseudocode.xml" hover="function: bits(2) AArch32.AccessUsesEL(AccType acctype)">AArch32.AccessUsesEL</a>(acctype) != <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>;

    for i = 0 to <a link="impl-shared.NumWatchpointsImplemented.0" file="shared_pseudocode.xml" hover="function: integer NumWatchpointsImplemented()">NumWatchpointsImplemented</a>() - 1
        if <a link="AArch32.WatchpointMatch.6" file="shared_pseudocode.xml" hover="function: boolean AArch32.WatchpointMatch(integer n, bits(32) vaddress, integer size, boolean ispriv,&#13; AccType acctype, boolean iswrite)">AArch32.WatchpointMatch</a>(i, vaddress, size, ispriv, acctype, iswrite) then
            match = TRUE;

    if match &amp;&amp; <a link="impl-shared.HaltOnBreakpointOrWatchpoint.0" file="shared_pseudocode.xml" hover="function: boolean HaltOnBreakpointOrWatchpoint()">HaltOnBreakpointOrWatchpoint</a>() then
        reason = <a link="DebugHalt_Watchpoint" file="shared_pseudocode.xml" hover="constant bits(6) DebugHalt_Watchpoint = '101011'">DebugHalt_Watchpoint</a>;
        EDWAR = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(vaddress);
        <a link="impl-shared.Halt.1" file="shared_pseudocode.xml" hover="function: Halt(bits(6) reason)">Halt</a>(reason);
    elsif match then
        debugmoe = <a link="DebugException_Watchpoint" file="shared_pseudocode.xml" hover="constant bits(4) DebugException_Watchpoint = '1010'">DebugException_Watchpoint</a>;
        return <a link="AArch32.DebugFault.3" file="shared_pseudocode.xml" hover="function: FaultRecord AArch32.DebugFault(AccType acctype, boolean iswrite, bits(4) debugmoe)">AArch32.DebugFault</a>(acctype, iswrite, debugmoe);
    else
        return <a link="impl-shared.NoFault.0" file="shared_pseudocode.xml" hover="function: FaultRecord NoFault()">NoFault</a>();</pstext>
    </ps>
    <ps name="aarch32/translation/faults/AArch32.DebugFault" mylink="aarch32.translation.faults.AArch32.DebugFault" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.DebugFault()
// ====================
// Return a fault record indicating a hardware watchpoint/breakpoint

FaultRecord <anchor link="AArch32.DebugFault.3" hover="function: FaultRecord AArch32.DebugFault(AccType acctype, boolean iswrite, bits(4) debugmoe)">AArch32.DebugFault</anchor>(<a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite, bits(4) debugmoe)
    <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault;

    fault.statuscode  = <a link="Fault_Debug" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Debug</a>;
    fault.acctype     = acctype;
    fault.write       = iswrite;
    fault.debugmoe    = debugmoe;
    fault.secondstage = FALSE;
    fault.s2fs1walk   = FALSE;

    return fault;</pstext>
    </ps>
    <ps name="aarch32/translation/faults/AArch32.IPAIsOutOfRange" mylink="aarch32.translation.faults.AArch32.IPAIsOutOfRange" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.IPAIsOutOfRange()
// =========================
// Check intermediate physical address bits not resolved by translation are ZERO

boolean <anchor link="AArch32.IPAIsOutOfRange.2" hover="function: boolean AArch32.IPAIsOutOfRange(S2TTWParams walkparams, bits(40) ipa)">AArch32.IPAIsOutOfRange</anchor>(<a link="S2TTWParams" file="shared_pseudocode.xml" hover="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams, bits(40) ipa)
    // Input Address size
    iasize = <a link="AArch32.S2IASize.1" file="shared_pseudocode.xml" hover="function: integer AArch32.S2IASize(bits(4) t0sz)">AArch32.S2IASize</a>(walkparams.t0sz);

    return iasize &lt; 40 &amp;&amp; !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(ipa&lt;39:iasize&gt;);</pstext>
    </ps>
    <ps name="aarch32/translation/faults/AArch32.S1HasAlignmentFault" mylink="aarch32.translation.faults.AArch32.S1HasAlignmentFault" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.S1HasAlignmentFault()
// =============================
// Returns whether stage 1 output fails alignment requirement on data accesses
// to Device memory

boolean <anchor link="AArch32.S1HasAlignmentFault.4" hover="function: boolean AArch32.S1HasAlignmentFault(AccType acctype, boolean aligned,&#13; bit ntlsmd, MemoryAttributes memattrs)">AArch32.S1HasAlignmentFault</anchor>(<a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned,
                                    bit ntlsmd, <a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs)
    if acctype == <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> || memattrs.memtype != <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
        return FALSE;

    if acctype == <a link="AccType_A32LSMD" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_A32LSMD</a> &amp;&amp; ntlsmd == '0' &amp;&amp; memattrs.device != <a link="DeviceType_GRE" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_GRE</a> then
        return TRUE;

    return !aligned || acctype == <a link="AccType_DCZVA" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DCZVA</a>;</pstext>
    </ps>
    <ps name="aarch32/translation/faults/AArch32.S1LDHasPermissionsFault" mylink="aarch32.translation.faults.AArch32.S1LDHasPermissionsFault" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.S1LDHasPermissionsFault()
// =================================
// Returns whether an access using stage 1 long-descriptor translation
// violates permissions of target memory

boolean <anchor link="AArch32.S1LDHasPermissionsFault.9" hover="function: boolean AArch32.S1LDHasPermissionsFault(Regime regime, SecurityState ss, S1TTWParams walkparams,&#13; Permissions perms, MemType memtype, PASpace paspace,&#13; boolean ispriv, AccType acctype, boolean iswrite)">AArch32.S1LDHasPermissionsFault</anchor>(<a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss, <a link="S1TTWParams" file="shared_pseudocode.xml" hover="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams,
                                        <a link="Permissions" file="shared_pseudocode.xml" hover="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(2) s2ap, bit s2xnx, bit s2xn )">Permissions</a> perms, <a link="MemType" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType</a> memtype, <a link="PASpace" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PASpace</a> paspace,
                                        boolean ispriv, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite)
    bit r;
    bit w;
    bit x;
    bit pr;
    bit pw;
    bit ur;
    bit uw;
    if <a link="impl-shared.HasUnprivileged.1" file="shared_pseudocode.xml" hover="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then
        // Apply leaf permissions
        case perms.ap&lt;2:1&gt; of
            when '00' (pr,pw,ur,uw) = ('1','1','0','0'); // R/W at PL1 only
            when '01' (pr,pw,ur,uw) = ('1','1','1','1'); // R/W at any PL
            when '10' (pr,pw,ur,uw) = ('1','0','0','0'); // RO at PL1 only
            when '11' (pr,pw,ur,uw) = ('1','0','1','0'); // RO at any PL

        // Apply hierarchical permissions
        case perms.ap_table of
            when '00' (pr,pw,ur,uw) = ( pr, pw, ur, uw); // No effect
            when '01' (pr,pw,ur,uw) = ( pr, pw,'0','0'); // Privileged access
            when '10' (pr,pw,ur,uw) = ( pr,'0', ur,'0'); // Read-only
            when '11' (pr,pw,ur,uw) = ( pr,'0','0','0'); // Read-only, privileged access

        xn   = perms.xn OR perms.xn_table;
        pxn  = perms.pxn OR perms.pxn_table;

        ux = ur AND NOT(xn OR (uw AND walkparams.wxn));
        px = pr AND NOT(xn OR pxn OR (pw AND walkparams.wxn) OR (uw AND walkparams.uwxn));

        pan_access = !(acctype IN {<a link="AccType_DC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>, <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a>, <a link="AccType_AT" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</a>});
        if <a link="impl-shared.HavePANExt.0" file="shared_pseudocode.xml" hover="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; pan_access then
            pan = PSTATE.PAN AND (ur OR uw);
            pr  = pr AND NOT(pan);
            pw  = pw AND NOT(pan);

        (r,w,x) = if ispriv then (pr,pw,px) else (ur,uw,ux);

        // Prevent execution from Non-secure space by PE in Secure state if SIF is set
        if ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp; paspace == <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a> then
            x = x AND NOT(walkparams.sif);
    else
        // Apply leaf permissions
        case perms.ap&lt;2&gt; of
            when '0' (r,w) = ('1','1'); // No effect
            when '1' (r,w) = ('1','0'); // Read-only

        // Apply hierarchical permissions
        case perms.ap_table&lt;1&gt; of
            when '0' (r,w) = ( r , w ); // No effect
            when '1' (r,w) = ( r ,'0'); // Read-only

        xn = perms.xn OR perms.xn_table;
        x  = NOT(xn OR (w AND walkparams.wxn));

    if acctype == <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> then
        constraint = <a link="impl-shared.ConstrainUnpredictable.1" file="shared_pseudocode.xml" hover="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a link="Unpredictable_INSTRDEVICE" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_INSTRDEVICE</a>);
        if constraint == <a link="Constraint_FAULT" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a> &amp;&amp; memtype == <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
            return TRUE;
        else
            return x == '0';
    elsif acctype IN {<a link="AccType_IC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>, <a link="AccType_DC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>} then
        return FALSE;
    elsif iswrite then
        return w == '0';
    else
        return r == '0';</pstext>
    </ps>
    <ps name="aarch32/translation/faults/AArch32.S1SDHasPermissionsFault" mylink="aarch32.translation.faults.AArch32.S1SDHasPermissionsFault" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.S1SDHasPermissionsFault()
// =================================
// Returns whether an access using stage 1 short-descriptor translation
// violates permissions of target memory

boolean <anchor link="AArch32.S1SDHasPermissionsFault.8" hover="function: boolean AArch32.S1SDHasPermissionsFault(Regime regime, SecurityState ss, Permissions perms_in,&#13; MemType memtype, PASpace paspace, boolean ispriv,&#13; AccType acctype, boolean iswrite)">AArch32.S1SDHasPermissionsFault</anchor>(<a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss, <a link="Permissions" file="shared_pseudocode.xml" hover="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(2) s2ap, bit s2xnx, bit s2xn )">Permissions</a> perms_in,
                                        <a link="MemType" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType</a> memtype, <a link="PASpace" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PASpace</a> paspace, boolean ispriv,
                                        <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite)
    <a link="Permissions" file="shared_pseudocode.xml" hover="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(2) s2ap, bit s2xnx, bit s2xn )">Permissions</a> perms = perms_in;
    bit pr;
    bit pw;
    bit ur;
    bit uw;
    SCTLR_Type sctlr;
    if regime == <a link="Regime_EL30" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> then
        sctlr = SCTLR_S;
    elsif <a link="impl-shared.HaveAArch32EL.1" file="shared_pseudocode.xml" hover="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
        sctlr = SCTLR_NS;
    else
        sctlr = SCTLR;

    if sctlr.AFE == '0' then
        // Map Reserved encoding '100'
        if perms.ap == '100' then
            perms.ap = bits(3) IMPLEMENTATION_DEFINED "Reserved short descriptor AP encoding";

        case perms.ap of
            when '000' (pr,pw,ur,uw) = ('0','0','0','0'); // No access
            when '001' (pr,pw,ur,uw) = ('1','1','0','0'); // R/W at PL1 only
            when '010' (pr,pw,ur,uw) = ('1','1','1','0'); // R/W at PL1, RO at PL0
            when '011' (pr,pw,ur,uw) = ('1','1','1','1'); // R/W at any PL
            //   '100' is reserved
            when '101' (pr,pw,ur,uw) = ('1','0','0','0'); // RO at PL1 only
            when '110' (pr,pw,ur,uw) = ('1','0','1','0'); // RO at any PL (deprecated)
            when '111' (pr,pw,ur,uw) = ('1','0','1','0'); // RO at any PL
    else // Simplified access permissions model
        case perms.ap&lt;2:1&gt; of
            when '00' (pr,pw,ur,uw) = ('1','1','0','0'); // R/W at PL1 only
            when '01' (pr,pw,ur,uw) = ('1','1','1','1'); // R/W at any PL
            when '10' (pr,pw,ur,uw) = ('1','0','0','0'); // RO at PL1 only
            when '11' (pr,pw,ur,uw) = ('1','0','1','0'); // RO at any PL

    ux = ur AND NOT(perms.xn OR (uw AND sctlr.WXN));
    px = pr AND NOT(perms.xn OR perms.pxn OR (pw AND sctlr.WXN) OR (uw AND sctlr.UWXN));

    pan_access = !(acctype IN {<a link="AccType_DC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>, <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a>, <a link="AccType_AT" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</a>});
    if <a link="impl-shared.HavePANExt.0" file="shared_pseudocode.xml" hover="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; pan_access then
        pan = PSTATE.PAN AND (ur OR uw);
        pr  = pr AND NOT(pan);
        pw  = pw AND NOT(pan);

    (r,w,x) = if ispriv then (pr,pw,px) else (ur,uw,ux);

    // Prevent execution from Non-secure space by PE in Secure state if SIF is set
    if ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp; paspace == <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a> then
        x = x AND NOT(if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then SCR.SIF else SCR_EL3.SIF);

    if acctype == <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> then
        constraint = <a link="impl-shared.ConstrainUnpredictable.1" file="shared_pseudocode.xml" hover="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a link="Unpredictable_INSTRDEVICE" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_INSTRDEVICE</a>);
        if constraint == <a link="Constraint_FAULT" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a> &amp;&amp; memtype == <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
            return TRUE;
        else
            return x == '0';
    elsif acctype IN {<a link="AccType_IC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>, <a link="AccType_DC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>} then
        return FALSE;
    elsif iswrite then
        return w == '0';
    else
        return r == '0';</pstext>
    </ps>
    <ps name="aarch32/translation/faults/AArch32.S2HasAlignmentFault" mylink="aarch32.translation.faults.AArch32.S2HasAlignmentFault" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.S2HasAlignmentFault()
// =============================
// Returns whether stage 2 output fails alignment requirement on data accesses
// to Device memory

boolean <anchor link="AArch32.S2HasAlignmentFault.3" hover="function: boolean AArch32.S2HasAlignmentFault(AccType acctype, boolean aligned,&#13; MemoryAttributes memattrs)">AArch32.S2HasAlignmentFault</anchor>(<a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned,
                                    <a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs)
    if acctype == <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> || memattrs.memtype != <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
        return FALSE;

    return !aligned || acctype == <a link="AccType_DCZVA" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DCZVA</a>;</pstext>
    </ps>
    <ps name="aarch32/translation/faults/AArch32.S2HasPermissionsFault" mylink="aarch32.translation.faults.AArch32.S2HasPermissionsFault" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.S2HasPermissionsFault()
// ===============================
// Returns whether stage 2 access violates permissions of target memory

boolean <anchor link="AArch32.S2HasPermissionsFault.7" hover="function: boolean AArch32.S2HasPermissionsFault(boolean s2fs1walk, S2TTWParams walkparams,&#13; Permissions perms, MemType memtype,&#13; boolean ispriv, AccType acctype,&#13; boolean iswrite)">AArch32.S2HasPermissionsFault</anchor>(boolean s2fs1walk, <a link="S2TTWParams" file="shared_pseudocode.xml" hover="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams,
                                      <a link="Permissions" file="shared_pseudocode.xml" hover="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(2) s2ap, bit s2xnx, bit s2xn )">Permissions</a> perms, <a link="MemType" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType</a> memtype,
                                      boolean ispriv, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype,
                                      boolean iswrite)
    bit px;
    bit ux;
    r = perms.s2ap&lt;0&gt;;
    w = perms.s2ap&lt;1&gt;;
    bit x;
    if <a link="impl-shared.HaveExtendedExecuteNeverExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveExtendedExecuteNeverExt()">HaveExtendedExecuteNeverExt</a>() then
        case perms.s2xn:perms.s2xnx of
            when '00'  (px, ux) = ( r , r );
            when '01'  (px, ux) = ('0', r );
            when '10'  (px, ux) = ('0','0');
            when '11'  (px, ux) = ( r ,'0');

        x = if ispriv then px else ux;
    else
        x = r AND NOT(perms.s2xn);

    if s2fs1walk &amp;&amp; walkparams.ptw == '1' &amp;&amp; memtype == <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
        return TRUE;
    elsif acctype == <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> then
        constraint = <a link="impl-shared.ConstrainUnpredictable.1" file="shared_pseudocode.xml" hover="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a link="Unpredictable_INSTRDEVICE" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_INSTRDEVICE</a>);
        if constraint == <a link="Constraint_FAULT" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a> &amp;&amp; memtype == <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
            return TRUE;
        else
            return x == '0';
    elsif acctype IN {<a link="AccType_IC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>, <a link="AccType_DC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>} then
        return FALSE;
    elsif iswrite then
        return w == '0';
    else
        return r == '0';</pstext>
    </ps>
    <ps name="aarch32/translation/faults/AArch32.S2InconsistentSL" mylink="aarch32.translation.faults.AArch32.S2InconsistentSL" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.S2InconsistentSL()
// ==========================
// Detect inconsistent configuration of stage 2 T0SZ and SL fields

boolean <anchor link="AArch32.S2InconsistentSL.1" hover="function: boolean AArch32.S2InconsistentSL(S2TTWParams walkparams)">AArch32.S2InconsistentSL</anchor>(<a link="S2TTWParams" file="shared_pseudocode.xml" hover="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams)
    startlevel  = <a link="AArch32.S2StartLevel.1" file="shared_pseudocode.xml" hover="function: integer AArch32.S2StartLevel(bits(2) sl0)">AArch32.S2StartLevel</a>(walkparams.sl0);
    levels      = <a link="FINAL_LEVEL" file="shared_pseudocode.xml" hover="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - startlevel;
    granulebits = <a link="impl-shared.TGxGranuleBits.1" file="shared_pseudocode.xml" hover="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(walkparams.tgx);
    stride      = granulebits - 3;

    // Input address size must at least be large enough to be resolved from the start level
    sl_min_iasize = (
        levels * stride // Bits resolved by table walk, except initial level
        + granulebits   // Bits directly mapped to output address
        + 1);           // At least 1 more bit to be decoded by initial level

    // Can accomodate 1 more stride in the level + concatenation of up to 2^4 tables
    sl_max_iasize = sl_min_iasize + (stride-1) + 4;
    // Configured Input Address size
    iasize        = <a link="AArch32.S2IASize.1" file="shared_pseudocode.xml" hover="function: integer AArch32.S2IASize(bits(4) t0sz)">AArch32.S2IASize</a>(walkparams.t0sz);

    return iasize &lt; sl_min_iasize || iasize &gt; sl_max_iasize;</pstext>
    </ps>
    <ps name="aarch32/translation/faults/AArch32.VAIsOutOfRange" mylink="aarch32.translation.faults.AArch32.VAIsOutOfRange" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.VAIsOutOfRange()
// ========================
// Check virtual address bits not resolved by translation are identical
// and of accepted value

boolean <anchor link="AArch32.VAIsOutOfRange.3" hover="function: boolean AArch32.VAIsOutOfRange(Regime regime, S1TTWParams walkparams, bits(32) va)">AArch32.VAIsOutOfRange</anchor>(<a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a link="S1TTWParams" file="shared_pseudocode.xml" hover="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams, bits(32) va)
    if regime == <a link="Regime_EL2" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a> then
        // Input Address size
        iasize = <a link="AArch32.S1IASize.1" file="shared_pseudocode.xml" hover="function: integer AArch32.S1IASize(bits(3) txsz)">AArch32.S1IASize</a>(walkparams.t0sz);
        return walkparams.t0sz != '000' &amp;&amp; !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(va&lt;31:iasize&gt;);
    elsif walkparams.t1sz != '000' &amp;&amp; walkparams.t0sz != '000' then
        // Lower range Input Address size
        lo_iasize = <a link="AArch32.S1IASize.1" file="shared_pseudocode.xml" hover="function: integer AArch32.S1IASize(bits(3) txsz)">AArch32.S1IASize</a>(walkparams.t0sz);
        // Upper range Input Address size
        up_iasize = <a link="AArch32.S1IASize.1" file="shared_pseudocode.xml" hover="function: integer AArch32.S1IASize(bits(3) txsz)">AArch32.S1IASize</a>(walkparams.t1sz);
        return !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(va&lt;31:lo_iasize&gt;) &amp;&amp; !<a link="impl-shared.IsOnes.1" file="shared_pseudocode.xml" hover="function: boolean IsOnes(bits(N) x)">IsOnes</a>(va&lt;31:up_iasize&gt;);
    else
        return FALSE;</pstext>
    </ps>
    <ps name="aarch32/translation/tlbcontext/AArch32.GetS1TLBContext" mylink="aarch32.translation.tlbcontext.AArch32.GetS1TLBContext" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.GetS1TLBContext()
// =========================
// Gather translation context for accesses with VA to match against TLB entries

TLBContext <anchor link="AArch32.GetS1TLBContext.3" hover="function: TLBContext AArch32.GetS1TLBContext(Regime regime, SecurityState ss, bits(32) va)">AArch32.GetS1TLBContext</anchor>(<a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(32) va)
    <a link="TLBContext" file="shared_pseudocode.xml" hover="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, bits(64) ia, TGx tg, bit cnp, bit xs )">TLBContext</a> tlbcontext;

    case regime of
        when <a link="Regime_EL2" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  tlbcontext = <a link="AArch32.TLBContextEL2.1" file="shared_pseudocode.xml" hover="function: TLBContext AArch32.TLBContextEL2(bits(32) va)">AArch32.TLBContextEL2</a>(va);
        when <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> tlbcontext = <a link="AArch32.TLBContextEL10.2" file="shared_pseudocode.xml" hover="function: TLBContext AArch32.TLBContextEL10(SecurityState ss, bits(32) va)">AArch32.TLBContextEL10</a>(ss, va);
        when <a link="Regime_EL30" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> tlbcontext = <a link="AArch32.TLBContextEL30.1" file="shared_pseudocode.xml" hover="function: TLBContext AArch32.TLBContextEL30(bits(32) va)">AArch32.TLBContextEL30</a>(va);

    tlbcontext.includes_s1 = TRUE;
    // The following may be amended for EL1&amp;0 Regime if caching of stage 2 is successful
    tlbcontext.includes_s2 = FALSE;
    return tlbcontext;</pstext>
    </ps>
    <ps name="aarch32/translation/tlbcontext/AArch32.GetS2TLBContext" mylink="aarch32.translation.tlbcontext.AArch32.GetS2TLBContext" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.GetS2TLBContext()
// =========================
// Gather translation context for accesses with IPA to match against TLB entries

TLBContext <anchor link="AArch32.GetS2TLBContext.1" hover="function: TLBContext AArch32.GetS2TLBContext(FullAddress ipa)">AArch32.GetS2TLBContext</anchor>(<a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> ipa)
    assert ipa.paspace == <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a>;

    <a link="TLBContext" file="shared_pseudocode.xml" hover="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, bits(64) ia, TGx tg, bit cnp, bit xs )">TLBContext</a> tlbcontext;

    tlbcontext.ss          = <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a>;
    tlbcontext.regime      = <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>;
    tlbcontext.ipaspace    = ipa.paspace;
    tlbcontext.vmid        = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(VTTBR.VMID);
    tlbcontext.tg          = <a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
    tlbcontext.includes_s1 = FALSE;
    tlbcontext.includes_s2 = TRUE;
    tlbcontext.ia          = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(ipa.address);
    tlbcontext.cnp         = if <a link="impl-shared.HaveCommonNotPrivateTransExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveCommonNotPrivateTransExt()">HaveCommonNotPrivateTransExt</a>() then VTTBR.CnP else '0';

    return tlbcontext;</pstext>
    </ps>
    <ps name="aarch32/translation/tlbcontext/AArch32.TLBContextEL10" mylink="aarch32.translation.tlbcontext.AArch32.TLBContextEL10" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.TLBContextEL10()
// ========================
// Gather translation context for accesses under EL10 regime
// (PL10 when EL3 is A64) to match against TLB entries

TLBContext <anchor link="AArch32.TLBContextEL10.2" hover="function: TLBContext AArch32.TLBContextEL10(SecurityState ss, bits(32) va)">AArch32.TLBContextEL10</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(32) va)
    <a link="TLBContext" file="shared_pseudocode.xml" hover="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, bits(64) ia, TGx tg, bit cnp, bit xs )">TLBContext</a> tlbcontext;
    TTBCR_Type ttbcr;
    TTBR0_Type ttbr0;
    TTBR1_Type ttbr1;

    if <a link="impl-shared.HaveAArch32EL.1" file="shared_pseudocode.xml" hover="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
        ttbcr      = TTBCR_NS;
        ttbr0      = TTBR0_NS;
        ttbr1      = TTBR1_NS;
        contextidr = CONTEXTIDR_NS;
    else
        ttbcr      = TTBCR;
        ttbr0      = TTBR0;
        ttbr1      = TTBR1;
        contextidr = CONTEXTIDR;

    tlbcontext.ss     = ss;
    tlbcontext.regime = <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>;

    if <a link="AArch32.EL2Enabled.1" file="shared_pseudocode.xml" hover="function: boolean AArch32.EL2Enabled(SecurityState ss)">AArch32.EL2Enabled</a>(ss) then
        tlbcontext.vmid = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(VTTBR.VMID);

    if ttbcr.EAE == '1' then
        tlbcontext.asid = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(if ttbcr.A1 == '0' then ttbr0.ASID else ttbr1.ASID);
    else
        tlbcontext.asid = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(contextidr.ASID);

    tlbcontext.tg = <a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
    tlbcontext.ia = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va);

    if <a link="impl-shared.HaveCommonNotPrivateTransExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveCommonNotPrivateTransExt()">HaveCommonNotPrivateTransExt</a>() &amp;&amp; ttbcr.EAE == '1' then
        if <a link="AArch32.GetVARange.3" file="shared_pseudocode.xml" hover="function: VARange AArch32.GetVARange(bits(32) va, bits(3) t0sz, bits(3) t1sz)">AArch32.GetVARange</a>(va, ttbcr.T0SZ, ttbcr.T1SZ) == <a link="VARange_LOWER" file="shared_pseudocode.xml" hover="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
            tlbcontext.cnp = ttbr0.CnP;
        else
            tlbcontext.cnp = ttbr1.CnP;
    else
        tlbcontext.cnp = '0';

    return tlbcontext;</pstext>
    </ps>
    <ps name="aarch32/translation/tlbcontext/AArch32.TLBContextEL2" mylink="aarch32.translation.tlbcontext.AArch32.TLBContextEL2" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.TLBContextEL2()
// =======================
// Gather translation context for accesses under EL2 regime to match against TLB entries

TLBContext <anchor link="AArch32.TLBContextEL2.1" hover="function: TLBContext AArch32.TLBContextEL2(bits(32) va)">AArch32.TLBContextEL2</anchor>(bits(32) va)
    <a link="TLBContext" file="shared_pseudocode.xml" hover="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, bits(64) ia, TGx tg, bit cnp, bit xs )">TLBContext</a> tlbcontext;

    tlbcontext.ss     = <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a>;
    tlbcontext.regime = <a link="Regime_EL2" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>;
    tlbcontext.ia     = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va);
    tlbcontext.tg     = <a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
    tlbcontext.cnp    = if <a link="impl-shared.HaveCommonNotPrivateTransExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveCommonNotPrivateTransExt()">HaveCommonNotPrivateTransExt</a>() then HTTBR.CnP else '0';

    return tlbcontext;</pstext>
    </ps>
    <ps name="aarch32/translation/tlbcontext/AArch32.TLBContextEL30" mylink="aarch32.translation.tlbcontext.AArch32.TLBContextEL30" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.TLBContextEL30()
// ========================
// Gather translation context for accesses under EL30 regime
// (PL10 in Secure state and EL3 is A32) to match against TLB entries

TLBContext <anchor link="AArch32.TLBContextEL30.1" hover="function: TLBContext AArch32.TLBContextEL30(bits(32) va)">AArch32.TLBContextEL30</anchor>(bits(32) va)
    <a link="TLBContext" file="shared_pseudocode.xml" hover="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, bits(64) ia, TGx tg, bit cnp, bit xs )">TLBContext</a> tlbcontext;

    tlbcontext.ss     = <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>;
    tlbcontext.regime = <a link="Regime_EL30" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a>;

    if TTBCR_S.EAE == '1' then
        tlbcontext.asid = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(if TTBCR_S.A1 == '0' then TTBR0_S.ASID else TTBR1_S.ASID);
    else
        tlbcontext.asid = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(CONTEXTIDR_S.ASID);

    tlbcontext.tg = <a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
    tlbcontext.ia = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va);

    if <a link="impl-shared.HaveCommonNotPrivateTransExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveCommonNotPrivateTransExt()">HaveCommonNotPrivateTransExt</a>() &amp;&amp; TTBCR_S.EAE == '1' then
        if <a link="AArch32.GetVARange.3" file="shared_pseudocode.xml" hover="function: VARange AArch32.GetVARange(bits(32) va, bits(3) t0sz, bits(3) t1sz)">AArch32.GetVARange</a>(va, TTBCR_S.T0SZ, TTBCR_S.T1SZ) == <a link="VARange_LOWER" file="shared_pseudocode.xml" hover="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
            tlbcontext.cnp = TTBR0_S.CnP;
        else
            tlbcontext.cnp = TTBR1_S.CnP;
    else
        tlbcontext.cnp = '0';

    return tlbcontext;</pstext>
    </ps>
    <ps name="aarch32/translation/translation/AArch32.AccessUsesEL" mylink="aarch32.translation.translation.AArch32.AccessUsesEL" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.AccessUsesEL()
// ======================
// Determine the privilege associated with the access

bits(2) <anchor link="AArch32.AccessUsesEL.1" hover="function: bits(2) AArch32.AccessUsesEL(AccType acctype)">AArch32.AccessUsesEL</anchor>(<a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype)
    if acctype == <a link="AccType_UNPRIV" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_UNPRIV</a> then
        return <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>;
    else
        return PSTATE.EL;</pstext>
    </ps>
    <ps name="aarch32/translation/translation/AArch32.EL2Enabled" mylink="aarch32.translation.translation.AArch32.EL2Enabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.EL2Enabled()
// ====================
// Returns whether EL2 is enabled for the given Security State

boolean <anchor link="AArch32.EL2Enabled.1" hover="function: boolean AArch32.EL2Enabled(SecurityState ss)">AArch32.EL2Enabled</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss)
    if ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> then
        if !(<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; <a link="impl-shared.HaveSecureEL2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>()) then
            return FALSE;
        elsif <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
            return SCR_EL3.EEL2 == '1';
        else
            return boolean IMPLEMENTATION_DEFINED "Secure-only implementation";
    else
        return <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>);</pstext>
    </ps>
    <ps name="aarch32/translation/translation/AArch32.FullTranslate" mylink="aarch32.translation.translation.AArch32.FullTranslate" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.FullTranslate()
// =======================
// Perform address translation as specified by VMSA-A32

AddressDescriptor <anchor link="AArch32.FullTranslate.4" hover="function: AddressDescriptor AArch32.FullTranslate(bits(32) va, AccType acctype,&#13; boolean iswrite, boolean aligned)">AArch32.FullTranslate</anchor>(bits(32) va, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype,
                                        boolean iswrite, boolean aligned)

    // Prepare fault fields in case a fault is detected
    fault = <a link="impl-shared.NoFault.0" file="shared_pseudocode.xml" hover="function: FaultRecord NoFault()">NoFault</a>();
    fault.acctype = acctype;
    fault.write   = iswrite;

    regime = <a link="impl-shared.TranslationRegime.2" file="shared_pseudocode.xml" hover="function: Regime TranslationRegime(bits(2) el, AccType acctype)">TranslationRegime</a>(PSTATE.EL, acctype);
    ispriv = PSTATE.EL != <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; acctype != <a link="AccType_UNPRIV" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_UNPRIV</a>;
    ss = <a link="impl-shared.SecurityStateForRegime.1" file="shared_pseudocode.xml" hover="function: SecurityState SecurityStateForRegime(Regime regime)">SecurityStateForRegime</a>(regime);

    // First Stage Translation
    <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> ipa;
    if regime == <a link="Regime_EL2" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a> || TTBCR.EAE == '1' then
        (fault, ipa) = <a link="AArch32.S1TranslateLD.8" file="shared_pseudocode.xml" hover="function: (FaultRecord, AddressDescriptor) AArch32.S1TranslateLD(FaultRecord fault_in, Regime regime,&#13; SecurityState ss, bits(32) va,&#13; AccType acctype, boolean aligned,&#13; boolean iswrite, boolean ispriv)">AArch32.S1TranslateLD</a>(fault, regime, ss, va, acctype,
                                             aligned, iswrite, ispriv);
    else
        (fault, ipa, -) = <a link="AArch32.S1TranslateSD.8" file="shared_pseudocode.xml" hover="function: (FaultRecord, AddressDescriptor, SDFType) AArch32.S1TranslateSD(FaultRecord fault_in, Regime regime,&#13; SecurityState ss, bits(32) va,&#13; AccType acctype, boolean aligned,&#13; boolean iswrite, boolean ispriv)">AArch32.S1TranslateSD</a>(fault, regime, ss, va, acctype,
                                                aligned, iswrite, ispriv);

    if fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return <a link="impl-shared.CreateFaultyAddressDescriptor.2" file="shared_pseudocode.xml" hover="function: AddressDescriptor CreateFaultyAddressDescriptor(bits(64) va, FaultRecord fault)">CreateFaultyAddressDescriptor</a>(<a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va), fault);

    if regime == <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() then
        ipa.vaddress = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va);
        s2fs1walk = FALSE;
        <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> pa;
        (fault, pa) = <a link="AArch32.S2Translate.8" file="shared_pseudocode.xml" hover="function: (FaultRecord, AddressDescriptor) AArch32.S2Translate(FaultRecord fault_in, AddressDescriptor ipa,&#13; SecurityState ss, boolean s2fs1walk,&#13; AccType acctype, boolean aligned,&#13; boolean iswrite, boolean ispriv)">AArch32.S2Translate</a>(fault, ipa, ss, s2fs1walk, acctype,
                                          aligned, iswrite, ispriv);

        if fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
            return <a link="impl-shared.CreateFaultyAddressDescriptor.2" file="shared_pseudocode.xml" hover="function: AddressDescriptor CreateFaultyAddressDescriptor(bits(64) va, FaultRecord fault)">CreateFaultyAddressDescriptor</a>(<a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va), fault);
        else
            return pa;
    else
        return ipa;</pstext>
    </ps>
    <ps name="aarch32/translation/translation/AArch32.OutputDomain" mylink="aarch32.translation.translation.AArch32.OutputDomain" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.OutputDomain()
// ======================
// Determine the domain the translated output address

bits(2) <anchor link="AArch32.OutputDomain.2" hover="function: bits(2) AArch32.OutputDomain(Regime regime, bits(4) domain)">AArch32.OutputDomain</anchor>(<a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(4) domain)
    bits(2) Dn;
    index = 2 * <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(domain);
    if regime == <a link="Regime_EL30" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> then
        Dn = DACR_S&lt;index+1:index&gt;;
    elsif <a link="impl-shared.HaveAArch32EL.1" file="shared_pseudocode.xml" hover="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
        Dn = DACR_NS&lt;index+1:index&gt;;
    else
        Dn = DACR&lt;index+1:index&gt;;

    if Dn == '10' then
        // Reserved value maps to an allocated value
        (-, Dn) = <a link="impl-shared.ConstrainUnpredictableBits.1" file="shared_pseudocode.xml" hover="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a link="Unpredictable_RESDACR" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESDACR</a>);

    return Dn;</pstext>
    </ps>
    <ps name="aarch32/translation/translation/AArch32.S1DisabledOutput" mylink="aarch32.translation.translation.AArch32.S1DisabledOutput" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.S1DisabledOutput()
// ==========================
// Flat map the VA to IPA/PA, depending on the regime, assigning default memory attributes

(FaultRecord, AddressDescriptor) <anchor link="AArch32.S1DisabledOutput.6" hover="function: (FaultRecord, AddressDescriptor) AArch32.S1DisabledOutput(FaultRecord fault_in, Regime regime,&#13; SecurityState ss, bits(32) va,&#13; AccType acctype, boolean aligned)">AArch32.S1DisabledOutput</anchor>(<a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault_in, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime,
                                                          <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(32) va,
                                                          <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned)

    <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault = fault_in;
    // No memory page is guarded when stage 1 address translation is disabled
    SetInGuardedPage(FALSE);

    <a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs;
    bit default_cacheable;
    if regime == <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a link="AArch32.EL2Enabled.1" file="shared_pseudocode.xml" hover="function: boolean AArch32.EL2Enabled(SecurityState ss)">AArch32.EL2Enabled</a>(ss) then
        if <a link="impl-shared.ELStateUsingAArch32.2" file="shared_pseudocode.xml" hover="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)">ELStateUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>) then
            default_cacheable = HCR.DC;
        else
            default_cacheable = HCR_EL2.DC;
    else
        default_cacheable = '0';

    if default_cacheable == '1' then
        // Use default cacheable settings
        memattrs.memtype      = <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
        memattrs.inner.attrs  = <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
        memattrs.inner.hints  = <a link="MemHint_RWA" file="shared_pseudocode.xml" hover="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
        memattrs.outer.attrs  = <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
        memattrs.outer.hints  = <a link="MemHint_RWA" file="shared_pseudocode.xml" hover="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
        memattrs.shareability = <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        if !<a link="impl-shared.ELStateUsingAArch32.2" file="shared_pseudocode.xml" hover="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)">ELStateUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>) &amp;&amp; <a link="impl-shared.HaveMTE2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() then
            memattrs.tagged = HCR_EL2.DCT == '1';
        else
            memattrs.tagged = FALSE;
    elsif acctype == <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> then
        memattrs.memtype      = <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
        memattrs.shareability = <a link="Shareability_OSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        memattrs.tagged       = FALSE;
        if <a link="AArch32.S1ICacheEnabled.1" file="shared_pseudocode.xml" hover="function: boolean AArch32.S1ICacheEnabled(Regime regime)">AArch32.S1ICacheEnabled</a>(regime) then
            memattrs.inner.attrs = <a link="MemAttr_WT" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
            memattrs.inner.hints = <a link="MemHint_RA" file="shared_pseudocode.xml" hover="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
            memattrs.outer.attrs = <a link="MemAttr_WT" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
            memattrs.outer.hints = <a link="MemHint_RA" file="shared_pseudocode.xml" hover="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
        else
            memattrs.inner.attrs = <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;
            memattrs.outer.attrs = <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;
    else
        // Treat memory region as Device
        memattrs.memtype      = <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
        memattrs.device       = <a link="DeviceType_nGnRnE" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a>;
        memattrs.shareability = <a link="Shareability_OSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        memattrs.tagged       = FALSE;

    bit ntlsmd;
    if <a link="impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveTrapLoadStoreMultipleDeviceExt()">HaveTrapLoadStoreMultipleDeviceExt</a>() then
        case regime of
            when <a link="Regime_EL30" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> ntlsmd = SCTLR_S.nTLSMD;
            when <a link="Regime_EL2" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  ntlsmd = HSCTLR.nTLSMD;
            when <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> ntlsmd = if <a link="impl-shared.HaveAArch32EL.1" file="shared_pseudocode.xml" hover="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then SCTLR_NS.nTLSMD else SCTLR.nTLSMD;
    else
        ntlsmd = '1';

    if <a link="AArch32.S1HasAlignmentFault.4" file="shared_pseudocode.xml" hover="function: boolean AArch32.S1HasAlignmentFault(AccType acctype, boolean aligned,&#13; bit ntlsmd, MemoryAttributes memattrs)">AArch32.S1HasAlignmentFault</a>(acctype, aligned, ntlsmd, memattrs) then
        fault.statuscode  = <a link="Fault_Alignment" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>;
        return (fault, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> oa;
    oa.address = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va);
    oa.paspace = if ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> then <a link="PAS_Secure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_Secure</a> else <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a>;
    ipa = <a link="impl-shared.CreateAddressDescriptor.3" file="shared_pseudocode.xml" hover="function: AddressDescriptor CreateAddressDescriptor(bits(64) va, FullAddress pa,&#13; MemoryAttributes memattrs)">CreateAddressDescriptor</a>(<a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va), oa, memattrs);

    return (fault, ipa);</pstext>
    </ps>
    <ps name="aarch32/translation/translation/AArch32.S1Enabled" mylink="aarch32.translation.translation.AArch32.S1Enabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.S1Enabled()
// ===================
// Returns whether stage 1 translation is enabled for the active translation regime

boolean <anchor link="AArch32.S1Enabled.2" hover="function: boolean AArch32.S1Enabled(Regime regime, SecurityState ss)">AArch32.S1Enabled</anchor>(<a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss)
    if regime == <a link="Regime_EL2" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a> then
        return HSCTLR.M == '1';
    elsif regime == <a link="Regime_EL30" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> then
        return SCTLR_S.M == '1';
    elsif !<a link="AArch32.EL2Enabled.1" file="shared_pseudocode.xml" hover="function: boolean AArch32.EL2Enabled(SecurityState ss)">AArch32.EL2Enabled</a>(ss) then
        return (if <a link="impl-shared.HaveAArch32EL.1" file="shared_pseudocode.xml" hover="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then SCTLR_NS.M else SCTLR.M) == '1';
    elsif <a link="impl-shared.ELStateUsingAArch32.2" file="shared_pseudocode.xml" hover="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)">ELStateUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>) then
        return HCR.&lt;TGE,DC&gt; == '00' &amp;&amp; (if <a link="impl-shared.HaveAArch32EL.1" file="shared_pseudocode.xml" hover="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then SCTLR_NS.M else SCTLR.M) == '1';
    else
        return HCR_EL2.&lt;TGE,DC&gt; == '00' &amp;&amp; SCTLR.M == '1';</pstext>
    </ps>
    <ps name="aarch32/translation/translation/AArch32.S1TranslateLD" mylink="aarch32.translation.translation.AArch32.S1TranslateLD" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.S1TranslateLD()
// =======================
// Perform a stage 1 translation using long-descriptor format mapping VA to IPA/PA
// depending on the regime

(FaultRecord, AddressDescriptor) <anchor link="AArch32.S1TranslateLD.8" hover="function: (FaultRecord, AddressDescriptor) AArch32.S1TranslateLD(FaultRecord fault_in, Regime regime,&#13; SecurityState ss, bits(32) va,&#13; AccType acctype, boolean aligned,&#13; boolean iswrite, boolean ispriv)">AArch32.S1TranslateLD</anchor>(<a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault_in, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime,
                                                       <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(32) va,
                                                       <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned,
                                                       boolean iswrite, boolean ispriv)
    <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault = fault_in;
    fault.secondstage = FALSE;
    fault.s2fs1walk   = FALSE;

    if !<a link="AArch32.S1Enabled.2" file="shared_pseudocode.xml" hover="function: boolean AArch32.S1Enabled(Regime regime, SecurityState ss)">AArch32.S1Enabled</a>(regime, ss) then
        return <a link="AArch32.S1DisabledOutput.6" file="shared_pseudocode.xml" hover="function: (FaultRecord, AddressDescriptor) AArch32.S1DisabledOutput(FaultRecord fault_in, Regime regime,&#13; SecurityState ss, bits(32) va,&#13; AccType acctype, boolean aligned)">AArch32.S1DisabledOutput</a>(fault, regime, ss, va, acctype, aligned);

    walkparams = <a link="AArch32.GetS1TTWParams.2" file="shared_pseudocode.xml" hover="function: S1TTWParams AArch32.GetS1TTWParams(Regime regime, bits(32) va)">AArch32.GetS1TTWParams</a>(regime, va);

    if <a link="AArch32.VAIsOutOfRange.3" file="shared_pseudocode.xml" hover="function: boolean AArch32.VAIsOutOfRange(Regime regime, S1TTWParams walkparams, bits(32) va)">AArch32.VAIsOutOfRange</a>(regime, walkparams, va) then
        fault.level      = 1;
        fault.statuscode = <a link="Fault_Translation" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        return (fault, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate;
    (fault, walkstate) = <a link="AArch32.S1WalkLD.6" file="shared_pseudocode.xml" hover="function: (FaultRecord, TTWState) AArch32.S1WalkLD(FaultRecord fault_in, Regime regime, SecurityState ss,&#13; S1TTWParams walkparams, bits(32) va, boolean ispriv)">AArch32.S1WalkLD</a>(fault, regime, ss, walkparams, va, ispriv);

    if fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return (fault, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    SetInGuardedPage(FALSE);  // AArch32-VMSA does not guard any pages

    if <a link="AArch32.S1HasAlignmentFault.4" file="shared_pseudocode.xml" hover="function: boolean AArch32.S1HasAlignmentFault(AccType acctype, boolean aligned,&#13; bit ntlsmd, MemoryAttributes memattrs)">AArch32.S1HasAlignmentFault</a>(acctype, aligned, walkparams.ntlsmd, walkstate.memattrs) then
        fault.statuscode = <a link="Fault_Alignment" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>;
    elsif <a link="impl-shared.IsAtomicRW.1" file="shared_pseudocode.xml" hover="function: boolean IsAtomicRW(AccType acctype)">IsAtomicRW</a>(acctype) then
        if <a link="AArch32.S1LDHasPermissionsFault.9" file="shared_pseudocode.xml" hover="function: boolean AArch32.S1LDHasPermissionsFault(Regime regime, SecurityState ss, S1TTWParams walkparams,&#13; Permissions perms, MemType memtype, PASpace paspace,&#13; boolean ispriv, AccType acctype, boolean iswrite)">AArch32.S1LDHasPermissionsFault</a>(regime, ss, walkparams,
                                           walkstate.permissions,
                                           walkstate.memattrs.memtype,
                                           walkstate.baseaddress.paspace,
                                           ispriv, acctype, FALSE) then
            // The permission fault was not caused by lack of write permissions
            fault.statuscode = <a link="Fault_Permission" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
            fault.write      = FALSE;
        elsif <a link="AArch32.S1LDHasPermissionsFault.9" file="shared_pseudocode.xml" hover="function: boolean AArch32.S1LDHasPermissionsFault(Regime regime, SecurityState ss, S1TTWParams walkparams,&#13; Permissions perms, MemType memtype, PASpace paspace,&#13; boolean ispriv, AccType acctype, boolean iswrite)">AArch32.S1LDHasPermissionsFault</a>(regime, ss, walkparams,
                                              walkstate.permissions,
                                              walkstate.memattrs.memtype,
                                              walkstate.baseaddress.paspace,
                                              ispriv, acctype, TRUE) then
            // The permission fault _was_ caused by lack of write permissions
            fault.statuscode = <a link="Fault_Permission" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
            fault.write      = TRUE;
    elsif <a link="AArch32.S1LDHasPermissionsFault.9" file="shared_pseudocode.xml" hover="function: boolean AArch32.S1LDHasPermissionsFault(Regime regime, SecurityState ss, S1TTWParams walkparams,&#13; Permissions perms, MemType memtype, PASpace paspace,&#13; boolean ispriv, AccType acctype, boolean iswrite)">AArch32.S1LDHasPermissionsFault</a>(regime, ss, walkparams,
                                          walkstate.permissions,
                                          walkstate.memattrs.memtype,
                                          walkstate.baseaddress.paspace,
                                          ispriv, acctype, iswrite) then
        fault.statuscode = <a link="Fault_Permission" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;

    if fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return (fault, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    <a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs;
    if ((acctype == <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> &amp;&amp;
            (walkstate.memattrs.memtype == <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> || !<a link="AArch32.S1ICacheEnabled.1" file="shared_pseudocode.xml" hover="function: boolean AArch32.S1ICacheEnabled(Regime regime)">AArch32.S1ICacheEnabled</a>(regime))) ||
        (acctype != <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> &amp;&amp;
             walkstate.memattrs.memtype == <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> &amp;&amp; !<a link="AArch32.S1DCacheEnabled.1" file="shared_pseudocode.xml" hover="function: boolean AArch32.S1DCacheEnabled(Regime regime)">AArch32.S1DCacheEnabled</a>(regime))) then
        // Treat memory attributes as Normal Non-Cacheable
        memattrs = <a link="impl-shared.NormalNCMemAttr.0" file="shared_pseudocode.xml" hover="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
        memattrs.xs = walkstate.memattrs.xs;
    else
        memattrs = walkstate.memattrs;

    // Shareability value of stage 1 translation subject to stage 2 is IMPLEMENTATION DEFINED
    // to be either effective value or descriptor value
    if (regime == <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a link="AArch32.EL2Enabled.1" file="shared_pseudocode.xml" hover="function: boolean AArch32.EL2Enabled(SecurityState ss)">AArch32.EL2Enabled</a>(ss) &amp;&amp;
            (if <a link="impl-shared.ELStateUsingAArch32.2" file="shared_pseudocode.xml" hover="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)">ELStateUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>) then HCR.VM else HCR_EL2.VM) == '1' &amp;&amp;
            !(boolean IMPLEMENTATION_DEFINED "Apply effective shareability at stage 1")) then
        memattrs.shareability = walkstate.memattrs.shareability;
    else
        memattrs.shareability = <a link="impl-shared.EffectiveShareability.1" file="shared_pseudocode.xml" hover="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(memattrs);

    // Output Address
    oa = <a link="impl-shared.StageOA.3" file="shared_pseudocode.xml" hover="function: FullAddress StageOA(bits(64) ia, TGx tgx, TTWState walkstate)">StageOA</a>(<a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va), walkparams.tgx, walkstate);
    ipa = <a link="impl-shared.CreateAddressDescriptor.3" file="shared_pseudocode.xml" hover="function: AddressDescriptor CreateAddressDescriptor(bits(64) va, FullAddress pa,&#13; MemoryAttributes memattrs)">CreateAddressDescriptor</a>(<a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va), oa, memattrs);

    return (fault, ipa);</pstext>
    </ps>
    <ps name="aarch32/translation/translation/AArch32.S1TranslateSD" mylink="aarch32.translation.translation.AArch32.S1TranslateSD" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.S1TranslateSD()
// =======================
// Perform a stage 1 translation using short-descriptor format mapping VA to IPA/PA
// depending on the regime

(FaultRecord, AddressDescriptor, SDFType) <anchor link="AArch32.S1TranslateSD.8" hover="function: (FaultRecord, AddressDescriptor, SDFType) AArch32.S1TranslateSD(FaultRecord fault_in, Regime regime,&#13; SecurityState ss, bits(32) va,&#13; AccType acctype, boolean aligned,&#13; boolean iswrite, boolean ispriv)">AArch32.S1TranslateSD</anchor>(<a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault_in, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime,
                                                                <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(32) va,
                                                                <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned,
                                                                boolean iswrite, boolean ispriv)

    <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault = fault_in;
    fault.secondstage = FALSE;
    fault.s2fs1walk   = FALSE;

    if !<a link="AArch32.S1Enabled.2" file="shared_pseudocode.xml" hover="function: boolean AArch32.S1Enabled(Regime regime, SecurityState ss)">AArch32.S1Enabled</a>(regime, ss) then
        <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> ipa;
        (fault, ipa) = <a link="AArch32.S1DisabledOutput.6" file="shared_pseudocode.xml" hover="function: (FaultRecord, AddressDescriptor) AArch32.S1DisabledOutput(FaultRecord fault_in, Regime regime,&#13; SecurityState ss, bits(32) va,&#13; AccType acctype, boolean aligned)">AArch32.S1DisabledOutput</a>(fault, regime, ss, va, acctype, aligned);
        return (fault, ipa, <a link="SDFType" file="shared_pseudocode.xml" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType</a> UNKNOWN);

    <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate;
    (fault, walkstate) = <a link="AArch32.S1WalkSD.5" file="shared_pseudocode.xml" hover="function: (FaultRecord, TTWState) AArch32.S1WalkSD(FaultRecord fault_in, Regime regime, SecurityState ss,&#13; bits(32) va, boolean ispriv)">AArch32.S1WalkSD</a>(fault, regime, ss, va, ispriv);

    if fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return (fault, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a link="SDFType" file="shared_pseudocode.xml" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType</a> UNKNOWN);

    domain = <a link="AArch32.OutputDomain.2" file="shared_pseudocode.xml" hover="function: bits(2) AArch32.OutputDomain(Regime regime, bits(4) domain)">AArch32.OutputDomain</a>(regime, walkstate.domain);
    SetInGuardedPage(FALSE);  // AArch32-VMSA does not guard any pages

    bit ntlsmd;
    if <a link="impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveTrapLoadStoreMultipleDeviceExt()">HaveTrapLoadStoreMultipleDeviceExt</a>() then
        case regime of
            when <a link="Regime_EL30" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> ntlsmd = SCTLR_S.nTLSMD;
            when <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> ntlsmd = if <a link="impl-shared.HaveAArch32EL.1" file="shared_pseudocode.xml" hover="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then SCTLR_NS.nTLSMD else SCTLR.nTLSMD;
    else
        ntlsmd = '1';

    if <a link="AArch32.S1HasAlignmentFault.4" file="shared_pseudocode.xml" hover="function: boolean AArch32.S1HasAlignmentFault(AccType acctype, boolean aligned,&#13; bit ntlsmd, MemoryAttributes memattrs)">AArch32.S1HasAlignmentFault</a>(acctype, aligned, ntlsmd, walkstate.memattrs) then
        fault.statuscode = <a link="Fault_Alignment" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>;
    elsif !(acctype IN {<a link="AccType_IC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>, <a link="AccType_DC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>}) &amp;&amp; domain == <a link="Domain_NoAccess" file="shared_pseudocode.xml" hover="constant bits(2) Domain_NoAccess = '00'">Domain_NoAccess</a> then
        fault.statuscode = <a link="Fault_Domain" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Domain</a>;
    elsif domain == <a link="Domain_Client" file="shared_pseudocode.xml" hover="constant bits(2) Domain_Client = '01'">Domain_Client</a> then
        if <a link="impl-shared.IsAtomicRW.1" file="shared_pseudocode.xml" hover="function: boolean IsAtomicRW(AccType acctype)">IsAtomicRW</a>(acctype) then
            if <a link="AArch32.S1SDHasPermissionsFault.8" file="shared_pseudocode.xml" hover="function: boolean AArch32.S1SDHasPermissionsFault(Regime regime, SecurityState ss, Permissions perms_in,&#13; MemType memtype, PASpace paspace, boolean ispriv,&#13; AccType acctype, boolean iswrite)">AArch32.S1SDHasPermissionsFault</a>(regime, ss, walkstate.permissions,
                                               walkstate.memattrs.memtype,
                                               walkstate.baseaddress.paspace,
                                               ispriv, acctype, FALSE) then
                // The permission fault was not caused by lack of write permissions
                fault.statuscode = <a link="Fault_Permission" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
                fault.write      = FALSE;
            elsif <a link="AArch32.S1SDHasPermissionsFault.8" file="shared_pseudocode.xml" hover="function: boolean AArch32.S1SDHasPermissionsFault(Regime regime, SecurityState ss, Permissions perms_in,&#13; MemType memtype, PASpace paspace, boolean ispriv,&#13; AccType acctype, boolean iswrite)">AArch32.S1SDHasPermissionsFault</a>(regime, ss, walkstate.permissions,
                                                  walkstate.memattrs.memtype,
                                                  walkstate.baseaddress.paspace,
                                                  ispriv, acctype, TRUE) then
                // The permission fault _was_ caused by lack of write permissions
                fault.statuscode = <a link="Fault_Permission" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
                fault.write      = TRUE;
        elsif <a link="AArch32.S1SDHasPermissionsFault.8" file="shared_pseudocode.xml" hover="function: boolean AArch32.S1SDHasPermissionsFault(Regime regime, SecurityState ss, Permissions perms_in,&#13; MemType memtype, PASpace paspace, boolean ispriv,&#13; AccType acctype, boolean iswrite)">AArch32.S1SDHasPermissionsFault</a>(regime, ss, walkstate.permissions,
                                              walkstate.memattrs.memtype,
                                              walkstate.baseaddress.paspace,
                                              ispriv, acctype, iswrite) then
            fault.statuscode = <a link="Fault_Permission" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;

    if fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        fault.domain = walkstate.domain;
        return (fault, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, walkstate.sdftype);

    <a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs;
    if ((acctype == <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> &amp;&amp;
            (walkstate.memattrs.memtype == <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> || !<a link="AArch32.S1ICacheEnabled.1" file="shared_pseudocode.xml" hover="function: boolean AArch32.S1ICacheEnabled(Regime regime)">AArch32.S1ICacheEnabled</a>(regime))) ||
        (acctype != <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> &amp;&amp;
             walkstate.memattrs.memtype == <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> &amp;&amp; !<a link="AArch32.S1DCacheEnabled.1" file="shared_pseudocode.xml" hover="function: boolean AArch32.S1DCacheEnabled(Regime regime)">AArch32.S1DCacheEnabled</a>(regime))) then
        // Treat memory attributes as Normal Non-Cacheable
        memattrs = <a link="impl-shared.NormalNCMemAttr.0" file="shared_pseudocode.xml" hover="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
        memattrs.xs = walkstate.memattrs.xs;
    else
        memattrs = walkstate.memattrs;

    // Shareability value of stage 1 translation subject to stage 2 is IMPLEMENTATION DEFINED
    // to be either effective value or descriptor value
    if (regime == <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a link="AArch32.EL2Enabled.1" file="shared_pseudocode.xml" hover="function: boolean AArch32.EL2Enabled(SecurityState ss)">AArch32.EL2Enabled</a>(ss) &amp;&amp;
            (if <a link="impl-shared.ELStateUsingAArch32.2" file="shared_pseudocode.xml" hover="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)">ELStateUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>) then HCR.VM else HCR_EL2.VM) == '1' &amp;&amp;
            !(boolean IMPLEMENTATION_DEFINED "Apply effective shareability at stage 1")) then
        memattrs.shareability = walkstate.memattrs.shareability;
    else
        memattrs.shareability = <a link="impl-shared.EffectiveShareability.1" file="shared_pseudocode.xml" hover="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(memattrs);

    // Output Address
    oa = <a link="AArch32.SDStageOA.3" file="shared_pseudocode.xml" hover="function: FullAddress AArch32.SDStageOA(FullAddress baseaddress, bits(32) va, SDFType sdftype)">AArch32.SDStageOA</a>(walkstate.baseaddress, va, walkstate.sdftype);
    ipa = <a link="impl-shared.CreateAddressDescriptor.3" file="shared_pseudocode.xml" hover="function: AddressDescriptor CreateAddressDescriptor(bits(64) va, FullAddress pa,&#13; MemoryAttributes memattrs)">CreateAddressDescriptor</a>(<a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va), oa, memattrs);

    return (fault, ipa, walkstate.sdftype);</pstext>
    </ps>
    <ps name="aarch32/translation/translation/AArch32.S2Translate" mylink="aarch32.translation.translation.AArch32.S2Translate" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.S2Translate()
// =====================
// Perform a stage 2 translation mapping an IPA to a PA

(FaultRecord, AddressDescriptor) <anchor link="AArch32.S2Translate.8" hover="function: (FaultRecord, AddressDescriptor) AArch32.S2Translate(FaultRecord fault_in, AddressDescriptor ipa,&#13; SecurityState ss, boolean s2fs1walk,&#13; AccType acctype, boolean aligned,&#13; boolean iswrite, boolean ispriv)">AArch32.S2Translate</anchor>(<a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault_in, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> ipa,
                                                     <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss, boolean s2fs1walk,
                                                     <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned,
                                                     boolean iswrite, boolean ispriv)

    <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault = fault_in;
    assert <a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(ipa.paddress.address&lt;51:40&gt;);

    if !<a link="impl-shared.ELStateUsingAArch32.2" file="shared_pseudocode.xml" hover="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)">ELStateUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>) then
        s1aarch64 = FALSE;
        return <a link="AArch64.S2Translate.9" file="shared_pseudocode.xml" hover="function: (FaultRecord, AddressDescriptor) AArch64.S2Translate(FaultRecord fault_in, AddressDescriptor ipa,&#13; boolean s1aarch64, SecurityState ss,&#13; boolean s2fs1walk, AccType acctype,&#13; boolean aligned, boolean iswrite,&#13; boolean ispriv)">AArch64.S2Translate</a>(fault, ipa, s1aarch64, ss, s2fs1walk, acctype,
                                   aligned, iswrite, ispriv);

    // Prepare fault fields in case a fault is detected
    fault.statuscode  = <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;
    fault.secondstage = TRUE;
    fault.s2fs1walk   = s2fs1walk;
    fault.ipaddress   = ipa.paddress;

    walkparams = <a link="AArch32.GetS2TTWParams.0" file="shared_pseudocode.xml" hover="function: S2TTWParams AArch32.GetS2TTWParams()">AArch32.GetS2TTWParams</a>();

    if walkparams.vm == '0' then
        // Stage 2 is disabled
        return (fault, ipa);

    if <a link="AArch32.IPAIsOutOfRange.2" file="shared_pseudocode.xml" hover="function: boolean AArch32.IPAIsOutOfRange(S2TTWParams walkparams, bits(40) ipa)">AArch32.IPAIsOutOfRange</a>(walkparams, ipa.paddress.address&lt;39:0&gt;) then
        fault.statuscode = <a link="Fault_Translation" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        fault.level      = 1;
        return (fault, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate;
    (fault, walkstate) = <a link="AArch32.S2Walk.3" file="shared_pseudocode.xml" hover="function: (FaultRecord, TTWState) AArch32.S2Walk(FaultRecord fault_in, S2TTWParams walkparams,&#13; AddressDescriptor ipa)">AArch32.S2Walk</a>(fault, walkparams, ipa);

    if fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return (fault, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    if <a link="AArch32.S2HasAlignmentFault.3" file="shared_pseudocode.xml" hover="function: boolean AArch32.S2HasAlignmentFault(AccType acctype, boolean aligned,&#13; MemoryAttributes memattrs)">AArch32.S2HasAlignmentFault</a>(acctype, aligned, walkstate.memattrs) then
        fault.statuscode = <a link="Fault_Alignment" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>;
    elsif <a link="impl-shared.IsAtomicRW.1" file="shared_pseudocode.xml" hover="function: boolean IsAtomicRW(AccType acctype)">IsAtomicRW</a>(acctype) then
        assert !s2fs1walk; // AArch32 does not support HW update of TT
        if <a link="AArch32.S2HasPermissionsFault.7" file="shared_pseudocode.xml" hover="function: boolean AArch32.S2HasPermissionsFault(boolean s2fs1walk, S2TTWParams walkparams,&#13; Permissions perms, MemType memtype,&#13; boolean ispriv, AccType acctype,&#13; boolean iswrite)">AArch32.S2HasPermissionsFault</a>(s2fs1walk, walkparams,
                                         walkstate.permissions,
                                         walkstate.memattrs.memtype,
                                         ispriv, acctype, FALSE) then
            // The permission fault was not caused by lack of write permissions
            fault.statuscode = <a link="Fault_Permission" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
            fault.write      = FALSE;
        elsif <a link="AArch32.S2HasPermissionsFault.7" file="shared_pseudocode.xml" hover="function: boolean AArch32.S2HasPermissionsFault(boolean s2fs1walk, S2TTWParams walkparams,&#13; Permissions perms, MemType memtype,&#13; boolean ispriv, AccType acctype,&#13; boolean iswrite)">AArch32.S2HasPermissionsFault</a>(s2fs1walk, walkparams,
                                            walkstate.permissions,
                                            walkstate.memattrs.memtype,
                                            ispriv, acctype, TRUE) then
            // The permission fault _was_ caused by lack of write permissions
            fault.statuscode = <a link="Fault_Permission" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
            fault.write      = TRUE;
    elsif <a link="AArch32.S2HasPermissionsFault.7" file="shared_pseudocode.xml" hover="function: boolean AArch32.S2HasPermissionsFault(boolean s2fs1walk, S2TTWParams walkparams,&#13; Permissions perms, MemType memtype,&#13; boolean ispriv, AccType acctype,&#13; boolean iswrite)">AArch32.S2HasPermissionsFault</a>(s2fs1walk, walkparams,
                                        walkstate.permissions,
                                        walkstate.memattrs.memtype,
                                        ispriv, acctype, iswrite) then
        fault.statuscode = <a link="Fault_Permission" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
    <a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> s2_memattrs;
    if ((s2fs1walk &amp;&amp;
             walkstate.memattrs.memtype == <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>) ||
        (acctype == <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> &amp;&amp;
            (walkstate.memattrs.memtype == <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> || HCR2.ID == '1')) ||
        (acctype != <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> &amp;&amp;
             walkstate.memattrs.memtype == <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> &amp;&amp; HCR2.CD == '1')) then
        // Treat memory attributes as Normal Non-Cacheable
        s2_memattrs = <a link="impl-shared.NormalNCMemAttr.0" file="shared_pseudocode.xml" hover="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
        s2_memattrs.xs = walkstate.memattrs.xs;
    else
        s2_memattrs = walkstate.memattrs;

    memattrs = <a link="impl-shared.S2CombineS1MemAttrs.2" file="shared_pseudocode.xml" hover="function: MemoryAttributes S2CombineS1MemAttrs(MemoryAttributes s1_memattrs,&#13; MemoryAttributes s2_memattrs)">S2CombineS1MemAttrs</a>(ipa.memattrs, s2_memattrs);
    ipa_64 = <a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(ipa.paddress.address&lt;39:0&gt;, 64);
    // Output Address
    oa = <a link="impl-shared.StageOA.3" file="shared_pseudocode.xml" hover="function: FullAddress StageOA(bits(64) ia, TGx tgx, TTWState walkstate)">StageOA</a>(ipa_64, walkparams.tgx, walkstate);
    pa = <a link="impl-shared.CreateAddressDescriptor.3" file="shared_pseudocode.xml" hover="function: AddressDescriptor CreateAddressDescriptor(bits(64) va, FullAddress pa,&#13; MemoryAttributes memattrs)">CreateAddressDescriptor</a>(ipa.vaddress, oa, memattrs);

    return (fault, pa);</pstext>
    </ps>
    <ps name="aarch32/translation/translation/AArch32.SDStageOA" mylink="aarch32.translation.translation.AArch32.SDStageOA" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.SDStageOA()
// ===================
// Given the final walk state of a short-descriptor translation walk,
// map the untranslated input address bits to the base output address

FullAddress <anchor link="AArch32.SDStageOA.3" hover="function: FullAddress AArch32.SDStageOA(FullAddress baseaddress, bits(32) va, SDFType sdftype)">AArch32.SDStageOA</anchor>(<a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> baseaddress, bits(32) va, <a link="SDFType" file="shared_pseudocode.xml" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType</a> sdftype)
    integer tsize;
    case sdftype of
        when <a link="SDFType_SmallPage" file="shared_pseudocode.xml" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_SmallPage</a>      tsize = 12;
        when <a link="SDFType_LargePage" file="shared_pseudocode.xml" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_LargePage</a>      tsize = 16;
        when <a link="SDFType_Section" file="shared_pseudocode.xml" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Section</a>        tsize = 20;
        when <a link="SDFType_Supersection" file="shared_pseudocode.xml" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Supersection</a>   tsize = 24;

    // Output Address
    <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> oa;
    oa.address = baseaddress.address&lt;51:tsize&gt;:va&lt;tsize-1:0&gt;;
    oa.paspace = baseaddress.paspace;
    return oa;</pstext>
    </ps>
    <ps name="aarch32/translation/translation/AArch32.TranslateAddress" mylink="aarch32.translation.translation.AArch32.TranslateAddress" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.TranslateAddress()
// ==========================
// Main entry point for translating an address

AddressDescriptor <anchor link="AArch32.TranslateAddress.5" hover="function: AddressDescriptor AArch32.TranslateAddress(bits(32) va, AccType acctype,&#13; boolean iswrite, boolean aligned,&#13; integer size)">AArch32.TranslateAddress</anchor>(bits(32) va, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype,
                                           boolean iswrite, boolean aligned,
                                           integer size)

    regime = <a link="impl-shared.TranslationRegime.2" file="shared_pseudocode.xml" hover="function: Regime TranslationRegime(bits(2) el, AccType acctype)">TranslationRegime</a>(PSTATE.EL, acctype);
    if !<a link="impl-shared.RegimeUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean RegimeUsingAArch32(Regime regime)">RegimeUsingAArch32</a>(regime) then
        return <a link="AArch64.TranslateAddress.5" file="shared_pseudocode.xml" hover="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccType acctype, boolean iswrite,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(<a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(va, 64), acctype, iswrite,
                                        aligned, size);
    result = <a link="AArch32.FullTranslate.4" file="shared_pseudocode.xml" hover="function: AddressDescriptor AArch32.FullTranslate(bits(32) va, AccType acctype,&#13; boolean iswrite, boolean aligned)">AArch32.FullTranslate</a>(va, acctype, iswrite, aligned);
    if !<a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(result) then
        result.fault = <a link="AArch32.CheckDebug.4" file="shared_pseudocode.xml" hover="function: FaultRecord AArch32.CheckDebug(bits(32) vaddress, AccType acctype, boolean iswrite, integer size)">AArch32.CheckDebug</a>(va, acctype, iswrite, size);

    // Update virtual address for abort functions
    result.vaddress = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va);

    return result;</pstext>
    </ps>
    <ps name="aarch32/translation/walk/AArch32.DecodeDescriptorTypeLD" mylink="aarch32.translation.walk.AArch32.DecodeDescriptorTypeLD" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.DecodeDescriptorTypeLD()
// ================================
// Determine whether the long-descriptor is a page, block or table

DescriptorType <anchor link="AArch32.DecodeDescriptorTypeLD.2" hover="function: DescriptorType AArch32.DecodeDescriptorTypeLD(bits(64) descriptor, integer level)">AArch32.DecodeDescriptorTypeLD</anchor>(bits(64) descriptor, integer level)
    if descriptor&lt;1:0&gt; == '11' &amp;&amp; level == <a link="FINAL_LEVEL" file="shared_pseudocode.xml" hover="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> then
        return <a link="DescriptorType_Page" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Page</a>;
    elsif descriptor&lt;1:0&gt; == '11' then
        return <a link="DescriptorType_Table" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Table</a>;
    elsif descriptor&lt;1:0&gt; == '01' &amp;&amp; level != <a link="FINAL_LEVEL" file="shared_pseudocode.xml" hover="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> then
        return <a link="DescriptorType_Block" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Block</a>;
    else
        return <a link="DescriptorType_Invalid" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Invalid</a>;</pstext>
    </ps>
    <ps name="aarch32/translation/walk/AArch32.DecodeDescriptorTypeSD" mylink="aarch32.translation.walk.AArch32.DecodeDescriptorTypeSD" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.DecodeDescriptorTypeSD()
// ================================
// Determine the type of the short-descriptor

SDFType <anchor link="AArch32.DecodeDescriptorTypeSD.2" hover="function: SDFType AArch32.DecodeDescriptorTypeSD(bits(32) descriptor, integer level)">AArch32.DecodeDescriptorTypeSD</anchor>(bits(32) descriptor, integer level)
    if level == 1 &amp;&amp; descriptor&lt;1:0&gt; == '01' then
        return <a link="SDFType_Table" file="shared_pseudocode.xml" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Table</a>;
    elsif level == 1 &amp;&amp; descriptor&lt;18,1&gt; == '01' then
        return <a link="SDFType_Section" file="shared_pseudocode.xml" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Section</a>;
    elsif level == 1 &amp;&amp; descriptor&lt;18,1&gt; == '11' then
        return <a link="SDFType_Supersection" file="shared_pseudocode.xml" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Supersection</a>;
    elsif level == 2 &amp;&amp; descriptor&lt;1:0&gt; == '01' then
        return <a link="SDFType_LargePage" file="shared_pseudocode.xml" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_LargePage</a>;
    elsif level == 2 &amp;&amp; descriptor&lt;1:0&gt; == '1x' then
        return <a link="SDFType_SmallPage" file="shared_pseudocode.xml" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_SmallPage</a>;
    else
        return <a link="SDFType_Invalid" file="shared_pseudocode.xml" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Invalid</a>;</pstext>
    </ps>
    <ps name="aarch32/translation/walk/AArch32.S1IASize" mylink="aarch32.translation.walk.AArch32.S1IASize" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.S1IASize()
// ==================
// Retrieve the number of bits containing the input address for stage 1 translation

integer <anchor link="AArch32.S1IASize.1" hover="function: integer AArch32.S1IASize(bits(3) txsz)">AArch32.S1IASize</anchor>(bits(3) txsz)
    return 32 - <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(txsz);</pstext>
    </ps>
    <ps name="aarch32/translation/walk/AArch32.S1WalkLD" mylink="aarch32.translation.walk.AArch32.S1WalkLD" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.S1WalkLD()
// ==================
// Traverse stage 1 translation tables in long format to obtain the final descriptor

(FaultRecord, TTWState) <anchor link="AArch32.S1WalkLD.6" hover="function: (FaultRecord, TTWState) AArch32.S1WalkLD(FaultRecord fault_in, Regime regime, SecurityState ss,&#13; S1TTWParams walkparams, bits(32) va, boolean ispriv)">AArch32.S1WalkLD</anchor>(<a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault_in, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss,
                                         <a link="S1TTWParams" file="shared_pseudocode.xml" hover="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams, bits(32) va, boolean ispriv)
    <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault = fault_in;
    bits(3) txsz;
    bits(64) ttbr;
    bit epd;
    if regime == <a link="Regime_EL2" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a> then
        ttbr = HTTBR;
        txsz = walkparams.t0sz;
    else
        varange = <a link="AArch32.GetVARange.3" file="shared_pseudocode.xml" hover="function: VARange AArch32.GetVARange(bits(32) va, bits(3) t0sz, bits(3) t1sz)">AArch32.GetVARange</a>(va, walkparams.t0sz, walkparams.t1sz);
        bits(64) ttbr0;
        bits(64) ttbr1;
        TTBCR_Type ttbcr;
        if regime == <a link="Regime_EL30" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> then
            ttbcr = TTBCR_S;
            ttbr0 = TTBR0_S;
            ttbr1 = TTBR1_S;
        elsif <a link="impl-shared.HaveAArch32EL.1" file="shared_pseudocode.xml" hover="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
            ttbcr = TTBCR_NS;
            ttbr0 = TTBR0_NS;
            ttbr1 = TTBR1_NS;
        else
            ttbcr = TTBCR;
            ttbr0 = TTBR0;
            ttbr1 = TTBR1;

        assert ttbcr.EAE == '1';
        if varange == <a link="VARange_LOWER" file="shared_pseudocode.xml" hover="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
            txsz = walkparams.t0sz;
            ttbr = ttbr0;
            epd  = ttbcr.EPD0;
        else
            txsz = walkparams.t1sz;
            ttbr = ttbr1;
            epd  = ttbcr.EPD1;

    if regime != <a link="Regime_EL2" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a> &amp;&amp; epd == '1' then
        fault.level      = 1;
        fault.statuscode = <a link="Fault_Translation" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        return (fault, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    // Input Address size
    iasize      = <a link="AArch32.S1IASize.1" file="shared_pseudocode.xml" hover="function: integer AArch32.S1IASize(bits(3) txsz)">AArch32.S1IASize</a>(txsz);
    granulebits = <a link="impl-shared.TGxGranuleBits.1" file="shared_pseudocode.xml" hover="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(walkparams.tgx);
    stride      = granulebits - 3;
    startlevel  = <a link="FINAL_LEVEL" file="shared_pseudocode.xml" hover="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - (((iasize-1) - granulebits) DIV stride);
    levels      = <a link="FINAL_LEVEL" file="shared_pseudocode.xml" hover="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - startlevel;

    if !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(ttbr&lt;47:40&gt;) then
        fault.statuscode = <a link="Fault_AddressSize" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
        fault.level      = 0;
        return (fault, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> baseaddress;
    baselsb = (iasize - (levels*stride + granulebits)) + 3;
    baseaddress.paspace = if ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> then <a link="PAS_Secure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_Secure</a> else <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a>;
    baseaddress.address = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(ttbr&lt;39:baselsb&gt;:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(baselsb));

    <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate;
    walkstate.baseaddress = baseaddress;
    walkstate.level       = startlevel;
    walkstate.istable     = TRUE;
    // In regimes that support global and non-global translations, translation
    // table entries from lookup levels other than the final level of lookup
    // are treated as being non-global
    walkstate.nG          = if <a link="impl-shared.HasUnprivileged.1" file="shared_pseudocode.xml" hover="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then '1' else '0';
    walkstate.memattrs    = <a link="impl-shared.WalkMemAttrs.3" file="shared_pseudocode.xml" hover="function: MemoryAttributes WalkMemAttrs(bits(2) sh, bits(2) irgn, bits(2) orgn)">WalkMemAttrs</a>(walkparams.sh, walkparams.irgn, walkparams.orgn);
    walkstate.permissions.ap_table  = '00';
    walkstate.permissions.xn_table  = '0';
    walkstate.permissions.pxn_table = '0';

    indexmsb = iasize - 1;
    bits(64) descriptor;
    <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> walkaddress;

    walkaddress.vaddress = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va);

    if !<a link="AArch32.S1DCacheEnabled.1" file="shared_pseudocode.xml" hover="function: boolean AArch32.S1DCacheEnabled(Regime regime)">AArch32.S1DCacheEnabled</a>(regime) then
        walkaddress.memattrs = <a link="impl-shared.NormalNCMemAttr.0" file="shared_pseudocode.xml" hover="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
        walkaddress.memattrs.xs = walkstate.memattrs.xs;
    else
        walkaddress.memattrs = walkstate.memattrs;

    // Shareability value of stage 1 translation subject to stage 2 is IMPLEMENTATION DEFINED
    // to be either effective value or descriptor value
    if (regime == <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a link="AArch32.EL2Enabled.1" file="shared_pseudocode.xml" hover="function: boolean AArch32.EL2Enabled(SecurityState ss)">AArch32.EL2Enabled</a>(ss) &amp;&amp;
        (if <a link="impl-shared.ELStateUsingAArch32.2" file="shared_pseudocode.xml" hover="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)">ELStateUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>) then HCR.VM else HCR_EL2.VM) == '1' &amp;&amp;
            !(boolean IMPLEMENTATION_DEFINED "Apply effective shareability at stage 1")) then
        walkaddress.memattrs.shareability = walkstate.memattrs.shareability;
    else
        walkaddress.memattrs.shareability = <a link="impl-shared.EffectiveShareability.1" file="shared_pseudocode.xml" hover="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(walkaddress.memattrs);

    integer indexlsb;
    <a link="DescriptorType" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType</a> desctype;
    repeat
        fault.level = walkstate.level;
        indexlsb = (<a link="FINAL_LEVEL" file="shared_pseudocode.xml" hover="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - walkstate.level)*stride + granulebits;
        bits(40) index = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va&lt;indexmsb:indexlsb&gt;:'000');

        walkaddress.paddress.address = walkstate.baseaddress.address OR <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(index);
        walkaddress.paddress.paspace = walkstate.baseaddress.paspace;

        // If there are two stages of translation, then the first stage table walk addresses
        // are themselves subject to translation
        if regime == <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a link="AArch32.EL2Enabled.1" file="shared_pseudocode.xml" hover="function: boolean AArch32.EL2Enabled(SecurityState ss)">AArch32.EL2Enabled</a>(ss) then
            s2fs1walk = TRUE;
            s2acctype = <a link="AccType_TTW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_TTW</a>;
            s2aligned = TRUE;
            s2write   = FALSE;
            (s2fault, s2walkaddress) = <a link="AArch32.S2Translate.8" file="shared_pseudocode.xml" hover="function: (FaultRecord, AddressDescriptor) AArch32.S2Translate(FaultRecord fault_in, AddressDescriptor ipa,&#13; SecurityState ss, boolean s2fs1walk,&#13; AccType acctype, boolean aligned,&#13; boolean iswrite, boolean ispriv)">AArch32.S2Translate</a>(fault, walkaddress, ss, s2fs1walk,
                                                           s2acctype, s2aligned, s2write, ispriv);
            // Check for a fault on the stage 2 walk
            if s2fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
                return (s2fault, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

            (fault, descriptor) = <a link="impl-shared.FetchDescriptor.3" file="shared_pseudocode.xml" hover="function: (FaultRecord, bits(N)) FetchDescriptor(bit ee, AddressDescriptor walkaddress, FaultRecord fault_in)">FetchDescriptor</a>(walkparams.ee, s2walkaddress, fault);
        else
            (fault, descriptor) = <a link="impl-shared.FetchDescriptor.3" file="shared_pseudocode.xml" hover="function: (FaultRecord, bits(N)) FetchDescriptor(bit ee, AddressDescriptor walkaddress, FaultRecord fault_in)">FetchDescriptor</a>(walkparams.ee, walkaddress, fault);

        if fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
            return (fault, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

        desctype = <a link="AArch32.DecodeDescriptorTypeLD.2" file="shared_pseudocode.xml" hover="function: DescriptorType AArch32.DecodeDescriptorTypeLD(bits(64) descriptor, integer level)">AArch32.DecodeDescriptorTypeLD</a>(descriptor, walkstate.level);

        case desctype of
            when <a link="DescriptorType_Table" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Table</a>
                if !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(descriptor&lt;47:40&gt;) then
                    fault.statuscode = <a link="Fault_AddressSize" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
                    return (fault, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

                walkstate.baseaddress.address = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(descriptor&lt;39:12&gt;:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(12));
                if walkstate.baseaddress.paspace == <a link="PAS_Secure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_Secure</a> &amp;&amp; descriptor&lt;63&gt; == '1' then
                    walkstate.baseaddress.paspace = <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a>;

                if walkparams.hpd == '0' then
                    walkstate.permissions.xn_table  = (walkstate.permissions.xn_table  OR
                                                        descriptor&lt;60&gt;);
                    walkstate.permissions.ap_table  = (walkstate.permissions.ap_table  OR
                                                        descriptor&lt;62:61&gt;);
                    walkstate.permissions.pxn_table = (walkstate.permissions.pxn_table OR
                                                        descriptor&lt;59&gt;);

                walkstate.level = walkstate.level + 1;
                indexmsb = indexlsb - 1;

            when <a link="DescriptorType_Invalid" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Invalid</a>
                fault.statuscode = <a link="Fault_Translation" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
                return (fault, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

            when <a link="DescriptorType_Page" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Page</a>, <a link="DescriptorType_Block" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Block</a>
                walkstate.istable = FALSE;

    until desctype IN {<a link="DescriptorType_Page" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Page</a>, <a link="DescriptorType_Block" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Block</a>};

    // Check the output address is inside the supported range
    if !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(descriptor&lt;47:40&gt;) then
        fault.statuscode = <a link="Fault_AddressSize" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
        return (fault, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    // Check the access flag
    if descriptor&lt;10&gt; == '0' then
        fault.statuscode = <a link="Fault_AccessFlag" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>;
        return (fault, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    walkstate.permissions.xn  = descriptor&lt;54&gt;;
    walkstate.permissions.pxn = descriptor&lt;53&gt;;
    walkstate.permissions.ap  = descriptor&lt;7:6&gt;:'1';
    walkstate.contiguous      = descriptor&lt;52&gt;;
    if regime == <a link="Regime_EL2" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a> then
        // All EL2 regime accesses are treated as Global
        walkstate.nG = '0';
    elsif ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp; walkstate.baseaddress.paspace == <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a> then
        // When a PE is using the Long-descriptor translation table format,
        // and is in Secure state, a translation must be treated as non-global,
        // regardless of the value of the nG bit,
        // if NSTable is set to 1 at any level of the translation table walk.
        walkstate.nG = '1';
    else
        walkstate.nG = descriptor&lt;11&gt;;

    walkstate.baseaddress.address = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(descriptor&lt;39:indexlsb&gt;:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(indexlsb));
    if walkstate.baseaddress.paspace == <a link="PAS_Secure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_Secure</a> &amp;&amp; descriptor&lt;5&gt; == '1' then
        walkstate.baseaddress.paspace = <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a>;

    memattr = descriptor&lt;4:2&gt;;
    sh      = descriptor&lt;9:8&gt;;
    attr    = <a link="impl-shared.MAIRAttr.2" file="shared_pseudocode.xml" hover="function: bits(8) MAIRAttr(integer index, MAIRType mair)">MAIRAttr</a>(<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(memattr), walkparams.mair);
    s1aarch64 = FALSE;
    walkstate.memattrs = <a link="impl-shared.S1DecodeMemAttrs.3" file="shared_pseudocode.xml" hover="function: MemoryAttributes S1DecodeMemAttrs(bits(8) attr_in, bits(2) sh, boolean s1aarch64)">S1DecodeMemAttrs</a>(attr, sh, s1aarch64);

    return (fault, walkstate);</pstext>
    </ps>
    <ps name="aarch32/translation/walk/AArch32.S1WalkSD" mylink="aarch32.translation.walk.AArch32.S1WalkSD" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.S1WalkSD()
// ==================
// Traverse stage 1 translation tables in short format to obtain the final descriptor

(FaultRecord, TTWState) <anchor link="AArch32.S1WalkSD.5" hover="function: (FaultRecord, TTWState) AArch32.S1WalkSD(FaultRecord fault_in, Regime regime, SecurityState ss,&#13; bits(32) va, boolean ispriv)">AArch32.S1WalkSD</anchor>(<a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault_in, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss,
                                         bits(32) va, boolean ispriv)
    <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault = fault_in;
    SCTLR_Type sctlr;
    TTBCR_Type ttbcr;
    TTBR0_Type ttbr0;
    TTBR1_Type ttbr1;
    // Determine correct translation control registers to use.
    if regime == <a link="Regime_EL30" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> then
        sctlr = SCTLR_S;
        ttbcr = TTBCR_S;
        ttbr0 = TTBR0_S;
        ttbr1 = TTBR1_S;
    elsif <a link="impl-shared.HaveAArch32EL.1" file="shared_pseudocode.xml" hover="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
        sctlr = SCTLR_NS;
        ttbcr = TTBCR_NS;
        ttbr0 = TTBR0_NS;
        ttbr1 = TTBR1_NS;
    else
        sctlr = SCTLR;
        ttbcr = TTBCR;
        ttbr0 = TTBR0;
        ttbr1 = TTBR1;

    assert ttbcr.EAE == '0';
    ee  = sctlr.EE;
    afe = sctlr.AFE;
    tre = sctlr.TRE;
    n = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(ttbcr.N);
    bits(32) ttb;
    bits(1) pd;
    bits(2) irgn;
    bits(2) rgn;
    bits(1) s;
    bits(1) nos;
    if n == 0 || <a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(va&lt;31:(32-n)&gt;) then
        ttb  = ttbr0.TTB0:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(7);
        pd   = ttbcr.PD0;
        irgn = ttbr0.IRGN;
        rgn  = ttbr0.RGN;
        s    = ttbr0.S;
        nos  = ttbr0.NOS;
    else
        n    = 0;  // TTBR1 translation always treats N as 0
        ttb  = ttbr1.TTB1:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(7);
        pd   = ttbcr.PD1;
        irgn = ttbr1.IRGN;
        rgn  = ttbr1.RGN;
        s    = ttbr1.S;
        nos  = ttbr1.NOS;

    // Check if Translation table walk disabled for translations with this Base register.
    if pd == '1' then
        fault.level      = 1;
        fault.statuscode = <a link="Fault_Translation" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        return (fault, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> baseaddress;
    baseaddress.paspace = if ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> then <a link="PAS_Secure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_Secure</a> else <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a>;
    baseaddress.address = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(ttb&lt;31:14-n&gt;:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(14-n));

    <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate;
    walkstate.baseaddress = baseaddress;
    // In regimes that support global and non-global translations, translation
    // table entries from lookup levels other than the final level of lookup
    // are treated as being non-global. Translations in Short-Descriptor Format
    // always support global &amp; non-global translations.
    walkstate.nG          = '1';
    walkstate.memattrs    = <a link="impl-shared.WalkMemAttrs.3" file="shared_pseudocode.xml" hover="function: MemoryAttributes WalkMemAttrs(bits(2) sh, bits(2) irgn, bits(2) orgn)">WalkMemAttrs</a>(s:nos, irgn, rgn);
    walkstate.level       = 1;
    walkstate.istable     = TRUE;

    bits(4) domain;
    bits(32) descriptor;
    <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> walkaddress;

    walkaddress.vaddress = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va);

    if !<a link="AArch32.S1DCacheEnabled.1" file="shared_pseudocode.xml" hover="function: boolean AArch32.S1DCacheEnabled(Regime regime)">AArch32.S1DCacheEnabled</a>(regime) then
        walkaddress.memattrs = <a link="impl-shared.NormalNCMemAttr.0" file="shared_pseudocode.xml" hover="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
        walkaddress.memattrs.xs = walkstate.memattrs.xs;
    else
        walkaddress.memattrs = walkstate.memattrs;

    // Shareability value of stage 1 translation subject to stage 2 is IMPLEMENTATION DEFINED
    // to be either effective value or descriptor value
    if (regime == <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a link="AArch32.EL2Enabled.1" file="shared_pseudocode.xml" hover="function: boolean AArch32.EL2Enabled(SecurityState ss)">AArch32.EL2Enabled</a>(ss) &amp;&amp;
        (if <a link="impl-shared.ELStateUsingAArch32.2" file="shared_pseudocode.xml" hover="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)">ELStateUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>) then HCR.VM else HCR_EL2.VM) == '1' &amp;&amp;
            !(boolean IMPLEMENTATION_DEFINED "Apply effective shareability at stage 1")) then
        walkaddress.memattrs.shareability = walkstate.memattrs.shareability;
    else
        walkaddress.memattrs.shareability = <a link="impl-shared.EffectiveShareability.1" file="shared_pseudocode.xml" hover="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(walkaddress.memattrs);

    bit nG;
    bit ns;
    bit pxn;
    bits(3) ap;
    bits(3) tex;
    bit c;
    bit b;
    bit xn;
    repeat
        fault.level = walkstate.level;

        bits(32) index;
        if walkstate.level == 1 then
            index = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va&lt;31-n:20&gt;:'00');
        else
            index = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va&lt;19:12&gt;:'00');

        walkaddress.paddress.address = walkstate.baseaddress.address OR <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(index);
        walkaddress.paddress.paspace = walkstate.baseaddress.paspace;

        if regime == <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a link="AArch32.EL2Enabled.1" file="shared_pseudocode.xml" hover="function: boolean AArch32.EL2Enabled(SecurityState ss)">AArch32.EL2Enabled</a>(ss) then
            s2fs1walk = TRUE;
            s2acctype = <a link="AccType_TTW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_TTW</a>;
            s2aligned = TRUE;
            s2write   = FALSE;
            (s2fault, s2walkaddress) = <a link="AArch32.S2Translate.8" file="shared_pseudocode.xml" hover="function: (FaultRecord, AddressDescriptor) AArch32.S2Translate(FaultRecord fault_in, AddressDescriptor ipa,&#13; SecurityState ss, boolean s2fs1walk,&#13; AccType acctype, boolean aligned,&#13; boolean iswrite, boolean ispriv)">AArch32.S2Translate</a>(fault, walkaddress, ss, s2fs1walk,
                                                           s2acctype, s2aligned, s2write, ispriv);

            if s2fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
                return (s2fault, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

            (fault, descriptor) = <a link="impl-shared.FetchDescriptor.3" file="shared_pseudocode.xml" hover="function: (FaultRecord, bits(N)) FetchDescriptor(bit ee, AddressDescriptor walkaddress, FaultRecord fault_in)">FetchDescriptor</a>(ee, s2walkaddress, fault);
        else
            (fault, descriptor) = <a link="impl-shared.FetchDescriptor.3" file="shared_pseudocode.xml" hover="function: (FaultRecord, bits(N)) FetchDescriptor(bit ee, AddressDescriptor walkaddress, FaultRecord fault_in)">FetchDescriptor</a>(ee, walkaddress, fault);

        if fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
            return (fault, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

        walkstate.sdftype = <a link="AArch32.DecodeDescriptorTypeSD.2" file="shared_pseudocode.xml" hover="function: SDFType AArch32.DecodeDescriptorTypeSD(bits(32) descriptor, integer level)">AArch32.DecodeDescriptorTypeSD</a>(descriptor, walkstate.level);

        case walkstate.sdftype of
            when <a link="SDFType_Invalid" file="shared_pseudocode.xml" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Invalid</a>
                fault.domain     = domain;
                fault.statuscode = <a link="Fault_Translation" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
                return (fault, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

            when <a link="SDFType_Table" file="shared_pseudocode.xml" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Table</a>
                domain = descriptor&lt;8:5&gt;;
                ns     = descriptor&lt;3&gt;;
                pxn    = descriptor&lt;2&gt;;

                walkstate.baseaddress.address = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(descriptor&lt;31:10&gt;:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(10));
                walkstate.level = 2;

            when <a link="SDFType_SmallPage" file="shared_pseudocode.xml" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_SmallPage</a>
                nG  = descriptor&lt;11&gt;;
                s   = descriptor&lt;10&gt;;
                ap  = descriptor&lt;9,5:4&gt;;
                tex = descriptor&lt;8:6&gt;;
                c   = descriptor&lt;3&gt;;
                b   = descriptor&lt;2&gt;;
                xn  = descriptor&lt;0&gt;;

                walkstate.baseaddress.address = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(descriptor&lt;31:12&gt;:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(12));
                walkstate.istable = FALSE;

            when <a link="SDFType_LargePage" file="shared_pseudocode.xml" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_LargePage</a>
                xn  = descriptor&lt;15&gt;;
                tex = descriptor&lt;14:12&gt;;
                nG  = descriptor&lt;11&gt;;
                s   = descriptor&lt;10&gt;;
                ap  = descriptor&lt;9,5:4&gt;;
                c   = descriptor&lt;3&gt;;
                b   = descriptor&lt;2&gt;;

                walkstate.baseaddress.address = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(descriptor&lt;31:16&gt;:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(16));
                walkstate.istable = FALSE;

            when <a link="SDFType_Section" file="shared_pseudocode.xml" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Section</a>
                ns     = descriptor&lt;19&gt;;
                nG     = descriptor&lt;17&gt;;
                s      = descriptor&lt;16&gt;;
                ap     = descriptor&lt;15,11:10&gt;;
                tex    = descriptor&lt;14:12&gt;;
                domain = descriptor&lt;8:5&gt;;
                xn     = descriptor&lt;4&gt;;
                c      = descriptor&lt;3&gt;;
                b      = descriptor&lt;2&gt;;
                pxn    = descriptor&lt;0&gt;;

                walkstate.baseaddress.address = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(descriptor&lt;31:20&gt;:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(20));
                walkstate.istable = FALSE;

            when <a link="SDFType_Supersection" file="shared_pseudocode.xml" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Supersection</a>
                ns     = descriptor&lt;19&gt;;
                nG     = descriptor&lt;17&gt;;
                s      = descriptor&lt;16&gt;;
                ap     = descriptor&lt;15,11:10&gt;;
                tex    = descriptor&lt;14:12&gt;;
                xn     = descriptor&lt;4&gt;;
                c      = descriptor&lt;3&gt;;
                b      = descriptor&lt;2&gt;;
                pxn    = descriptor&lt;0&gt;;
                domain = '0000';

                walkstate.baseaddress.address = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(descriptor&lt;8:5,23:20,31:24&gt;:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(24));
                walkstate.istable = FALSE;

    until walkstate.sdftype != <a link="SDFType_Table" file="shared_pseudocode.xml" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Table</a>;

    if afe == '1' &amp;&amp; ap&lt;0&gt; == '0' then
        fault.domain     = domain;
        fault.statuscode = <a link="Fault_AccessFlag" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>;
        return (fault, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    // Decode the TEX, C, B and S bits to produce target memory attributes
    if tre == '1' then
        walkstate.memattrs = <a link="AArch32.RemappedTEXDecode.5" file="shared_pseudocode.xml" hover="function: MemoryAttributes AArch32.RemappedTEXDecode(Regime regime, bits(3) TEX, bit C, bit B, bit S)">AArch32.RemappedTEXDecode</a>(regime, tex, c, b, s);
    elsif <a link="impl-aarch32.RemapRegsHaveResetValues.0" file="shared_pseudocode.xml" hover="function: boolean RemapRegsHaveResetValues()">RemapRegsHaveResetValues</a>() then
        walkstate.memattrs = <a link="AArch32.DefaultTEXDecode.4" file="shared_pseudocode.xml" hover="function: MemoryAttributes AArch32.DefaultTEXDecode(bits(3) TEX_in, bit C_in, bit B_in, bit S)">AArch32.DefaultTEXDecode</a>(tex, c, b, s);
    else
        walkstate.memattrs = <a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> IMPLEMENTATION_DEFINED;

    walkstate.permissions.ap  = ap;
    walkstate.permissions.xn  = xn;
    walkstate.permissions.pxn = pxn;
    walkstate.domain = domain;
    walkstate.nG     = nG;

    if ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp; ns == '0' then
        walkstate.baseaddress.paspace = <a link="PAS_Secure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_Secure</a>;
    else
        walkstate.baseaddress.paspace = <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a>;

    return (fault, walkstate);</pstext>
    </ps>
    <ps name="aarch32/translation/walk/AArch32.S2IASize" mylink="aarch32.translation.walk.AArch32.S2IASize" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.S2IASize()
// ==================
// Retrieve the number of bits containing the input address for stage 2 translation

integer <anchor link="AArch32.S2IASize.1" hover="function: integer AArch32.S2IASize(bits(4) t0sz)">AArch32.S2IASize</anchor>(bits(4) t0sz)
    return 32 - <a link="impl-shared.SInt.1" file="shared_pseudocode.xml" hover="function: integer SInt(bits(N) x)">SInt</a>(t0sz);</pstext>
    </ps>
    <ps name="aarch32/translation/walk/AArch32.S2StartLevel" mylink="aarch32.translation.walk.AArch32.S2StartLevel" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.S2StartLevel()
// ======================
// Determine the initial lookup level when performing a stage 2 translation
// table walk

integer <anchor link="AArch32.S2StartLevel.1" hover="function: integer AArch32.S2StartLevel(bits(2) sl0)">AArch32.S2StartLevel</anchor>(bits(2) sl0)
    return 2 - <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(sl0);</pstext>
    </ps>
    <ps name="aarch32/translation/walk/AArch32.S2Walk" mylink="aarch32.translation.walk.AArch32.S2Walk" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.S2Walk()
// ================
// Traverse stage 2 translation tables in long format to obtain the final descriptor

(FaultRecord, TTWState) <anchor link="AArch32.S2Walk.3" hover="function: (FaultRecord, TTWState) AArch32.S2Walk(FaultRecord fault_in, S2TTWParams walkparams,&#13; AddressDescriptor ipa)">AArch32.S2Walk</anchor>(<a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault_in, <a link="S2TTWParams" file="shared_pseudocode.xml" hover="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams,
                                       <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> ipa)
    <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault = fault_in;

    if walkparams.sl0 == '1x' || <a link="AArch32.S2InconsistentSL.1" file="shared_pseudocode.xml" hover="function: boolean AArch32.S2InconsistentSL(S2TTWParams walkparams)">AArch32.S2InconsistentSL</a>(walkparams) then
        fault.statuscode = <a link="Fault_Translation" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        fault.level      = 1;
        return (fault, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    // Input Address size
    iasize      = <a link="AArch32.S2IASize.1" file="shared_pseudocode.xml" hover="function: integer AArch32.S2IASize(bits(4) t0sz)">AArch32.S2IASize</a>(walkparams.t0sz);
    startlevel  = <a link="AArch32.S2StartLevel.1" file="shared_pseudocode.xml" hover="function: integer AArch32.S2StartLevel(bits(2) sl0)">AArch32.S2StartLevel</a>(walkparams.sl0);
    levels      = <a link="FINAL_LEVEL" file="shared_pseudocode.xml" hover="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - startlevel;
    granulebits = <a link="impl-shared.TGxGranuleBits.1" file="shared_pseudocode.xml" hover="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(walkparams.tgx);
    stride      = granulebits - 3;

    if !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(VTTBR&lt;47:40&gt;) then
        fault.statuscode = <a link="Fault_AddressSize" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
        fault.level      = 0;
        return (fault, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> baseaddress;
    baselsb = (iasize - (levels*stride + granulebits)) + 3;
    baseaddress.paspace = <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a>;
    baseaddress.address = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(VTTBR&lt;39:baselsb&gt;:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(baselsb));

    <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate;
    walkstate.baseaddress = baseaddress;
    walkstate.level       = startlevel;
    walkstate.istable     = TRUE;
    walkstate.memattrs    = <a link="impl-shared.WalkMemAttrs.3" file="shared_pseudocode.xml" hover="function: MemoryAttributes WalkMemAttrs(bits(2) sh, bits(2) irgn, bits(2) orgn)">WalkMemAttrs</a>(walkparams.sh, walkparams.irgn,
                                         walkparams.orgn);

    indexmsb = iasize - 1;
    bits(64) descriptor;
    <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> walkaddress;

    walkaddress.vaddress = ipa.vaddress;
    if HCR2.CD == '1' then
        walkaddress.memattrs = <a link="impl-shared.NormalNCMemAttr.0" file="shared_pseudocode.xml" hover="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
        walkaddress.memattrs.xs = walkstate.memattrs.xs;
    else
        walkaddress.memattrs = walkstate.memattrs;

    walkaddress.memattrs.shareability = <a link="impl-shared.EffectiveShareability.1" file="shared_pseudocode.xml" hover="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(walkaddress.memattrs);

    integer indexlsb;
    <a link="DescriptorType" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType</a> desctype;
    repeat
        fault.level = walkstate.level;

        indexlsb = (<a link="FINAL_LEVEL" file="shared_pseudocode.xml" hover="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - walkstate.level)*stride + granulebits;
        bits(40) index = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(ipa.paddress.address&lt;indexmsb:indexlsb&gt;:'000');

        walkaddress.paddress.address = walkstate.baseaddress.address OR <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(index);
        walkaddress.paddress.paspace = walkstate.baseaddress.paspace;

        (fault, descriptor) = <a link="impl-shared.FetchDescriptor.3" file="shared_pseudocode.xml" hover="function: (FaultRecord, bits(N)) FetchDescriptor(bit ee, AddressDescriptor walkaddress, FaultRecord fault_in)">FetchDescriptor</a>(walkparams.ee, walkaddress, fault);

        if fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
            return (fault, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

        desctype = <a link="AArch32.DecodeDescriptorTypeLD.2" file="shared_pseudocode.xml" hover="function: DescriptorType AArch32.DecodeDescriptorTypeLD(bits(64) descriptor, integer level)">AArch32.DecodeDescriptorTypeLD</a>(descriptor, walkstate.level);

        case desctype of
            when <a link="DescriptorType_Table" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Table</a>
                if !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(descriptor&lt;47:40&gt;) then
                    fault.statuscode = <a link="Fault_AddressSize" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
                    return (fault, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

                walkstate.baseaddress.address = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(descriptor&lt;39:12&gt;:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(12));
                walkstate.level = walkstate.level + 1;
                indexmsb = indexlsb - 1;

            when <a link="DescriptorType_Invalid" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Invalid</a>
                fault.statuscode = <a link="Fault_Translation" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
                return (fault, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

            when <a link="DescriptorType_Page" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Page</a>, <a link="DescriptorType_Block" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Block</a>
                walkstate.istable = FALSE;

    until desctype IN {<a link="DescriptorType_Page" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Page</a>, <a link="DescriptorType_Block" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Block</a>};

    // Check the output address is inside the supported range
    if !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(descriptor&lt;47:40&gt;) then
        fault.statuscode = <a link="Fault_AddressSize" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
        return (fault, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    // Check the access flag
    if descriptor&lt;10&gt; == '0' then
        fault.statuscode = <a link="Fault_AccessFlag" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>;
        return (fault, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    // Unpack the descriptor into address and upper and lower block attributes
    walkstate.baseaddress.address = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(descriptor&lt;39:indexlsb&gt;:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(indexlsb));

    walkstate.permissions.s2ap = descriptor&lt;7:6&gt;;
    walkstate.permissions.s2xn = descriptor&lt;54&gt;;
    if <a link="impl-shared.HaveExtendedExecuteNeverExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveExtendedExecuteNeverExt()">HaveExtendedExecuteNeverExt</a>() then
        walkstate.permissions.s2xnx = descriptor&lt;53&gt;;
    else
        walkstate.permissions.s2xnx = '0';

    memattr = descriptor&lt;5:2&gt;;
    sh      = descriptor&lt;9:8&gt;;
    walkstate.memattrs   = <a link="impl-shared.S2DecodeMemAttrs.2" file="shared_pseudocode.xml" hover="function: MemoryAttributes S2DecodeMemAttrs(bits(4) attr, bits(2) sh)">S2DecodeMemAttrs</a>(memattr, sh);
    walkstate.contiguous = descriptor&lt;52&gt;;

    return (fault, walkstate);</pstext>
    </ps>
    <ps name="aarch32/translation/walk/AArch32.TranslationSizeSD" mylink="aarch32.translation.walk.AArch32.TranslationSizeSD" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.TranslationSizeSD()
// ===========================
// Determine the size of the translation

integer <anchor link="AArch32.TranslationSizeSD.1" hover="function: integer AArch32.TranslationSizeSD(SDFType sdftype)">AArch32.TranslationSizeSD</anchor>(<a link="SDFType" file="shared_pseudocode.xml" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType</a> sdftype)
    integer tsize;
    case sdftype of
        when <a link="SDFType_SmallPage" file="shared_pseudocode.xml" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_SmallPage</a>      tsize = 12;
        when <a link="SDFType_LargePage" file="shared_pseudocode.xml" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_LargePage</a>      tsize = 16;
        when <a link="SDFType_Section" file="shared_pseudocode.xml" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Section</a>        tsize = 20;
        when <a link="SDFType_Supersection" file="shared_pseudocode.xml" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Supersection</a>   tsize = 24;

    return tsize;</pstext>
    </ps>
    <ps name="aarch32/translation/walk/RemapRegsHaveResetValues" mylink="aarch32.translation.walk.RemapRegsHaveResetValues" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">boolean <anchor link="impl-aarch32.RemapRegsHaveResetValues.0" hover="function: boolean RemapRegsHaveResetValues()">RemapRegsHaveResetValues</anchor>();</pstext>
    </ps>
    <ps name="aarch32/translation/walkparams/AArch32.GetS1TTWParams" mylink="aarch32.translation.walkparams.AArch32.GetS1TTWParams" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.GetS1TTWParams()
// ========================
// Returns stage 1 translation table walk parameters from respective controlling
// system registers.

S1TTWParams <anchor link="AArch32.GetS1TTWParams.2" hover="function: S1TTWParams AArch32.GetS1TTWParams(Regime regime, bits(32) va)">AArch32.GetS1TTWParams</anchor>(<a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(32) va)
    <a link="S1TTWParams" file="shared_pseudocode.xml" hover="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams;

    case regime of
        when <a link="Regime_EL2" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  walkparams = <a link="AArch32.S1TTWParamsEL2.0" file="shared_pseudocode.xml" hover="function: S1TTWParams AArch32.S1TTWParamsEL2()">AArch32.S1TTWParamsEL2</a>();
        when <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> walkparams = <a link="AArch32.S1TTWParamsEL10.1" file="shared_pseudocode.xml" hover="function: S1TTWParams AArch32.S1TTWParamsEL10(bits(32) va)">AArch32.S1TTWParamsEL10</a>(va);
        when <a link="Regime_EL30" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> walkparams = <a link="AArch32.S1TTWParamsEL30.1" file="shared_pseudocode.xml" hover="function: S1TTWParams AArch32.S1TTWParamsEL30(bits(32) va)">AArch32.S1TTWParamsEL30</a>(va);

    return walkparams;</pstext>
    </ps>
    <ps name="aarch32/translation/walkparams/AArch32.GetS2TTWParams" mylink="aarch32.translation.walkparams.AArch32.GetS2TTWParams" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.GetS2TTWParams()
// ========================
// Gather walk parameters for stage 2 translation

S2TTWParams <anchor link="AArch32.GetS2TTWParams.0" hover="function: S2TTWParams AArch32.GetS2TTWParams()">AArch32.GetS2TTWParams</anchor>()
    <a link="S2TTWParams" file="shared_pseudocode.xml" hover="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams;

    walkparams.tgx  = <a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
    walkparams.s    = VTCR.S;
    walkparams.t0sz = VTCR.T0SZ;
    walkparams.sl0  = VTCR.SL0;
    walkparams.irgn = VTCR.IRGN0;
    walkparams.orgn = VTCR.ORGN0;
    walkparams.sh   = VTCR.SH0;
    walkparams.ee   = HSCTLR.EE;
    walkparams.ptw  = HCR.PTW;
    walkparams.vm   = HCR.VM OR HCR.DC;

    // VTCR.S must match VTCR.T0SZ[3]
    if walkparams.s != walkparams.t0sz&lt;3&gt; then
        (-, walkparams.t0sz) = <a link="impl-shared.ConstrainUnpredictableBits.1" file="shared_pseudocode.xml" hover="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a link="Unpredictable_RESVTCRS" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESVTCRS</a>);

    return walkparams;</pstext>
    </ps>
    <ps name="aarch32/translation/walkparams/AArch32.GetVARange" mylink="aarch32.translation.walkparams.AArch32.GetVARange" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.GetVARange()
// ====================
// Select the translation base address for stage 1 long-descriptor walks

VARange <anchor link="AArch32.GetVARange.3" hover="function: VARange AArch32.GetVARange(bits(32) va, bits(3) t0sz, bits(3) t1sz)">AArch32.GetVARange</anchor>(bits(32) va, bits(3) t0sz, bits(3) t1sz)
    // Lower range Input Address size
    lo_iasize = <a link="AArch32.S1IASize.1" file="shared_pseudocode.xml" hover="function: integer AArch32.S1IASize(bits(3) txsz)">AArch32.S1IASize</a>(t0sz);
    // Upper range Input Address size
    up_iasize = <a link="AArch32.S1IASize.1" file="shared_pseudocode.xml" hover="function: integer AArch32.S1IASize(bits(3) txsz)">AArch32.S1IASize</a>(t1sz);

    if t1sz == '000' &amp;&amp; t0sz == '000' then
        return <a link="VARange_LOWER" file="shared_pseudocode.xml" hover="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a>;
    elsif t1sz == '000' then
        return if <a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(va&lt;31:lo_iasize&gt;) then <a link="VARange_LOWER" file="shared_pseudocode.xml" hover="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> else <a link="VARange_UPPER" file="shared_pseudocode.xml" hover="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_UPPER</a>;
    elsif t0sz == '000' then
        return if <a link="impl-shared.IsOnes.1" file="shared_pseudocode.xml" hover="function: boolean IsOnes(bits(N) x)">IsOnes</a>(va&lt;31:up_iasize&gt;) then <a link="VARange_UPPER" file="shared_pseudocode.xml" hover="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_UPPER</a> else <a link="VARange_LOWER" file="shared_pseudocode.xml" hover="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a>;
    elsif <a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(va&lt;31:lo_iasize&gt;) then
        return <a link="VARange_LOWER" file="shared_pseudocode.xml" hover="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a>;
    elsif <a link="impl-shared.IsOnes.1" file="shared_pseudocode.xml" hover="function: boolean IsOnes(bits(N) x)">IsOnes</a>(va&lt;31:up_iasize&gt;) then
        return <a link="VARange_UPPER" file="shared_pseudocode.xml" hover="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_UPPER</a>;
    else
        // Will be reported as a Translation Fault
        return <a link="VARange" file="shared_pseudocode.xml" hover="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange</a> UNKNOWN;</pstext>
    </ps>
    <ps name="aarch32/translation/walkparams/AArch32.S1DCacheEnabled" mylink="aarch32.translation.walkparams.AArch32.S1DCacheEnabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.S1DCacheEnabled()
// =========================
// Determine cacheability of stage 1 data accesses

boolean <anchor link="AArch32.S1DCacheEnabled.1" hover="function: boolean AArch32.S1DCacheEnabled(Regime regime)">AArch32.S1DCacheEnabled</anchor>(<a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime)
    case regime of
        when <a link="Regime_EL30" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> return SCTLR_S.C == '1';
        when <a link="Regime_EL2" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  return HSCTLR.C == '1';
        when <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> return (if <a link="impl-shared.HaveAArch32EL.1" file="shared_pseudocode.xml" hover="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then SCTLR_NS.C else SCTLR.C) == '1';</pstext>
    </ps>
    <ps name="aarch32/translation/walkparams/AArch32.S1ICacheEnabled" mylink="aarch32.translation.walkparams.AArch32.S1ICacheEnabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.S1ICacheEnabled()
// =========================
// Determine cacheability of stage 1 instruction fetches

boolean <anchor link="AArch32.S1ICacheEnabled.1" hover="function: boolean AArch32.S1ICacheEnabled(Regime regime)">AArch32.S1ICacheEnabled</anchor>(<a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime)
    case regime of
        when <a link="Regime_EL30" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> return SCTLR_S.I == '1';
        when <a link="Regime_EL2" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  return HSCTLR.I == '1';
        when <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> return (if <a link="impl-shared.HaveAArch32EL.1" file="shared_pseudocode.xml" hover="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then SCTLR_NS.I else SCTLR.I) == '1';</pstext>
    </ps>
    <ps name="aarch32/translation/walkparams/AArch32.S1TTWParamsEL10" mylink="aarch32.translation.walkparams.AArch32.S1TTWParamsEL10" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.S1TTWParamsEL10()
// =========================
// Gather stage 1 translation table walk parameters for EL1&amp;0 regime
// (with EL2 enabled or disabled).

S1TTWParams <anchor link="AArch32.S1TTWParamsEL10.1" hover="function: S1TTWParams AArch32.S1TTWParamsEL10(bits(32) va)">AArch32.S1TTWParamsEL10</anchor>(bits(32) va)
    bits(64) mair;
    bit sif;
    TTBCR_Type ttbcr;
    TTBCR2_Type ttbcr2;
    SCTLR_Type sctlr;

    if <a link="impl-shared.HaveAArch32EL.1" file="shared_pseudocode.xml" hover="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
        ttbcr  = TTBCR_NS;
        ttbcr2 = TTBCR2_NS;
        sctlr  = SCTLR_NS;
        mair   = MAIR1_NS:MAIR0_NS;
        sif    = SCR.SIF;
    else
        ttbcr  = TTBCR;
        ttbcr2 = TTBCR2;
        sctlr  = SCTLR;
        mair   = MAIR1:MAIR0;
        sif    = SCR_EL3.SIF;

    assert ttbcr.EAE == '1';
    <a link="S1TTWParams" file="shared_pseudocode.xml" hover="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams;

    walkparams.t0sz   = ttbcr.T0SZ;
    walkparams.t1sz   = ttbcr.T1SZ;
    walkparams.ee     = sctlr.EE;
    walkparams.wxn    = sctlr.WXN;
    walkparams.uwxn   = sctlr.UWXN;
    walkparams.ntlsmd = if <a link="impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveTrapLoadStoreMultipleDeviceExt()">HaveTrapLoadStoreMultipleDeviceExt</a>() then sctlr.nTLSMD else '1';
    walkparams.mair   = mair;
    walkparams.sif    = sif;

    varange = <a link="AArch32.GetVARange.3" file="shared_pseudocode.xml" hover="function: VARange AArch32.GetVARange(bits(32) va, bits(3) t0sz, bits(3) t1sz)">AArch32.GetVARange</a>(va, walkparams.t0sz, walkparams.t1sz);
    if varange == <a link="VARange_LOWER" file="shared_pseudocode.xml" hover="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
        walkparams.sh   = ttbcr.SH0;
        walkparams.irgn = ttbcr.IRGN0;
        walkparams.orgn = ttbcr.ORGN0;
        walkparams.hpd  = if <a link="AArch32.HaveHPDExt.0" file="shared_pseudocode.xml" hover="function: boolean AArch32.HaveHPDExt()">AArch32.HaveHPDExt</a>() then ttbcr.T2E AND ttbcr2.HPD0 else '0';
    else
        walkparams.sh   = ttbcr.SH1;
        walkparams.irgn = ttbcr.IRGN1;
        walkparams.orgn = ttbcr.ORGN1;
        walkparams.hpd  = if <a link="AArch32.HaveHPDExt.0" file="shared_pseudocode.xml" hover="function: boolean AArch32.HaveHPDExt()">AArch32.HaveHPDExt</a>() then ttbcr.T2E AND ttbcr2.HPD1 else '0';

    return walkparams;</pstext>
    </ps>
    <ps name="aarch32/translation/walkparams/AArch32.S1TTWParamsEL2" mylink="aarch32.translation.walkparams.AArch32.S1TTWParamsEL2" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.S1TTWParamsEL2()
// ========================
// Gather stage 1 translation table walk parameters for EL2 regime

S1TTWParams <anchor link="AArch32.S1TTWParamsEL2.0" hover="function: S1TTWParams AArch32.S1TTWParamsEL2()">AArch32.S1TTWParamsEL2</anchor>()
    <a link="S1TTWParams" file="shared_pseudocode.xml" hover="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams;

    walkparams.tgx  = <a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
    walkparams.t0sz = HTCR.T0SZ;
    walkparams.irgn = HTCR.SH0;
    walkparams.orgn = HTCR.IRGN0;
    walkparams.sh   = HTCR.ORGN0;
    walkparams.hpd  = if <a link="AArch32.HaveHPDExt.0" file="shared_pseudocode.xml" hover="function: boolean AArch32.HaveHPDExt()">AArch32.HaveHPDExt</a>() then HTCR.HPD else '0';
    walkparams.ee   = HSCTLR.EE;
    walkparams.wxn  = HSCTLR.WXN;
    if <a link="impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveTrapLoadStoreMultipleDeviceExt()">HaveTrapLoadStoreMultipleDeviceExt</a>() then
        walkparams.ntlsmd = HSCTLR.nTLSMD;
    else
        walkparams.ntlsmd = '1';

    walkparams.mair = HMAIR1:HMAIR0;

    return walkparams;</pstext>
    </ps>
    <ps name="aarch32/translation/walkparams/AArch32.S1TTWParamsEL30" mylink="aarch32.translation.walkparams.AArch32.S1TTWParamsEL30" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.S1TTWParamsEL30()
// =========================
// Gather stage 1 translation table walk parameters for EL3&amp;0 regime

S1TTWParams <anchor link="AArch32.S1TTWParamsEL30.1" hover="function: S1TTWParams AArch32.S1TTWParamsEL30(bits(32) va)">AArch32.S1TTWParamsEL30</anchor>(bits(32) va)
    assert TTBCR_S.EAE == '1';
    <a link="S1TTWParams" file="shared_pseudocode.xml" hover="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams;

    walkparams.t0sz   = TTBCR_S.T0SZ;
    walkparams.t1sz   = TTBCR_S.T1SZ;
    walkparams.ee     = SCTLR_S.EE;
    walkparams.wxn    = SCTLR_S.WXN;
    walkparams.uwxn   = SCTLR_S.UWXN;
    walkparams.ntlsmd = if <a link="impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveTrapLoadStoreMultipleDeviceExt()">HaveTrapLoadStoreMultipleDeviceExt</a>() then SCTLR_S.nTLSMD else '1';
    walkparams.mair   = MAIR1_S:MAIR0_S;
    walkparams.sif    = SCR.SIF;

    varange = <a link="AArch32.GetVARange.3" file="shared_pseudocode.xml" hover="function: VARange AArch32.GetVARange(bits(32) va, bits(3) t0sz, bits(3) t1sz)">AArch32.GetVARange</a>(va, walkparams.t0sz, walkparams.t1sz);
    if varange == <a link="VARange_LOWER" file="shared_pseudocode.xml" hover="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
        walkparams.sh   = TTBCR_S.SH0;
        walkparams.irgn = TTBCR_S.IRGN0;
        walkparams.orgn = TTBCR_S.ORGN0;
        walkparams.hpd  = if <a link="AArch32.HaveHPDExt.0" file="shared_pseudocode.xml" hover="function: boolean AArch32.HaveHPDExt()">AArch32.HaveHPDExt</a>() then TTBCR_S.T2E AND TTBCR2_S.HPD0 else '0';
    else
        walkparams.sh   = TTBCR_S.SH1;
        walkparams.irgn = TTBCR_S.IRGN1;
        walkparams.orgn = TTBCR_S.ORGN1;
        walkparams.hpd  = if <a link="AArch32.HaveHPDExt.0" file="shared_pseudocode.xml" hover="function: boolean AArch32.HaveHPDExt()">AArch32.HaveHPDExt</a>() then TTBCR_S.T2E AND TTBCR2_S.HPD1 else '0';

    return walkparams;</pstext>
    </ps>
    <ps name="aarch64/debug/breakpoint/AArch64.BreakpointMatch" mylink="aarch64.debug.breakpoint.AArch64.BreakpointMatch" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.BreakpointMatch()
// =========================
// Breakpoint matching in an AArch64 translation regime.

boolean <anchor link="AArch64.BreakpointMatch.4" hover="function: boolean AArch64.BreakpointMatch(integer n, bits(64) vaddress,&#13; AccType acctype, integer size)">AArch64.BreakpointMatch</anchor>(integer n, bits(64) vaddress,
                                <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, integer size)
    assert !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());
    assert n &lt; <a link="impl-shared.NumBreakpointsImplemented.0" file="shared_pseudocode.xml" hover="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>();

    enabled = DBGBCR_EL1[n].E == '1';
    ispriv = PSTATE.EL != <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>;
    linked = DBGBCR_EL1[n].BT == '0x01';
    isbreakpnt = TRUE;
    linked_to = FALSE;

    state_match = <a link="AArch64.StateMatch.8" file="shared_pseudocode.xml" hover="function: boolean AArch64.StateMatch(bits(2) SSC_in,  bit HMC_in,&#13; bits(2) PxC_in, boolean linked_in, bits(4) LBN,&#13; boolean isbreakpnt, AccType acctype, boolean ispriv)">AArch64.StateMatch</a>(DBGBCR_EL1[n].SSC, DBGBCR_EL1[n].HMC, DBGBCR_EL1[n].PMC,
                                     linked, DBGBCR_EL1[n].LBN, isbreakpnt, acctype, ispriv);
    value_match = <a link="AArch64.BreakpointValueMatch.3" file="shared_pseudocode.xml" hover="function: boolean AArch64.BreakpointValueMatch(integer n_in, bits(64) vaddress, boolean linked_to)">AArch64.BreakpointValueMatch</a>(n, vaddress, linked_to);

    if <a link="impl-shared.HaveAArch32.0" file="shared_pseudocode.xml" hover="function: boolean HaveAArch32()">HaveAArch32</a>() &amp;&amp; size == 4 then                    // Check second halfword
        // If the breakpoint address and BAS of an Address breakpoint match the address of the
        // second halfword of an instruction, but not the address of the first halfword, it is
        // CONSTRAINED UNPREDICTABLE whether or not this breakpoint generates a Breakpoint debug
        // event.
        match_i = <a link="AArch64.BreakpointValueMatch.3" file="shared_pseudocode.xml" hover="function: boolean AArch64.BreakpointValueMatch(integer n_in, bits(64) vaddress, boolean linked_to)">AArch64.BreakpointValueMatch</a>(n, vaddress + 2, linked_to);
        if !value_match &amp;&amp; match_i then
            value_match = <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_BPMATCHHALF" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_BPMATCHHALF</a>);
    if vaddress&lt;1&gt; == '1' &amp;&amp; DBGBCR_EL1[n].BAS == '1111' then
        // The above notwithstanding, if DBGBCR_EL1[n].BAS == '1111', then it is CONSTRAINED
        // UNPREDICTABLE whether or not a Breakpoint debug event is generated for an instruction
        // at the address DBGBVR_EL1[n]+2.
        if value_match then value_match = <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_BPMATCHHALF" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_BPMATCHHALF</a>);

    match = value_match &amp;&amp; state_match &amp;&amp; enabled;

    return match;</pstext>
    </ps>
    <ps name="aarch64/debug/breakpoint/AArch64.BreakpointValueMatch" mylink="aarch64.debug.breakpoint.AArch64.BreakpointValueMatch" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.BreakpointValueMatch()
// ==============================

boolean <anchor link="AArch64.BreakpointValueMatch.3" hover="function: boolean AArch64.BreakpointValueMatch(integer n_in, bits(64) vaddress, boolean linked_to)">AArch64.BreakpointValueMatch</anchor>(integer n_in, bits(64) vaddress, boolean linked_to)

    // "n" is the identity of the breakpoint unit to match against.
    // "vaddress" is the current instruction address, ignored if linked_to is TRUE and for Context
    //   matching breakpoints.
    // "linked_to" is TRUE if this is a call from StateMatch for linking.
    integer n = n_in;

    // If a non-existent breakpoint then it is CONSTRAINED UNPREDICTABLE whether this gives
    // no match or the breakpoint is mapped to another UNKNOWN implemented breakpoint.
    if n &gt;= <a link="impl-shared.NumBreakpointsImplemented.0" file="shared_pseudocode.xml" hover="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() then
        <a link="Constraint" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint</a> c;
        (c, n) = <a link="impl-shared.ConstrainUnpredictableInteger.3" file="shared_pseudocode.xml" hover="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high, Unpredictable which)">ConstrainUnpredictableInteger</a>(0, <a link="impl-shared.NumBreakpointsImplemented.0" file="shared_pseudocode.xml" hover="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() - 1, <a link="Unpredictable_BPNOTIMPL" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_BPNOTIMPL</a>);
        assert c IN {<a link="Constraint_DISABLED" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>, <a link="Constraint_UNKNOWN" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>};
        if c == <a link="Constraint_DISABLED" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a> then return FALSE;

    // If this breakpoint is not enabled, it cannot generate a match. (This could also happen on a
    // call from StateMatch for linking).
    if DBGBCR_EL1[n].E == '0' then return FALSE;

    context_aware = (n &gt;= (<a link="impl-shared.NumBreakpointsImplemented.0" file="shared_pseudocode.xml" hover="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() - <a link="impl-shared.NumContextAwareBreakpointsImplemented.0" file="shared_pseudocode.xml" hover="function: integer NumContextAwareBreakpointsImplemented()">NumContextAwareBreakpointsImplemented</a>()));

    // If BT is set to a reserved type, behaves either as disabled or as a not-reserved type.
    dbgtype = DBGBCR_EL1[n].BT;

    if ((dbgtype IN {'011x','11xx'} &amp;&amp; !<a link="impl-shared.HaveVirtHostExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; !<a link="impl-shared.HaveV82Debug.0" file="shared_pseudocode.xml" hover="function: boolean HaveV82Debug()">HaveV82Debug</a>()) ||    // Context matching
          dbgtype == '010x' ||                                                      // Reserved
          (dbgtype != '0x0x' &amp;&amp; !context_aware) ||                                  // Context matching
          (dbgtype == '1xxx' &amp;&amp; !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>))) then                                 // EL2 extension
        (c, dbgtype) = <a link="impl-shared.ConstrainUnpredictableBits.1" file="shared_pseudocode.xml" hover="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a link="Unpredictable_RESBPTYPE" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESBPTYPE</a>);
        assert c IN {<a link="Constraint_DISABLED" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>, <a link="Constraint_UNKNOWN" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>};
        if c == <a link="Constraint_DISABLED" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a> then return FALSE;
        // Otherwise the value returned by ConstrainUnpredictableBits must be a not-reserved value

    // Determine what to compare against.
    match_addr = (dbgtype == '0x0x');
    match_vmid = (dbgtype == '10xx');
    match_cid  = (dbgtype == '001x');
    match_cid1 = (dbgtype IN { '101x', 'x11x'});
    match_cid2 = (dbgtype == '11xx');
    linked     = (dbgtype == 'xxx1');

    // If this is a call from StateMatch, return FALSE if the breakpoint is not programmed for a
    // VMID and/or context ID match, of if not context-aware. The above assertions mean that the
    // code can just test for match_addr == TRUE to confirm all these things.
    if linked_to &amp;&amp; (!linked || match_addr) then return FALSE;

    // If called from BreakpointMatch return FALSE for Linked context ID and/or VMID matches.
    if !linked_to &amp;&amp; linked &amp;&amp; !match_addr then return FALSE;

    // Do the comparison.
    boolean BVR_match;
    if match_addr then
        boolean byte_select_match;
        byte = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(vaddress&lt;1:0&gt;);
        if <a link="impl-shared.HaveAArch32.0" file="shared_pseudocode.xml" hover="function: boolean HaveAArch32()">HaveAArch32</a>() then
            // T32 instructions can be executed at EL0 in an AArch64 translation regime.
            assert byte IN {0,2};                 // "vaddress" is halfword aligned
            byte_select_match = (DBGBCR_EL1[n].BAS&lt;byte&gt; == '1');
        else
            assert byte == 0;                     // "vaddress" is word aligned
            byte_select_match = TRUE;             // DBGBCR_EL1[n].BAS&lt;byte&gt; is RES1
        // If the DBGxVR&lt;n&gt;_EL1.RESS field bits are not a sign extension of the MSB
        // of DBGBVR&lt;n&gt;_EL1.VA, it is UNPREDICTABLE whether they appear to be
        // included in the match.
        // If 'vaddress' is outside of the current virtual address space, then the access
        // generates a Translation fault.
        integer top = <a link="AArch64.VAMax.0" file="shared_pseudocode.xml" hover="function: integer AArch64.VAMax()">AArch64.VAMax</a>();
        if !<a link="impl-shared.IsOnes.1" file="shared_pseudocode.xml" hover="function: boolean IsOnes(bits(N) x)">IsOnes</a>(DBGBVR_EL1[n]&lt;63:top&gt;) &amp;&amp; !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(DBGBVR_EL1[n]&lt;63:top&gt;) then
            if <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_DBGxVR_RESS" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_DBGxVR_RESS</a>) then
                top = 63;
        BVR_match = (vaddress&lt;top:2&gt; == DBGBVR_EL1[n]&lt;top:2&gt;) &amp;&amp; byte_select_match;

    elsif match_cid then
        if <a link="impl-shared.IsInHost.0" file="shared_pseudocode.xml" hover="function: boolean IsInHost()">IsInHost</a>() then
            BVR_match = (CONTEXTIDR_EL2&lt;31:0&gt; == DBGBVR_EL1[n]&lt;31:0&gt;);
        else
            BVR_match = (PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; CONTEXTIDR_EL1&lt;31:0&gt; == DBGBVR_EL1[n]&lt;31:0&gt;);
    elsif match_cid1 then
        BVR_match = (PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; !<a link="impl-shared.IsInHost.0" file="shared_pseudocode.xml" hover="function: boolean IsInHost()">IsInHost</a>() &amp;&amp; CONTEXTIDR_EL1&lt;31:0&gt; == DBGBVR_EL1[n]&lt;31:0&gt;);
    boolean BXVR_match;
    if match_vmid then
        bits(16) vmid;
        bits(16) bvr_vmid;
        if !<a link="impl-shared.Have16bitVMID.0" file="shared_pseudocode.xml" hover="function: boolean Have16bitVMID()">Have16bitVMID</a>() || VTCR_EL2.VS == '0' then
            vmid = <a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(VTTBR_EL2.VMID&lt;7:0&gt;, 16);
            bvr_vmid = <a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(DBGBVR_EL1[n]&lt;39:32&gt;, 16);
        else
            vmid = VTTBR_EL2.VMID;
            bvr_vmid = DBGBVR_EL1[n]&lt;47:32&gt;;
        BXVR_match = (PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                      !<a link="impl-shared.IsInHost.0" file="shared_pseudocode.xml" hover="function: boolean IsInHost()">IsInHost</a>() &amp;&amp;
                      vmid == bvr_vmid);
    elsif match_cid2 then
        BXVR_match = (PSTATE.EL != <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> &amp;&amp; (<a link="impl-shared.HaveVirtHostExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() || <a link="impl-shared.HaveV82Debug.0" file="shared_pseudocode.xml" hover="function: boolean HaveV82Debug()">HaveV82Debug</a>()) &amp;&amp;
                      <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                      DBGBVR_EL1[n]&lt;63:32&gt; == CONTEXTIDR_EL2&lt;31:0&gt;);

    bvr_match_valid = (match_addr || match_cid || match_cid1);
    bxvr_match_valid = (match_vmid || match_cid2);

    match = (!bxvr_match_valid || BXVR_match) &amp;&amp; (!bvr_match_valid || BVR_match);

    return match;</pstext>
    </ps>
    <ps name="aarch64/debug/breakpoint/AArch64.StateMatch" mylink="aarch64.debug.breakpoint.AArch64.StateMatch" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.StateMatch()
// ====================
// Determine whether a breakpoint or watchpoint is enabled in the current mode and state.

boolean <anchor link="AArch64.StateMatch.8" hover="function: boolean AArch64.StateMatch(bits(2) SSC_in,  bit HMC_in,&#13; bits(2) PxC_in, boolean linked_in, bits(4) LBN,&#13; boolean isbreakpnt, AccType acctype, boolean ispriv)">AArch64.StateMatch</anchor>(bits(2) SSC_in,  bit HMC_in,
                           bits(2) PxC_in, boolean linked_in, bits(4) LBN,
                           boolean isbreakpnt, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean ispriv)

    // "SSC_in","HMC_in","PxC_in" are the control fields from the DBGBCR[n] or DBGWCR[n] register.
    // "linked_in" is TRUE if this is a linked breakpoint/watchpoint type.
    // "LBN" is the linked breakpoint number from the DBGBCR[n] or DBGWCR[n] register.
    // "isbreakpnt" is TRUE for breakpoints, FALSE for watchpoints.
    // "ispriv" is valid for watchpoints, and selects between privileged and unprivileged accesses.
    bits(2) SSC = SSC_in;
    bit HMC = HMC_in;
    bits(2) PxC = PxC_in;
    boolean linked = linked_in;

    // If parameters are set to a reserved type, behaves as either disabled or a defined type
    <a link="Constraint" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint</a> c;
    (c, SSC, HMC, PxC) = <a link="impl-shared.CheckValidStateMatch.4" file="shared_pseudocode.xml" hover="function: (Constraint, bits(2), bit, bits(2)) CheckValidStateMatch(bits(2) SSC_in, bit HMC_in, bits(2) PxC_in,&#13; boolean isbreakpnt)">CheckValidStateMatch</a>(SSC, HMC, PxC, isbreakpnt);
    if c == <a link="Constraint_DISABLED" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a> then return FALSE;
    // Otherwise the HMC,SSC,PxC values are either valid or the values returned by
    // CheckValidStateMatch are valid.

    EL3_match = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; HMC == '1' &amp;&amp; SSC&lt;0&gt; == '0';
    EL2_match = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; ((HMC == '1' &amp;&amp; (SSC:PxC != '1000')) || SSC == '11');
    EL1_match = PxC&lt;0&gt; == '1';
    EL0_match = PxC&lt;1&gt; == '1';

    boolean priv_match;
    if <a link="impl-shared.HaveNV2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveNV2Ext()">HaveNV2Ext</a>() &amp;&amp; acctype == <a link="AccType_NV2REGISTER" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NV2REGISTER</a> &amp;&amp; !isbreakpnt then
        priv_match = EL2_match;
    elsif !ispriv &amp;&amp; !isbreakpnt then
        priv_match = EL0_match;
    else
        case PSTATE.EL of
            when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>  priv_match = EL3_match;
            when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>  priv_match = EL2_match;
            when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>  priv_match = EL1_match;
            when <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>  priv_match = EL0_match;

    boolean security_state_match;
    ss = <a link="impl-shared.CurrentSecurityState.0" file="shared_pseudocode.xml" hover="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>();
    case SSC of
        when '00' security_state_match = TRUE;                             // Both
        when '01' security_state_match = ss == <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a>;               // Non-secure only
        when '10' security_state_match = ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>;                  // Secure only
        when '11' security_state_match = (HMC == '1' || ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>);  // HMC=1 -&gt; Both, 0 -&gt; Secure only
    integer lbn;
    if linked then
        // "LBN" must be an enabled context-aware breakpoint unit. If it is not context-aware then
        // it is CONSTRAINED UNPREDICTABLE whether this gives no match, or LBN is mapped to some
        // UNKNOWN breakpoint that is context-aware.
        lbn = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(LBN);
        first_ctx_cmp = <a link="impl-shared.NumBreakpointsImplemented.0" file="shared_pseudocode.xml" hover="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() - <a link="impl-shared.NumContextAwareBreakpointsImplemented.0" file="shared_pseudocode.xml" hover="function: integer NumContextAwareBreakpointsImplemented()">NumContextAwareBreakpointsImplemented</a>();
        last_ctx_cmp = <a link="impl-shared.NumBreakpointsImplemented.0" file="shared_pseudocode.xml" hover="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() - 1;
        if (lbn &lt; first_ctx_cmp || lbn &gt; last_ctx_cmp) then
            (c, lbn) = <a link="impl-shared.ConstrainUnpredictableInteger.3" file="shared_pseudocode.xml" hover="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high, Unpredictable which)">ConstrainUnpredictableInteger</a>(first_ctx_cmp, last_ctx_cmp, <a link="Unpredictable_BPNOTCTXCMP" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_BPNOTCTXCMP</a>);
            assert c IN {<a link="Constraint_DISABLED" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>, <a link="Constraint_NONE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>, <a link="Constraint_UNKNOWN" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>};
            case c of
                when <a link="Constraint_DISABLED" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>  return FALSE;      // Disabled
                when <a link="Constraint_NONE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>      linked = FALSE;    // No linking
                // Otherwise ConstrainUnpredictableInteger returned a context-aware breakpoint

    boolean linked_match;
    if linked then
        vaddress = bits(64) UNKNOWN;
        linked_to = TRUE;
        linked_match = <a link="AArch64.BreakpointValueMatch.3" file="shared_pseudocode.xml" hover="function: boolean AArch64.BreakpointValueMatch(integer n_in, bits(64) vaddress, boolean linked_to)">AArch64.BreakpointValueMatch</a>(lbn, vaddress, linked_to);

    return priv_match &amp;&amp; security_state_match &amp;&amp; (!linked || linked_match);</pstext>
    </ps>
    <ps name="aarch64/debug/enables/AArch64.GenerateDebugExceptions" mylink="aarch64.debug.enables.AArch64.GenerateDebugExceptions" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.GenerateDebugExceptions()
// =================================

boolean <anchor link="AArch64.GenerateDebugExceptions.0" hover="function: boolean AArch64.GenerateDebugExceptions()">AArch64.GenerateDebugExceptions</anchor>()
    return <a link="AArch64.GenerateDebugExceptionsFrom.3" file="shared_pseudocode.xml" hover="function: boolean AArch64.GenerateDebugExceptionsFrom(bits(2) from, boolean secure, bit mask)">AArch64.GenerateDebugExceptionsFrom</a>(PSTATE.EL, <a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>(), PSTATE.D);</pstext>
    </ps>
    <ps name="aarch64/debug/enables/AArch64.GenerateDebugExceptionsFrom" mylink="aarch64.debug.enables.AArch64.GenerateDebugExceptionsFrom" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.GenerateDebugExceptionsFrom()
// =====================================

boolean <anchor link="AArch64.GenerateDebugExceptionsFrom.3" hover="function: boolean AArch64.GenerateDebugExceptionsFrom(bits(2) from, boolean secure, bit mask)">AArch64.GenerateDebugExceptionsFrom</anchor>(bits(2) from, boolean secure, bit mask)

    if OSLSR_EL1.OSLK == '1' || <a link="impl-shared.DoubleLockStatus.0" file="shared_pseudocode.xml" hover="function: boolean DoubleLockStatus()">DoubleLockStatus</a>() || <a link="impl-shared.Halted.0" file="shared_pseudocode.xml" hover="function: boolean Halted()">Halted</a>() then
        return FALSE;

    route_to_el2 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; (!secure || <a link="impl-shared.IsSecureEL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>()) &amp;&amp; (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1');
    target = (if route_to_el2 then <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> else <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>);
    boolean enabled;
    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; secure then
        enabled = MDCR_EL3.SDD == '0';
        if from == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then
            enabled = enabled || SDER32_EL3.SUIDEN == '1';
    else
        enabled = TRUE;

    if from == target then
        enabled = enabled &amp;&amp; MDSCR_EL1.KDE == '1' &amp;&amp; mask == '0';
    else
        enabled = enabled &amp;&amp; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(target) &gt; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(from);

    return enabled;</pstext>
    </ps>
    <ps name="aarch64/debug/pmu/AArch64.CheckForPMUOverflow" mylink="aarch64.debug.pmu.AArch64.CheckForPMUOverflow" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.CheckForPMUOverflow()
// =============================
// Signal Performance Monitors overflow IRQ and CTI overflow events

<anchor link="AArch64.CheckForPMUOverflow.0" hover="function: AArch64.CheckForPMUOverflow()">AArch64.CheckForPMUOverflow</anchor>()
    boolean pmuirq;
    bit E;
    pmuirq = PMCR_EL0.E == '1' &amp;&amp; PMINTENSET_EL1.C == '1' &amp;&amp; PMOVSSET_EL0.C == '1';
    integer counters = <a link="impl-shared.GetNumEventCounters.0" file="shared_pseudocode.xml" hover="function: integer GetNumEventCounters()">GetNumEventCounters</a>();
    if counters != 0 then
        for idx = 0 to counters - 1
            E = if <a link="AArch64.PMUCounterIsHyp.1" file="shared_pseudocode.xml" hover="function: boolean AArch64.PMUCounterIsHyp(integer n)">AArch64.PMUCounterIsHyp</a>(idx) then MDCR_EL2.HPME else PMCR_EL0.E;
            if E == '1' &amp;&amp; PMINTENSET_EL1&lt;idx&gt; == '1' &amp;&amp; PMOVSSET_EL0&lt;idx&gt; == '1' then pmuirq = TRUE;

    SetInterruptRequestLevel(<a link="InterruptID_PMUIRQ" file="shared_pseudocode.xml" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_PMUIRQ</a>, if pmuirq then HIGH else LOW);

    CTI_SetEventLevel(<a link="CrossTriggerIn_PMUOverflow" file="shared_pseudocode.xml" hover="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow,&#13; CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3,&#13; CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1,&#13; CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}">CrossTriggerIn_PMUOverflow</a>, if pmuirq then HIGH else LOW);

    // The request remains set until the condition is cleared. (For example, an interrupt handler
    // or cross-triggered event handler clears the overflow status flag by writing to PMOVSCLR_EL0.)</pstext>
    </ps>
    <ps name="aarch64/debug/pmu/AArch64.ClearEventCounters" mylink="aarch64.debug.pmu.AArch64.ClearEventCounters" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.ClearEventCounters()
// ============================
// Zero all the event counters.

<anchor link="AArch64.ClearEventCounters.0" hover="function: AArch64.ClearEventCounters()">AArch64.ClearEventCounters</anchor>()
    integer counters = <a link="AArch64.GetNumEventCountersAccessible.0" file="shared_pseudocode.xml" hover="function: integer AArch64.GetNumEventCountersAccessible()">AArch64.GetNumEventCountersAccessible</a>();
    if counters != 0 then
        for idx = 0 to counters - 1
            PMEVCNTR_EL0[idx] = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();</pstext>
    </ps>
    <ps name="aarch64/debug/pmu/AArch64.CountPMUEvents" mylink="aarch64.debug.pmu.AArch64.CountPMUEvents" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.CountPMUEvents()
// ========================
// Return TRUE if counter "idx" should count its event. For the cycle counter, idx == CYCLE_COUNTER_ID.

boolean <anchor link="AArch64.CountPMUEvents.1" hover="function: boolean AArch64.CountPMUEvents(integer idx)">AArch64.CountPMUEvents</anchor>(integer idx)
    assert idx == <a link="CYCLE_COUNTER_ID" file="shared_pseudocode.xml" hover="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> || idx &lt; <a link="impl-shared.GetNumEventCounters.0" file="shared_pseudocode.xml" hover="function: integer GetNumEventCounters()">GetNumEventCounters</a>();
    boolean debug;
    boolean enabled;
    boolean prohibited;
    boolean filtered;
    boolean frozen;
    boolean resvd_for_el2;
    bit E;
    bit spme;
    bits(32) ovflws;
    // Event counting is disabled in Debug state
    debug = <a link="impl-shared.Halted.0" file="shared_pseudocode.xml" hover="function: boolean Halted()">Halted</a>();

    // Software can reserve some counters for EL2
    resvd_for_el2 = <a link="AArch64.PMUCounterIsHyp.1" file="shared_pseudocode.xml" hover="function: boolean AArch64.PMUCounterIsHyp(integer n)">AArch64.PMUCounterIsHyp</a>(idx);

    // Main enable controls
    if idx == <a link="CYCLE_COUNTER_ID" file="shared_pseudocode.xml" hover="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then
        enabled = PMCR_EL0.E == '1' &amp;&amp; PMCNTENSET_EL0.C == '1';
    else
        E = if resvd_for_el2 then MDCR_EL2.HPME else PMCR_EL0.E;
        enabled = E == '1' &amp;&amp; PMCNTENSET_EL0&lt;idx&gt; == '1';

    // Event counting is allowed unless it is prohibited by any rule below
    prohibited = FALSE;

    // Event counting in Secure state is prohibited if all of:
    // * EL3 is implemented
    // * MDCR_EL3.SPME == 0, and either:
    //   - FEAT_PMUv3p7 is not implemented
    //   - MDCR_EL3.MPMX == 0
    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>() then
        if <a link="impl-shared.HavePMUv3p7.0" file="shared_pseudocode.xml" hover="function: boolean HavePMUv3p7()">HavePMUv3p7</a>() then
            prohibited = MDCR_EL3.&lt;SPME,MPMX&gt; == '00';
        else
            prohibited = MDCR_EL3.SPME == '0';

    // Event counting at EL3 is prohibited if all of:
    // * FEAT_PMUv3p7 is implemented
    // * One of the following is true:
    //   - MDCR_EL3.SPME == 0
    //   - PMNx is not reserved for EL2
    // * MDCR_EL3.MPMX == 1
    if !prohibited &amp;&amp; PSTATE.EL == <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> &amp;&amp; <a link="impl-shared.HavePMUv3p7.0" file="shared_pseudocode.xml" hover="function: boolean HavePMUv3p7()">HavePMUv3p7</a>() then
        prohibited = MDCR_EL3.MPMX == '1' &amp;&amp; (MDCR_EL3.SPME == '0' || !resvd_for_el2);

    // Event counting at EL2 is prohibited if all of:
    // * The HPMD Extension is implemented
    // * PMNx is not reserved for EL2
    // * MDCR_EL2.HPMD == 1
    if !prohibited &amp;&amp; PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; <a link="impl-shared.HaveHPMDExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveHPMDExt()">HaveHPMDExt</a>() &amp;&amp; !resvd_for_el2 then
        prohibited = MDCR_EL2.HPMD == '1';

    // The IMPLEMENTATION DEFINED authentication interface might override software
    if prohibited &amp;&amp; !<a link="impl-shared.HaveNoSecurePMUDisableOverride.0" file="shared_pseudocode.xml" hover="function: boolean HaveNoSecurePMUDisableOverride()">HaveNoSecurePMUDisableOverride</a>() then
        prohibited = !<a link="impl-shared.ExternalSecureNoninvasiveDebugEnabled.0" file="shared_pseudocode.xml" hover="function: boolean ExternalSecureNoninvasiveDebugEnabled()">ExternalSecureNoninvasiveDebugEnabled</a>();

    // Event counting might be frozen
    frozen = FALSE;

    // If FEAT_PMUv3p7 is implemented, event counting can be frozen
    if <a link="impl-shared.HavePMUv3p7.0" file="shared_pseudocode.xml" hover="function: boolean HavePMUv3p7()">HavePMUv3p7</a>() then
        ovflws = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(PMOVSSET_EL0&lt;<a link="impl-shared.GetNumEventCounters.0" file="shared_pseudocode.xml" hover="function: integer GetNumEventCounters()">GetNumEventCounters</a>()-1:0&gt;);
        if resvd_for_el2 then
            FZ = MDCR_EL2.HPMFZO;
            ovflws&lt;<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(MDCR_EL2.HPMN)-1:0&gt; = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();
        else
            FZ = PMCR_EL0.FZO;
            if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(MDCR_EL2.HPMN) &lt; <a link="impl-shared.GetNumEventCounters.0" file="shared_pseudocode.xml" hover="function: integer GetNumEventCounters()">GetNumEventCounters</a>() then
                ovflws&lt;<a link="impl-shared.GetNumEventCounters.0" file="shared_pseudocode.xml" hover="function: integer GetNumEventCounters()">GetNumEventCounters</a>()-1:<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(MDCR_EL2.HPMN)&gt; = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();
        frozen = (FZ == '1') &amp;&amp; !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(ovflws);

    // PMCR_EL0.DP disables the cycle counter when event counting is prohibited
    if (prohibited || frozen) &amp;&amp; idx == <a link="CYCLE_COUNTER_ID" file="shared_pseudocode.xml" hover="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then
        enabled = enabled &amp;&amp; (PMCR_EL0.DP == '0');
        // Otherwise whether event counting is prohibited does not affect the cycle counter
        prohibited = FALSE;
        frozen = FALSE;

    // If FEAT_PMUv3p5 is implemented, cycle counting can be prohibited.
    // This is not overridden by PMCR_EL0.DP.
    if <a link="impl-shared.HavePMUv3p5.0" file="shared_pseudocode.xml" hover="function: boolean HavePMUv3p5()">HavePMUv3p5</a>() &amp;&amp; idx == <a link="CYCLE_COUNTER_ID" file="shared_pseudocode.xml" hover="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then
        if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>() &amp;&amp; MDCR_EL3.SCCD == '1' then
            prohibited = TRUE;
        if PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; MDCR_EL2.HCCD == '1' then
            prohibited = TRUE;

    // If FEAT_PMUv3p7 is implemented, cycle counting an be prohibited at EL3.
    // This is not overriden by PMCR_EL0.DP.
    if <a link="impl-shared.HavePMUv3p7.0" file="shared_pseudocode.xml" hover="function: boolean HavePMUv3p7()">HavePMUv3p7</a>() &amp;&amp; idx == <a link="CYCLE_COUNTER_ID" file="shared_pseudocode.xml" hover="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then
        if PSTATE.EL == <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> &amp;&amp; MDCR_EL3.MCCD == '1' then
            prohibited = TRUE;

    // Event counting can be filtered by the {P, U, NSK, NSU, NSH, M, SH} bits
    filter = if idx == <a link="CYCLE_COUNTER_ID" file="shared_pseudocode.xml" hover="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then PMCCFILTR_EL0&lt;31:0&gt; else PMEVTYPER_EL0[idx]&lt;31:0&gt;;

    P   = filter&lt;31&gt;;
    U   = filter&lt;30&gt;;
    NSK = if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then filter&lt;29&gt; else '0';
    NSU = if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then filter&lt;28&gt; else '0';
    NSH = if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then filter&lt;27&gt; else '0';
    M   = if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then filter&lt;26&gt; else '0';
    SH  = if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a link="impl-shared.HaveSecureEL2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() then filter&lt;24&gt; else '0';

    ss = <a link="impl-shared.CurrentSecurityState.0" file="shared_pseudocode.xml" hover="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>();
    case PSTATE.EL of
        when <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> filtered = if ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> then U == '1' else U != NSU;
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> filtered = if ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> then P == '1' else P != NSK;
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> filtered = if ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> then NSH == SH else NSH == '0';
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> filtered = M != P;

    return !debug &amp;&amp; enabled &amp;&amp; !prohibited &amp;&amp; !filtered &amp;&amp; !frozen;</pstext>
    </ps>
    <ps name="aarch64/debug/pmu/AArch64.GetNumEventCountersAccessible" mylink="aarch64.debug.pmu.AArch64.GetNumEventCountersAccessible" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.GetNumEventCountersAccessible()
// =======================================
// Return the number of event counters that can be accessed at the current Exception level.

integer <anchor link="AArch64.GetNumEventCountersAccessible.0" hover="function: integer AArch64.GetNumEventCountersAccessible()">AArch64.GetNumEventCountersAccessible</anchor>()
    integer n;
    integer total_counters = <a link="impl-shared.GetNumEventCounters.0" file="shared_pseudocode.xml" hover="function: integer GetNumEventCounters()">GetNumEventCounters</a>();
    // Software can reserve some counters for EL2
    if PSTATE.EL IN {<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>, <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() then
        n = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(MDCR_EL2.HPMN);
        if n &gt; total_counters || (!<a link="impl-shared.HaveFeatHPMN0.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatHPMN0()">HaveFeatHPMN0</a>() &amp;&amp; n == 0) then
            (-, n) = <a link="impl-shared.ConstrainUnpredictableInteger.3" file="shared_pseudocode.xml" hover="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high, Unpredictable which)">ConstrainUnpredictableInteger</a>(0, total_counters,
                                                   <a link="Unpredictable_PMUEVENTCOUNTER" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_PMUEVENTCOUNTER</a>);
    else
        n = total_counters;

    return n;</pstext>
    </ps>
    <ps name="aarch64/debug/pmu/AArch64.IncrementEventCounter" mylink="aarch64.debug.pmu.AArch64.IncrementEventCounter" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.IncrementEventCounter()
// ===============================
// Increment the specified event counter by the specified amount.

<anchor link="AArch64.IncrementEventCounter.2" hover="function: AArch64.IncrementEventCounter(integer idx, integer increment)">AArch64.IncrementEventCounter</anchor>(integer idx, integer increment)
    integer old_value;
    integer new_value;
    integer ovflw;
    bit lp;
    old_value = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PMEVCNTR_EL0[idx]);
    new_value = old_value + <a link="impl-shared.PMUCountValue.2" file="shared_pseudocode.xml" hover="function: integer PMUCountValue(integer n, integer V)">PMUCountValue</a>(idx, increment);

    if <a link="impl-shared.HavePMUv3p5.0" file="shared_pseudocode.xml" hover="function: boolean HavePMUv3p5()">HavePMUv3p5</a>() then
        PMEVCNTR_EL0[idx] = new_value&lt;63:0&gt;;
        lp = if <a link="AArch64.PMUCounterIsHyp.1" file="shared_pseudocode.xml" hover="function: boolean AArch64.PMUCounterIsHyp(integer n)">AArch64.PMUCounterIsHyp</a>(idx) then MDCR_EL2.HLP else PMCR_EL0.LP;
        ovflw = if lp == '1' then 64 else 32;
    else
        PMEVCNTR_EL0[idx] = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(new_value&lt;31:0&gt;);
        ovflw = 32;

    if old_value&lt;64:ovflw&gt; != new_value&lt;64:ovflw&gt; then
        PMOVSSET_EL0&lt;idx&gt; = '1';
        PMOVSCLR_EL0&lt;idx&gt; = '1';
        // Check for the CHAIN event from an even counter
        if idx&lt;0&gt; == '0' &amp;&amp; idx + 1 &lt; <a link="impl-shared.GetNumEventCounters.0" file="shared_pseudocode.xml" hover="function: integer GetNumEventCounters()">GetNumEventCounters</a>() &amp;&amp; (!<a link="impl-shared.HavePMUv3p5.0" file="shared_pseudocode.xml" hover="function: boolean HavePMUv3p5()">HavePMUv3p5</a>() || lp == '0') then
            <a link="impl-shared.PMUEvent.3" file="shared_pseudocode.xml" hover="function: PMUEvent(bits(16) event, integer increment, integer idx)">PMUEvent</a>(<a link="PMU_EVENT_CHAIN" file="shared_pseudocode.xml" hover="constant bits(16) PMU_EVENT_CHAIN = 0x001E&lt;15:0&gt;">PMU_EVENT_CHAIN</a>, 1, idx + 1);</pstext>
    </ps>
    <ps name="aarch64/debug/pmu/AArch64.PMUCounterIsHyp" mylink="aarch64.debug.pmu.AArch64.PMUCounterIsHyp" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.PMUCounterIsHyp
// =======================
// Returns TRUE if a counter is reserved for use by EL2, FALSE otherwise.

boolean <anchor link="AArch64.PMUCounterIsHyp.1" hover="function: boolean AArch64.PMUCounterIsHyp(integer n)">AArch64.PMUCounterIsHyp</anchor>(integer n)
    boolean resvd_for_el2;
    // Software can reserve some event counters for EL2
    if n != <a link="CYCLE_COUNTER_ID" file="shared_pseudocode.xml" hover="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> &amp;&amp; <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
        resvd_for_el2 = n &gt;= <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(MDCR_EL2.HPMN);
        if <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(MDCR_EL2.HPMN) &gt; <a link="impl-shared.GetNumEventCounters.0" file="shared_pseudocode.xml" hover="function: integer GetNumEventCounters()">GetNumEventCounters</a>() || (!<a link="impl-shared.HaveFeatHPMN0.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatHPMN0()">HaveFeatHPMN0</a>() &amp;&amp; <a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(MDCR_EL2.HPMN)) then
            resvd_for_el2 = boolean UNKNOWN;
    else
        resvd_for_el2 = FALSE;

    return resvd_for_el2;</pstext>
    </ps>
    <ps name="aarch64/debug/pmu/AArch64.PMUCycle" mylink="aarch64.debug.pmu.AArch64.PMUCycle" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.PMUCycle()
// ==================
// Called at the end of each cycle to increment event counters and
// check for PMU overflow. In pseudocode, a cycle ends after the
// execution of the operational pseudocode.

<anchor link="AArch64.PMUCycle.0" hover="function: AArch64.PMUCycle()">AArch64.PMUCycle</anchor>()
    if !<a link="impl-shared.HavePMUv3.0" file="shared_pseudocode.xml" hover="function: boolean HavePMUv3()">HavePMUv3</a>() then
        return;

    <a link="impl-shared.PMUEvent.1" file="shared_pseudocode.xml" hover="function: PMUEvent(bits(16) event)">PMUEvent</a>(<a link="PMU_EVENT_CPU_CYCLES" file="shared_pseudocode.xml" hover="constant bits(16) PMU_EVENT_CPU_CYCLES = 0x0011&lt;15:0&gt;">PMU_EVENT_CPU_CYCLES</a>);

    integer counters = <a link="impl-shared.GetNumEventCounters.0" file="shared_pseudocode.xml" hover="function: integer GetNumEventCounters()">GetNumEventCounters</a>();
    if counters != 0 then
        for idx = 0 to counters - 1
            if <a link="AArch64.CountPMUEvents.1" file="shared_pseudocode.xml" hover="function: boolean AArch64.CountPMUEvents(integer idx)">AArch64.CountPMUEvents</a>(idx) then
                accumulated = PMUEventAccumulator[idx];
                <a link="AArch64.IncrementEventCounter.2" file="shared_pseudocode.xml" hover="function: AArch64.IncrementEventCounter(integer idx, integer increment)">AArch64.IncrementEventCounter</a>(idx, accumulated);
            PMUEventAccumulator[idx] = 0;

    integer old_value;
    integer new_value;
    integer ovflw;
    if (<a link="AArch64.CountPMUEvents.1" file="shared_pseudocode.xml" hover="function: boolean AArch64.CountPMUEvents(integer idx)">AArch64.CountPMUEvents</a>(<a link="CYCLE_COUNTER_ID" file="shared_pseudocode.xml" hover="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a>) &amp;&amp;
        (!<a link="impl-shared.HaveAArch32.0" file="shared_pseudocode.xml" hover="function: boolean HaveAArch32()">HaveAArch32</a>() || PMCR_EL0.LC == '1' || PMCR_EL0.D == '0' || <a link="impl-shared.HasElapsed64Cycles.0" file="shared_pseudocode.xml" hover="function: boolean HasElapsed64Cycles()">HasElapsed64Cycles</a>())) then
        old_value = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PMCCNTR_EL0);
        new_value = old_value + 1;
        PMCCNTR_EL0 = new_value&lt;63:0&gt;;

        if <a link="impl-shared.HaveAArch32.0" file="shared_pseudocode.xml" hover="function: boolean HaveAArch32()">HaveAArch32</a>() then
            ovflw = if PMCR_EL0.LC == '1' then 64 else 32;
        else
            ovflw = 64;

        if old_value&lt;64:ovflw&gt; != new_value&lt;64:ovflw&gt; then
            PMOVSSET_EL0.C = '1';
            PMOVSCLR_EL0.C = '1';

    <a link="AArch64.CheckForPMUOverflow.0" file="shared_pseudocode.xml" hover="function: AArch64.CheckForPMUOverflow()">AArch64.CheckForPMUOverflow</a>();</pstext>
    </ps>
    <ps name="aarch64/debug/pmu/AArch64.PMUSwIncrement" mylink="aarch64.debug.pmu.AArch64.PMUSwIncrement" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.PMUSwIncrement()
// ========================
// Generate PMU Events on a write to PMSWINC_EL0.

<anchor link="AArch64.PMUSwIncrement.1" hover="function: AArch64.PMUSwIncrement(bits(32) sw_incr)">AArch64.PMUSwIncrement</anchor>(bits(32) sw_incr)
    integer counters = <a link="AArch64.GetNumEventCountersAccessible.0" file="shared_pseudocode.xml" hover="function: integer AArch64.GetNumEventCountersAccessible()">AArch64.GetNumEventCountersAccessible</a>();
    if counters != 0 then
        for idx = 0 to counters - 1
            if sw_incr&lt;idx&gt; == '1' then
                <a link="impl-shared.PMUEvent.3" file="shared_pseudocode.xml" hover="function: PMUEvent(bits(16) event, integer increment, integer idx)">PMUEvent</a>(<a link="PMU_EVENT_SW_INCR" file="shared_pseudocode.xml" hover="constant bits(16) PMU_EVENT_SW_INCR = 0x0000&lt;15:0&gt;">PMU_EVENT_SW_INCR</a>, 1, idx);</pstext>
    </ps>
    <ps name="aarch64/debug/statisticalprofiling/CollectContextIDR1" mylink="aarch64.debug.statisticalprofiling.CollectContextIDR1" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CollectContextIDR1()
// ====================

boolean <anchor link="impl-aarch64.CollectContextIDR1.0" hover="function: boolean CollectContextIDR1()">CollectContextIDR1</anchor>()
    if !<a link="impl-aarch64.StatisticalProfilingEnabled.0" file="shared_pseudocode.xml" hover="function: boolean StatisticalProfilingEnabled()">StatisticalProfilingEnabled</a>() then return FALSE;
    if  PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then return FALSE;
    if <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then return FALSE;
    return PMSCR_EL1.CX == '1';</pstext>
    </ps>
    <ps name="aarch64/debug/statisticalprofiling/CollectContextIDR2" mylink="aarch64.debug.statisticalprofiling.CollectContextIDR2" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CollectContextIDR2()
// ====================

boolean <anchor link="impl-aarch64.CollectContextIDR2.0" hover="function: boolean CollectContextIDR2()">CollectContextIDR2</anchor>()
    if !<a link="impl-aarch64.StatisticalProfilingEnabled.0" file="shared_pseudocode.xml" hover="function: boolean StatisticalProfilingEnabled()">StatisticalProfilingEnabled</a>() then return FALSE;
    if !<a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() then return FALSE;
    return PMSCR_EL2.CX == '1';</pstext>
    </ps>
    <ps name="aarch64/debug/statisticalprofiling/CollectPhysicalAddress" mylink="aarch64.debug.statisticalprofiling.CollectPhysicalAddress" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CollectPhysicalAddress()
// ========================

boolean <anchor link="impl-aarch64.CollectPhysicalAddress.0" hover="function: boolean CollectPhysicalAddress()">CollectPhysicalAddress</anchor>()
    if !<a link="impl-aarch64.StatisticalProfilingEnabled.0" file="shared_pseudocode.xml" hover="function: boolean StatisticalProfilingEnabled()">StatisticalProfilingEnabled</a>() then return FALSE;
    (owning_ss, owning_el) = <a link="impl-aarch64.ProfilingBufferOwner.0" file="shared_pseudocode.xml" hover="function: (SecurityState, bits(2)) ProfilingBufferOwner()">ProfilingBufferOwner</a>();
    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; (owning_ss != <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> || <a link="impl-shared.IsSecureEL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>()) then
        return PMSCR_EL2.PA == '1' &amp;&amp; (owning_el == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> || PMSCR_EL1.PA == '1');
    else
        return PMSCR_EL1.PA == '1';</pstext>
    </ps>
    <ps name="aarch64/debug/statisticalprofiling/CollectTimeStamp" mylink="aarch64.debug.statisticalprofiling.CollectTimeStamp" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CollectTimeStamp()
// ==================

TimeStamp <anchor link="impl-aarch64.CollectTimeStamp.0" hover="function: TimeStamp CollectTimeStamp()">CollectTimeStamp</anchor>()

    if !<a link="impl-aarch64.StatisticalProfilingEnabled.0" file="shared_pseudocode.xml" hover="function: boolean StatisticalProfilingEnabled()">StatisticalProfilingEnabled</a>() then return <a link="TimeStamp_None" file="shared_pseudocode.xml" hover="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_None</a>;
    (-, owning_el) = <a link="impl-aarch64.ProfilingBufferOwner.0" file="shared_pseudocode.xml" hover="function: (SecurityState, bits(2)) ProfilingBufferOwner()">ProfilingBufferOwner</a>();

    if owning_el == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then
        if PMSCR_EL2.TS == '0' then return <a link="TimeStamp_None" file="shared_pseudocode.xml" hover="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_None</a>;
    else
        if PMSCR_EL1.TS == '0' then return <a link="TimeStamp_None" file="shared_pseudocode.xml" hover="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_None</a>;

    bits(2) PCT_el1;
    if !<a link="impl-shared.HaveECVExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveECVExt()">HaveECVExt</a>() then
        PCT_el1 = '0':PMSCR_EL1.PCT&lt;0&gt;;       // PCT&lt;1&gt; is RES0
    else
        PCT_el1 = PMSCR_EL1.PCT;
        if PCT_el1 == '10' then
            // Reserved value
            (-, PCT_el1) = <a link="impl-shared.ConstrainUnpredictableBits.1" file="shared_pseudocode.xml" hover="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a link="Unpredictable_PMSCR_PCT" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_PMSCR_PCT</a>);
    if <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() then
        bits(2) PCT_el2;
        if !<a link="impl-shared.HaveECVExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveECVExt()">HaveECVExt</a>() then
            PCT_el2 = '0':PMSCR_EL2.PCT&lt;0&gt;;   // PCT&lt;1&gt; is RES0
        else
            PCT_el2 = PMSCR_EL2.PCT;
            if PCT_el2 == '10' then
                // Reserved value
                (-, PCT_el2) = <a link="impl-shared.ConstrainUnpredictableBits.1" file="shared_pseudocode.xml" hover="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a link="Unpredictable_PMSCR_PCT" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_PMSCR_PCT</a>);
        case PCT_el2 of
            when '00'
                return <a link="TimeStamp_Virtual" file="shared_pseudocode.xml" hover="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Virtual</a>;
            when '01'
                if owning_el == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then return <a link="TimeStamp_Physical" file="shared_pseudocode.xml" hover="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Physical</a>;
            when '11'
                assert <a link="impl-shared.HaveECVExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveECVExt()">HaveECVExt</a>();          // FEAT_ECV must be implemented
                if owning_el == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; PCT_el1 == '00' then
                    return <a link="TimeStamp_Virtual" file="shared_pseudocode.xml" hover="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Virtual</a>;
                else
                    return <a link="TimeStamp_OffsetPhysical" file="shared_pseudocode.xml" hover="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_OffsetPhysical</a>;
            otherwise
                <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();

    case PCT_el1 of
        when '00' return <a link="TimeStamp_Virtual" file="shared_pseudocode.xml" hover="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Virtual</a>;
        when '01' return <a link="TimeStamp_Physical" file="shared_pseudocode.xml" hover="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Physical</a>;
        when '11'
            assert <a link="impl-shared.HaveECVExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveECVExt()">HaveECVExt</a>();              // FEAT_ECV must be implemented
            return <a link="TimeStamp_OffsetPhysical" file="shared_pseudocode.xml" hover="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_OffsetPhysical</a>;
        otherwise <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();</pstext>
    </ps>
    <ps name="aarch64/debug/statisticalprofiling/OpType" mylink="aarch64.debug.statisticalprofiling.OpType" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="OpType" hover="enumeration OpType {&#13; OpType_Load, OpType_Store, OpType_LoadAtomic, OpType_Branch, OpType_Other }">OpType</anchor> {
    <anchor link="OpType_Load" hover="enumeration OpType {&#13; OpType_Load, OpType_Store, OpType_LoadAtomic, OpType_Branch, OpType_Other }">OpType_Load</anchor>,           // Any memory-read operation other than atomics, compare-and-swap, and swap
    <anchor link="OpType_Store" hover="enumeration OpType {&#13; OpType_Load, OpType_Store, OpType_LoadAtomic, OpType_Branch, OpType_Other }">OpType_Store</anchor>,          // Any memory-write operation, including atomics without return
    <anchor link="OpType_LoadAtomic" hover="enumeration OpType {&#13; OpType_Load, OpType_Store, OpType_LoadAtomic, OpType_Branch, OpType_Other }">OpType_LoadAtomic</anchor>,     // Atomics with return, compare-and-swap and swap
    <anchor link="OpType_Branch" hover="enumeration OpType {&#13; OpType_Load, OpType_Store, OpType_LoadAtomic, OpType_Branch, OpType_Other }">OpType_Branch</anchor>,         // Software write to the PC
    <anchor link="OpType_Other" hover="enumeration OpType {&#13; OpType_Load, OpType_Store, OpType_LoadAtomic, OpType_Branch, OpType_Other }">OpType_Other</anchor>           // Any other class of operation
};</pstext>
    </ps>
    <ps name="aarch64/debug/statisticalprofiling/ProfilingBufferEnabled" mylink="aarch64.debug.statisticalprofiling.ProfilingBufferEnabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ProfilingBufferEnabled()
// ========================

boolean <anchor link="impl-aarch64.ProfilingBufferEnabled.0" hover="function: boolean ProfilingBufferEnabled()">ProfilingBufferEnabled</anchor>()
    if !<a link="impl-shared.HaveStatisticalProfiling.0" file="shared_pseudocode.xml" hover="function: boolean HaveStatisticalProfiling()">HaveStatisticalProfiling</a>() then return FALSE;
    (owning_ss, owning_el) = <a link="impl-aarch64.ProfilingBufferOwner.0" file="shared_pseudocode.xml" hover="function: (SecurityState, bits(2)) ProfilingBufferOwner()">ProfilingBufferOwner</a>();
    state_match = ((owning_ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>    &amp;&amp; SCR_EL3.NS == '0') ||
                   (owning_ss == <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a> &amp;&amp; SCR_EL3.NS == '1'));
    return (!<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(owning_el) &amp;&amp; state_match &amp;&amp;
            PMBLIMITR_EL1.E == '1' &amp;&amp; PMBSR_EL1.S == '0');</pstext>
    </ps>
    <ps name="aarch64/debug/statisticalprofiling/ProfilingBufferOwner" mylink="aarch64.debug.statisticalprofiling.ProfilingBufferOwner" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ProfilingBufferOwner()
// ======================

(SecurityState, bits(2)) <anchor link="impl-aarch64.ProfilingBufferOwner.0" hover="function: (SecurityState, bits(2)) ProfilingBufferOwner()">ProfilingBufferOwner</anchor>()
    <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> owning_ss;

    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
        owning_ss = if MDCR_EL3.NSPB&lt;1&gt; == '0' then <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> else <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a>;
    else
        owning_ss = if <a link="impl-shared.SecureOnlyImplementation.0" file="shared_pseudocode.xml" hover="function: boolean SecureOnlyImplementation()">SecureOnlyImplementation</a>() then <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> else <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a>;

    bits(2) owning_el;
    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; (owning_ss != <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> || <a link="impl-shared.IsSecureEL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>()) then
        owning_el = if MDCR_EL2.E2PB == '00' then <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> else <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;
    else
        owning_el = <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;

    return (owning_ss, owning_el);</pstext>
    </ps>
    <ps name="aarch64/debug/statisticalprofiling/ProfilingSynchronizationBarrier" mylink="aarch64.debug.statisticalprofiling.ProfilingSynchronizationBarrier" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Barrier to ensure that all existing profiling data has been formatted, and profiling buffer
// addresses have been translated such that writes to the profiling buffer have been initiated.
// A following DSB completes when writes to the profiling buffer have completed.
<anchor link="impl-aarch64.ProfilingSynchronizationBarrier.0" hover="function: ProfilingSynchronizationBarrier()">ProfilingSynchronizationBarrier</anchor>();</pstext>
    </ps>
    <ps name="aarch64/debug/statisticalprofiling/SPECollectRecord" mylink="aarch64.debug.statisticalprofiling.SPECollectRecord" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SPECollectRecord()
// ==================
// Returns TRUE if the sampled class of instructions or operations, as
// determined by PMSFCR_EL1, are recorded and FALSE otherwise.

boolean <anchor link="impl-aarch64.SPECollectRecord.3" hover="function: boolean SPECollectRecord(bits(64) events, integer total_latency, OpType optype)">SPECollectRecord</anchor>(bits(64) events, integer total_latency, <a link="OpType" file="shared_pseudocode.xml" hover="enumeration OpType {&#13; OpType_Load, OpType_Store, OpType_LoadAtomic, OpType_Branch, OpType_Other }">OpType</a> optype)
    assert <a link="impl-aarch64.StatisticalProfilingEnabled.0" file="shared_pseudocode.xml" hover="function: boolean StatisticalProfilingEnabled()">StatisticalProfilingEnabled</a>();

    bits(64) mask = 0xAA&lt;63:0&gt;;                             // Bits [7,5,3,1]
    if <a link="impl-shared.HaveStatisticalProfilingv1p1.0" file="shared_pseudocode.xml" hover="function: boolean HaveStatisticalProfilingv1p1()">HaveStatisticalProfilingv1p1</a>() then mask&lt;11&gt; = '1';  // Alignment Flag
    if <a link="impl-shared.HaveStatisticalProfilingv1p2.0" file="shared_pseudocode.xml" hover="function: boolean HaveStatisticalProfilingv1p2()">HaveStatisticalProfilingv1p2</a>() then mask&lt;6&gt; = '1';   // Not taken flag

    mask&lt;63:48&gt; = bits(16) IMPLEMENTATION_DEFINED "SPE mask 63:48";
    mask&lt;31:24&gt; = bits(8) IMPLEMENTATION_DEFINED "SPE mask 31:24";
    mask&lt;15:12&gt; = bits(4) IMPLEMENTATION_DEFINED "SPE mask 15:12";

    // Check for UNPREDICTABLE case
    if (<a link="impl-shared.HaveStatisticalProfilingv1p2.0" file="shared_pseudocode.xml" hover="function: boolean HaveStatisticalProfilingv1p2()">HaveStatisticalProfilingv1p2</a>() &amp;&amp; PMSFCR_EL1.&lt;FnE,FE&gt; == '11' &amp;&amp;
        !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(PMSEVFR_EL1 AND PMSNEVFR_EL1 AND mask)) then
        if <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_BADPMSFCR" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_BADPMSFCR</a>) then
            return FALSE;
    else
        // Filtering by event
        if PMSFCR_EL1.FE == '1' &amp;&amp; !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(PMSEVFR_EL1) then
            e = events AND mask;
            m = PMSEVFR_EL1 AND mask;
            if !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(NOT(e) AND m) then return FALSE;

        // Filtering by inverse event
        if (<a link="impl-shared.HaveStatisticalProfilingv1p2.0" file="shared_pseudocode.xml" hover="function: boolean HaveStatisticalProfilingv1p2()">HaveStatisticalProfilingv1p2</a>() &amp;&amp; PMSFCR_EL1.FnE == '1' &amp;&amp;
            !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(PMSNEVFR_EL1)) then
            e = events AND mask;
            m = PMSNEVFR_EL1 AND mask;
            if !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(e AND m) then return FALSE;

    // Filtering by type
    if PMSFCR_EL1.FT == '1' &amp;&amp; !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(PMSFCR_EL1.&lt;B,LD,ST&gt;) then
        case optype of
            when <a link="OpType_Branch" file="shared_pseudocode.xml" hover="enumeration OpType {&#13; OpType_Load, OpType_Store, OpType_LoadAtomic, OpType_Branch, OpType_Other }">OpType_Branch</a>
                if PMSFCR_EL1.B == '0' then return FALSE;
            when <a link="OpType_Load" file="shared_pseudocode.xml" hover="enumeration OpType {&#13; OpType_Load, OpType_Store, OpType_LoadAtomic, OpType_Branch, OpType_Other }">OpType_Load</a>
                if PMSFCR_EL1.LD == '0' then return FALSE;
            when <a link="OpType_Store" file="shared_pseudocode.xml" hover="enumeration OpType {&#13; OpType_Load, OpType_Store, OpType_LoadAtomic, OpType_Branch, OpType_Other }">OpType_Store</a>
                if PMSFCR_EL1.ST == '0' then return FALSE;
            when <a link="OpType_LoadAtomic" file="shared_pseudocode.xml" hover="enumeration OpType {&#13; OpType_Load, OpType_Store, OpType_LoadAtomic, OpType_Branch, OpType_Other }">OpType_LoadAtomic</a>
                if PMSFCR_EL1.&lt;LD,ST&gt; == '00' then return FALSE;
            otherwise
                return FALSE;

    // Filtering by latency
    if PMSFCR_EL1.FL == '1' &amp;&amp; !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(PMSLATFR_EL1.MINLAT) then
        if total_latency &lt; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PMSLATFR_EL1.MINLAT) then
            return FALSE;

    // Check for UNPREDICTABLE cases
    if ((PMSFCR_EL1.FE == '1' &amp;&amp; <a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(PMSEVFR_EL1 AND mask)) ||
        (PMSFCR_EL1.FT == '1' &amp;&amp; <a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(PMSFCR_EL1.&lt;B,LD,ST&gt;)) ||
        (PMSFCR_EL1.FL == '1' &amp;&amp; <a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(PMSLATFR_EL1.MINLAT))) then
        return <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_BADPMSFCR" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_BADPMSFCR</a>);

    if (<a link="impl-shared.HaveStatisticalProfilingv1p2.0" file="shared_pseudocode.xml" hover="function: boolean HaveStatisticalProfilingv1p2()">HaveStatisticalProfilingv1p2</a>() &amp;&amp;
        ((PMSFCR_EL1.FnE == '1' &amp;&amp; <a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(PMSNEVFR_EL1 AND mask)) ||
        (PMSFCR_EL1.&lt;FnE,FE&gt; == '11' &amp;&amp;
            !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(PMSEVFR_EL1 AND PMSNEVFR_EL1 AND mask)))) then
        return <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_BADPMSFCR" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_BADPMSFCR</a>);

    return TRUE;</pstext>
    </ps>
    <ps name="aarch64/debug/statisticalprofiling/StatisticalProfilingEnabled" mylink="aarch64.debug.statisticalprofiling.StatisticalProfilingEnabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// StatisticalProfilingEnabled()
// =============================

boolean <anchor link="impl-aarch64.StatisticalProfilingEnabled.0" hover="function: boolean StatisticalProfilingEnabled()">StatisticalProfilingEnabled</anchor>()
    if !<a link="impl-shared.HaveStatisticalProfiling.0" file="shared_pseudocode.xml" hover="function: boolean HaveStatisticalProfiling()">HaveStatisticalProfiling</a>() || <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() || !<a link="impl-aarch64.ProfilingBufferEnabled.0" file="shared_pseudocode.xml" hover="function: boolean ProfilingBufferEnabled()">ProfilingBufferEnabled</a>() then
        return FALSE;

    tge_set = <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1';
    (owning_ss, owning_el) = <a link="impl-aarch64.ProfilingBufferOwner.0" file="shared_pseudocode.xml" hover="function: (SecurityState, bits(2)) ProfilingBufferOwner()">ProfilingBufferOwner</a>();
    if (<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(owning_el) &lt;  <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) || (tge_set &amp;&amp; owning_el == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) ||
        owning_ss != <a link="impl-shared.CurrentSecurityState.0" file="shared_pseudocode.xml" hover="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>())  then
        return FALSE;
    bit spe_bit;
    case PSTATE.EL of
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>  <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>  spe_bit = PMSCR_EL2.E2SPE;
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>  spe_bit = PMSCR_EL1.E1SPE;
        when <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>  spe_bit = (if tge_set then PMSCR_EL2.E0HSPE else PMSCR_EL1.E0SPE);

    return spe_bit == '1';</pstext>
    </ps>
    <ps name="aarch64/debug/statisticalprofiling/TimeStamp" mylink="aarch64.debug.statisticalprofiling.TimeStamp" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="TimeStamp" hover="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp</anchor> {
    <anchor link="TimeStamp_None" hover="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_None</anchor>,              // No timestamp
    <anchor link="TimeStamp_CoreSight" hover="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_CoreSight</anchor>,         // CoreSight time (IMPLEMENTATION DEFINED)
    <anchor link="TimeStamp_Physical" hover="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Physical</anchor>,          // Physical counter value with no offset
    <anchor link="TimeStamp_OffsetPhysical" hover="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_OffsetPhysical</anchor>,    // Physical counter value minus CNTPOFF_EL2
    <anchor link="TimeStamp_Virtual" hover="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Virtual</anchor>  };        // Physical counter value minus CNTVOFF_EL2</pstext>
    </ps>
    <ps name="aarch64/debug/takeexceptiondbg/AArch64.TakeExceptionInDebugState" mylink="aarch64.debug.takeexceptiondbg.AArch64.TakeExceptionInDebugState" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.TakeExceptionInDebugState()
// ===================================
// Take an exception in Debug state to an Exception level using AArch64.

<anchor link="AArch64.TakeExceptionInDebugState.2" hover="function: AArch64.TakeExceptionInDebugState(bits(2) target_el, ExceptionRecord exception_in)">AArch64.TakeExceptionInDebugState</anchor>(bits(2) target_el, <a link="ExceptionRecord" file="shared_pseudocode.xml" hover="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception_in)
    assert <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(target_el) &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(target_el) &amp;&amp; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt;= <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL);
    <a link="ExceptionRecord" file="shared_pseudocode.xml" hover="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception = exception_in;
    boolean sync_errors;
    if <a link="impl-shared.HaveIESB.0" file="shared_pseudocode.xml" hover="function: boolean HaveIESB()">HaveIESB</a>() then
        sync_errors = <a link="impl-aarch64.SCTLR.read.1" file="shared_pseudocode.xml" hover="accessor: SCTLRType SCTLR[bits(2) regime]">SCTLR</a>[target_el].IESB == '1';
        if <a link="impl-shared.HaveDoubleFaultExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>() then
            sync_errors = sync_errors || (SCR_EL3.&lt;EA,NMEA&gt; == '11' &amp;&amp; target_el == <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>);
        // SCTLR[].IESB and/or SCR_EL3.NMEA (if applicable) might be ignored in Debug state.
        if !<a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_IESBinDebug" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_IESBinDebug</a>) then
            sync_errors = FALSE;
    else
        sync_errors = FALSE;

    <a link="impl-shared.SynchronizeContext.0" file="shared_pseudocode.xml" hover="function: SynchronizeContext()">SynchronizeContext</a>();

    // If coming from AArch32 state, the top parts of the X[] registers might be set to zero
    from_32 = <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>();
    if from_32 then <a link="AArch64.MaybeZeroRegisterUppers.0" file="shared_pseudocode.xml" hover="function: AArch64.MaybeZeroRegisterUppers()">AArch64.MaybeZeroRegisterUppers</a>();

    <a link="AArch64.ReportException.2" file="shared_pseudocode.xml" hover="function: AArch64.ReportException(ExceptionRecord exception, bits(2) target_el)">AArch64.ReportException</a>(exception, target_el);

    PSTATE.EL = target_el;
    PSTATE.nRW = '0';
    PSTATE.SP = '1';

    <a link="impl-shared.SPSR.write.0" file="shared_pseudocode.xml" hover="accessor: SPSR[] = bits(N) value">SPSR</a>[] = bits(64) UNKNOWN;
    <a link="impl-aarch64.ELR.write.0" file="shared_pseudocode.xml" hover="accessor: ELR[] = bits(64) value">ELR</a>[] = bits(64) UNKNOWN;

    // PSTATE.{SS,D,A,I,F} are not observable and ignored in Debug state, so behave as if UNKNOWN.
    PSTATE.&lt;SS,D,A,I,F&gt; = bits(5) UNKNOWN;
    PSTATE.IL = '0';
    if from_32 then                             // Coming from AArch32
        PSTATE.IT = '00000000';
        PSTATE.T = '0';                         // PSTATE.J is RES0
    if (<a link="impl-shared.HavePANExt.0" file="shared_pseudocode.xml" hover="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; (PSTATE.EL == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> || (PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; <a link="impl-shared.ELIsInHost.1" file="shared_pseudocode.xml" hover="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>))) &amp;&amp;
        <a link="impl-aarch64.SCTLR.read.0" file="shared_pseudocode.xml" hover="accessor: SCTLRType SCTLR[]">SCTLR</a>[].SPAN == '0') then
        PSTATE.PAN = '1';
    if <a link="impl-shared.HaveUAOExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveUAOExt()">HaveUAOExt</a>() then PSTATE.UAO = '0';
    if <a link="impl-shared.HaveBTIExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveBTIExt()">HaveBTIExt</a>() then PSTATE.BTYPE = '00';
    if <a link="impl-shared.HaveSSBSExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = bit UNKNOWN;
    if <a link="impl-shared.HaveMTEExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveMTEExt()">HaveMTEExt</a>() then PSTATE.TCO = '1';

    DLR_EL0 = bits(64) UNKNOWN;
    DSPSR_EL0 = bits(64) UNKNOWN;

    EDSCR.ERR = '1';
    <a link="impl-shared.UpdateEDSCRFields.0" file="shared_pseudocode.xml" hover="function: UpdateEDSCRFields()">UpdateEDSCRFields</a>();                        // Update EDSCR processor state flags.

    if sync_errors then
        <a link="impl-shared.SynchronizeErrors.0" file="shared_pseudocode.xml" hover="function: SynchronizeErrors()">SynchronizeErrors</a>();

    <a link="impl-shared.EndOfInstruction.0" file="shared_pseudocode.xml" hover="function: EndOfInstruction()">EndOfInstruction</a>();</pstext>
    </ps>
    <ps name="aarch64/debug/watchpoint/AArch64.WatchpointByteMatch" mylink="aarch64.debug.watchpoint.AArch64.WatchpointByteMatch" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.WatchpointByteMatch()
// =============================

boolean <anchor link="AArch64.WatchpointByteMatch.3" hover="function: boolean AArch64.WatchpointByteMatch(integer n, AccType acctype, bits(64) vaddress)">AArch64.WatchpointByteMatch</anchor>(integer n, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, bits(64) vaddress)

    integer top = <a link="AArch64.VAMax.0" file="shared_pseudocode.xml" hover="function: integer AArch64.VAMax()">AArch64.VAMax</a>();
    bottom = if DBGWVR_EL1[n]&lt;2&gt; == '1' then 2 else 3;            // Word or doubleword
    byte_select_match = (DBGWCR_EL1[n].BAS&lt;<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(vaddress&lt;bottom-1:0&gt;)&gt; != '0');
    mask = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(DBGWCR_EL1[n].MASK);

    // If DBGWCR_EL1[n].MASK is non-zero value and DBGWCR_EL1[n].BAS is not set to '11111111', or
    // DBGWCR_EL1[n].BAS specifies a non-contiguous set of bytes behavior is CONSTRAINED
    // UNPREDICTABLE.
    if mask &gt; 0 &amp;&amp; !<a link="impl-shared.IsOnes.1" file="shared_pseudocode.xml" hover="function: boolean IsOnes(bits(N) x)">IsOnes</a>(DBGWCR_EL1[n].BAS) then
        byte_select_match = <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_WPMASKANDBAS" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_WPMASKANDBAS</a>);
    else
        LSB = (DBGWCR_EL1[n].BAS AND NOT(DBGWCR_EL1[n].BAS - 1));  MSB = (DBGWCR_EL1[n].BAS + LSB);
        if !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(MSB AND (MSB - 1)) then                     // Not contiguous
            byte_select_match = <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_WPBASCONTIGUOUS" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_WPBASCONTIGUOUS</a>);
            bottom = 3;                                        // For the whole doubleword

    // If the address mask is set to a reserved value, the behavior is CONSTRAINED UNPREDICTABLE.
    if mask &gt; 0 &amp;&amp; mask &lt;= 2 then
        <a link="Constraint" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint</a> c;
        (c, mask) = <a link="impl-shared.ConstrainUnpredictableInteger.3" file="shared_pseudocode.xml" hover="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high, Unpredictable which)">ConstrainUnpredictableInteger</a>(3, 31, <a link="Unpredictable_RESWPMASK" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESWPMASK</a>);
        assert c IN {<a link="Constraint_DISABLED" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>, <a link="Constraint_NONE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>, <a link="Constraint_UNKNOWN" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>};
        case c of
            when <a link="Constraint_DISABLED" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>  return FALSE;            // Disabled
            when <a link="Constraint_NONE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>      mask = 0;                // No masking
            // Otherwise the value returned by ConstrainUnpredictableInteger is a not-reserved value

    boolean WVR_match;
    if mask &gt; bottom then
        // If the DBGxVR&lt;n&gt;_EL1.RESS field bits are not a sign extension of the MSB
        // of DBGBVR&lt;n&gt;_EL1.VA, it is UNPREDICTABLE whether they appear to be
        // included in the match.
        if !<a link="impl-shared.IsOnes.1" file="shared_pseudocode.xml" hover="function: boolean IsOnes(bits(N) x)">IsOnes</a>(DBGBVR_EL1[n]&lt;63:top&gt;) &amp;&amp; !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(DBGBVR_EL1[n]&lt;63:top&gt;) then
            if <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_DBGxVR_RESS" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_DBGxVR_RESS</a>) then
                top = 63;
        WVR_match = (vaddress&lt;top:mask&gt; == DBGWVR_EL1[n]&lt;top:mask&gt;);
        // If masked bits of DBGWVR_EL1[n] are not zero, the behavior is CONSTRAINED UNPREDICTABLE.
        if WVR_match &amp;&amp; !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(DBGWVR_EL1[n]&lt;mask-1:bottom&gt;) then
            WVR_match = <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_WPMASKEDBITS" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_WPMASKEDBITS</a>);
    else
        WVR_match = vaddress&lt;top:bottom&gt; == DBGWVR_EL1[n]&lt;top:bottom&gt;;

    return WVR_match &amp;&amp; byte_select_match;</pstext>
    </ps>
    <ps name="aarch64/debug/watchpoint/AArch64.WatchpointMatch" mylink="aarch64.debug.watchpoint.AArch64.WatchpointMatch" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.WatchpointMatch()
// =========================
// Watchpoint matching in an AArch64 translation regime.

boolean <anchor link="AArch64.WatchpointMatch.6" hover="function: boolean AArch64.WatchpointMatch(integer n, bits(64) vaddress, integer size, boolean ispriv,&#13; AccType acctype, boolean iswrite)">AArch64.WatchpointMatch</anchor>(integer n, bits(64) vaddress, integer size, boolean ispriv,
                                <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite)
    assert !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());
    assert n &lt; <a link="impl-shared.NumWatchpointsImplemented.0" file="shared_pseudocode.xml" hover="function: integer NumWatchpointsImplemented()">NumWatchpointsImplemented</a>();

    // "ispriv" is:
    //  * FALSE for all loads, stores, and atomic operations executed at EL0.
    //  * FALSE if the access is unprivileged.
    //  * TRUE for all other loads, stores, and atomic operations.

    enabled = DBGWCR_EL1[n].E == '1';
    linked = DBGWCR_EL1[n].WT == '1';
    isbreakpnt = FALSE;

    state_match = <a link="AArch64.StateMatch.8" file="shared_pseudocode.xml" hover="function: boolean AArch64.StateMatch(bits(2) SSC_in,  bit HMC_in,&#13; bits(2) PxC_in, boolean linked_in, bits(4) LBN,&#13; boolean isbreakpnt, AccType acctype, boolean ispriv)">AArch64.StateMatch</a>(DBGWCR_EL1[n].SSC, DBGWCR_EL1[n].HMC, DBGWCR_EL1[n].PAC,
                                     linked, DBGWCR_EL1[n].LBN, isbreakpnt, acctype, ispriv);
    ls_match = FALSE;
    if acctype == <a link="AccType_ATOMICRW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a> then
        ls_match = (DBGWCR_EL1[n].LSC != '00');
    else
        ls_match = (DBGWCR_EL1[n].LSC&lt;(if iswrite then 1 else 0)&gt; == '1');

    value_match = FALSE;
    for byte = 0 to size - 1
        value_match = value_match || <a link="AArch64.WatchpointByteMatch.3" file="shared_pseudocode.xml" hover="function: boolean AArch64.WatchpointByteMatch(integer n, AccType acctype, bits(64) vaddress)">AArch64.WatchpointByteMatch</a>(n, acctype, vaddress + byte);

    return value_match &amp;&amp; state_match &amp;&amp; ls_match &amp;&amp; enabled;</pstext>
    </ps>
    <ps name="aarch64/exceptions/aborts/AArch64.Abort" mylink="aarch64.exceptions.aborts.AArch64.Abort" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.Abort()
// ===============
// Abort and Debug exception handling in an AArch64 translation regime.

<anchor link="AArch64.Abort.2" hover="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</anchor>(bits(64) vaddress, <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)

    if <a link="impl-shared.IsDebugException.1" file="shared_pseudocode.xml" hover="function: boolean IsDebugException(FaultRecord fault)">IsDebugException</a>(fault) then
        if fault.acctype == <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> then
            if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fault.debugmoe == <a link="DebugException_VectorCatch" file="shared_pseudocode.xml" hover="constant bits(4) DebugException_VectorCatch = '0101'">DebugException_VectorCatch</a> then
                <a link="AArch64.VectorCatchException.1" file="shared_pseudocode.xml" hover="function: AArch64.VectorCatchException(FaultRecord fault)">AArch64.VectorCatchException</a>(fault);
            else
                <a link="AArch64.BreakpointException.1" file="shared_pseudocode.xml" hover="function: AArch64.BreakpointException(FaultRecord fault)">AArch64.BreakpointException</a>(fault);
        else
            <a link="AArch64.WatchpointException.2" file="shared_pseudocode.xml" hover="function: AArch64.WatchpointException(bits(64) vaddress, FaultRecord fault)">AArch64.WatchpointException</a>(vaddress, fault);
    elsif fault.acctype == <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> then
        <a link="AArch64.InstructionAbort.2" file="shared_pseudocode.xml" hover="function: AArch64.InstructionAbort(bits(64) vaddress, FaultRecord fault)">AArch64.InstructionAbort</a>(vaddress, fault);
    else
        <a link="AArch64.DataAbort.2" file="shared_pseudocode.xml" hover="function: AArch64.DataAbort(bits(64) vaddress, FaultRecord fault)">AArch64.DataAbort</a>(vaddress, fault);</pstext>
    </ps>
    <ps name="aarch64/exceptions/aborts/AArch64.AbortSyndrome" mylink="aarch64.exceptions.aborts.AArch64.AbortSyndrome" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.AbortSyndrome()
// =======================
// Creates an exception syndrome record for Abort and Watchpoint exceptions
// from an AArch64 translation regime.

ExceptionRecord <anchor link="AArch64.AbortSyndrome.3" hover="function: ExceptionRecord AArch64.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(64) vaddress)">AArch64.AbortSyndrome</anchor>(<a link="Exception" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception</a> exceptype, <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault, bits(64) vaddress)
    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(exceptype);

    d_side = exceptype IN {<a link="Exception_DataAbort" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>, <a link="Exception_NV2DataAbort" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2DataAbort</a>, <a link="Exception_Watchpoint" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Watchpoint</a>, <a link="Exception_NV2Watchpoint" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2Watchpoint</a>};

    (exception.syndrome, exception.syndrome2) = <a link="AArch64.FaultSyndrome.2" file="shared_pseudocode.xml" hover="function: (bits(25), bits(5)) AArch64.FaultSyndrome(boolean d_side, FaultRecord fault)">AArch64.FaultSyndrome</a>(d_side, fault);
    exception.vaddress = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(vaddress);
    if <a link="impl-shared.IPAValid.1" file="shared_pseudocode.xml" hover="function: boolean IPAValid(FaultRecord fault)">IPAValid</a>(fault) then
        exception.ipavalid = TRUE;
        exception.NS = if fault.ipaddress.paspace == <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a> then '1' else '0';
        exception.ipaddress = fault.ipaddress.address;
    else
        exception.ipavalid = FALSE;

    return exception;</pstext>
    </ps>
    <ps name="aarch64/exceptions/aborts/AArch64.CheckPCAlignment" mylink="aarch64.exceptions.aborts.AArch64.CheckPCAlignment" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.CheckPCAlignment()
// ==========================

<anchor link="AArch64.CheckPCAlignment.0" hover="function: AArch64.CheckPCAlignment()">AArch64.CheckPCAlignment</anchor>()

    bits(64) pc = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    if pc&lt;1:0&gt; != '00' then
        <a link="AArch64.PCAlignmentFault.0" file="shared_pseudocode.xml" hover="function: AArch64.PCAlignmentFault()">AArch64.PCAlignmentFault</a>();</pstext>
    </ps>
    <ps name="aarch64/exceptions/aborts/AArch64.DataAbort" mylink="aarch64.exceptions.aborts.AArch64.DataAbort" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.DataAbort()
// ===================

<anchor link="AArch64.DataAbort.2" hover="function: AArch64.DataAbort(bits(64) vaddress, FaultRecord fault)">AArch64.DataAbort</anchor>(bits(64) vaddress, <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    route_to_el3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.EA == '1' &amp;&amp; <a link="impl-shared.IsExternalAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault);
    route_to_el2 = (<a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp;
                    (HCR_EL2.TGE == '1' ||
                     (<a link="impl-shared.HaveRASExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; HCR_EL2.TEA == '1' &amp;&amp; <a link="impl-shared.IsExternalAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault)) ||
                     (<a link="impl-shared.HaveNV2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveNV2Ext()">HaveNV2Ext</a>() &amp;&amp; fault.acctype == <a link="AccType_NV2REGISTER" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NV2REGISTER</a>) ||
                     <a link="impl-shared.IsSecondStage.1" file="shared_pseudocode.xml" hover="function: boolean IsSecondStage(FaultRecord fault)">IsSecondStage</a>(fault)));

    bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    integer vect_offset;
    if (<a link="impl-shared.HaveDoubleFaultExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>() &amp;&amp; (PSTATE.EL == <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> || route_to_el3) &amp;&amp;
        <a link="impl-shared.IsExternalAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) &amp;&amp; SCR_EL3.EASE == '1') then
        vect_offset = 0x180;
    else
        vect_offset = 0x0;
    <a link="ExceptionRecord" file="shared_pseudocode.xml" hover="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception;
    if <a link="impl-shared.HaveNV2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveNV2Ext()">HaveNV2Ext</a>() &amp;&amp; fault.acctype == <a link="AccType_NV2REGISTER" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NV2REGISTER</a> then
        exception = <a link="AArch64.AbortSyndrome.3" file="shared_pseudocode.xml" hover="function: ExceptionRecord AArch64.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(64) vaddress)">AArch64.AbortSyndrome</a>(<a link="Exception_NV2DataAbort" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2DataAbort</a>, fault, vaddress);
    else
        exception = <a link="AArch64.AbortSyndrome.3" file="shared_pseudocode.xml" hover="function: ExceptionRecord AArch64.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(64) vaddress)">AArch64.AbortSyndrome</a>(<a link="Exception_DataAbort" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>, fault, vaddress);
    bits(2) target_el = <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;
    if PSTATE.EL == <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> || route_to_el3 then
        target_el = <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>;
    elsif PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> || route_to_el2 then
        target_el = <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;
    <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/aborts/AArch64.EffectiveTCF" mylink="aarch64.exceptions.aborts.AArch64.EffectiveTCF" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.EffectiveTCF()
// ======================
// Returns the TCF field applied to tag check faults in the given Exception level.

bits(2) <anchor link="AArch64.EffectiveTCF.1" hover="function: bits(2) AArch64.EffectiveTCF(AccType acctype)">AArch64.EffectiveTCF</anchor>(<a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype)
    bits(2) tcf, el;
    el = <a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>();

    if el == <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> then
        tcf = SCTLR_EL3.TCF;
    elsif el == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then
        if <a link="AArch64.AccessUsesEL.1" file="shared_pseudocode.xml" hover="function: bits(2) AArch64.AccessUsesEL(AccType acctype)">AArch64.AccessUsesEL</a>(acctype) == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then
            tcf = SCTLR_EL2.TCF0;
        else
            tcf = SCTLR_EL2.TCF;
    elsif el == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> then
        if <a link="AArch64.AccessUsesEL.1" file="shared_pseudocode.xml" hover="function: bits(2) AArch64.AccessUsesEL(AccType acctype)">AArch64.AccessUsesEL</a>(acctype) == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then
            tcf = SCTLR_EL1.TCF0;
        else
            tcf = SCTLR_EL1.TCF;

    if tcf == '11' then        //reserved value
        if !<a link="impl-shared.HaveMTE3Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveMTE3Ext()">HaveMTE3Ext</a>() then
            (-,tcf) = <a link="impl-shared.ConstrainUnpredictableBits.1" file="shared_pseudocode.xml" hover="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a link="Unpredictable_RESTCF" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESTCF</a>);

    return tcf;</pstext>
    </ps>
    <ps name="aarch64/exceptions/aborts/AArch64.InstructionAbort" mylink="aarch64.exceptions.aborts.AArch64.InstructionAbort" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.InstructionAbort()
// ==========================

<anchor link="AArch64.InstructionAbort.2" hover="function: AArch64.InstructionAbort(bits(64) vaddress, FaultRecord fault)">AArch64.InstructionAbort</anchor>(bits(64) vaddress, <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    // External aborts on instruction fetch must be taken synchronously
    if <a link="impl-shared.HaveDoubleFaultExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>() then assert fault.statuscode != <a link="Fault_AsyncExternal" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>;
    route_to_el3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.EA == '1' &amp;&amp; <a link="impl-shared.IsExternalAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault);
    route_to_el2 = (<a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp;
                    (HCR_EL2.TGE == '1' ||
                     (<a link="impl-shared.HaveRASExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; HCR_EL2.TEA == '1' &amp;&amp; <a link="impl-shared.IsExternalAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault)) ||
                     <a link="impl-shared.IsSecondStage.1" file="shared_pseudocode.xml" hover="function: boolean IsSecondStage(FaultRecord fault)">IsSecondStage</a>(fault)));

    <a link="ExceptionRecord" file="shared_pseudocode.xml" hover="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception;
    bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    integer vect_offset;
    if (<a link="impl-shared.HaveDoubleFaultExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>() &amp;&amp; (PSTATE.EL == <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> || route_to_el3) &amp;&amp;
        <a link="impl-shared.IsExternalAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) &amp;&amp; SCR_EL3.EASE == '1') then
        vect_offset = 0x180;
    else
        vect_offset = 0x0;

    exception = <a link="AArch64.AbortSyndrome.3" file="shared_pseudocode.xml" hover="function: ExceptionRecord AArch64.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(64) vaddress)">AArch64.AbortSyndrome</a>(<a link="Exception_InstructionAbort" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_InstructionAbort</a>, fault, vaddress);

    bits(2) target_el = <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;
    if PSTATE.EL == <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> || route_to_el3 then
        target_el = <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>;
    elsif PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> || route_to_el2 then
        target_el = <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;
    <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/aborts/AArch64.PCAlignmentFault" mylink="aarch64.exceptions.aborts.AArch64.PCAlignmentFault" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.PCAlignmentFault()
// ==========================
// Called on unaligned program counter in AArch64 state.

<anchor link="AArch64.PCAlignmentFault.0" hover="function: AArch64.PCAlignmentFault()">AArch64.PCAlignmentFault</anchor>()

    bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_PCAlignment" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PCAlignment</a>);
    exception.vaddress = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();

    bits(2) target_el = <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;
    if <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then
        target_el = PSTATE.EL;
    elsif <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then
        target_el = <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;
    <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/aborts/AArch64.RaiseTagCheckFault" mylink="aarch64.exceptions.aborts.AArch64.RaiseTagCheckFault" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.RaiseTagCheckFault()
// ============================
// Raise a tag check fault exception.

<anchor link="AArch64.RaiseTagCheckFault.2" hover="function: AArch64.RaiseTagCheckFault(bits(64) va, boolean write)">AArch64.RaiseTagCheckFault</anchor>(bits(64) va, boolean write)
    bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    integer vect_offset = 0x0;

    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_DataAbort" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>);
    exception.syndrome&lt;5:0&gt; = '010001';
    if write then
        exception.syndrome&lt;6&gt; = '1';
    exception.vaddress = bits(4) UNKNOWN : va&lt;59:0&gt;;

    bits(2) target_el = <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;
    if <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then
        target_el = PSTATE.EL;
    elsif PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then
        target_el = <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;
    <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/aborts/AArch64.ReportTagCheckFault" mylink="aarch64.exceptions.aborts.AArch64.ReportTagCheckFault" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.ReportTagCheckFault()
// =============================
// Records a tag check fault exception into the appropriate TCFR_ELx.

<anchor link="AArch64.ReportTagCheckFault.2" hover="function: AArch64.ReportTagCheckFault(bits(2) el, bit ttbr)">AArch64.ReportTagCheckFault</anchor>(bits(2) el, bit ttbr)
    if el == <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> then
        assert ttbr == '0';
        TFSR_EL3.TF0 = '1';
    elsif el == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then
        if ttbr == '0' then
            TFSR_EL2.TF0 = '1';
        else
            TFSR_EL2.TF1 = '1';
    elsif el == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> then
        if ttbr == '0' then
            TFSR_EL1.TF0 = '1';
        else
            TFSR_EL1.TF1 = '1';
    elsif el == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then
        if ttbr == '0' then
            TFSRE0_EL1.TF0 = '1';
        else
            TFSRE0_EL1.TF1 = '1';</pstext>
    </ps>
    <ps name="aarch64/exceptions/aborts/AArch64.SPAlignmentFault" mylink="aarch64.exceptions.aborts.AArch64.SPAlignmentFault" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.SPAlignmentFault()
// ==========================
// Called on an unaligned stack pointer in AArch64 state.

<anchor link="AArch64.SPAlignmentFault.0" hover="function: AArch64.SPAlignmentFault()">AArch64.SPAlignmentFault</anchor>()

    bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_SPAlignment" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SPAlignment</a>);

    bits(2) target_el = <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;
    if <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then
        target_el = PSTATE.EL;
    elsif <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then
        target_el = <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;
    <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/aborts/AArch64.TagCheckFault" mylink="aarch64.exceptions.aborts.AArch64.TagCheckFault" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.TagCheckFault()
// =======================
// Handle a tag check fault condition.

<anchor link="AArch64.TagCheckFault.3" hover="function: AArch64.TagCheckFault(bits(64) vaddress, AccType acctype, boolean iswrite)">AArch64.TagCheckFault</anchor>(bits(64) vaddress, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite)
    bits(2) tcf, el;
    el = <a link="AArch64.AccessUsesEL.1" file="shared_pseudocode.xml" hover="function: bits(2) AArch64.AccessUsesEL(AccType acctype)">AArch64.AccessUsesEL</a>(acctype);
    tcf = <a link="AArch64.EffectiveTCF.1" file="shared_pseudocode.xml" hover="function: bits(2) AArch64.EffectiveTCF(AccType acctype)">AArch64.EffectiveTCF</a>(acctype);
    case tcf of
        when '00'       // Tag Check Faults have no effect on the PE
            return;
        when '01'       // Tag Check Faults cause a synchronous exception
            <a link="AArch64.RaiseTagCheckFault.2" file="shared_pseudocode.xml" hover="function: AArch64.RaiseTagCheckFault(bits(64) va, boolean write)">AArch64.RaiseTagCheckFault</a>(vaddress, iswrite);
        when '10'       // Tag Check Faults are asynchronously accumulated
            <a link="AArch64.ReportTagCheckFault.2" file="shared_pseudocode.xml" hover="function: AArch64.ReportTagCheckFault(bits(2) el, bit ttbr)">AArch64.ReportTagCheckFault</a>(el, vaddress&lt;55&gt;);
        when '11'       // Tag Check Faults cause a synchronous exception on reads or on
                        // a read-write access, and are asynchronously accumulated on writes
            // Check for access performing both a read and a write.
            readwrite = acctype IN {<a link="AccType_ATOMICRW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a>,
                                    <a link="AccType_ORDEREDATOMICRW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMICRW</a>,
                                    <a link="AccType_ORDEREDRW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDRW</a>};

            if !iswrite || readwrite then
                <a link="AArch64.RaiseTagCheckFault.2" file="shared_pseudocode.xml" hover="function: AArch64.RaiseTagCheckFault(bits(64) va, boolean write)">AArch64.RaiseTagCheckFault</a>(vaddress, iswrite);
            else
                <a link="AArch64.ReportTagCheckFault.2" file="shared_pseudocode.xml" hover="function: AArch64.ReportTagCheckFault(bits(2) el, bit ttbr)">AArch64.ReportTagCheckFault</a>(PSTATE.EL, vaddress&lt;55&gt;);</pstext>
    </ps>
    <ps name="aarch64/exceptions/aborts/BranchTargetException" mylink="aarch64.exceptions.aborts.BranchTargetException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// BranchTargetException()
// =======================
// Raise branch target exception.

<anchor link="AArch64.BranchTargetException.1" hover="function: AArch64.BranchTargetException(bits(52) vaddress)">AArch64.BranchTargetException</anchor>(bits(52) vaddress)
    bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_BranchTarget" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_BranchTarget</a>);
    exception.syndrome&lt;1:0&gt;   = PSTATE.BTYPE;
    exception.syndrome&lt;24:2&gt;  = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();         // RES0

    bits(2) target_el = <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;
    if <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then
        target_el = PSTATE.EL;
    elsif PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then
        target_el = <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;
    <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/async/AArch64.TakePhysicalFIQException" mylink="aarch64.exceptions.async.AArch64.TakePhysicalFIQException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.TakePhysicalFIQException()
// ==================================

<anchor link="AArch64.TakePhysicalFIQException.0" hover="function: AArch64.TakePhysicalFIQException()">AArch64.TakePhysicalFIQException</anchor>()

    route_to_el3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.FIQ == '1';
    route_to_el2 = (PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                    (HCR_EL2.TGE == '1' || HCR_EL2.FMO == '1'));
    bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x100;
    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_FIQ" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FIQ</a>);

    if route_to_el3 then
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, exception, preferred_exception_return, vect_offset);
    elsif PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> || route_to_el2 then
        assert PSTATE.EL != <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>;
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        assert PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>};
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/async/AArch64.TakePhysicalIRQException" mylink="aarch64.exceptions.async.AArch64.TakePhysicalIRQException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.TakePhysicalIRQException()
// ==================================
// Take an enabled physical IRQ exception.

<anchor link="AArch64.TakePhysicalIRQException.0" hover="function: AArch64.TakePhysicalIRQException()">AArch64.TakePhysicalIRQException</anchor>()

    route_to_el3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.IRQ == '1';
    route_to_el2 = (PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                    (HCR_EL2.TGE == '1' || HCR_EL2.IMO == '1'));
    bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x80;

    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_IRQ" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IRQ</a>);

    if route_to_el3 then
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, exception, preferred_exception_return, vect_offset);
    elsif PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> || route_to_el2 then
        assert PSTATE.EL != <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>;
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        assert PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>};
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/async/AArch64.TakePhysicalSErrorException" mylink="aarch64.exceptions.async.AArch64.TakePhysicalSErrorException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.TakePhysicalSErrorException()
// =====================================

<anchor link="AArch64.TakePhysicalSErrorException.1" hover="function: AArch64.TakePhysicalSErrorException(bits(25) syndrome)">AArch64.TakePhysicalSErrorException</anchor>(bits(25) syndrome)

    route_to_el3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.EA == '1';
    route_to_el2 = (PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                    (HCR_EL2.TGE == '1' || (!<a link="impl-shared.IsInHost.0" file="shared_pseudocode.xml" hover="function: boolean IsInHost()">IsInHost</a>() &amp;&amp; HCR_EL2.AMO == '1')));
    bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x180;

    bits(2) target_el;
    if PSTATE.EL == <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> || route_to_el3 then
        target_el = <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>;
    elsif PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> || route_to_el2 then
        target_el = <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;
    else
        target_el = <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;

    if <a link="impl-shared.IsSErrorEdgeTriggered.2" file="shared_pseudocode.xml" hover="function: boolean IsSErrorEdgeTriggered(bits(2) target_el, bits(25) syndrome)">IsSErrorEdgeTriggered</a>(target_el, syndrome) then
        <a link="impl-shared.ClearPendingPhysicalSError.0" file="shared_pseudocode.xml" hover="function: ClearPendingPhysicalSError()">ClearPendingPhysicalSError</a>();

    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_SError" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SError</a>);
    exception.syndrome = syndrome;
    <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/async/AArch64.TakeVirtualFIQException" mylink="aarch64.exceptions.async.AArch64.TakeVirtualFIQException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.TakeVirtualFIQException()
// =================================

<anchor link="AArch64.TakeVirtualFIQException.0" hover="function: AArch64.TakeVirtualFIQException()">AArch64.TakeVirtualFIQException</anchor>()
    assert PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>();
    assert HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.FMO == '1';  // Virtual IRQ enabled if TGE==0 and FMO==1

    bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x100;

    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_FIQ" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FIQ</a>);

    <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/async/AArch64.TakeVirtualIRQException" mylink="aarch64.exceptions.async.AArch64.TakeVirtualIRQException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.TakeVirtualIRQException()
// =================================

<anchor link="AArch64.TakeVirtualIRQException.0" hover="function: AArch64.TakeVirtualIRQException()">AArch64.TakeVirtualIRQException</anchor>()
    assert PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>();
    assert HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.IMO == '1';  // Virtual IRQ enabled if TGE==0 and IMO==1

    bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x80;

    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_IRQ" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IRQ</a>);

    <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/async/AArch64.TakeVirtualSErrorException" mylink="aarch64.exceptions.async.AArch64.TakeVirtualSErrorException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.TakeVirtualSErrorException()
// ====================================

<anchor link="AArch64.TakeVirtualSErrorException.1" hover="function: AArch64.TakeVirtualSErrorException(bits(25) syndrome)">AArch64.TakeVirtualSErrorException</anchor>(bits(25) syndrome)

    assert PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>();
    assert HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.AMO == '1';  // Virtual SError enabled if TGE==0 and AMO==1

    bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x180;
    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_SError" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SError</a>);

    if <a link="impl-shared.HaveRASExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveRASExt()">HaveRASExt</a>() then
        exception.syndrome&lt;24&gt;   = VSESR_EL2.IDS;
        exception.syndrome&lt;23:0&gt; = VSESR_EL2.ISS;
    else
        impdef_syndrome = syndrome&lt;24&gt; == '1';
        if impdef_syndrome then exception.syndrome = syndrome;

    <a link="impl-shared.ClearPendingVirtualSError.0" file="shared_pseudocode.xml" hover="function: ClearPendingVirtualSError()">ClearPendingVirtualSError</a>();
    <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/debug/AArch64.BreakpointException" mylink="aarch64.exceptions.debug.AArch64.BreakpointException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.BreakpointException()
// =============================

<anchor link="AArch64.BreakpointException.1" hover="function: AArch64.BreakpointException(FaultRecord fault)">AArch64.BreakpointException</anchor>(<a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    assert PSTATE.EL != <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>;

    route_to_el2 = (PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                    (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1'));

    bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    vaddress = bits(64) UNKNOWN;
    exception = <a link="AArch64.AbortSyndrome.3" file="shared_pseudocode.xml" hover="function: ExceptionRecord AArch64.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(64) vaddress)">AArch64.AbortSyndrome</a>(<a link="Exception_Breakpoint" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Breakpoint</a>, fault, vaddress);

    if PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> || route_to_el2 then
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/debug/AArch64.SoftwareBreakpoint" mylink="aarch64.exceptions.debug.AArch64.SoftwareBreakpoint" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.SoftwareBreakpoint()
// ============================

<anchor link="AArch64.SoftwareBreakpoint.1" hover="function: AArch64.SoftwareBreakpoint(bits(16) immediate)">AArch64.SoftwareBreakpoint</anchor>(bits(16) immediate)

    route_to_el2 = (PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp;
                    <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1'));

    bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_SoftwareBreakpoint" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareBreakpoint</a>);
    exception.syndrome&lt;15:0&gt; = immediate;

    if <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif route_to_el2 then
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/debug/AArch64.SoftwareStepException" mylink="aarch64.exceptions.debug.AArch64.SoftwareStepException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.SoftwareStepException()
// ===============================

<anchor link="AArch64.SoftwareStepException.0" hover="function: AArch64.SoftwareStepException()">AArch64.SoftwareStepException</anchor>()
    assert PSTATE.EL != <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>;

    route_to_el2 = (PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                    (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1'));

    bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_SoftwareStep" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareStep</a>);
    if <a link="impl-shared.SoftwareStep_DidNotStep.0" file="shared_pseudocode.xml" hover="function: boolean SoftwareStep_DidNotStep()">SoftwareStep_DidNotStep</a>() then
        exception.syndrome&lt;24&gt; = '0';
    else
        exception.syndrome&lt;24&gt; = '1';
        exception.syndrome&lt;6&gt; = if <a link="impl-shared.SoftwareStep_SteppedEX.0" file="shared_pseudocode.xml" hover="function: boolean SoftwareStep_SteppedEX()">SoftwareStep_SteppedEX</a>() then '1' else '0';
    exception.syndrome&lt;5:0&gt; = '100010';                // IFSC = Debug Exception

    if PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> || route_to_el2 then
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/debug/AArch64.VectorCatchException" mylink="aarch64.exceptions.debug.AArch64.VectorCatchException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.VectorCatchException()
// ==============================
// Vector Catch taken from EL0 or EL1 to EL2. This can only be called when debug exceptions are
// being routed to EL2, as Vector Catch is a legacy debug event.

<anchor link="AArch64.VectorCatchException.1" hover="function: AArch64.VectorCatchException(FaultRecord fault)">AArch64.VectorCatchException</anchor>(<a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    assert PSTATE.EL != <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;
    assert <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1');

    bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    vaddress = bits(64) UNKNOWN;
    exception = <a link="AArch64.AbortSyndrome.3" file="shared_pseudocode.xml" hover="function: ExceptionRecord AArch64.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(64) vaddress)">AArch64.AbortSyndrome</a>(<a link="Exception_VectorCatch" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_VectorCatch</a>, fault, vaddress);

    <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/debug/AArch64.WatchpointException" mylink="aarch64.exceptions.debug.AArch64.WatchpointException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.WatchpointException()
// =============================

<anchor link="AArch64.WatchpointException.2" hover="function: AArch64.WatchpointException(bits(64) vaddress, FaultRecord fault)">AArch64.WatchpointException</anchor>(bits(64) vaddress, <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    assert PSTATE.EL != <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>;

    route_to_el2 = (PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                    (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1'));

    bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    <a link="ExceptionRecord" file="shared_pseudocode.xml" hover="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception;
    if <a link="impl-shared.HaveNV2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveNV2Ext()">HaveNV2Ext</a>() &amp;&amp; fault.acctype == <a link="AccType_NV2REGISTER" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NV2REGISTER</a> then
        exception = <a link="AArch64.AbortSyndrome.3" file="shared_pseudocode.xml" hover="function: ExceptionRecord AArch64.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(64) vaddress)">AArch64.AbortSyndrome</a>(<a link="Exception_NV2Watchpoint" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2Watchpoint</a>, fault, vaddress);
    else
        exception = <a link="AArch64.AbortSyndrome.3" file="shared_pseudocode.xml" hover="function: ExceptionRecord AArch64.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(64) vaddress)">AArch64.AbortSyndrome</a>(<a link="Exception_Watchpoint" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Watchpoint</a>, fault, vaddress);

    if PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> || route_to_el2 then
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/exceptions/AArch64.ExceptionClass" mylink="aarch64.exceptions.exceptions.AArch64.ExceptionClass" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.ExceptionClass()
// ========================
// Returns the Exception Class and Instruction Length fields to be reported in ESR

(integer,bit) <anchor link="AArch64.ExceptionClass.2" hover="function: (integer,bit) AArch64.ExceptionClass(Exception exceptype, bits(2) target_el)">AArch64.ExceptionClass</anchor>(<a link="Exception" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception</a> exceptype, bits(2) target_el)

    il_is_valid = TRUE;
    from_32 = <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>();
    integer ec;
    case exceptype of
        when <a link="Exception_Uncategorized" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a>        ec = 0x00; il_is_valid = FALSE;
        when <a link="Exception_WFxTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_WFxTrap</a>              ec = 0x01;
        when <a link="Exception_CP15RTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RTTrap</a>           ec = 0x03; assert from_32;
        when <a link="Exception_CP15RRTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RRTTrap</a>          ec = 0x04; assert from_32;
        when <a link="Exception_CP14RTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RTTrap</a>           ec = 0x05; assert from_32;
        when <a link="Exception_CP14DTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14DTTrap</a>           ec = 0x06; assert from_32;
        when <a link="Exception_AdvSIMDFPAccessTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>  ec = 0x07;
        when <a link="Exception_FPIDTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPIDTrap</a>             ec = 0x08;
        when <a link="Exception_PACTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PACTrap</a>              ec = 0x09;
        when <a link="Exception_LDST64BTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_LDST64BTrap</a>          ec = 0x0A;
        when <a link="Exception_CP14RRTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RRTTrap</a>          ec = 0x0C; assert from_32;
        when <a link="Exception_BranchTarget" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_BranchTarget</a>         ec = 0x0D;
        when <a link="Exception_IllegalState" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IllegalState</a>         ec = 0x0E; il_is_valid = FALSE;
        when <a link="Exception_SupervisorCall" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SupervisorCall</a>       ec = 0x11;
        when <a link="Exception_HypervisorCall" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_HypervisorCall</a>       ec = 0x12;
        when <a link="Exception_MonitorCall" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_MonitorCall</a>          ec = 0x13;
        when <a link="Exception_SystemRegisterTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SystemRegisterTrap</a>   ec = 0x18; assert !from_32;
        when <a link="Exception_ERetTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_ERetTrap</a>             ec = 0x1A; assert !from_32;
        when <a link="Exception_PACFail" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PACFail</a>              ec = 0x1C; assert !from_32;
        when <a link="Exception_InstructionAbort" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_InstructionAbort</a>     ec = 0x20; il_is_valid = FALSE;
        when <a link="Exception_PCAlignment" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PCAlignment</a>          ec = 0x22; il_is_valid = FALSE;
        when <a link="Exception_DataAbort" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>            ec = 0x24;
        when <a link="Exception_NV2DataAbort" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2DataAbort</a>         ec = 0x25;
        when <a link="Exception_SPAlignment" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SPAlignment</a>          ec = 0x26; il_is_valid = FALSE; assert !from_32;
        when <a link="Exception_MemCpyMemSet" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_MemCpyMemSet</a>         ec = 0x27;
        when <a link="Exception_FPTrappedException" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPTrappedException</a>   ec = 0x28;
        when <a link="Exception_SError" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SError</a>               ec = 0x2F; il_is_valid = FALSE;
        when <a link="Exception_Breakpoint" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Breakpoint</a>           ec = 0x30; il_is_valid = FALSE;
        when <a link="Exception_SoftwareStep" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareStep</a>         ec = 0x32; il_is_valid = FALSE;
        when <a link="Exception_Watchpoint" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Watchpoint</a>           ec = 0x34; il_is_valid = FALSE;
        when <a link="Exception_NV2Watchpoint" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2Watchpoint</a>        ec = 0x35; il_is_valid = FALSE;
        when <a link="Exception_SoftwareBreakpoint" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareBreakpoint</a>   ec = 0x38;
        when <a link="Exception_VectorCatch" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_VectorCatch</a>          ec = 0x3A; il_is_valid = FALSE; assert from_32;
        otherwise                           <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();

    if ec IN {0x20,0x24,0x30,0x32,0x34} &amp;&amp; target_el == PSTATE.EL then
        ec = ec + 1;

    if ec IN {0x11,0x12,0x13,0x28,0x38} &amp;&amp; !from_32 then
        ec = ec + 4;
    bit il;
    if il_is_valid then
        il = if <a link="impl-shared.ThisInstrLength.0" file="shared_pseudocode.xml" hover="function: integer ThisInstrLength()">ThisInstrLength</a>() == 32 then '1' else '0';
    else
        il = '1';
    assert from_32 || il == '1';            // AArch64 instructions always 32-bit

    return (ec,il);</pstext>
    </ps>
    <ps name="aarch64/exceptions/exceptions/AArch64.ReportException" mylink="aarch64.exceptions.exceptions.AArch64.ReportException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.ReportException()
// =========================
// Report syndrome information for exception taken to AArch64 state.

<anchor link="AArch64.ReportException.2" hover="function: AArch64.ReportException(ExceptionRecord exception, bits(2) target_el)">AArch64.ReportException</anchor>(<a link="ExceptionRecord" file="shared_pseudocode.xml" hover="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception, bits(2) target_el)

    <a link="Exception" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception</a> exceptype = exception.exceptype;

    (ec,il) = <a link="AArch64.ExceptionClass.2" file="shared_pseudocode.xml" hover="function: (integer,bit) AArch64.ExceptionClass(Exception exceptype, bits(2) target_el)">AArch64.ExceptionClass</a>(exceptype, target_el);
    iss = exception.syndrome;
    iss2 = exception.syndrome2;

    // IL is not valid for Data Abort exceptions without valid instruction syndrome information
    if ec IN {0x24,0x25} &amp;&amp; iss&lt;24&gt; == '0' then
        il = '1';

    <a link="impl-aarch64.ESR.write.1" file="shared_pseudocode.xml" hover="accessor: ESR[bits(2) regime] = ESRType value">ESR</a>[target_el] = (<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(27) :   // &lt;63:37&gt;
                      iss2      :   // &lt;36:32&gt;
                      ec&lt;5:0&gt;   :   // &lt;31:26&gt;
                      il        :   // &lt;25&gt;
                      iss);         // &lt;24:0&gt;

    if exceptype IN {
        <a link="Exception_InstructionAbort" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_InstructionAbort</a>,
        <a link="Exception_PCAlignment" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PCAlignment</a>,
        <a link="Exception_DataAbort" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>,
        <a link="Exception_NV2DataAbort" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2DataAbort</a>,
        <a link="Exception_NV2Watchpoint" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2Watchpoint</a>,
        <a link="Exception_Watchpoint" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Watchpoint</a>
    } then
        <a link="impl-aarch64.FAR.write.1" file="shared_pseudocode.xml" hover="accessor: FAR[bits(2) regime] = bits(64) value">FAR</a>[target_el] = exception.vaddress;
    else
        <a link="impl-aarch64.FAR.write.1" file="shared_pseudocode.xml" hover="accessor: FAR[bits(2) regime] = bits(64) value">FAR</a>[target_el] = bits(64) UNKNOWN;

    if exception.ipavalid then
        HPFAR_EL2&lt;43:4&gt; = exception.ipaddress&lt;51:12&gt;;
        if <a link="impl-shared.IsSecureEL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>() &amp;&amp; <a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>() then
            HPFAR_EL2.NS = exception.NS;
        else
            HPFAR_EL2.NS = '0';
    elsif target_el == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then
        HPFAR_EL2&lt;43:4&gt; = bits(40) UNKNOWN;

    return;</pstext>
    </ps>
    <ps name="aarch64/exceptions/exceptions/AArch64.ResetControlRegisters" mylink="aarch64.exceptions.exceptions.AArch64.ResetControlRegisters" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Resets System registers and memory-mapped control registers that have architecturally-defined
// reset values to those values.
<anchor link="AArch64.ResetControlRegisters.1" hover="function: AArch64.ResetControlRegisters(boolean cold_reset)">AArch64.ResetControlRegisters</anchor>(boolean cold_reset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/exceptions/AArch64.TakeReset" mylink="aarch64.exceptions.exceptions.AArch64.TakeReset" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.TakeReset()
// ===================
// Reset into AArch64 state

<anchor link="AArch64.TakeReset.1" hover="function: AArch64.TakeReset(boolean cold_reset)">AArch64.TakeReset</anchor>(boolean cold_reset)
    assert <a link="impl-shared.HaveAArch64.0" file="shared_pseudocode.xml" hover="function: boolean HaveAArch64()">HaveAArch64</a>();

    // Enter the highest implemented Exception level in AArch64 state
    PSTATE.nRW = '0';
    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
        PSTATE.EL = <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>;
    elsif <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
        PSTATE.EL = <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;
    else
        PSTATE.EL = <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;

    // Reset System registers and other system components
    <a link="AArch64.ResetControlRegisters.1" file="shared_pseudocode.xml" hover="function: AArch64.ResetControlRegisters(boolean cold_reset)">AArch64.ResetControlRegisters</a>(cold_reset);

    // Reset all other PSTATE fields
    PSTATE.SP = '1';              // Select stack pointer
    PSTATE.&lt;D,A,I,F&gt;  = '1111';   // All asynchronous exceptions masked
    PSTATE.SS = '0';              // Clear software step bit
    PSTATE.DIT = '0';             // PSTATE.DIT is reset to 0 when resetting into AArch64
    PSTATE.IL = '0';              // Clear Illegal Execution state bit

    // All registers, bits and fields not reset by the above pseudocode or by the BranchTo() call
    // below are UNKNOWN bitstrings after reset. In particular, the return information registers
    // ELR_ELx and SPSR_ELx have UNKNOWN values, so that it
    // is impossible to return from a reset in an architecturally defined way.
    <a link="AArch64.ResetGeneralRegisters.0" file="shared_pseudocode.xml" hover="function: AArch64.ResetGeneralRegisters()">AArch64.ResetGeneralRegisters</a>();
    <a link="AArch64.ResetSIMDFPRegisters.0" file="shared_pseudocode.xml" hover="function: AArch64.ResetSIMDFPRegisters()">AArch64.ResetSIMDFPRegisters</a>();
    <a link="AArch64.ResetSpecialRegisters.0" file="shared_pseudocode.xml" hover="function: AArch64.ResetSpecialRegisters()">AArch64.ResetSpecialRegisters</a>();
    <a link="impl-shared.ResetExternalDebugRegisters.1" file="shared_pseudocode.xml" hover="function: ResetExternalDebugRegisters(boolean cold_reset)">ResetExternalDebugRegisters</a>(cold_reset);

    bits(64) rv;                      // IMPLEMENTATION DEFINED reset vector

    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
        rv = RVBAR_EL3;
    elsif <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
        rv = RVBAR_EL2;
    else
        rv = RVBAR_EL1;

    // The reset vector must be correctly aligned
    assert <a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(rv&lt;63:<a link="AArch64.PAMax.0" file="shared_pseudocode.xml" hover="function: integer AArch64.PAMax()">AArch64.PAMax</a>()&gt;) &amp;&amp; <a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(rv&lt;1:0&gt;);

    boolean branch_conditional = FALSE;
    <a link="impl-shared.BranchTo.3" file="shared_pseudocode.xml" hover="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(rv, <a link="BranchType_RESET" file="shared_pseudocode.xml" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType_RESET</a>, branch_conditional);</pstext>
    </ps>
    <ps name="aarch64/exceptions/ieeefp/AArch64.FPTrappedException" mylink="aarch64.exceptions.ieeefp.AArch64.FPTrappedException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.FPTrappedException()
// ============================

<anchor link="AArch64.FPTrappedException.2" hover="function: AArch64.FPTrappedException(boolean is_ase, bits(8) accumulated_exceptions)">AArch64.FPTrappedException</anchor>(boolean is_ase, bits(8) accumulated_exceptions)
    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_FPTrappedException" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPTrappedException</a>);
    if is_ase then
        if boolean IMPLEMENTATION_DEFINED "vector instructions set TFV to 1" then
            exception.syndrome&lt;23&gt; = '1';                          // TFV
        else
            exception.syndrome&lt;23&gt; = '0';                          // TFV
    else
        exception.syndrome&lt;23&gt; = '1';                              // TFV
    exception.syndrome&lt;10:8&gt; = bits(3) UNKNOWN;                    // VECITR
    if exception.syndrome&lt;23&gt; == '1' then
        exception.syndrome&lt;7,4:0&gt; = accumulated_exceptions&lt;7,4:0&gt;; // IDF,IXF,UFF,OFF,DZF,IOF
    else
        exception.syndrome&lt;7,4:0&gt; = bits(6) UNKNOWN;

    route_to_el2 = <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1';

    bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    if <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif route_to_el2 then
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/syscalls/AArch64.CallHypervisor" mylink="aarch64.exceptions.syscalls.AArch64.CallHypervisor" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.CallHypervisor()
// ========================
// Performs a HVC call

<anchor link="AArch64.CallHypervisor.1" hover="function: AArch64.CallHypervisor(bits(16) immediate)">AArch64.CallHypervisor</anchor>(bits(16) immediate)
    assert <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>);

    if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then <a link="AArch32.ITAdvance.0" file="shared_pseudocode.xml" hover="function: AArch32.ITAdvance()">AArch32.ITAdvance</a>();
    <a link="impl-shared.SSAdvance.0" file="shared_pseudocode.xml" hover="function: SSAdvance()">SSAdvance</a>();
    bits(64) preferred_exception_return = <a link="impl-shared.NextInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) NextInstrAddr()">NextInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_HypervisorCall" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_HypervisorCall</a>);
    exception.syndrome&lt;15:0&gt; = immediate;

    if PSTATE.EL == <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> then
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, exception, preferred_exception_return, vect_offset);
    else
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/syscalls/AArch64.CallSecureMonitor" mylink="aarch64.exceptions.syscalls.AArch64.CallSecureMonitor" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.CallSecureMonitor()
// ===========================

<anchor link="AArch64.CallSecureMonitor.1" hover="function: AArch64.CallSecureMonitor(bits(16) immediate)">AArch64.CallSecureMonitor</anchor>(bits(16) immediate)
    assert <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>);
    if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then <a link="AArch32.ITAdvance.0" file="shared_pseudocode.xml" hover="function: AArch32.ITAdvance()">AArch32.ITAdvance</a>();
    <a link="impl-shared.SSAdvance.0" file="shared_pseudocode.xml" hover="function: SSAdvance()">SSAdvance</a>();
    bits(64) preferred_exception_return = <a link="impl-shared.NextInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) NextInstrAddr()">NextInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_MonitorCall" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_MonitorCall</a>);
    exception.syndrome&lt;15:0&gt; = immediate;

    <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/syscalls/AArch64.CallSupervisor" mylink="aarch64.exceptions.syscalls.AArch64.CallSupervisor" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.CallSupervisor()
// ========================
// Calls the Supervisor

<anchor link="AArch64.CallSupervisor.1" hover="function: AArch64.CallSupervisor(bits(16) immediate_in)">AArch64.CallSupervisor</anchor>(bits(16) immediate_in)
    bits(16) immediate = immediate_in;
    if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then <a link="AArch32.ITAdvance.0" file="shared_pseudocode.xml" hover="function: AArch32.ITAdvance()">AArch32.ITAdvance</a>();
    <a link="impl-shared.SSAdvance.0" file="shared_pseudocode.xml" hover="function: SSAdvance()">SSAdvance</a>();
    route_to_el2 = PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1';

    bits(64) preferred_exception_return = <a link="impl-shared.NextInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) NextInstrAddr()">NextInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_SupervisorCall" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SupervisorCall</a>);
    exception.syndrome&lt;15:0&gt; = immediate;

    if <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif route_to_el2 then
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/takeexception/AArch64.TakeException" mylink="aarch64.exceptions.takeexception.AArch64.TakeException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.TakeException()
// =======================
// Take an exception to an Exception level using AArch64.

<anchor link="AArch64.TakeException.4" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</anchor>(bits(2) target_el, <a link="ExceptionRecord" file="shared_pseudocode.xml" hover="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception_in,
                      bits(64) preferred_exception_return, integer vect_offset_in)
    assert <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(target_el) &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(target_el) &amp;&amp; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt;= <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL);
    <a link="ExceptionRecord" file="shared_pseudocode.xml" hover="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception = exception_in;
    boolean sync_errors;
    if <a link="impl-shared.HaveIESB.0" file="shared_pseudocode.xml" hover="function: boolean HaveIESB()">HaveIESB</a>() then
        sync_errors = <a link="impl-aarch64.SCTLR.read.1" file="shared_pseudocode.xml" hover="accessor: SCTLRType SCTLR[bits(2) regime]">SCTLR</a>[target_el].IESB == '1';
        if <a link="impl-shared.HaveDoubleFaultExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>() then
            sync_errors = sync_errors || (SCR_EL3.&lt;EA,NMEA&gt; == '11' &amp;&amp; target_el == <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>);
        if sync_errors &amp;&amp; <a link="impl-shared.InsertIESBBeforeException.1" file="shared_pseudocode.xml" hover="function: boolean InsertIESBBeforeException(bits(2) el)">InsertIESBBeforeException</a>(target_el) then
            <a link="impl-shared.SynchronizeErrors.0" file="shared_pseudocode.xml" hover="function: SynchronizeErrors()">SynchronizeErrors</a>();
            iesb_req = FALSE;
            sync_errors = FALSE;
            <a link="impl-shared.TakeUnmaskedPhysicalSErrorInterrupts.1" file="shared_pseudocode.xml" hover="function: TakeUnmaskedPhysicalSErrorInterrupts(boolean iesb_req)">TakeUnmaskedPhysicalSErrorInterrupts</a>(iesb_req);
    else
        sync_errors = FALSE;

    <a link="impl-shared.SynchronizeContext.0" file="shared_pseudocode.xml" hover="function: SynchronizeContext()">SynchronizeContext</a>();

    // If coming from AArch32 state, the top parts of the X[] registers might be set to zero
    from_32 = <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>();
    if from_32 then <a link="AArch64.MaybeZeroRegisterUppers.0" file="shared_pseudocode.xml" hover="function: AArch64.MaybeZeroRegisterUppers()">AArch64.MaybeZeroRegisterUppers</a>();

    integer vect_offset = vect_offset_in;
    if <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) then
        boolean lower_32;
        if target_el == <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> then
            if <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() then
                lower_32 = <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>);
            else
                lower_32 = <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>);
        elsif <a link="impl-shared.IsInHost.0" file="shared_pseudocode.xml" hover="function: boolean IsInHost()">IsInHost</a>() &amp;&amp; PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; target_el == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then
            lower_32 = <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>);
        else
            lower_32 = <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(target_el - 1);
        vect_offset = vect_offset + (if lower_32 then 0x600 else 0x400);

    elsif PSTATE.SP == '1' then
        vect_offset = vect_offset + 0x200;

    bits(64) spsr = <a link="impl-shared.GetPSRFromPSTATE.1" file="shared_pseudocode.xml" hover="function: bits(N) GetPSRFromPSTATE(ExceptionalOccurrenceTargetState targetELState)">GetPSRFromPSTATE</a>(<a link="AArch64_NonDebugState" file="shared_pseudocode.xml" hover="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">AArch64_NonDebugState</a>);

    if PSTATE.EL == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; target_el == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if <a link="impl-shared.HaveNV2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveNV2Ext()">HaveNV2Ext</a>() &amp;&amp; (HCR_EL2.&lt;NV,NV1,NV2&gt; == '100' || HCR_EL2.&lt;NV,NV1,NV2&gt; == '111') then
            spsr&lt;3:2&gt; = '10';
        else
            if <a link="impl-shared.HaveNVExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveNVExt()">HaveNVExt</a>() &amp;&amp; HCR_EL2.&lt;NV,NV1&gt; == '10' then
                spsr&lt;3:2&gt; = '10';

    if <a link="impl-shared.HaveBTIExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveBTIExt()">HaveBTIExt</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
        boolean zero_btype;
        // SPSR[].BTYPE is only guaranteed valid for these exception types
        if exception.exceptype IN {<a link="Exception_SError" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SError</a>, <a link="Exception_IRQ" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IRQ</a>, <a link="Exception_FIQ" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FIQ</a>,
                              <a link="Exception_SoftwareStep" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareStep</a>, <a link="Exception_PCAlignment" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PCAlignment</a>,
                              <a link="Exception_InstructionAbort" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_InstructionAbort</a>, <a link="Exception_Breakpoint" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Breakpoint</a>,
                              <a link="Exception_VectorCatch" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_VectorCatch</a>, <a link="Exception_SoftwareBreakpoint" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareBreakpoint</a>,
                              <a link="Exception_IllegalState" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IllegalState</a>, <a link="Exception_BranchTarget" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_BranchTarget</a>} then
            zero_btype = FALSE;
        else
            zero_btype = <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_ZEROBTYPE" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_ZEROBTYPE</a>);
        if zero_btype then spsr&lt;11:10&gt; = '00';

    if <a link="impl-shared.HaveNV2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveNV2Ext()">HaveNV2Ext</a>() &amp;&amp; exception.exceptype == <a link="Exception_NV2DataAbort" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2DataAbort</a> &amp;&amp; target_el == <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> then
        // External aborts are configured to be taken to EL3
        exception.exceptype = <a link="Exception_DataAbort" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>;
    if !(exception.exceptype IN {<a link="Exception_IRQ" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IRQ</a>, <a link="Exception_FIQ" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FIQ</a>}) then
        <a link="AArch64.ReportException.2" file="shared_pseudocode.xml" hover="function: AArch64.ReportException(ExceptionRecord exception, bits(2) target_el)">AArch64.ReportException</a>(exception, target_el);

    PSTATE.EL = target_el;
    PSTATE.nRW = '0';
    PSTATE.SP = '1';

    <a link="impl-shared.SPSR.write.0" file="shared_pseudocode.xml" hover="accessor: SPSR[] = bits(N) value">SPSR</a>[] = spsr;
    <a link="impl-aarch64.ELR.write.0" file="shared_pseudocode.xml" hover="accessor: ELR[] = bits(64) value">ELR</a>[] = preferred_exception_return;

    PSTATE.SS = '0';
    if <a link="impl-shared.HaveFeatNMI.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatNMI()">HaveFeatNMI</a>() &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(target_el) then PSTATE.ALLINT = NOT <a link="impl-aarch64.SCTLR.read.0" file="shared_pseudocode.xml" hover="accessor: SCTLRType SCTLR[]">SCTLR</a>[].SPINTMASK;
    PSTATE.&lt;D,A,I,F&gt; = '1111';
    PSTATE.IL = '0';
    if from_32 then                             // Coming from AArch32
        PSTATE.IT = '00000000';
        PSTATE.T = '0';                         // PSTATE.J is RES0
    if (<a link="impl-shared.HavePANExt.0" file="shared_pseudocode.xml" hover="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; (PSTATE.EL == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> || (PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; <a link="impl-shared.ELIsInHost.1" file="shared_pseudocode.xml" hover="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>))) &amp;&amp;
        <a link="impl-aarch64.SCTLR.read.0" file="shared_pseudocode.xml" hover="accessor: SCTLRType SCTLR[]">SCTLR</a>[].SPAN == '0') then
        PSTATE.PAN = '1';
    if <a link="impl-shared.HaveUAOExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveUAOExt()">HaveUAOExt</a>() then PSTATE.UAO = '0';
    if <a link="impl-shared.HaveBTIExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveBTIExt()">HaveBTIExt</a>() then PSTATE.BTYPE = '00';
    if <a link="impl-shared.HaveSSBSExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = <a link="impl-aarch64.SCTLR.read.0" file="shared_pseudocode.xml" hover="accessor: SCTLRType SCTLR[]">SCTLR</a>[].DSSBS;
    if <a link="impl-shared.HaveMTEExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveMTEExt()">HaveMTEExt</a>() then PSTATE.TCO = '1';

    boolean branch_conditional = FALSE;
    <a link="impl-shared.BranchTo.3" file="shared_pseudocode.xml" hover="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(<a link="impl-aarch64.VBAR.read.0" file="shared_pseudocode.xml" hover="accessor: bits(64) VBAR[]">VBAR</a>[]&lt;63:11&gt;:vect_offset&lt;10:0&gt;, <a link="BranchType_EXCEPTION" file="shared_pseudocode.xml" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType_EXCEPTION</a>, branch_conditional);

    <a link="impl-shared.CheckExceptionCatch.1" file="shared_pseudocode.xml" hover="function: CheckExceptionCatch(boolean exception_entry)">CheckExceptionCatch</a>(TRUE);                  // Check for debug event on exception entry

    if sync_errors then
        <a link="impl-shared.SynchronizeErrors.0" file="shared_pseudocode.xml" hover="function: SynchronizeErrors()">SynchronizeErrors</a>();
        iesb_req = TRUE;
        <a link="impl-shared.TakeUnmaskedPhysicalSErrorInterrupts.1" file="shared_pseudocode.xml" hover="function: TakeUnmaskedPhysicalSErrorInterrupts(boolean iesb_req)">TakeUnmaskedPhysicalSErrorInterrupts</a>(iesb_req);

    <a link="impl-shared.EndOfInstruction.0" file="shared_pseudocode.xml" hover="function: EndOfInstruction()">EndOfInstruction</a>();</pstext>
    </ps>
    <ps name="aarch64/exceptions/traps/AArch64.AArch32SystemAccessTrap" mylink="aarch64.exceptions.traps.AArch64.AArch32SystemAccessTrap" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.AArch32SystemAccessTrap()
// =================================
// Trapped AARCH32 system register access.

<anchor link="AArch64.AArch32SystemAccessTrap.2" hover="function: AArch64.AArch32SystemAccessTrap(bits(2) target_el, integer ec)">AArch64.AArch32SystemAccessTrap</anchor>(bits(2) target_el, integer ec)
    assert <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(target_el) &amp;&amp; target_el != <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt;= <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL);

    bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a link="AArch64.AArch32SystemAccessTrapSyndrome.2" file="shared_pseudocode.xml" hover="function: ExceptionRecord AArch64.AArch32SystemAccessTrapSyndrome(bits(32) instr, integer ec)">AArch64.AArch32SystemAccessTrapSyndrome</a>(<a link="impl-shared.ThisInstr.0" file="shared_pseudocode.xml" hover="function: bits(32) ThisInstr()">ThisInstr</a>(), ec);
    <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/traps/AArch64.AArch32SystemAccessTrapSyndrome" mylink="aarch64.exceptions.traps.AArch64.AArch32SystemAccessTrapSyndrome" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.AArch32SystemAccessTrapSyndrome()
// =========================================
// Returns the syndrome information for traps on AArch32 MCR, MCRR, MRC, MRRC, and VMRS, VMSR instructions,
// other than traps that are due to HCPTR or CPACR.

ExceptionRecord <anchor link="AArch64.AArch32SystemAccessTrapSyndrome.2" hover="function: ExceptionRecord AArch64.AArch32SystemAccessTrapSyndrome(bits(32) instr, integer ec)">AArch64.AArch32SystemAccessTrapSyndrome</anchor>(bits(32) instr, integer ec)
    <a link="ExceptionRecord" file="shared_pseudocode.xml" hover="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception;

    case ec of
        when 0x0    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_Uncategorized" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a>);
        when 0x3    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_CP15RTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RTTrap</a>);
        when 0x4    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_CP15RRTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RRTTrap</a>);
        when 0x5    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_CP14RTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RTTrap</a>);
        when 0x6    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_CP14DTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14DTTrap</a>);
        when 0x7    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_AdvSIMDFPAccessTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>);
        when 0x8    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_FPIDTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPIDTrap</a>);
        when 0xC    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_CP14RRTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RRTTrap</a>);
        otherwise   <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();

    bits(20) iss = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();

    if exception.exceptype == <a link="Exception_Uncategorized" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a> then
        return exception;
    elsif exception.exceptype IN {<a link="Exception_FPIDTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPIDTrap</a>, <a link="Exception_CP14RTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RTTrap</a>, <a link="Exception_CP15RTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RTTrap</a>} then
        // Trapped MRC/MCR, VMRS on FPSID
        if exception.exceptype != <a link="Exception_FPIDTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPIDTrap</a> then    // When trap is not for VMRS
            iss&lt;19:17&gt; = instr&lt;7:5&gt;;           // opc2
            iss&lt;16:14&gt; = instr&lt;23:21&gt;;         // opc1
            iss&lt;13:10&gt; = instr&lt;19:16&gt;;         // CRn
            iss&lt;4:1&gt;   = instr&lt;3:0&gt;;           // CRm
        else
            iss&lt;19:17&gt; = '000';
            iss&lt;16:14&gt; = '111';
            iss&lt;13:10&gt; = instr&lt;19:16&gt;;         // reg
            iss&lt;4:1&gt;   = '0000';

        if instr&lt;20&gt; == '1' &amp;&amp; instr&lt;15:12&gt; == '1111' then    // MRC, Rt==15
            iss&lt;9:5&gt; = '11111';
        elsif instr&lt;20&gt; == '0' &amp;&amp; instr&lt;15:12&gt; == '1111' then // MCR, Rt==15
            iss&lt;9:5&gt; = bits(5) UNKNOWN;
        else
            iss&lt;9:5&gt; = LookUpRIndex(UInt(instr&lt;15:12&gt;), PSTATE.M)&lt;4:0&gt;;
    elsif exception.exceptype IN {<a link="Exception_CP14RRTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RRTTrap</a>, <a link="Exception_AdvSIMDFPAccessTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>, <a link="Exception_CP15RRTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RRTTrap</a>} then
        // Trapped MRRC/MCRR, VMRS/VMSR
        iss&lt;19:16&gt; = instr&lt;7:4&gt;;          // opc1
        if instr&lt;19:16&gt; == '1111' then    // Rt2==15
            iss&lt;14:10&gt; = bits(5) UNKNOWN;
        else
            iss&lt;14:10&gt; = LookUpRIndex(UInt(instr&lt;19:16&gt;), PSTATE.M)&lt;4:0&gt;;

        if instr&lt;15:12&gt; == '1111' then    // Rt==15
            iss&lt;9:5&gt; = bits(5) UNKNOWN;
        else
            iss&lt;9:5&gt; = LookUpRIndex(UInt(instr&lt;15:12&gt;), PSTATE.M)&lt;4:0&gt;;
        iss&lt;4:1&gt;   = instr&lt;3:0&gt;;         // CRm
    elsif exception.exceptype == <a link="Exception_CP14DTTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14DTTrap</a> then
        // Trapped LDC/STC
        iss&lt;19:12&gt; = instr&lt;7:0&gt;;         // imm8
        iss&lt;4&gt;     = instr&lt;23&gt;;          // U
        iss&lt;2:1&gt;   = instr&lt;24,21&gt;;       // P,W
        if instr&lt;19:16&gt; == '1111' then   // Rn==15, LDC(Literal addressing)/STC
            iss&lt;9:5&gt; = bits(5) UNKNOWN;
            iss&lt;3&gt;   = '1';
    iss&lt;0&gt; = instr&lt;20&gt;;                  // Direction

    exception.syndrome&lt;24:20&gt; = <a link="impl-shared.ConditionSyndrome.0" file="shared_pseudocode.xml" hover="function: bits(5) ConditionSyndrome()">ConditionSyndrome</a>();
    exception.syndrome&lt;19:0&gt;  = iss;

    return exception;</pstext>
    </ps>
    <ps name="aarch64/exceptions/traps/AArch64.AdvSIMDFPAccessTrap" mylink="aarch64.exceptions.traps.AArch64.AdvSIMDFPAccessTrap" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.AdvSIMDFPAccessTrap()
// =============================
// Trapped access to Advanced SIMD or FP registers due to CPACR[].

<anchor link="AArch64.AdvSIMDFPAccessTrap.1" hover="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</anchor>(bits(2) target_el)
    bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    route_to_el2 = (target_el == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1');

    if route_to_el2 then
        exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_Uncategorized" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a>);
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_AdvSIMDFPAccessTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>);
        exception.syndrome&lt;24:20&gt; = <a link="impl-shared.ConditionSyndrome.0" file="shared_pseudocode.xml" hover="function: bits(5) ConditionSyndrome()">ConditionSyndrome</a>();
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);

    return;</pstext>
    </ps>
    <ps name="aarch64/exceptions/traps/AArch64.CheckCP15InstrCoarseTraps" mylink="aarch64.exceptions.traps.AArch64.CheckCP15InstrCoarseTraps" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.CheckCP15InstrCoarseTraps()
// ===================================
// Check for coarse-grained AArch32  traps to System registers in the
// coproc=0b1111 encoding space by HSTR_EL2, HCR_EL2, and SCTLR_ELx.

<anchor link="AArch64.CheckCP15InstrCoarseTraps.3" hover="function: AArch64.CheckCP15InstrCoarseTraps(integer CRn, integer nreg, integer CRm)">AArch64.CheckCP15InstrCoarseTraps</anchor>(integer CRn, integer nreg, integer CRm)
    trapped_encoding = ((CRn == 9  &amp;&amp; CRm IN {0,1,2,    5,6,7,8   }) ||
                        (CRn == 10 &amp;&amp; CRm IN {0,1,    4,      8   }) ||
                        (CRn == 11 &amp;&amp; CRm IN {0,1,2,3,4,5,6,7,8,15}));

    // Check for MRC and MCR disabled by SCTLR_EL1.TIDCP.
    if (<a link="impl-shared.HaveFeatTIDCP1.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatTIDCP1()">HaveFeatTIDCP1</a>() &amp;&amp; PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a link="impl-shared.IsInHost.0" file="shared_pseudocode.xml" hover="function: boolean IsInHost()">IsInHost</a>() &amp;&amp;
           !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; SCTLR_EL1.TIDCP == '1' &amp;&amp; trapped_encoding) then
        if <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then
            <a link="AArch64.AArch32SystemAccessTrap.2" file="shared_pseudocode.xml" hover="function: AArch64.AArch32SystemAccessTrap(bits(2) target_el, integer ec)">AArch64.AArch32SystemAccessTrap</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, 0x3);
        else
            <a link="AArch64.AArch32SystemAccessTrap.2" file="shared_pseudocode.xml" hover="function: AArch64.AArch32SystemAccessTrap(bits(2) target_el, integer ec)">AArch64.AArch32SystemAccessTrap</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>, 0x3);

    // Check for coarse-grained Hyp traps
    if PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() then
        // Check for MRC and MCR disabled by SCTLR_EL2.TIDCP.
        if (<a link="impl-shared.HaveFeatTIDCP1.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatTIDCP1()">HaveFeatTIDCP1</a>() &amp;&amp; PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a link="impl-shared.IsInHost.0" file="shared_pseudocode.xml" hover="function: boolean IsInHost()">IsInHost</a>() &amp;&amp;
                SCTLR_EL2.TIDCP == '1' &amp;&amp; trapped_encoding) then
            <a link="AArch64.AArch32SystemAccessTrap.2" file="shared_pseudocode.xml" hover="function: AArch64.AArch32SystemAccessTrap(bits(2) target_el, integer ec)">AArch64.AArch32SystemAccessTrap</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, 0x3);

        major = if nreg == 1 then CRn else CRm;
        // Check for MCR, MRC, MCRR, and MRRC disabled by HSTR_EL2&lt;CRn/CRm&gt;
        // and MRC and MCR disabled by HCR_EL2.TIDCP.
        if ((!<a link="impl-shared.IsInHost.0" file="shared_pseudocode.xml" hover="function: boolean IsInHost()">IsInHost</a>() &amp;&amp; !(major IN {4,14}) &amp;&amp; HSTR_EL2&lt;major&gt; == '1') ||
                (HCR_EL2.TIDCP == '1' &amp;&amp; nreg == 1 &amp;&amp; trapped_encoding)) then
            if (PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp;
                    boolean IMPLEMENTATION_DEFINED "UNDEF unallocated CP15 access at <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>") then
                UNDEFINED;
            <a link="AArch64.AArch32SystemAccessTrap.2" file="shared_pseudocode.xml" hover="function: AArch64.AArch32SystemAccessTrap(bits(2) target_el, integer ec)">AArch64.AArch32SystemAccessTrap</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, 0x3);</pstext>
    </ps>
    <ps name="aarch64/exceptions/traps/AArch64.CheckFPAdvSIMDEnabled" mylink="aarch64.exceptions.traps.AArch64.CheckFPAdvSIMDEnabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.CheckFPAdvSIMDEnabled()
// ===============================

<anchor link="AArch64.CheckFPAdvSIMDEnabled.0" hover="function: AArch64.CheckFPAdvSIMDEnabled()">AArch64.CheckFPAdvSIMDEnabled</anchor>()
    <a link="AArch64.CheckFPEnabled.0" file="shared_pseudocode.xml" hover="function: AArch64.CheckFPEnabled()">AArch64.CheckFPEnabled</a>();</pstext>
    </ps>
    <ps name="aarch64/exceptions/traps/AArch64.CheckFPAdvSIMDTrap" mylink="aarch64.exceptions.traps.AArch64.CheckFPAdvSIMDTrap" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.CheckFPAdvSIMDTrap()
// ============================
// Check against CPTR_EL2 and CPTR_EL3.

<anchor link="AArch64.CheckFPAdvSIMDTrap.0" hover="function: AArch64.CheckFPAdvSIMDTrap()">AArch64.CheckFPAdvSIMDTrap</anchor>()
    if PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>, <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() then
        // Check if access disabled in CPTR_EL2
        if <a link="impl-shared.HaveVirtHostExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; HCR_EL2.E2H == '1' then
            boolean disabled;
            case CPTR_EL2.FPEN of
                when 'x0' disabled = TRUE;
                when '01' disabled = PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; HCR_EL2.TGE == '1';
                when '11' disabled = FALSE;
            if disabled then <a link="AArch64.AdvSIMDFPAccessTrap.1" file="shared_pseudocode.xml" hover="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>);
        else
            if CPTR_EL2.TFP == '1' then <a link="AArch64.AdvSIMDFPAccessTrap.1" file="shared_pseudocode.xml" hover="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>);

    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
        // Check if access disabled in CPTR_EL3
        if CPTR_EL3.TFP == '1' then <a link="AArch64.AdvSIMDFPAccessTrap.1" file="shared_pseudocode.xml" hover="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>);

    return;</pstext>
    </ps>
    <ps name="aarch64/exceptions/traps/AArch64.CheckFPEnabled" mylink="aarch64.exceptions.traps.AArch64.CheckFPEnabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.CheckFPEnabled()
// ========================
// Check against CPACR[]

<anchor link="AArch64.CheckFPEnabled.0" hover="function: AArch64.CheckFPEnabled()">AArch64.CheckFPEnabled</anchor>()
    if PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; !<a link="impl-shared.IsInHost.0" file="shared_pseudocode.xml" hover="function: boolean IsInHost()">IsInHost</a>() then
        // Check if access disabled in CPACR_EL1
        boolean disabled;
        case CPACR_EL1.FPEN of
            when 'x0' disabled = TRUE;
            when '01' disabled = PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>;
            when '11' disabled = FALSE;
        if disabled then <a link="AArch64.AdvSIMDFPAccessTrap.1" file="shared_pseudocode.xml" hover="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>);

    <a link="AArch64.CheckFPAdvSIMDTrap.0" file="shared_pseudocode.xml" hover="function: AArch64.CheckFPAdvSIMDTrap()">AArch64.CheckFPAdvSIMDTrap</a>();               // Also check against CPTR_EL2 and CPTR_EL3</pstext>
    </ps>
    <ps name="aarch64/exceptions/traps/AArch64.CheckForERetTrap" mylink="aarch64.exceptions.traps.AArch64.CheckForERetTrap" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.CheckForERetTrap()
// ==========================
// Check for trap on ERET, ERETAA, ERETAB instruction

<anchor link="AArch64.CheckForERetTrap.2" hover="function: AArch64.CheckForERetTrap(boolean eret_with_pac, boolean pac_uses_key_a)">AArch64.CheckForERetTrap</anchor>(boolean eret_with_pac, boolean pac_uses_key_a)

    route_to_el2 = FALSE;
    // Non-secure EL1 execution of ERET, ERETAA, ERETAB when either HCR_EL2.NV or HFGITR_EL2.ERET is set,
    // is trapped to EL2
    route_to_el2 = (PSTATE.EL == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                   ((<a link="impl-shared.HaveNVExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveNVExt()">HaveNVExt</a>() &amp;&amp; HCR_EL2.NV == '1') ||
                   (<a link="impl-shared.HaveFGTExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveFGTExt()">HaveFGTExt</a>() &amp;&amp; HCR_EL2.&lt;E2H, TGE&gt; != '11' &amp;&amp;
                   (!<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) || SCR_EL3.FGTEn == '1') &amp;&amp; HFGITR_EL2.ERET == '1')));
    if route_to_el2 then
        <a link="ExceptionRecord" file="shared_pseudocode.xml" hover="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception;
        bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
        vect_offset = 0x0;
        exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_ERetTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_ERetTrap</a>);
        if !eret_with_pac then                             // ERET
            exception.syndrome&lt;1&gt; = '0';
            exception.syndrome&lt;0&gt; = '0';                   // RES0
        else
            exception.syndrome&lt;1&gt; = '1';
            if pac_uses_key_a then                         // ERETAA
                exception.syndrome&lt;0&gt; = '0';
            else    // ERETAB
                exception.syndrome&lt;0&gt; = '1';
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/traps/AArch64.CheckForSMCUndefOrTrap" mylink="aarch64.exceptions.traps.AArch64.CheckForSMCUndefOrTrap" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.CheckForSMCUndefOrTrap()
// ================================
// Check for UNDEFINED or trap on SMC instruction

<anchor link="AArch64.CheckForSMCUndefOrTrap.1" hover="function: AArch64.CheckForSMCUndefOrTrap(bits(16) imm)">AArch64.CheckForSMCUndefOrTrap</anchor>(bits(16) imm)
    if PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then UNDEFINED;
    if (!(PSTATE.EL == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TSC == '1') &amp;&amp;
        <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.SMD == '1') then
        UNDEFINED;
    route_to_el2 = FALSE;
    if !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
        if PSTATE.EL == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() then
            if <a link="impl-shared.HaveNVExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveNVExt()">HaveNVExt</a>() &amp;&amp; HCR_EL2.NV == '1' &amp;&amp; HCR_EL2.TSC == '1' then
                route_to_el2 = TRUE;
            else
                UNDEFINED;
        else
            UNDEFINED;
    else
        route_to_el2 = PSTATE.EL == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TSC == '1';
    if route_to_el2 then
        bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
        vect_offset = 0x0;
        exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_MonitorCall" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_MonitorCall</a>);
        exception.syndrome&lt;15:0&gt; = imm;
        exception.trappedsyscallinst = TRUE;
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/traps/AArch64.CheckForSVCTrap" mylink="aarch64.exceptions.traps.AArch64.CheckForSVCTrap" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.CheckForSVCTrap()
// =========================
// Check for trap on SVC instruction

<anchor link="AArch64.CheckForSVCTrap.1" hover="function: AArch64.CheckForSVCTrap(bits(16) immediate)">AArch64.CheckForSVCTrap</anchor>(bits(16) immediate)
    if <a link="impl-shared.HaveFGTExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveFGTExt()">HaveFGTExt</a>() then
        route_to_el2 = FALSE;
        if PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then
            route_to_el2 = (!<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>) &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>)  &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HFGITR_EL2.SVC_EL0 == '1' &amp;&amp;
                           (HCR_EL2.&lt;E2H, TGE&gt; != '11' &amp;&amp; (!<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) || SCR_EL3.FGTEn == '1')));

        elsif PSTATE.EL == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> then
            route_to_el2 = (!<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HFGITR_EL2.SVC_EL1 == '1' &amp;&amp;
                           (HCR_EL2.&lt;E2H, TGE&gt; != '11' &amp;&amp; (!<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) || SCR_EL3.FGTEn == '1')));

        if route_to_el2 then
            exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_SupervisorCall" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SupervisorCall</a>);
            exception.syndrome&lt;15:0&gt; = immediate;
            exception.trappedsyscallinst = TRUE;
            bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
            vect_offset = 0x0;

            <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/traps/AArch64.CheckForWFxTrap" mylink="aarch64.exceptions.traps.AArch64.CheckForWFxTrap" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.CheckForWFxTrap()
// =========================
// Check for trap on WFE or WFI instruction

<anchor link="AArch64.CheckForWFxTrap.2" hover="function: AArch64.CheckForWFxTrap(bits(2) target_el, WFxType wfxtype)">AArch64.CheckForWFxTrap</anchor>(bits(2) target_el, <a link="WFxType" file="shared_pseudocode.xml" hover="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType</a> wfxtype)
    assert <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(target_el);

    boolean is_wfe = wfxtype IN {<a link="WFxType_WFE" file="shared_pseudocode.xml" hover="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFE</a>, <a link="WFxType_WFET" file="shared_pseudocode.xml" hover="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFET</a>};
    boolean trap;
    case target_el of
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>
            trap = (if is_wfe then <a link="impl-aarch64.SCTLR.read.0" file="shared_pseudocode.xml" hover="accessor: SCTLRType SCTLR[]">SCTLR</a>[].nTWE else <a link="impl-aarch64.SCTLR.read.0" file="shared_pseudocode.xml" hover="accessor: SCTLRType SCTLR[]">SCTLR</a>[].nTWI) == '0';
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>
            trap = (if is_wfe then HCR_EL2.TWE else HCR_EL2.TWI) == '1';
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>
            trap = (if is_wfe then SCR_EL3.TWE else SCR_EL3.TWI) == '1';

    if trap then
        <a link="AArch64.WFxTrap.2" file="shared_pseudocode.xml" hover="function: AArch64.WFxTrap(WFxType wfxtype, bits(2) target_el)">AArch64.WFxTrap</a>(wfxtype, target_el);</pstext>
    </ps>
    <ps name="aarch64/exceptions/traps/AArch64.CheckIllegalState" mylink="aarch64.exceptions.traps.AArch64.CheckIllegalState" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.CheckIllegalState()
// ===========================
// Check PSTATE.IL bit and generate Illegal Execution state exception if set.

<anchor link="AArch64.CheckIllegalState.0" hover="function: AArch64.CheckIllegalState()">AArch64.CheckIllegalState</anchor>()
    if PSTATE.IL == '1' then
        route_to_el2 = PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1';

        bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
        vect_offset = 0x0;

        exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_IllegalState" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IllegalState</a>);

        if <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then
            <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
        elsif route_to_el2 then
            <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
        else
            <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/traps/AArch64.MonitorModeTrap" mylink="aarch64.exceptions.traps.AArch64.MonitorModeTrap" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.MonitorModeTrap()
// =========================
// Trapped use of Monitor mode features in a Secure EL1 AArch32 mode

<anchor link="AArch64.MonitorModeTrap.0" hover="function: AArch64.MonitorModeTrap()">AArch64.MonitorModeTrap</anchor>()
    bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_Uncategorized" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a>);

    if <a link="impl-shared.IsSecureEL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>() then
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/traps/AArch64.SystemAccessTrap" mylink="aarch64.exceptions.traps.AArch64.SystemAccessTrap" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.SystemAccessTrap()
// ==========================
// Trapped access to AArch64 system register or system instruction.

<anchor link="AArch64.SystemAccessTrap.2" hover="function: AArch64.SystemAccessTrap(bits(2) target_el, integer ec)">AArch64.SystemAccessTrap</anchor>(bits(2) target_el, integer ec)
    assert <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(target_el) &amp;&amp; target_el != <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt;= <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL);

    bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a link="AArch64.SystemAccessTrapSyndrome.2" file="shared_pseudocode.xml" hover="function: ExceptionRecord AArch64.SystemAccessTrapSyndrome(bits(32) instr_in, integer ec)">AArch64.SystemAccessTrapSyndrome</a>(<a link="impl-shared.ThisInstr.0" file="shared_pseudocode.xml" hover="function: bits(32) ThisInstr()">ThisInstr</a>(), ec);
    <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/traps/AArch64.SystemAccessTrapSyndrome" mylink="aarch64.exceptions.traps.AArch64.SystemAccessTrapSyndrome" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.SystemAccessTrapSyndrome()
// ==================================
// Returns the syndrome information for traps on AArch64 MSR/MRS instructions.

ExceptionRecord <anchor link="AArch64.SystemAccessTrapSyndrome.2" hover="function: ExceptionRecord AArch64.SystemAccessTrapSyndrome(bits(32) instr_in, integer ec)">AArch64.SystemAccessTrapSyndrome</anchor>(bits(32) instr_in, integer ec)
    <a link="ExceptionRecord" file="shared_pseudocode.xml" hover="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception;
    bits(32) instr = instr_in;
    case ec of
        when 0x0                                                     // Trapped access due to unknown reason.
            exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_Uncategorized" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a>);
        when 0x7                                                     // Trapped access to SVE, Advance SIMD&amp;FP system register.
            exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_AdvSIMDFPAccessTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>);
            exception.syndrome&lt;24:20&gt; = <a link="impl-shared.ConditionSyndrome.0" file="shared_pseudocode.xml" hover="function: bits(5) ConditionSyndrome()">ConditionSyndrome</a>();
        when 0x18                                                    // Trapped access to system register or system instruction.
            exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_SystemRegisterTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SystemRegisterTrap</a>);
            instr = <a link="impl-shared.ThisInstr.0" file="shared_pseudocode.xml" hover="function: bits(32) ThisInstr()">ThisInstr</a>();
            exception.syndrome&lt;21:20&gt; = instr&lt;20:19&gt;;          // Op0
            exception.syndrome&lt;19:17&gt; = instr&lt;7:5&gt;;            // Op2
            exception.syndrome&lt;16:14&gt; = instr&lt;18:16&gt;;          // Op1
            exception.syndrome&lt;13:10&gt; = instr&lt;15:12&gt;;          // CRn
            exception.syndrome&lt;9:5&gt;   = instr&lt;4:0&gt;;            // Rt
            exception.syndrome&lt;4:1&gt;   = instr&lt;11:8&gt;;           // CRm
            exception.syndrome&lt;0&gt;     = instr&lt;21&gt;;             // Direction
        otherwise
            <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();

    return exception;</pstext>
    </ps>
    <ps name="aarch64/exceptions/traps/AArch64.UndefinedFault" mylink="aarch64.exceptions.traps.AArch64.UndefinedFault" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.UndefinedFault()
// ========================

<anchor link="AArch64.UndefinedFault.0" hover="function: AArch64.UndefinedFault()">AArch64.UndefinedFault</anchor>()

    route_to_el2 = PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1';
    bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_Uncategorized" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a>);

    if <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif route_to_el2 then
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/traps/AArch64.WFxTrap" mylink="aarch64.exceptions.traps.AArch64.WFxTrap" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.WFxTrap()
// =================

<anchor link="AArch64.WFxTrap.2" hover="function: AArch64.WFxTrap(WFxType wfxtype, bits(2) target_el)">AArch64.WFxTrap</anchor>(<a link="WFxType" file="shared_pseudocode.xml" hover="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType</a> wfxtype, bits(2) target_el)
    assert <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL);

    bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_WFxTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_WFxTrap</a>);
    exception.syndrome&lt;24:20&gt; = <a link="impl-shared.ConditionSyndrome.0" file="shared_pseudocode.xml" hover="function: bits(5) ConditionSyndrome()">ConditionSyndrome</a>();

    case wfxtype of
        when <a link="WFxType_WFI" file="shared_pseudocode.xml" hover="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFI</a>
            exception.syndrome&lt;1:0&gt; = '00';
        when <a link="WFxType_WFE" file="shared_pseudocode.xml" hover="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFE</a>
            exception.syndrome&lt;1:0&gt; = '01';
        when <a link="WFxType_WFIT" file="shared_pseudocode.xml" hover="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFIT</a>
            exception.syndrome&lt;1:0&gt; = '10';
            if <a link="impl-shared.HaveFeatWFxT2.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatWFxT2()">HaveFeatWFxT2</a>() then
                exception.syndrome&lt;2&gt;   = '1';   // Register field is valid
                exception.syndrome&lt;9:5&gt; = <a link="impl-shared.ThisInstr.0" file="shared_pseudocode.xml" hover="function: bits(32) ThisInstr()">ThisInstr</a>()&lt;4:0&gt;;
            else
                exception.syndrome&lt;2&gt; = '0';     // Register field is invalid
        when <a link="WFxType_WFET" file="shared_pseudocode.xml" hover="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFET</a>
            exception.syndrome&lt;1:0&gt; = '11';
            if <a link="impl-shared.HaveFeatWFxT2.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatWFxT2()">HaveFeatWFxT2</a>() then
                exception.syndrome&lt;2&gt;   = '1';   // Register field is valid
                exception.syndrome&lt;9:5&gt; = <a link="impl-shared.ThisInstr.0" file="shared_pseudocode.xml" hover="function: bits(32) ThisInstr()">ThisInstr</a>()&lt;4:0&gt;;
            else
                exception.syndrome&lt;2&gt; = '0';     // Register field is invalid

    if target_el == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/exceptions/traps/CheckFPAdvSIMDEnabled64" mylink="aarch64.exceptions.traps.CheckFPAdvSIMDEnabled64" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CheckFPAdvSIMDEnabled64()
// =========================
// AArch64 instruction wrapper

<anchor link="impl-aarch64.CheckFPAdvSIMDEnabled64.0" hover="function: CheckFPAdvSIMDEnabled64()">CheckFPAdvSIMDEnabled64</anchor>()
    <a link="AArch64.CheckFPAdvSIMDEnabled.0" file="shared_pseudocode.xml" hover="function: AArch64.CheckFPAdvSIMDEnabled()">AArch64.CheckFPAdvSIMDEnabled</a>();</pstext>
    </ps>
    <ps name="aarch64/exceptions/traps/CheckFPEnabled64" mylink="aarch64.exceptions.traps.CheckFPEnabled64" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CheckFPEnabled64()
// ==================
// AArch64 instruction wrapper

<anchor link="impl-aarch64.CheckFPEnabled64.0" hover="function: CheckFPEnabled64()">CheckFPEnabled64</anchor>()
    <a link="AArch64.CheckFPEnabled.0" file="shared_pseudocode.xml" hover="function: AArch64.CheckFPEnabled()">AArch64.CheckFPEnabled</a>();</pstext>
    </ps>
    <ps name="aarch64/exceptions/traps/CheckLDST64BEnabled" mylink="aarch64.exceptions.traps.CheckLDST64BEnabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CheckLDST64BEnabled()
// =====================
// Checks for trap on ST64B and LD64B instructions

<anchor link="impl-aarch64.CheckLDST64BEnabled.0" hover="function: CheckLDST64BEnabled()">CheckLDST64BEnabled</anchor>()
    boolean trap = FALSE;
    bits(25) iss = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>('10');  // 0x2
    bits(2) target_el;

    if PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then
        if !<a link="impl-shared.IsInHost.0" file="shared_pseudocode.xml" hover="function: boolean IsInHost()">IsInHost</a>() then
            trap = SCTLR_EL1.EnALS == '0';
            target_el = if <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> else <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;
        else
            trap = SCTLR_EL2.EnALS == '0';
            target_el = <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;
    else
        target_el = <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;

    if (!trap &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; <a link="impl-shared.HaveFeatHCX.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatHCX()">HaveFeatHCX</a>() &amp;&amp;
        ((PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a link="impl-shared.IsInHost.0" file="shared_pseudocode.xml" hover="function: boolean IsInHost()">IsInHost</a>()) || PSTATE.EL == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>)) then
        trap = !<a link="impl-aarch64.IsHCRXEL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean IsHCRXEL2Enabled()">IsHCRXEL2Enabled</a>() || HCRX_EL2.EnALS == '0';
        target_el = <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;

    if trap then <a link="impl-aarch64.LDST64BTrap.2" file="shared_pseudocode.xml" hover="function: LDST64BTrap(bits(2) target_el, bits(25) iss)">LDST64BTrap</a>(target_el, iss);</pstext>
    </ps>
    <ps name="aarch64/exceptions/traps/CheckST64BV0Enabled" mylink="aarch64.exceptions.traps.CheckST64BV0Enabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CheckST64BV0Enabled()
// =====================
// Checks for trap on ST64BV0 instruction

<anchor link="impl-aarch64.CheckST64BV0Enabled.0" hover="function: CheckST64BV0Enabled()">CheckST64BV0Enabled</anchor>()
    boolean trap = FALSE;
    bits(25) iss = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>('1');  // 0x1
    bits(2) target_el;

    if PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then
        if !<a link="impl-shared.IsInHost.0" file="shared_pseudocode.xml" hover="function: boolean IsInHost()">IsInHost</a>() then
            trap = SCTLR_EL1.EnAS0 == '0';
            target_el = if <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> else <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;
        else
            trap = SCTLR_EL2.EnAS0 == '0';
            target_el = <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;

    if (!trap &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; <a link="impl-shared.HaveFeatHCX.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatHCX()">HaveFeatHCX</a>() &amp;&amp;
        ((PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a link="impl-shared.IsInHost.0" file="shared_pseudocode.xml" hover="function: boolean IsInHost()">IsInHost</a>()) || PSTATE.EL == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>)) then
        trap = !<a link="impl-aarch64.IsHCRXEL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean IsHCRXEL2Enabled()">IsHCRXEL2Enabled</a>() || HCRX_EL2.EnAS0 == '0';
        target_el = <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;

    if !trap &amp;&amp; PSTATE.EL != <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> then
        trap = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.EnAS0 == '0';
        target_el = <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>;

    if trap then <a link="impl-aarch64.LDST64BTrap.2" file="shared_pseudocode.xml" hover="function: LDST64BTrap(bits(2) target_el, bits(25) iss)">LDST64BTrap</a>(target_el, iss);</pstext>
    </ps>
    <ps name="aarch64/exceptions/traps/CheckST64BVEnabled" mylink="aarch64.exceptions.traps.CheckST64BVEnabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CheckST64BVEnabled()
// ====================
// Checks for trap on ST64BV instruction

<anchor link="impl-aarch64.CheckST64BVEnabled.0" hover="function: CheckST64BVEnabled()">CheckST64BVEnabled</anchor>()
    boolean trap = FALSE;
    bits(25) iss = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();
    bits(2) target_el;

    if PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then
        if !<a link="impl-shared.IsInHost.0" file="shared_pseudocode.xml" hover="function: boolean IsInHost()">IsInHost</a>() then
            trap = SCTLR_EL1.EnASR == '0';
            target_el = if <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> else <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;
        else
            trap = SCTLR_EL2.EnASR == '0';
            target_el = <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;

    if (!trap &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; <a link="impl-shared.HaveFeatHCX.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatHCX()">HaveFeatHCX</a>() &amp;&amp;
        ((PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a link="impl-shared.IsInHost.0" file="shared_pseudocode.xml" hover="function: boolean IsInHost()">IsInHost</a>()) || PSTATE.EL == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>)) then
        trap = !<a link="impl-aarch64.IsHCRXEL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean IsHCRXEL2Enabled()">IsHCRXEL2Enabled</a>() || HCRX_EL2.EnASR == '0';
        target_el = <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;

    if trap then <a link="impl-aarch64.LDST64BTrap.2" file="shared_pseudocode.xml" hover="function: LDST64BTrap(bits(2) target_el, bits(25) iss)">LDST64BTrap</a>(target_el, iss);</pstext>
    </ps>
    <ps name="aarch64/exceptions/traps/LDST64BTrap" mylink="aarch64.exceptions.traps.LDST64BTrap" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// LDST64BTrap()
// =============
// Trapped access to LD64B, ST64B, ST64BV and ST64BV0 instructions

<anchor link="impl-aarch64.LDST64BTrap.2" hover="function: LDST64BTrap(bits(2) target_el, bits(25) iss)">LDST64BTrap</anchor>(bits(2) target_el, bits(25) iss)
    bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_LDST64BTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_LDST64BTrap</a>);
    exception.syndrome = iss;
    <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);

    return;</pstext>
    </ps>
    <ps name="aarch64/exceptions/traps/WFETrapDelay" mylink="aarch64.exceptions.traps.WFETrapDelay" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// WFETrapDelay()
// ==============
// Returns TRUE when delay in trap to WFE is enabled with value to amount of delay,
// FALSE otherwise.

(boolean, integer) <anchor link="impl-aarch64.WFETrapDelay.1" hover="function: (boolean, integer) WFETrapDelay(bits(2) target_el)">WFETrapDelay</anchor>(bits(2) target_el)
    boolean delay_enabled;
    integer delay;
    case target_el of
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>
            if !<a link="impl-shared.IsInHost.0" file="shared_pseudocode.xml" hover="function: boolean IsInHost()">IsInHost</a>() then
                delay_enabled = SCTLR_EL1.TWEDEn == '1';
                delay         = 1 &lt;&lt; (<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(SCTLR_EL1.TWEDEL) + 8);
            else
                delay_enabled = SCTLR_EL2.TWEDEn == '1';
                delay         = 1 &lt;&lt; (<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(SCTLR_EL2.TWEDEL) + 8);
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>
            assert <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>();
            delay_enabled = HCR_EL2.TWEDEn == '1';
            delay         = 1 &lt;&lt; (<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(HCR_EL2.TWEDEL) + 8);
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>
            delay_enabled = SCR_EL3.TWEDEn == '1';
            delay         = 1 &lt;&lt; (<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(SCR_EL3.TWEDEL) + 8);

    return (delay_enabled, delay);</pstext>
    </ps>
    <ps name="aarch64/exceptions/traps/WaitForEventUntilDelay" mylink="aarch64.exceptions.traps.WaitForEventUntilDelay" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns TRUE if WaitForEvent() returns before WFE trap delay expires,
// FALSE otherwise.
boolean <anchor link="impl-aarch64.WaitForEventUntilDelay.2" hover="function: boolean WaitForEventUntilDelay(boolean delay_enabled, integer delay)">WaitForEventUntilDelay</anchor>(boolean delay_enabled, integer delay);</pstext>
    </ps>
    <ps name="aarch64/functions/aborts/AArch64.FaultSyndrome" mylink="aarch64.functions.aborts.AArch64.FaultSyndrome" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.FaultSyndrome()
// =======================
// Creates an exception syndrome value for Abort and Watchpoint exceptions taken to
// an Exception level using AArch64.

(bits(25), bits(5)) <anchor link="AArch64.FaultSyndrome.2" hover="function: (bits(25), bits(5)) AArch64.FaultSyndrome(boolean d_side, FaultRecord fault)">AArch64.FaultSyndrome</anchor>(boolean d_side, <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    assert fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    bits(25) iss = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();
    bits(5) iss2 = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();

    if !<a link="impl-shared.HaveFeatLS64.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatLS64()">HaveFeatLS64</a>() &amp;&amp; <a link="impl-shared.HaveRASExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; <a link="impl-shared.IsAsyncAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsAsyncAbort(Fault statuscode)">IsAsyncAbort</a>(fault) then
        iss&lt;12:11&gt; = fault.errortype; // SET

    if d_side then
        if <a link="impl-shared.HaveFeatLS64.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatLS64()">HaveFeatLS64</a>() &amp;&amp; fault.acctype == <a link="AccType_ATOMICLS64" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICLS64</a> then
            if (fault.statuscode IN {<a link="Fault_AccessFlag" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>,
                <a link="Fault_Translation" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>, <a link="Fault_Permission" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>}) then
                (iss2, iss&lt;24:14&gt;, iss&lt;12:11&gt;) = <a link="impl-aarch64.LS64InstructionSyndrome.0" file="shared_pseudocode.xml" hover="function: (bits(5), bits(11), bits(2)) LS64InstructionSyndrome()">LS64InstructionSyndrome</a>();
        else
            if (<a link="impl-shared.IsSecondStage.1" file="shared_pseudocode.xml" hover="function: boolean IsSecondStage(FaultRecord fault)">IsSecondStage</a>(fault) &amp;&amp; !fault.s2fs1walk &amp;&amp;
                (!<a link="impl-shared.IsExternalSyncAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(fault) ||
                (!<a link="impl-shared.HaveRASExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; fault.acctype == <a link="AccType_TTW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_TTW</a> &amp;&amp;
                boolean IMPLEMENTATION_DEFINED "ISV on second stage translation table walk"))) then
                iss&lt;24:14&gt; = <a link="impl-shared.LSInstructionSyndrome.0" file="shared_pseudocode.xml" hover="function: bits(11) LSInstructionSyndrome()">LSInstructionSyndrome</a>();

        if <a link="impl-shared.HaveNV2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveNV2Ext()">HaveNV2Ext</a>() &amp;&amp; fault.acctype == <a link="AccType_NV2REGISTER" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NV2REGISTER</a> then
            iss&lt;13&gt; = '1';   // Fault is generated by use of VNCR_EL2

        if fault.acctype IN {<a link="AccType_DC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>, <a link="AccType_IC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>, <a link="AccType_AT" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</a>, <a link="AccType_ATPAN" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATPAN</a>} then
            iss&lt;8&gt; = '1';  iss&lt;6&gt; = '1';
        else
            iss&lt;6&gt; = if fault.write then '1' else '0';

    if <a link="impl-shared.IsExternalAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) then iss&lt;9&gt; = fault.extflag;
    iss&lt;7&gt; = if fault.s2fs1walk then '1' else '0';
    iss&lt;5:0&gt; = <a link="impl-shared.EncodeLDFSC.2" file="shared_pseudocode.xml" hover="function: bits(6) EncodeLDFSC(Fault statuscode, integer level)">EncodeLDFSC</a>(fault.statuscode, fault.level);

    return (iss, iss2);</pstext>
    </ps>
    <ps name="aarch64/functions/aborts/LS64InstructionSyndrome" mylink="aarch64.functions.aborts.LS64InstructionSyndrome" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns the syndrome information and LST for a Data Abort by a
// ST64B, ST64BV, ST64BV0, or LD64B instruction. The syndrome information
// includes the ISS2, extended syndrome field, and LST.
(bits(5), bits(11), bits(2)) <anchor link="impl-aarch64.LS64InstructionSyndrome.0" hover="function: (bits(5), bits(11), bits(2)) LS64InstructionSyndrome()">LS64InstructionSyndrome</anchor>();</pstext>
    </ps>
    <ps name="aarch64/functions/cache/AArch64.DataMemZero" mylink="aarch64.functions.cache.AArch64.DataMemZero" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.DataMemZero()
// =====================
// Write Zero to data memory

<anchor link="AArch64.DataMemZero.4" hover="function: AArch64.DataMemZero(bits(64) regval, bits(64) vaddress, AddressDescriptor memaddrdesc_in, integer size)">AArch64.DataMemZero</anchor>(bits(64) regval, bits(64) vaddress, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc_in, integer size)
    iswrite = TRUE;
    <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc = memaddrdesc_in;
    for i = 0 to size-1
        accdesc = <a link="impl-shared.CreateAccessDescriptor.1" file="shared_pseudocode.xml" hover="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(<a link="AccType_DCZVA" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DCZVA</a>);
        if <a link="impl-shared.HaveMTEExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveMTEExt()">HaveMTEExt</a>() then
            if <a link="AArch64.AccessIsTagChecked.2" file="shared_pseudocode.xml" hover="function: boolean AArch64.AccessIsTagChecked(bits(64) vaddr, AccType acctype)">AArch64.AccessIsTagChecked</a>(vaddress, <a link="AccType_DCZVA" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DCZVA</a>) then
                bits(4) ptag = <a link="AArch64.PhysicalTag.1" file="shared_pseudocode.xml" hover="function: bits(4) AArch64.PhysicalTag(bits(64) vaddr)">AArch64.PhysicalTag</a>(vaddress);
                if !<a link="AArch64.CheckTag.4" file="shared_pseudocode.xml" hover="function: boolean AArch64.CheckTag(AddressDescriptor memaddrdesc, AccessDescriptor accdesc, bits(4) ptag, boolean write)">AArch64.CheckTag</a>(memaddrdesc, accdesc, ptag, iswrite) then
                    if boolean IMPLEMENTATION_DEFINED "DC_ZVA tag fault reported with lowest faulting address" then
                        <a link="AArch64.TagCheckFault.3" file="shared_pseudocode.xml" hover="function: AArch64.TagCheckFault(bits(64) vaddress, AccType acctype, boolean iswrite)">AArch64.TagCheckFault</a>(vaddress, <a link="AccType_DCZVA" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DCZVA</a>, iswrite);
                    else
                        <a link="AArch64.TagCheckFault.3" file="shared_pseudocode.xml" hover="function: AArch64.TagCheckFault(bits(64) vaddress, AccType acctype, boolean iswrite)">AArch64.TagCheckFault</a>(regval, <a link="AccType_DCZVA" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DCZVA</a>, iswrite);
        memstatus = <a link="impl-shared.PhysMemWrite.4" file="shared_pseudocode.xml" hover="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(memaddrdesc, 1, accdesc, <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>());
        if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a link="impl-shared.HandleExternalWriteAbort.4" file="shared_pseudocode.xml" hover="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, 1, accdesc);
        memaddrdesc.paddress.address = memaddrdesc.paddress.address + 1;
    return;</pstext>
    </ps>
    <ps name="aarch64/functions/cache/AArch64.TagMemZero" mylink="aarch64.functions.cache.AArch64.TagMemZero" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.TagMemZero()
// ====================
// Write Zero to tag memory

<anchor link="AArch64.TagMemZero.2" hover="function: AArch64.TagMemZero(bits(64) vaddress_in, integer size)">AArch64.TagMemZero</anchor>(bits(64) vaddress_in, integer size)
    bits(64) vaddress = vaddress_in;
    integer count = size &gt;&gt; <a link="LOG2_TAG_GRANULE" file="shared_pseudocode.xml" hover="constant integer LOG2_TAG_GRANULE = 4">LOG2_TAG_GRANULE</a>;
    bits(4) tag = <a link="AArch64.AllocationTagFromAddress.1" file="shared_pseudocode.xml" hover="function: bits(4) AArch64.AllocationTagFromAddress(bits(64) tagged_address)">AArch64.AllocationTagFromAddress</a>(vaddress);
    for i = 0 to count-1
        <a link="AArch64.MemTag.write.2" file="shared_pseudocode.xml" hover="accessor: AArch64.MemTag[bits(64) address, AccType acctype] = bits(4) value">AArch64.MemTag</a>[vaddress, <a link="AccType_NORMAL" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NORMAL</a>] = tag;
        vaddress = vaddress + <a link="TAG_GRANULE" file="shared_pseudocode.xml" hover="constant integer TAG_GRANULE = 1 &lt;&lt; LOG2_TAG_GRANULE">TAG_GRANULE</a>;
    return;</pstext>
    </ps>
    <ps name="aarch64/functions/exclusive/AArch64.ExclusiveMonitorsPass" mylink="aarch64.functions.exclusive.AArch64.ExclusiveMonitorsPass" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.ExclusiveMonitorsPass()
// ===============================
// Return TRUE if the Exclusives monitors for the current PE include all of the addresses
// associated with the virtual address region of size bytes starting at address.
// The immediately following memory write must be to the same addresses.

boolean <anchor link="AArch64.ExclusiveMonitorsPass.2" hover="function: boolean AArch64.ExclusiveMonitorsPass(bits(64) address, integer size)">AArch64.ExclusiveMonitorsPass</anchor>(bits(64) address, integer size)

    // It is IMPLEMENTATION DEFINED whether the detection of memory aborts happens
    // before or after the check on the local Exclusives monitor. As a result a failure
    // of the local monitor can occur on some implementations even if the memory
    // access would give an memory abort.

    acctype = <a link="AccType_ATOMIC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMIC</a>;
    iswrite = TRUE;

    aligned = <a link="AArch64.CheckAlignment.4" file="shared_pseudocode.xml" hover="function: boolean AArch64.CheckAlignment(bits(64) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch64.CheckAlignment</a>(address, size, acctype, iswrite);

    passed = <a link="AArch64.IsExclusiveVA.3" file="shared_pseudocode.xml" hover="function: boolean AArch64.IsExclusiveVA(bits(64) address, integer processorid, integer size)">AArch64.IsExclusiveVA</a>(address, <a link="impl-shared.ProcessorID.0" file="shared_pseudocode.xml" hover="function: integer ProcessorID()">ProcessorID</a>(), size);
    if !passed then
        return FALSE;

    memaddrdesc = <a link="AArch64.TranslateAddress.5" file="shared_pseudocode.xml" hover="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccType acctype, boolean iswrite,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, acctype, iswrite, aligned, size);
    // Check for aborts or debug exceptions
    if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a link="AArch64.Abort.2" file="shared_pseudocode.xml" hover="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, memaddrdesc.fault);

    passed = <a link="impl-shared.IsExclusiveLocal.3" file="shared_pseudocode.xml" hover="function: boolean IsExclusiveLocal(FullAddress paddress, integer processorid, integer size)">IsExclusiveLocal</a>(memaddrdesc.paddress, <a link="impl-shared.ProcessorID.0" file="shared_pseudocode.xml" hover="function: integer ProcessorID()">ProcessorID</a>(), size);
    <a link="impl-shared.ClearExclusiveLocal.1" file="shared_pseudocode.xml" hover="function: ClearExclusiveLocal(integer processorid)">ClearExclusiveLocal</a>(<a link="impl-shared.ProcessorID.0" file="shared_pseudocode.xml" hover="function: integer ProcessorID()">ProcessorID</a>());

    if passed then
        if memaddrdesc.memattrs.shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then
            passed = <a link="impl-shared.IsExclusiveGlobal.3" file="shared_pseudocode.xml" hover="function: boolean IsExclusiveGlobal(FullAddress paddress, integer processorid, integer size)">IsExclusiveGlobal</a>(memaddrdesc.paddress, <a link="impl-shared.ProcessorID.0" file="shared_pseudocode.xml" hover="function: integer ProcessorID()">ProcessorID</a>(), size);

    return passed;</pstext>
    </ps>
    <ps name="aarch64/functions/exclusive/AArch64.IsExclusiveVA" mylink="aarch64.functions.exclusive.AArch64.IsExclusiveVA" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// An optional IMPLEMENTATION DEFINED test for an exclusive access to a virtual
// address region of size bytes starting at address.
//
// It is permitted (but not required) for this function to return FALSE and
// cause a store exclusive to fail if the virtual address region is not
// totally included within the region recorded by MarkExclusiveVA().
//
// It is always safe to return TRUE which will check the physical address only.
boolean <anchor link="AArch64.IsExclusiveVA.3" hover="function: boolean AArch64.IsExclusiveVA(bits(64) address, integer processorid, integer size)">AArch64.IsExclusiveVA</anchor>(bits(64) address, integer processorid, integer size);</pstext>
    </ps>
    <ps name="aarch64/functions/exclusive/AArch64.MarkExclusiveVA" mylink="aarch64.functions.exclusive.AArch64.MarkExclusiveVA" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Optionally record an exclusive access to the virtual address region of size bytes
// starting at address for processorid.
<anchor link="AArch64.MarkExclusiveVA.3" hover="function: AArch64.MarkExclusiveVA(bits(64) address, integer processorid, integer size)">AArch64.MarkExclusiveVA</anchor>(bits(64) address, integer processorid, integer size);</pstext>
    </ps>
    <ps name="aarch64/functions/exclusive/AArch64.SetExclusiveMonitors" mylink="aarch64.functions.exclusive.AArch64.SetExclusiveMonitors" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.SetExclusiveMonitors()
// ==============================
// Sets the Exclusives monitors for the current PE to record the addresses associated
// with the virtual address region of size bytes starting at address.

<anchor link="AArch64.SetExclusiveMonitors.2" hover="function: AArch64.SetExclusiveMonitors(bits(64) address, integer size)">AArch64.SetExclusiveMonitors</anchor>(bits(64) address, integer size)
    acctype = <a link="AccType_ATOMIC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMIC</a>;
    iswrite = FALSE;

    aligned = <a link="AArch64.CheckAlignment.4" file="shared_pseudocode.xml" hover="function: boolean AArch64.CheckAlignment(bits(64) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch64.CheckAlignment</a>(address, size, acctype, iswrite);

    memaddrdesc = <a link="AArch64.TranslateAddress.5" file="shared_pseudocode.xml" hover="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccType acctype, boolean iswrite,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, acctype, iswrite, aligned, size);
    // Check for aborts or debug exceptions
    if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        return;

    if memaddrdesc.memattrs.shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then
        <a link="impl-shared.MarkExclusiveGlobal.3" file="shared_pseudocode.xml" hover="function: MarkExclusiveGlobal(FullAddress paddress, integer processorid, integer size)">MarkExclusiveGlobal</a>(memaddrdesc.paddress, <a link="impl-shared.ProcessorID.0" file="shared_pseudocode.xml" hover="function: integer ProcessorID()">ProcessorID</a>(), size);

    <a link="impl-shared.MarkExclusiveLocal.3" file="shared_pseudocode.xml" hover="function: MarkExclusiveLocal(FullAddress paddress, integer processorid, integer size)">MarkExclusiveLocal</a>(memaddrdesc.paddress, <a link="impl-shared.ProcessorID.0" file="shared_pseudocode.xml" hover="function: integer ProcessorID()">ProcessorID</a>(), size);

    <a link="AArch64.MarkExclusiveVA.3" file="shared_pseudocode.xml" hover="function: AArch64.MarkExclusiveVA(bits(64) address, integer processorid, integer size)">AArch64.MarkExclusiveVA</a>(address, <a link="impl-shared.ProcessorID.0" file="shared_pseudocode.xml" hover="function: integer ProcessorID()">ProcessorID</a>(), size);</pstext>
    </ps>
    <ps name="aarch64/functions/fusedrstep/FPRSqrtStepFused" mylink="aarch64.functions.fusedrstep.FPRSqrtStepFused" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPRSqrtStepFused()
// ==================

bits(N) <anchor link="impl-aarch64.FPRSqrtStepFused.2" hover="function: bits(N) FPRSqrtStepFused(bits(N) op1_in, bits(N) op2)">FPRSqrtStepFused</anchor>(bits(N) op1_in, bits(N) op2)
    assert N IN {16, 32, 64};
    bits(N) result;
    bits(N) op1 = op1_in;
    boolean done;
    <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr = FPCR[];
    op1 = <a link="impl-shared.FPNeg.1" file="shared_pseudocode.xml" hover="function: bits(N) FPNeg(bits(N) op)">FPNeg</a>(op1);
    boolean altfp = <a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; fpcr.AH == '1';
    boolean fpexc = !altfp;                         // Generate no floating-point exceptions
    if altfp then fpcr.&lt;FIZ,FZ&gt; = '11';             // Flush denormal input and output to zero
    if altfp then fpcr.RMode = '00';                // Use RNE rounding mode

    (type1,sign1,value1) = <a link="impl-shared.FPUnpack.3" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op1, fpcr, fpexc);
    (type2,sign2,value2) = <a link="impl-shared.FPUnpack.3" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op2, fpcr, fpexc);
    (done,result) = <a link="impl-shared.FPProcessNaNs.7" file="shared_pseudocode.xml" hover="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean altfmaxfmin, boolean fpexc)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr, FALSE, fpexc);
    <a link="FPRounding" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding = <a link="impl-shared.FPRoundingMode.1" file="shared_pseudocode.xml" hover="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);

    if !done then
        inf1 = (type1 == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        inf2 = (type2 == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        zero2 = (type2 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result = <a link="impl-shared.FPOnePointFive.1" file="shared_pseudocode.xml" hover="function: bits(N) FPOnePointFive(bit sign)">FPOnePointFive</a>('0');
        elsif inf1 || inf2 then
            result = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign1 EOR sign2);
        else
            // Fully fused multiply-add and halve
            result_value = (3.0 + (value1 * value2)) / 2.0;
            if result_value == 0.0 then
                // Sign of exact zero result depends on rounding mode
                sign = if rounding == <a link="FPRounding_NEGINF" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a> then '1' else '0';
                result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
            else
                result = <a link="impl-shared.FPRound.4" file="shared_pseudocode.xml" hover="function: bits(N) FPRound(real op, FPCRType fpcr_in, FPRounding rounding, boolean fpexc)">FPRound</a>(result_value, fpcr, rounding, fpexc);

    return result;</pstext>
    </ps>
    <ps name="aarch64/functions/fusedrstep/FPRecipStepFused" mylink="aarch64.functions.fusedrstep.FPRecipStepFused" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPRecipStepFused()
// ==================

bits(N) <anchor link="impl-aarch64.FPRecipStepFused.2" hover="function: bits(N) FPRecipStepFused(bits(N) op1_in, bits(N) op2)">FPRecipStepFused</anchor>(bits(N) op1_in, bits(N) op2)
    assert N IN {16, 32, 64};
    bits(N) op1 = op1_in;
    bits(N) result;
    boolean done;
    <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr = FPCR[];
    op1 = <a link="impl-shared.FPNeg.1" file="shared_pseudocode.xml" hover="function: bits(N) FPNeg(bits(N) op)">FPNeg</a>(op1);

    boolean altfp = <a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; fpcr.AH == '1';
    boolean fpexc = !altfp;                         // Generate no floating-point exceptions
    if altfp then fpcr.&lt;FIZ,FZ&gt; = '11';             // Flush denormal input and output to zero
    if altfp then fpcr.RMode    = '00';             // Use RNE rounding mode

    (type1,sign1,value1) = <a link="impl-shared.FPUnpack.3" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op1, fpcr, fpexc);
    (type2,sign2,value2) = <a link="impl-shared.FPUnpack.3" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op2, fpcr, fpexc);
    (done,result) = <a link="impl-shared.FPProcessNaNs.7" file="shared_pseudocode.xml" hover="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean altfmaxfmin, boolean fpexc)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr, FALSE, fpexc);
    <a link="FPRounding" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding = <a link="impl-shared.FPRoundingMode.1" file="shared_pseudocode.xml" hover="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);

    if !done then
        inf1  = (type1 == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        inf2  = (type2 == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        zero2 = (type2 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result = <a link="impl-shared.FPTwo.1" file="shared_pseudocode.xml" hover="function: bits(N) FPTwo(bit sign)">FPTwo</a>('0');
        elsif inf1 || inf2 then
            result = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign1 EOR sign2);
        else
            // Fully fused multiply-add
            result_value = 2.0 + (value1 * value2);
            if result_value == 0.0 then
                // Sign of exact zero result depends on rounding mode
                sign = if rounding == <a link="FPRounding_NEGINF" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a> then '1' else '0';
                result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
            else
                result = <a link="impl-shared.FPRound.4" file="shared_pseudocode.xml" hover="function: bits(N) FPRound(real op, FPCRType fpcr_in, FPRounding rounding, boolean fpexc)">FPRound</a>(result_value, fpcr, rounding, fpexc);

    return result;</pstext>
    </ps>
    <ps name="aarch64/functions/memory/AArch64.AccessIsTagChecked" mylink="aarch64.functions.memory.AArch64.AccessIsTagChecked" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.AccessIsTagChecked()
// ============================
// TRUE if a given access is tag-checked, FALSE otherwise.

boolean <anchor link="AArch64.AccessIsTagChecked.2" hover="function: boolean AArch64.AccessIsTagChecked(bits(64) vaddr, AccType acctype)">AArch64.AccessIsTagChecked</anchor>(bits(64) vaddr, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype)
    if PSTATE.M&lt;4&gt; == '1' then return FALSE;

    if <a link="impl-shared.EffectiveTBI.3" file="shared_pseudocode.xml" hover="function: bit EffectiveTBI(bits(64) address, boolean IsInstr, bits(2) el)">EffectiveTBI</a>(vaddr, FALSE, PSTATE.EL) == '0' then
        return FALSE;

    if <a link="impl-shared.EffectiveTCMA.2" file="shared_pseudocode.xml" hover="function: bit EffectiveTCMA(bits(64) address, bits(2) el)">EffectiveTCMA</a>(vaddr, PSTATE.EL) == '1' &amp;&amp; (vaddr&lt;59:55&gt; == '00000' || vaddr&lt;59:55&gt; == '11111') then
        return FALSE;

    if !<a link="AArch64.AllocationTagAccessIsEnabled.1" file="shared_pseudocode.xml" hover="function: boolean AArch64.AllocationTagAccessIsEnabled(AccType acctype)">AArch64.AllocationTagAccessIsEnabled</a>(acctype) then
        return FALSE;

    if acctype IN {<a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a>, <a link="AccType_TTW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_TTW</a>, <a link="AccType_DC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>, <a link="AccType_IC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>} then
        return FALSE;

    if acctype == <a link="AccType_NV2REGISTER" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NV2REGISTER</a> then
        return FALSE;

    if PSTATE.TCO=='1' then
        return FALSE;

    if !<a link="impl-aarch64.IsTagCheckedInstruction.0" file="shared_pseudocode.xml" hover="function: boolean IsTagCheckedInstruction()">IsTagCheckedInstruction</a>() then
        return FALSE;

    return TRUE;</pstext>
    </ps>
    <ps name="aarch64/functions/memory/AArch64.AddressWithAllocationTag" mylink="aarch64.functions.memory.AArch64.AddressWithAllocationTag" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.AddressWithAllocationTag()
// ==================================
// Generate a 64-bit value containing a Logical Address Tag from a 64-bit
// virtual address and an Allocation Tag.
// If the extension is disabled, treats the Allocation Tag as '0000'.

bits(64) <anchor link="AArch64.AddressWithAllocationTag.3" hover="function: bits(64) AArch64.AddressWithAllocationTag(bits(64) address, AccType acctype, bits(4) allocation_tag)">AArch64.AddressWithAllocationTag</anchor>(bits(64) address, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, bits(4) allocation_tag)
    bits(64) result = address;
    bits(4) tag;
    if <a link="AArch64.AllocationTagAccessIsEnabled.1" file="shared_pseudocode.xml" hover="function: boolean AArch64.AllocationTagAccessIsEnabled(AccType acctype)">AArch64.AllocationTagAccessIsEnabled</a>(acctype) then
        tag = allocation_tag;
    else
        tag = '0000';
    result&lt;59:56&gt; = tag;
    return result;</pstext>
    </ps>
    <ps name="aarch64/functions/memory/AArch64.AllocationTagFromAddress" mylink="aarch64.functions.memory.AArch64.AllocationTagFromAddress" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.AllocationTagFromAddress()
// ==================================
// Generate an Allocation Tag from a 64-bit value containing a Logical Address Tag.

bits(4) <anchor link="AArch64.AllocationTagFromAddress.1" hover="function: bits(4) AArch64.AllocationTagFromAddress(bits(64) tagged_address)">AArch64.AllocationTagFromAddress</anchor>(bits(64) tagged_address)
    return tagged_address&lt;59:56&gt;;</pstext>
    </ps>
    <ps name="aarch64/functions/memory/AArch64.CheckAlignment" mylink="aarch64.functions.memory.AArch64.CheckAlignment" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.CheckAlignment()
// ========================

boolean <anchor link="AArch64.CheckAlignment.4" hover="function: boolean AArch64.CheckAlignment(bits(64) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch64.CheckAlignment</anchor>(bits(64) address, integer alignment, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype,
                               boolean iswrite)

    aligned = (address == <a link="impl-shared.Align.2" file="shared_pseudocode.xml" hover="function: integer Align(integer x, integer y)">Align</a>(address, alignment));
    atomic  = acctype IN { <a link="AccType_ATOMIC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMIC</a>, <a link="AccType_ATOMICRW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a>, <a link="AccType_ORDEREDATOMIC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMIC</a>,
                           <a link="AccType_ORDEREDATOMICRW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMICRW</a>, <a link="AccType_ATOMICLS64" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICLS64</a>, <a link="AccType_A32LSMD" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_A32LSMD</a>};
    ordered = acctype IN { <a link="AccType_ORDERED" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDERED</a>, <a link="AccType_ORDEREDRW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDRW</a>, <a link="AccType_LIMITEDORDERED" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_LIMITEDORDERED</a>,
                           <a link="AccType_ORDEREDATOMIC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMIC</a>, <a link="AccType_ORDEREDATOMICRW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMICRW</a> };
    vector  = acctype == <a link="AccType_VEC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VEC</a>;
    boolean check;
    if <a link="impl-aarch64.SCTLR.read.0" file="shared_pseudocode.xml" hover="accessor: SCTLRType SCTLR[]">SCTLR</a>[].A == '1' then check = TRUE;
    elsif <a link="impl-shared.HaveLSE2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveLSE2Ext()">HaveLSE2Ext</a>() then
        check = (<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(address&lt;3:0&gt;) + alignment &gt; 16) &amp;&amp; ((ordered &amp;&amp; <a link="impl-aarch64.SCTLR.read.0" file="shared_pseudocode.xml" hover="accessor: SCTLRType SCTLR[]">SCTLR</a>[].nAA == '0') || atomic);
    else check = atomic || ordered;

    if check &amp;&amp; !aligned then
        secondstage = FALSE;
        <a link="AArch64.Abort.2" file="shared_pseudocode.xml" hover="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, <a link="impl-shared.AlignmentFault.3" file="shared_pseudocode.xml" hover="function: FaultRecord AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)">AlignmentFault</a>(acctype, iswrite, secondstage));

    return aligned;</pstext>
    </ps>
    <ps name="aarch64/functions/memory/AArch64.CheckTag" mylink="aarch64.functions.memory.AArch64.CheckTag" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.CheckTag()
// ==================
// Performs a Tag Check operation for a memory access and returns
// whether the check passed

boolean <anchor link="AArch64.CheckTag.4" hover="function: boolean AArch64.CheckTag(AddressDescriptor memaddrdesc, AccessDescriptor accdesc, bits(4) ptag, boolean write)">AArch64.CheckTag</anchor>(<a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc, <a link="AccessDescriptor" file="shared_pseudocode.xml" hover="type AccessDescriptor is ( MPAMinfo mpam, AccType acctype)">AccessDescriptor</a> accdesc, bits(4) ptag, boolean write)
    if memaddrdesc.memattrs.tagged then
        (memstatus, readtag) = <a link="impl-aarch64.PhysMemTagRead.2" file="shared_pseudocode.xml" hover="function: (PhysMemRetStatus, bits(4)) PhysMemTagRead(AddressDescriptor desc, AccessDescriptor accdesc)">PhysMemTagRead</a>(memaddrdesc, accdesc);
        if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a link="impl-shared.HandleExternalReadAbort.4" file="shared_pseudocode.xml" hover="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, 1, accdesc);
        return ptag == readtag;
    else
        return TRUE;</pstext>
    </ps>
    <ps name="aarch64/functions/memory/AArch64.MemSingle" mylink="aarch64.functions.memory.AArch64.MemSingle" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.MemSingle[] - non-assignment (read) form
// ================================================
// Perform an atomic, little-endian read of 'size' bytes.

bits(size*8) <anchor link="AArch64.MemSingle.read.4" hover="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned]">AArch64.MemSingle</anchor>[bits(64) address, integer size, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned]
    boolean ispair = FALSE;
    return <a link="AArch64.MemSingle.read.5" file="shared_pseudocode.xml" hover="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair]">AArch64.MemSingle</a>[address, size, acctype, aligned, ispair];

// AArch64.MemSingle[] - non-assignment (read) form
// ================================================
// Perform an atomic, little-endian read of 'size' bytes.

bits(size*8) <anchor link="AArch64.MemSingle.read.5" hover="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair]">AArch64.MemSingle</anchor>[bits(64) address, integer size, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned, boolean ispair]
    assert size IN {1, 2, 4, 8, 16};
    constant halfsize = size DIV 2;
    if <a link="impl-shared.HaveLSE2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveLSE2Ext()">HaveLSE2Ext</a>() then
        assert <a link="impl-aarch64.CheckAllInAlignedQuantity.3" file="shared_pseudocode.xml" hover="function: boolean CheckAllInAlignedQuantity(bits(64) address, integer size, integer alignment)">CheckAllInAlignedQuantity</a>(address, size, 16);
    else
        assert address == <a link="impl-shared.Align.2" file="shared_pseudocode.xml" hover="function: integer Align(integer x, integer y)">Align</a>(address, size);

    <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc;
    bits(size*8) value;
    iswrite = FALSE;

    memaddrdesc = <a link="AArch64.TranslateAddress.5" file="shared_pseudocode.xml" hover="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccType acctype, boolean iswrite,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, acctype, iswrite, aligned, size);
    // Check for aborts or debug exceptions
    if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a link="AArch64.Abort.2" file="shared_pseudocode.xml" hover="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, memaddrdesc.fault);

    // Memory array access
    accdesc = <a link="impl-shared.CreateAccessDescriptor.1" file="shared_pseudocode.xml" hover="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(acctype);
    if <a link="impl-shared.HaveMTE2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() then
        if <a link="AArch64.AccessIsTagChecked.2" file="shared_pseudocode.xml" hover="function: boolean AArch64.AccessIsTagChecked(bits(64) vaddr, AccType acctype)">AArch64.AccessIsTagChecked</a>(<a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(address, 64), acctype) then
            bits(4) ptag = <a link="AArch64.PhysicalTag.1" file="shared_pseudocode.xml" hover="function: bits(4) AArch64.PhysicalTag(bits(64) vaddr)">AArch64.PhysicalTag</a>(<a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(address, 64));
            if !<a link="AArch64.CheckTag.4" file="shared_pseudocode.xml" hover="function: boolean AArch64.CheckTag(AddressDescriptor memaddrdesc, AccessDescriptor accdesc, bits(4) ptag, boolean write)">AArch64.CheckTag</a>(memaddrdesc, accdesc, ptag, iswrite) then
                <a link="AArch64.TagCheckFault.3" file="shared_pseudocode.xml" hover="function: AArch64.TagCheckFault(bits(64) vaddress, AccType acctype, boolean iswrite)">AArch64.TagCheckFault</a>(<a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(address, 64), acctype, iswrite);

    (atomic, splitpair) = <a link="impl-aarch64.CheckSingleAccessAttributes.7" file="shared_pseudocode.xml" hover="function: (boolean, boolean) CheckSingleAccessAttributes(bits(64) address, MemoryAttributes memattrs, integer size,&#13; AccType acctype, boolean iswrite, boolean aligned, boolean ispair)">CheckSingleAccessAttributes</a>(address, memaddrdesc.memattrs, size, acctype, iswrite, aligned, ispair);
    <a link="PhysMemRetStatus" file="shared_pseudocode.xml" hover="type PhysMemRetStatus is (Fault statuscode, bit extflag, bits(2) errortype, bits(64) store64bstatus, AccType acctype)">PhysMemRetStatus</a> memstatus;
    if atomic then
        (memstatus, value) = <a link="impl-shared.PhysMemRead.3" file="shared_pseudocode.xml" hover="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(memaddrdesc, size, accdesc);
        if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a link="impl-shared.HandleExternalReadAbort.4" file="shared_pseudocode.xml" hover="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, size, accdesc);
    elsif splitpair then
        assert ispair;
        bits(halfsize * 8) lowhalf, highhalf;
        (memstatus, lowhalf) = <a link="impl-shared.PhysMemRead.3" file="shared_pseudocode.xml" hover="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(memaddrdesc, halfsize, accdesc);
        if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a link="impl-shared.HandleExternalReadAbort.4" file="shared_pseudocode.xml" hover="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, halfsize, accdesc);
        memaddrdesc.paddress.address = memaddrdesc.paddress.address + halfsize;
        (memstatus, highhalf) = <a link="impl-shared.PhysMemRead.3" file="shared_pseudocode.xml" hover="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(memaddrdesc, halfsize, accdesc);
        if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a link="impl-shared.HandleExternalReadAbort.4" file="shared_pseudocode.xml" hover="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, halfsize, accdesc);

        value = highhalf:lowhalf;
    else
        for i = 0 to size-1
            (memstatus, value&lt;8*i+7:8*i&gt;) = <a link="impl-shared.PhysMemRead.3" file="shared_pseudocode.xml" hover="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(memaddrdesc, 1, accdesc);
            if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
                <a link="impl-shared.HandleExternalReadAbort.4" file="shared_pseudocode.xml" hover="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, 1, accdesc);
            memaddrdesc.paddress.address = memaddrdesc.paddress.address + 1;
    return value;

// AArch64.MemSingle[] - assignment (write) form
// =============================================

<anchor link="AArch64.MemSingle.write.4" hover="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned] = bits(size*8) value">AArch64.MemSingle</anchor>[bits(64) address, integer size, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned] = bits(size*8) value
    boolean ispair = FALSE;
    <a link="AArch64.MemSingle.write.5" file="shared_pseudocode.xml" hover="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair] = bits(size*8) value">AArch64.MemSingle</a>[address, size, acctype, aligned, ispair] = value;
    return;

// AArch64.MemSingle[] - assignment (write) form
// =============================================
// Perform an atomic, little-endian write of 'size' bytes.

<anchor link="AArch64.MemSingle.write.5" hover="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair] = bits(size*8) value">AArch64.MemSingle</anchor>[bits(64) address, integer size, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned, boolean ispair] = bits(size*8) value
    assert size IN {1, 2, 4, 8, 16};
    constant halfsize = size DIV 2;
    if <a link="impl-shared.HaveLSE2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveLSE2Ext()">HaveLSE2Ext</a>() then
        assert <a link="impl-aarch64.CheckAllInAlignedQuantity.3" file="shared_pseudocode.xml" hover="function: boolean CheckAllInAlignedQuantity(bits(64) address, integer size, integer alignment)">CheckAllInAlignedQuantity</a>(address, size, 16);
    else
        assert address == <a link="impl-shared.Align.2" file="shared_pseudocode.xml" hover="function: integer Align(integer x, integer y)">Align</a>(address, size);

    <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc;
    iswrite = TRUE;

    memaddrdesc = <a link="AArch64.TranslateAddress.5" file="shared_pseudocode.xml" hover="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccType acctype, boolean iswrite,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, acctype, iswrite, aligned, size);
    // Check for aborts or debug exceptions
    if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a link="AArch64.Abort.2" file="shared_pseudocode.xml" hover="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, memaddrdesc.fault);

    // Effect on exclusives
    if memaddrdesc.memattrs.shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then
        <a link="impl-shared.ClearExclusiveByAddress.3" file="shared_pseudocode.xml" hover="function: ClearExclusiveByAddress(FullAddress paddress, integer processorid, integer size)">ClearExclusiveByAddress</a>(memaddrdesc.paddress, <a link="impl-shared.ProcessorID.0" file="shared_pseudocode.xml" hover="function: integer ProcessorID()">ProcessorID</a>(), size);

    // Memory array access
    accdesc = <a link="impl-shared.CreateAccessDescriptor.1" file="shared_pseudocode.xml" hover="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(acctype);
    if <a link="impl-shared.HaveMTE2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() then
        if <a link="AArch64.AccessIsTagChecked.2" file="shared_pseudocode.xml" hover="function: boolean AArch64.AccessIsTagChecked(bits(64) vaddr, AccType acctype)">AArch64.AccessIsTagChecked</a>(<a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(address, 64), acctype) then
            bits(4) ptag = <a link="AArch64.PhysicalTag.1" file="shared_pseudocode.xml" hover="function: bits(4) AArch64.PhysicalTag(bits(64) vaddr)">AArch64.PhysicalTag</a>(<a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(address, 64));
            if !<a link="AArch64.CheckTag.4" file="shared_pseudocode.xml" hover="function: boolean AArch64.CheckTag(AddressDescriptor memaddrdesc, AccessDescriptor accdesc, bits(4) ptag, boolean write)">AArch64.CheckTag</a>(memaddrdesc, accdesc, ptag, iswrite) then
                <a link="AArch64.TagCheckFault.3" file="shared_pseudocode.xml" hover="function: AArch64.TagCheckFault(bits(64) vaddress, AccType acctype, boolean iswrite)">AArch64.TagCheckFault</a>(<a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(address, 64), acctype, iswrite);

    (atomic, splitpair) = <a link="impl-aarch64.CheckSingleAccessAttributes.7" file="shared_pseudocode.xml" hover="function: (boolean, boolean) CheckSingleAccessAttributes(bits(64) address, MemoryAttributes memattrs, integer size,&#13; AccType acctype, boolean iswrite, boolean aligned, boolean ispair)">CheckSingleAccessAttributes</a>(address, memaddrdesc.memattrs, size, acctype, iswrite, aligned, ispair);
    if atomic then
        memstatus = <a link="impl-shared.PhysMemWrite.4" file="shared_pseudocode.xml" hover="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(memaddrdesc, size, accdesc, value);
        if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a link="impl-shared.HandleExternalWriteAbort.4" file="shared_pseudocode.xml" hover="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, size, accdesc);
    elsif splitpair then
        assert ispair;
        bits(halfsize*8) lowhalf, highhalf;
        &lt;highhalf, lowhalf&gt; = value;

        memstatus = <a link="impl-shared.PhysMemWrite.4" file="shared_pseudocode.xml" hover="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(memaddrdesc, halfsize, accdesc, lowhalf);
        if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a link="impl-shared.HandleExternalWriteAbort.4" file="shared_pseudocode.xml" hover="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, halfsize, accdesc);
        memaddrdesc.paddress.address = memaddrdesc.paddress.address + halfsize;
        memstatus = <a link="impl-shared.PhysMemWrite.4" file="shared_pseudocode.xml" hover="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(memaddrdesc, halfsize, accdesc, highhalf);
        if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a link="impl-shared.HandleExternalWriteAbort.4" file="shared_pseudocode.xml" hover="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, halfsize, accdesc);
    else
        for i = 0 to size-1
            memstatus = <a link="impl-shared.PhysMemWrite.4" file="shared_pseudocode.xml" hover="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(memaddrdesc, 1, accdesc, value&lt;8*i+7:8*i&gt;);
            if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
                <a link="impl-shared.HandleExternalWriteAbort.4" file="shared_pseudocode.xml" hover="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, 1, accdesc);
            memaddrdesc.paddress.address = memaddrdesc.paddress.address + 1;
    return;</pstext>
    </ps>
    <ps name="aarch64/functions/memory/AArch64.MemTag" mylink="aarch64.functions.memory.AArch64.MemTag" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.MemTag[] - non-assignment (read) form
// =============================================
// Load an Allocation Tag from memory.

bits(4) <anchor link="AArch64.MemTag.read.2" hover="accessor: bits(4) AArch64.MemTag[bits(64) address, AccType acctype]">AArch64.MemTag</anchor>[bits(64) address, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype]
    <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc;
    bits(4) value;

    iswrite = FALSE;
    aligned = TRUE;
    memaddrdesc = <a link="AArch64.TranslateAddress.5" file="shared_pseudocode.xml" hover="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccType acctype, boolean iswrite,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, acctype, iswrite, aligned,
                                           <a link="TAG_GRANULE" file="shared_pseudocode.xml" hover="constant integer TAG_GRANULE = 1 &lt;&lt; LOG2_TAG_GRANULE">TAG_GRANULE</a>);
    accdesc = <a link="impl-shared.CreateAccessDescriptor.1" file="shared_pseudocode.xml" hover="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(acctype);
    // Check for aborts or debug exceptions
    if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a link="AArch64.Abort.2" file="shared_pseudocode.xml" hover="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, memaddrdesc.fault);

    // Return the granule tag if tagging is enabled...
    if <a link="AArch64.AllocationTagAccessIsEnabled.1" file="shared_pseudocode.xml" hover="function: boolean AArch64.AllocationTagAccessIsEnabled(AccType acctype)">AArch64.AllocationTagAccessIsEnabled</a>(acctype) &amp;&amp; memaddrdesc.memattrs.tagged then
        (memstatus, tag) = <a link="impl-aarch64.PhysMemTagRead.2" file="shared_pseudocode.xml" hover="function: (PhysMemRetStatus, bits(4)) PhysMemTagRead(AddressDescriptor desc, AccessDescriptor accdesc)">PhysMemTagRead</a>(memaddrdesc, accdesc);
        if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a link="impl-shared.HandleExternalReadAbort.4" file="shared_pseudocode.xml" hover="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, 1, accdesc);
        return tag;
    else
        // ...otherwise read tag as zero.
        return '0000';

// AArch64.MemTag[] - assignment (write) form
// ==========================================
// Store an Allocation Tag to memory.

<anchor link="AArch64.MemTag.write.2" hover="accessor: AArch64.MemTag[bits(64) address, AccType acctype] = bits(4) value">AArch64.MemTag</anchor>[bits(64) address, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype] = bits(4) value
    <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc;
    iswrite = TRUE;

    // Stores of allocation tags must be aligned
    if address != <a link="impl-shared.Align.2" file="shared_pseudocode.xml" hover="function: integer Align(integer x, integer y)">Align</a>(address, <a link="TAG_GRANULE" file="shared_pseudocode.xml" hover="constant integer TAG_GRANULE = 1 &lt;&lt; LOG2_TAG_GRANULE">TAG_GRANULE</a>) then
        boolean secondstage = FALSE;
        <a link="AArch64.Abort.2" file="shared_pseudocode.xml" hover="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, <a link="impl-shared.AlignmentFault.3" file="shared_pseudocode.xml" hover="function: FaultRecord AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)">AlignmentFault</a>(acctype, iswrite, secondstage));

    aligned = TRUE;
    memaddrdesc = <a link="AArch64.TranslateAddress.5" file="shared_pseudocode.xml" hover="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccType acctype, boolean iswrite,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, acctype, iswrite, aligned,
                                           <a link="TAG_GRANULE" file="shared_pseudocode.xml" hover="constant integer TAG_GRANULE = 1 &lt;&lt; LOG2_TAG_GRANULE">TAG_GRANULE</a>);

    // It is CONSTRAINED UNPREDICTABLE if tags stored to memory locations marked as Device
    // generate an Alignment Fault or store the data to locations.
    if memaddrdesc.memattrs.memtype == <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
        c = <a link="impl-shared.ConstrainUnpredictable.1" file="shared_pseudocode.xml" hover="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a link="Unpredictable_DEVICETAGSTORE" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_DEVICETAGSTORE</a>);
        assert c IN {<a link="Constraint_NONE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>, <a link="Constraint_FAULT" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a>};
        if c == <a link="Constraint_FAULT" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a> then
            boolean secondstage = FALSE;
            <a link="AArch64.Abort.2" file="shared_pseudocode.xml" hover="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, <a link="impl-shared.AlignmentFault.3" file="shared_pseudocode.xml" hover="function: FaultRecord AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)">AlignmentFault</a>(acctype, iswrite, secondstage));

    // Check for aborts or debug exceptions
    if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a link="AArch64.Abort.2" file="shared_pseudocode.xml" hover="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, memaddrdesc.fault);

    accdesc = <a link="impl-shared.CreateAccessDescriptor.1" file="shared_pseudocode.xml" hover="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(acctype);
    // Memory array access
    if <a link="AArch64.AllocationTagAccessIsEnabled.1" file="shared_pseudocode.xml" hover="function: boolean AArch64.AllocationTagAccessIsEnabled(AccType acctype)">AArch64.AllocationTagAccessIsEnabled</a>(acctype) &amp;&amp; memaddrdesc.memattrs.tagged then
        memstatus = <a link="impl-aarch64.PhysMemTagWrite.3" file="shared_pseudocode.xml" hover="function: PhysMemRetStatus PhysMemTagWrite(AddressDescriptor desc, AccessDescriptor accdesc, bits (4) value)">PhysMemTagWrite</a>(memaddrdesc, accdesc, value);
        if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a link="impl-shared.HandleExternalWriteAbort.4" file="shared_pseudocode.xml" hover="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, 1, accdesc);</pstext>
    </ps>
    <ps name="aarch64/functions/memory/AArch64.PhysicalTag" mylink="aarch64.functions.memory.AArch64.PhysicalTag" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.PhysicalTag()
// =====================
// Generate a Physical Tag from a Logical Tag in an address

bits(4) <anchor link="AArch64.PhysicalTag.1" hover="function: bits(4) AArch64.PhysicalTag(bits(64) vaddr)">AArch64.PhysicalTag</anchor>(bits(64) vaddr)
    return vaddr&lt;59:56&gt;;</pstext>
    </ps>
    <ps name="aarch64/functions/memory/AArch64.TranslateAddressForAtomicAccess" mylink="aarch64.functions.memory.AArch64.TranslateAddressForAtomicAccess" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.TranslateAddressForAtomicAccess()
// =========================================
// Performs an alignment check for atomic memory operations.
// Also translates 64-bit Virtual Address into Physical Address.

AddressDescriptor <anchor link="AArch64.TranslateAddressForAtomicAccess.2" hover="function: AddressDescriptor AArch64.TranslateAddressForAtomicAccess(bits(64) address, integer sizeinbits)">AArch64.TranslateAddressForAtomicAccess</anchor>(bits(64) address, integer sizeinbits)
    boolean iswrite = FALSE;
    size = sizeinbits DIV 8;

    assert size IN {1, 2, 4, 8, 16};

    aligned = <a link="AArch64.CheckAlignment.4" file="shared_pseudocode.xml" hover="function: boolean AArch64.CheckAlignment(bits(64) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch64.CheckAlignment</a>(address, size, <a link="AccType_ATOMICRW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a>, iswrite);

    // MMU or MPU lookup
    memaddrdesc = <a link="AArch64.TranslateAddress.5" file="shared_pseudocode.xml" hover="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccType acctype, boolean iswrite,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, <a link="AccType_ATOMICRW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a>, iswrite,
                                           aligned, size);

    // Check for aborts or debug exceptions
    if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a link="AArch64.Abort.2" file="shared_pseudocode.xml" hover="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, memaddrdesc.fault);

    // Effect on exclusives
    if memaddrdesc.memattrs.shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then
        <a link="impl-shared.ClearExclusiveByAddress.3" file="shared_pseudocode.xml" hover="function: ClearExclusiveByAddress(FullAddress paddress, integer processorid, integer size)">ClearExclusiveByAddress</a>(memaddrdesc.paddress, <a link="impl-shared.ProcessorID.0" file="shared_pseudocode.xml" hover="function: integer ProcessorID()">ProcessorID</a>(), size);

    if <a link="impl-shared.HaveMTE2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() &amp;&amp; <a link="AArch64.AccessIsTagChecked.2" file="shared_pseudocode.xml" hover="function: boolean AArch64.AccessIsTagChecked(bits(64) vaddr, AccType acctype)">AArch64.AccessIsTagChecked</a>(address, <a link="AccType_ATOMICRW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a>) then
        bits(4) ptag = <a link="AArch64.PhysicalTag.1" file="shared_pseudocode.xml" hover="function: bits(4) AArch64.PhysicalTag(bits(64) vaddr)">AArch64.PhysicalTag</a>(address);
        accdesc = <a link="impl-shared.CreateAccessDescriptor.1" file="shared_pseudocode.xml" hover="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(<a link="AccType_ATOMICRW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a>);
        if !<a link="AArch64.CheckTag.4" file="shared_pseudocode.xml" hover="function: boolean AArch64.CheckTag(AddressDescriptor memaddrdesc, AccessDescriptor accdesc, bits(4) ptag, boolean write)">AArch64.CheckTag</a>(memaddrdesc, accdesc, ptag, iswrite) then
            <a link="AArch64.TagCheckFault.3" file="shared_pseudocode.xml" hover="function: AArch64.TagCheckFault(bits(64) vaddress, AccType acctype, boolean iswrite)">AArch64.TagCheckFault</a>(address, <a link="AccType_ATOMICRW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a>, iswrite);

    return memaddrdesc;</pstext>
    </ps>
    <ps name="aarch64/functions/memory/AddressSupportsLS64" mylink="aarch64.functions.memory.AddressSupportsLS64" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns TRUE if the 64-byte block following the given address supports the
// LD64B and ST64B instructions, and FALSE otherwise.
boolean <anchor link="impl-aarch64.AddressSupportsLS64.1" hover="function: boolean AddressSupportsLS64(bits(64) address)">AddressSupportsLS64</anchor>(bits(64) address);</pstext>
    </ps>
    <ps name="aarch64/functions/memory/CheckAllInAlignedQuantity" mylink="aarch64.functions.memory.CheckAllInAlignedQuantity" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CheckAllInAlignedQuantity()
// ===========================
// Returns TRUE if all accessed bytes are within one aligned quantity, FALSE otherwise.

boolean <anchor link="impl-aarch64.CheckAllInAlignedQuantity.3" hover="function: boolean CheckAllInAlignedQuantity(bits(64) address, integer size, integer alignment)">CheckAllInAlignedQuantity</anchor>(bits(64) address, integer size, integer alignment)
    assert(size &lt;= alignment);
    return <a link="impl-shared.Align.2" file="shared_pseudocode.xml" hover="function: integer Align(integer x, integer y)">Align</a>(address+size-1, alignment) == <a link="impl-shared.Align.2" file="shared_pseudocode.xml" hover="function: integer Align(integer x, integer y)">Align</a>(address, alignment);</pstext>
    </ps>
    <ps name="aarch64/functions/memory/CheckSPAlignment" mylink="aarch64.functions.memory.CheckSPAlignment" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CheckSPAlignment()
// ==================
// Check correct stack pointer alignment for AArch64 state.

<anchor link="impl-aarch64.CheckSPAlignment.0" hover="function: CheckSPAlignment()">CheckSPAlignment</anchor>()
    bits(64) sp = <a link="impl-aarch64.SP.read.0" file="shared_pseudocode.xml" hover="accessor: bits(width) SP[]">SP</a>[];
    boolean stack_align_check;
    if PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then
        stack_align_check = (<a link="impl-aarch64.SCTLR.read.0" file="shared_pseudocode.xml" hover="accessor: SCTLRType SCTLR[]">SCTLR</a>[].SA0 != '0');
    else
        stack_align_check = (<a link="impl-aarch64.SCTLR.read.0" file="shared_pseudocode.xml" hover="accessor: SCTLRType SCTLR[]">SCTLR</a>[].SA != '0');

    if stack_align_check &amp;&amp; sp != <a link="impl-shared.Align.2" file="shared_pseudocode.xml" hover="function: integer Align(integer x, integer y)">Align</a>(sp, 16) then
        <a link="AArch64.SPAlignmentFault.0" file="shared_pseudocode.xml" hover="function: AArch64.SPAlignmentFault()">AArch64.SPAlignmentFault</a>();

    return;</pstext>
    </ps>
    <ps name="aarch64/functions/memory/CheckSingleAccessAttributes" mylink="aarch64.functions.memory.CheckSingleAccessAttributes" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CheckSingleAccessAttributes()
// =============================
//
// When FEAT_LSE2 is implemented, a MemSingle[] access needs to be further assessed once the memory
// attributes are determined.
// If it was aligned to access size or targets Normal Inner Write-Back, Outer Write-Back Cacheable
// memory then it is single copy atomic and there is no alignment fault.
// If not, for exclusives, atomics and non atomic acquire release instructions - it is CONSTRAINED UNPREDICTABLE
// if they generate an alignment fault.  If they do not generate an alignement fault - they are
// single copy atomic.
// Otherwise it is IMPLEMENTATION DEFINED - if they are single copy atomic.
//
// The function returns (atomic, splitpair), where
//     atomic indicates if the access is single copy atomic.
//     splitpair indicates that a load/store pair is split into 2 single copy atomic accesses.
//     when atomic and splitpair are both FALSE - the access is not single copy atomic and may be treated
//        as byte accesses.

(boolean, boolean) <anchor link="impl-aarch64.CheckSingleAccessAttributes.7" hover="function: (boolean, boolean) CheckSingleAccessAttributes(bits(64) address, MemoryAttributes memattrs, integer size,&#13; AccType acctype, boolean iswrite, boolean aligned, boolean ispair)">CheckSingleAccessAttributes</anchor>(bits(64) address, <a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs, integer size,
                        <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite, boolean aligned, boolean ispair)
    isnormalwb = (memattrs.memtype     == <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> &amp;&amp;
                  memattrs.inner.attrs == <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp;
                  memattrs.outer.attrs == <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>);

    atomic    = TRUE;
    splitpair = FALSE;
    if isnormalwb then return (atomic, splitpair);

    accatomic  = acctype IN { <a link="AccType_ATOMIC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMIC</a>, <a link="AccType_ATOMICRW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a>, <a link="AccType_ORDEREDATOMIC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMIC</a>,
                <a link="AccType_ORDEREDATOMICRW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMICRW</a>, <a link="AccType_ATOMICLS64" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICLS64</a>, <a link="AccType_A32LSMD" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_A32LSMD</a>};
    ordered = acctype IN { <a link="AccType_ORDERED" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDERED</a>, <a link="AccType_ORDEREDRW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDRW</a>, <a link="AccType_LIMITEDORDERED" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_LIMITEDORDERED</a>, <a link="AccType_ORDEREDATOMIC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMIC</a>, <a link="AccType_ORDEREDATOMICRW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMICRW</a> };

    if !aligned &amp;&amp; (accatomic || ordered) then
        atomic = <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_MISALIGNEDATOMIC" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_MISALIGNEDATOMIC</a>);
        if !atomic then
            secondstage = FALSE;
            <a link="AArch64.Abort.2" file="shared_pseudocode.xml" hover="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, <a link="impl-shared.AlignmentFault.3" file="shared_pseudocode.xml" hover="function: FaultRecord AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)">AlignmentFault</a>(acctype, iswrite, secondstage));
        else
            return (atomic, splitpair);

    if ispair &amp;&amp; aligned then
        // load / store pair requests that are aligned to each register access are split into 2 single copy atomic accesses
        atomic    = FALSE;
        splitpair = TRUE;
        return (atomic, splitpair);

    if aligned then
        return (atomic, splitpair);

    atomic = boolean IMPLEMENTATION_DEFINED "Misaligned accesses within 16 byte aligned memory but not Normal Cacheable Writeback are Atomic";

    return (atomic, splitpair);</pstext>
    </ps>
    <ps name="aarch64/functions/memory/IsTagCheckedInstruction" mylink="aarch64.functions.memory.IsTagCheckedInstruction" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns True if the current instruction uses tag-checked memory access,
// False otherwise.
boolean <anchor link="impl-aarch64.IsTagCheckedInstruction.0" hover="function: boolean IsTagCheckedInstruction()">IsTagCheckedInstruction</anchor>();</pstext>
    </ps>
    <ps name="aarch64/functions/memory/Mem" mylink="aarch64.functions.memory.Mem" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Mem[] - non-assignment (read) form
// ==================================
// Perform a read of 'size' bytes. The access byte order is reversed for a big-endian access.
// Instruction fetches would call AArch64.MemSingle directly.

bits(size*8) <anchor link="impl-aarch64.Mem.read.3" hover="accessor: bits(size*8) Mem[bits(64) address, integer size, AccType acctype]">Mem</anchor>[bits(64) address, integer size, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype]
    boolean ispair = FALSE;
    return <a link="impl-aarch64.Mem.read.4" file="shared_pseudocode.xml" hover="accessor: bits(size*8) Mem[bits(64) address, integer size, AccType acctype, boolean ispair]">Mem</a>[address, size, acctype, ispair];

bits(size*8) <anchor link="impl-aarch64.Mem.read.4" hover="accessor: bits(size*8) Mem[bits(64) address, integer size, AccType acctype, boolean ispair]">Mem</anchor>[bits(64) address, integer size, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean ispair]
    assert size IN {1, 2, 4, 8, 16};
    constant halfsize = size DIV 2;
    bits(size * 8) value;
    bits(halfsize * 8) lowhalf, highhalf;
    boolean iswrite = FALSE;
    boolean aligned;
    if ispair then
        // check alignment on size of element accessed, not overall access size
        aligned = <a link="AArch64.CheckAlignment.4" file="shared_pseudocode.xml" hover="function: boolean AArch64.CheckAlignment(bits(64) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch64.CheckAlignment</a>(address, halfsize, acctype, iswrite);
    else
        aligned = <a link="AArch64.CheckAlignment.4" file="shared_pseudocode.xml" hover="function: boolean AArch64.CheckAlignment(bits(64) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch64.CheckAlignment</a>(address, size, acctype, iswrite);
    boolean atomic;
    if size != 16 || !(acctype IN {<a link="AccType_VEC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VEC</a>, <a link="AccType_VECSTREAM" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VECSTREAM</a>}) then
        if !<a link="impl-shared.HaveLSE2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveLSE2Ext()">HaveLSE2Ext</a>() then
            atomic = aligned;
        else
            atomic = <a link="impl-aarch64.CheckAllInAlignedQuantity.3" file="shared_pseudocode.xml" hover="function: boolean CheckAllInAlignedQuantity(bits(64) address, integer size, integer alignment)">CheckAllInAlignedQuantity</a>(address, size, 16);
    elsif acctype IN {<a link="AccType_VEC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VEC</a>, <a link="AccType_VECSTREAM" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VECSTREAM</a>} then
        // 128-bit SIMD&amp;FP loads are treated as a pair of 64-bit single-copy atomic accesses
        // 64-bit aligned.
        atomic = address == <a link="impl-shared.Align.2" file="shared_pseudocode.xml" hover="function: integer Align(integer x, integer y)">Align</a>(address, 8);
    else
        // 16-byte integer access
        atomic = address == <a link="impl-shared.Align.2" file="shared_pseudocode.xml" hover="function: integer Align(integer x, integer y)">Align</a>(address, 16);

    if !atomic &amp;&amp; ispair &amp;&amp; address == <a link="impl-shared.Align.2" file="shared_pseudocode.xml" hover="function: integer Align(integer x, integer y)">Align</a>(address, halfsize) then
        single_is_pair = FALSE;
        single_is_aligned = TRUE;
        lowhalf = <a link="AArch64.MemSingle.read.5" file="shared_pseudocode.xml" hover="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair]">AArch64.MemSingle</a>[address, halfsize, acctype, single_is_aligned, single_is_pair];
        highhalf = <a link="AArch64.MemSingle.read.5" file="shared_pseudocode.xml" hover="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair]">AArch64.MemSingle</a>[address + halfsize, halfsize, acctype, single_is_aligned, single_is_pair];
        value = highhalf:lowhalf;
    elsif atomic &amp;&amp; ispair then
        value = <a link="AArch64.MemSingle.read.5" file="shared_pseudocode.xml" hover="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair]">AArch64.MemSingle</a>[address, size, acctype, aligned, ispair];
    elsif !atomic then

        assert size &gt; 1;
        value&lt;7:0&gt; = <a link="AArch64.MemSingle.read.4" file="shared_pseudocode.xml" hover="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned]">AArch64.MemSingle</a>[address, 1, acctype, aligned];

        // For subsequent bytes it is CONSTRAINED UNPREDICTABLE whether an unaligned Device memory
        // access will generate an Alignment Fault, as to get this far means the first byte did
        // not, so we must be changing to a new translation page.
        if !aligned then
            c = <a link="impl-shared.ConstrainUnpredictable.1" file="shared_pseudocode.xml" hover="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a link="Unpredictable_DEVPAGE2" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_DEVPAGE2</a>);
            assert c IN {<a link="Constraint_FAULT" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a>, <a link="Constraint_NONE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>};
            if c == <a link="Constraint_NONE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a> then aligned = TRUE;

        for i = 1 to size-1
            value&lt;8*i+7:8*i&gt; = <a link="AArch64.MemSingle.read.4" file="shared_pseudocode.xml" hover="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned]">AArch64.MemSingle</a>[address+i, 1, acctype, aligned];
    elsif size == 16 &amp;&amp; acctype IN {<a link="AccType_VEC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VEC</a>, <a link="AccType_VECSTREAM" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VECSTREAM</a>} then
        lowhalf = <a link="AArch64.MemSingle.read.5" file="shared_pseudocode.xml" hover="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair]">AArch64.MemSingle</a>[address, halfsize, acctype, aligned, ispair];
        highhalf = <a link="AArch64.MemSingle.read.5" file="shared_pseudocode.xml" hover="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair]">AArch64.MemSingle</a>[address + halfsize, halfsize, acctype, aligned, ispair];
        value = highhalf:lowhalf;
    else
        value = <a link="AArch64.MemSingle.read.5" file="shared_pseudocode.xml" hover="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair]">AArch64.MemSingle</a>[address, size, acctype, aligned, ispair];

    if <a link="impl-shared.BigEndian.1" file="shared_pseudocode.xml" hover="function: boolean BigEndian(AccType acctype)">BigEndian</a>(acctype) then
        value = <a link="impl-shared.BigEndianReverse.1" file="shared_pseudocode.xml" hover="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(value);

    return value;

// Mem[] - assignment (write) form
// ===============================
// Perform a write of 'size' bytes. The byte order is reversed for a big-endian access.

Mem[bits(64) address, integer size, AccType acctype] = bits(size*8) value_in
    boolean ispair = FALSE;
    Mem[address, size, acctype, ispair] = value_in;

Mem[bits(64) address, integer size, AccType acctype, boolean ispair] = bits(size*8) value_in
    boolean iswrite = TRUE;
    constant halfsize = size DIV 2;
    bits(size*8) value = value_in;
    bits(halfsize*8) lowhalf, highhalf;
    boolean atomic;
    boolean aligned;
    if <a link="impl-shared.BigEndian.1" file="shared_pseudocode.xml" hover="function: boolean BigEndian(AccType acctype)">BigEndian</a>(acctype) then
        value = <a link="impl-shared.BigEndianReverse.1" file="shared_pseudocode.xml" hover="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(value);

    if ispair then
        // check alignment on size of element accessed, not overall access size
        aligned = <a link="AArch64.CheckAlignment.4" file="shared_pseudocode.xml" hover="function: boolean AArch64.CheckAlignment(bits(64) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch64.CheckAlignment</a>(address, halfsize, acctype, iswrite);
    else
        aligned = <a link="AArch64.CheckAlignment.4" file="shared_pseudocode.xml" hover="function: boolean AArch64.CheckAlignment(bits(64) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch64.CheckAlignment</a>(address, size, acctype, iswrite);
    if ispair then
        atomic = <a link="impl-aarch64.CheckAllInAlignedQuantity.3" file="shared_pseudocode.xml" hover="function: boolean CheckAllInAlignedQuantity(bits(64) address, integer size, integer alignment)">CheckAllInAlignedQuantity</a>(address, size, 16);
    elsif size != 16 || !(acctype IN {<a link="AccType_VEC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VEC</a>, <a link="AccType_VECSTREAM" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VECSTREAM</a>}) then
        if !<a link="impl-shared.HaveLSE2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveLSE2Ext()">HaveLSE2Ext</a>() then
            atomic = aligned;
        else
            atomic = <a link="impl-aarch64.CheckAllInAlignedQuantity.3" file="shared_pseudocode.xml" hover="function: boolean CheckAllInAlignedQuantity(bits(64) address, integer size, integer alignment)">CheckAllInAlignedQuantity</a>(address, size, 16);
    elsif (acctype IN {<a link="AccType_VEC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VEC</a>, <a link="AccType_VECSTREAM" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VECSTREAM</a>}) then
        // 128-bit SIMD&amp;FP stores are treated as a pair of 64-bit single-copy atomic accesses
        // 64-bit aligned.
        atomic = address == <a link="impl-shared.Align.2" file="shared_pseudocode.xml" hover="function: integer Align(integer x, integer y)">Align</a>(address, 8);
    else
        // 16-byte integer access
        atomic = address == <a link="impl-shared.Align.2" file="shared_pseudocode.xml" hover="function: integer Align(integer x, integer y)">Align</a>(address, 16);

    if !atomic &amp;&amp; ispair &amp;&amp; address == <a link="impl-shared.Align.2" file="shared_pseudocode.xml" hover="function: integer Align(integer x, integer y)">Align</a>(address, halfsize) then
        single_is_aligned = TRUE;
        &lt;highhalf, lowhalf&gt; = value;
        <a link="AArch64.MemSingle.write.5" file="shared_pseudocode.xml" hover="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair] = bits(size*8) value">AArch64.MemSingle</a>[address, halfsize, acctype, single_is_aligned, ispair] = lowhalf;
        <a link="AArch64.MemSingle.write.5" file="shared_pseudocode.xml" hover="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair] = bits(size*8) value">AArch64.MemSingle</a>[address + halfsize, halfsize, acctype, single_is_aligned, ispair] = highhalf;
    elsif atomic &amp;&amp; ispair then
        <a link="AArch64.MemSingle.write.5" file="shared_pseudocode.xml" hover="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair] = bits(size*8) value">AArch64.MemSingle</a>[address, size, acctype, aligned, ispair] = value;
    elsif !atomic then
        assert size &gt; 1;
        <a link="AArch64.MemSingle.write.4" file="shared_pseudocode.xml" hover="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned] = bits(size*8) value">AArch64.MemSingle</a>[address, 1, acctype, aligned] = value&lt;7:0&gt;;

        // For subsequent bytes it is CONSTRAINED UNPREDICTABLE whether an unaligned Device memory
        // access will generate an Alignment Fault, as to get this far means the first byte did
        // not, so we must be changing to a new translation page.
        if !aligned then
            c = <a link="impl-shared.ConstrainUnpredictable.1" file="shared_pseudocode.xml" hover="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a link="Unpredictable_DEVPAGE2" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_DEVPAGE2</a>);
            assert c IN {<a link="Constraint_FAULT" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a>, <a link="Constraint_NONE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>};
            if c == <a link="Constraint_NONE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a> then aligned = TRUE;

        for i = 1 to size-1
            <a link="AArch64.MemSingle.write.4" file="shared_pseudocode.xml" hover="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned] = bits(size*8) value">AArch64.MemSingle</a>[address+i, 1, acctype, aligned] = value&lt;8*i+7:8*i&gt;;
    elsif size == 16 &amp;&amp; acctype IN {<a link="AccType_VEC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VEC</a>, <a link="AccType_VECSTREAM" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VECSTREAM</a>} then
        &lt;highhalf, lowhalf&gt; = value;
        <a link="AArch64.MemSingle.write.5" file="shared_pseudocode.xml" hover="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair] = bits(size*8) value">AArch64.MemSingle</a>[address, halfsize, acctype, aligned, ispair] = lowhalf;
        <a link="AArch64.MemSingle.write.5" file="shared_pseudocode.xml" hover="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair] = bits(size*8) value">AArch64.MemSingle</a>[address + halfsize, halfsize, acctype, aligned, ispair] = highhalf;
    else
        <a link="AArch64.MemSingle.write.5" file="shared_pseudocode.xml" hover="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair] = bits(size*8) value">AArch64.MemSingle</a>[address, size, acctype, aligned, ispair] = value;
    return;</pstext>
    </ps>
    <ps name="aarch64/functions/memory/MemAtomic" mylink="aarch64.functions.memory.MemAtomic" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// MemAtomic()
// ===========
// Performs load and store memory operations for a given virtual address.

bits(size) <anchor link="impl-aarch64.MemAtomic.5" hover="function: bits(size) MemAtomic(bits(64) address, MemAtomicOp op, bits(size) value, AccType ldacctype, AccType stacctype)">MemAtomic</anchor>(bits(64) address, <a link="MemAtomicOp" file="shared_pseudocode.xml" hover="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp</a> op, bits(size) value, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> ldacctype, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> stacctype)
    bits(size) newvalue;
    memaddrdesc = <a link="AArch64.TranslateAddressForAtomicAccess.2" file="shared_pseudocode.xml" hover="function: AddressDescriptor AArch64.TranslateAddressForAtomicAccess(bits(64) address, integer sizeinbits)">AArch64.TranslateAddressForAtomicAccess</a>(address, size);
    ldaccdesc = <a link="impl-shared.CreateAccessDescriptor.1" file="shared_pseudocode.xml" hover="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(ldacctype);
    staccdesc = <a link="impl-shared.CreateAccessDescriptor.1" file="shared_pseudocode.xml" hover="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(stacctype);

    // All observers in the shareability domain observe the
    // following load and store atomically.
    (memstatus, oldvalue) = <a link="impl-shared.PhysMemRead.3" file="shared_pseudocode.xml" hover="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(memaddrdesc, size DIV 8, ldaccdesc);
    if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        <a link="impl-shared.HandleExternalReadAbort.4" file="shared_pseudocode.xml" hover="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, size DIV 8, ldaccdesc);
    if <a link="impl-shared.BigEndian.1" file="shared_pseudocode.xml" hover="function: boolean BigEndian(AccType acctype)">BigEndian</a>(ldacctype) then
        oldvalue = <a link="impl-shared.BigEndianReverse.1" file="shared_pseudocode.xml" hover="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(oldvalue);

    case op of
        when <a link="MemAtomicOp_ADD" file="shared_pseudocode.xml" hover="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp_ADD</a>   newvalue = oldvalue + value;
        when <a link="MemAtomicOp_BIC" file="shared_pseudocode.xml" hover="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp_BIC</a>   newvalue = oldvalue AND NOT(value);
        when <a link="MemAtomicOp_EOR" file="shared_pseudocode.xml" hover="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp_EOR</a>   newvalue = oldvalue EOR value;
        when <a link="MemAtomicOp_ORR" file="shared_pseudocode.xml" hover="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp_ORR</a>   newvalue = oldvalue OR value;
        when <a link="MemAtomicOp_SMAX" file="shared_pseudocode.xml" hover="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp_SMAX</a>  newvalue = if <a link="impl-shared.SInt.1" file="shared_pseudocode.xml" hover="function: integer SInt(bits(N) x)">SInt</a>(oldvalue) &gt; <a link="impl-shared.SInt.1" file="shared_pseudocode.xml" hover="function: integer SInt(bits(N) x)">SInt</a>(value) then oldvalue else value;
        when <a link="MemAtomicOp_SMIN" file="shared_pseudocode.xml" hover="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp_SMIN</a>  newvalue = if <a link="impl-shared.SInt.1" file="shared_pseudocode.xml" hover="function: integer SInt(bits(N) x)">SInt</a>(oldvalue) &gt; <a link="impl-shared.SInt.1" file="shared_pseudocode.xml" hover="function: integer SInt(bits(N) x)">SInt</a>(value) then value else oldvalue;
        when <a link="MemAtomicOp_UMAX" file="shared_pseudocode.xml" hover="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp_UMAX</a>  newvalue = if <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(oldvalue) &gt; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(value) then oldvalue else value;
        when <a link="MemAtomicOp_UMIN" file="shared_pseudocode.xml" hover="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp_UMIN</a>  newvalue = if <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(oldvalue) &gt; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(value) then value else oldvalue;
        when <a link="MemAtomicOp_SWP" file="shared_pseudocode.xml" hover="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp_SWP</a>   newvalue = value;

    if <a link="impl-shared.BigEndian.1" file="shared_pseudocode.xml" hover="function: boolean BigEndian(AccType acctype)">BigEndian</a>(stacctype) then
        newvalue = <a link="impl-shared.BigEndianReverse.1" file="shared_pseudocode.xml" hover="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(newvalue);
    memstatus = <a link="impl-shared.PhysMemWrite.4" file="shared_pseudocode.xml" hover="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(memaddrdesc, size DIV 8, staccdesc, newvalue);
    if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        <a link="impl-shared.HandleExternalWriteAbort.4" file="shared_pseudocode.xml" hover="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, size DIV 8, staccdesc);

    // Load operations return the old (pre-operation) value
    return oldvalue;</pstext>
    </ps>
    <ps name="aarch64/functions/memory/MemAtomicCompareAndSwap" mylink="aarch64.functions.memory.MemAtomicCompareAndSwap" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// MemAtomicCompareAndSwap()
// =========================
// Compares the value stored at the passed-in memory address against the passed-in expected
// value. If the comparison is successful, the value at the passed-in memory address is swapped
// with the passed-in new_value.

bits(size) <anchor link="impl-aarch64.MemAtomicCompareAndSwap.5" hover="function: bits(size) MemAtomicCompareAndSwap(bits(64) address, bits(size) expectedvalue,&#13; bits(size) newvalue_in, AccType ldacctype, AccType stacctype)">MemAtomicCompareAndSwap</anchor>(bits(64) address, bits(size) expectedvalue,
                                   bits(size) newvalue_in, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> ldacctype, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> stacctype)
    bits(size) newvalue = newvalue_in;
    memaddrdesc = <a link="AArch64.TranslateAddressForAtomicAccess.2" file="shared_pseudocode.xml" hover="function: AddressDescriptor AArch64.TranslateAddressForAtomicAccess(bits(64) address, integer sizeinbits)">AArch64.TranslateAddressForAtomicAccess</a>(address, size);
    ldaccdesc = <a link="impl-shared.CreateAccessDescriptor.1" file="shared_pseudocode.xml" hover="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(ldacctype);
    staccdesc = <a link="impl-shared.CreateAccessDescriptor.1" file="shared_pseudocode.xml" hover="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(stacctype);

    // All observers in the shareability domain observe the
    // following load and store atomically.
    (memstatus, oldvalue) = <a link="impl-shared.PhysMemRead.3" file="shared_pseudocode.xml" hover="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(memaddrdesc, size DIV 8, ldaccdesc);
    if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        <a link="impl-shared.HandleExternalReadAbort.4" file="shared_pseudocode.xml" hover="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, size DIV 8, ldaccdesc);
    if <a link="impl-shared.BigEndian.1" file="shared_pseudocode.xml" hover="function: boolean BigEndian(AccType acctype)">BigEndian</a>(ldacctype) then
        oldvalue = <a link="impl-shared.BigEndianReverse.1" file="shared_pseudocode.xml" hover="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(oldvalue);

    if oldvalue == expectedvalue then
        if <a link="impl-shared.BigEndian.1" file="shared_pseudocode.xml" hover="function: boolean BigEndian(AccType acctype)">BigEndian</a>(stacctype) then
            newvalue = <a link="impl-shared.BigEndianReverse.1" file="shared_pseudocode.xml" hover="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(newvalue);
        memstatus = <a link="impl-shared.PhysMemWrite.4" file="shared_pseudocode.xml" hover="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(memaddrdesc, size DIV 8, staccdesc, newvalue);
        if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a link="impl-shared.HandleExternalWriteAbort.4" file="shared_pseudocode.xml" hover="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, size DIV 8, staccdesc);
    return oldvalue;</pstext>
    </ps>
    <ps name="aarch64/functions/memory/MemLoad64B" mylink="aarch64.functions.memory.MemLoad64B" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// MemLoad64B()
// ============
// Performs an atomic 64-byte read from a given virtual address.

bits(512) <anchor link="impl-aarch64.MemLoad64B.2" hover="function: bits(512) MemLoad64B(bits(64) address, AccType acctype)">MemLoad64B</anchor>(bits(64) address, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype)
    bits(512) data;
    boolean iswrite = FALSE;
    constant integer size = 64;

    aligned = <a link="AArch64.CheckAlignment.4" file="shared_pseudocode.xml" hover="function: boolean AArch64.CheckAlignment(bits(64) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch64.CheckAlignment</a>(address, size, acctype, iswrite);

    if !<a link="impl-aarch64.AddressSupportsLS64.1" file="shared_pseudocode.xml" hover="function: boolean AddressSupportsLS64(bits(64) address)">AddressSupportsLS64</a>(address) then
        c = <a link="impl-shared.ConstrainUnpredictable.1" file="shared_pseudocode.xml" hover="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a link="Unpredictable_LS64UNSUPPORTED" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_LS64UNSUPPORTED</a>);
        assert c IN {<a link="Constraint_LIMITED_ATOMICITY" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_LIMITED_ATOMICITY</a>, <a link="Constraint_FAULT" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a>};

        if c == <a link="Constraint_FAULT" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a> then
            // Generate a stage 1 Data Abort reported using the DFSC code of 110101.
            boolean secondstage = FALSE;
            boolean s2fs1walk = FALSE;
            fault = <a link="AArch64.ExclusiveFault.4" file="shared_pseudocode.xml" hover="function: FaultRecord AArch64.ExclusiveFault(AccType acctype, boolean iswrite,&#13; boolean secondstage, boolean s2fs1walk)">AArch64.ExclusiveFault</a>(acctype, iswrite, secondstage, s2fs1walk);
            <a link="AArch64.Abort.2" file="shared_pseudocode.xml" hover="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, fault);
        else
            // Accesses are not single-copy atomic above the byte level
            for i = 0 to 63
                data&lt;7+8*i : 8*i&gt; = <a link="AArch64.MemSingle.read.4" file="shared_pseudocode.xml" hover="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned]">AArch64.MemSingle</a>[address+8*i, 1, acctype, aligned];
            return data;

    <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc;
    memaddrdesc = <a link="AArch64.TranslateAddress.5" file="shared_pseudocode.xml" hover="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccType acctype, boolean iswrite,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, acctype, iswrite, aligned, size);

    // Check for aborts or debug exceptions
    if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a link="AArch64.Abort.2" file="shared_pseudocode.xml" hover="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, memaddrdesc.fault);

    // Effect on exclusives
    if memaddrdesc.memattrs.shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then
        <a link="impl-shared.ClearExclusiveByAddress.3" file="shared_pseudocode.xml" hover="function: ClearExclusiveByAddress(FullAddress paddress, integer processorid, integer size)">ClearExclusiveByAddress</a>(memaddrdesc.paddress, <a link="impl-shared.ProcessorID.0" file="shared_pseudocode.xml" hover="function: integer ProcessorID()">ProcessorID</a>(), size);

    // Memory array access
    accdesc = <a link="impl-shared.CreateAccessDescriptor.1" file="shared_pseudocode.xml" hover="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(acctype);
    if <a link="impl-shared.HaveMTE2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() then
        if <a link="AArch64.AccessIsTagChecked.2" file="shared_pseudocode.xml" hover="function: boolean AArch64.AccessIsTagChecked(bits(64) vaddr, AccType acctype)">AArch64.AccessIsTagChecked</a>(<a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(address, 64), acctype) then
            bits(4) ptag = <a link="AArch64.PhysicalTag.1" file="shared_pseudocode.xml" hover="function: bits(4) AArch64.PhysicalTag(bits(64) vaddr)">AArch64.PhysicalTag</a>(<a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(address, 64));
            if !<a link="AArch64.CheckTag.4" file="shared_pseudocode.xml" hover="function: boolean AArch64.CheckTag(AddressDescriptor memaddrdesc, AccessDescriptor accdesc, bits(4) ptag, boolean write)">AArch64.CheckTag</a>(memaddrdesc, accdesc, ptag, iswrite) then
                <a link="AArch64.TagCheckFault.3" file="shared_pseudocode.xml" hover="function: AArch64.TagCheckFault(bits(64) vaddress, AccType acctype, boolean iswrite)">AArch64.TagCheckFault</a>(address, acctype, iswrite);

    <a link="PhysMemRetStatus" file="shared_pseudocode.xml" hover="type PhysMemRetStatus is (Fault statuscode, bit extflag, bits(2) errortype, bits(64) store64bstatus, AccType acctype)">PhysMemRetStatus</a> memstatus;
    (memstatus, data) = <a link="impl-shared.PhysMemRead.3" file="shared_pseudocode.xml" hover="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(memaddrdesc, size, accdesc);
    if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        <a link="impl-shared.HandleExternalReadAbort.4" file="shared_pseudocode.xml" hover="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, size, accdesc);
    return data;</pstext>
    </ps>
    <ps name="aarch64/functions/memory/MemStore64B" mylink="aarch64.functions.memory.MemStore64B" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// MemStore64B()
// =============
// Performs an atomic 64-byte store to a given virtual address. Function does
// not return the status of the store.

<anchor link="impl-aarch64.MemStore64B.3" hover="function: MemStore64B(bits(64) address, bits(512) value, AccType acctype)">MemStore64B</anchor>(bits(64) address, bits(512) value, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype)
    boolean iswrite = TRUE;
    constant integer size = 64;
    aligned = <a link="AArch64.CheckAlignment.4" file="shared_pseudocode.xml" hover="function: boolean AArch64.CheckAlignment(bits(64) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch64.CheckAlignment</a>(address, size, acctype, iswrite);

    if !<a link="impl-aarch64.AddressSupportsLS64.1" file="shared_pseudocode.xml" hover="function: boolean AddressSupportsLS64(bits(64) address)">AddressSupportsLS64</a>(address) then
        c = <a link="impl-shared.ConstrainUnpredictable.1" file="shared_pseudocode.xml" hover="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a link="Unpredictable_LS64UNSUPPORTED" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_LS64UNSUPPORTED</a>);
        assert c IN {<a link="Constraint_LIMITED_ATOMICITY" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_LIMITED_ATOMICITY</a>, <a link="Constraint_FAULT" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a>};

        if c == <a link="Constraint_FAULT" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a> then
            // Generate a Data Abort reported using the DFSC code of 110101.
            boolean secondstage = FALSE;
            boolean s2fs1walk = FALSE;
            fault = <a link="AArch64.ExclusiveFault.4" file="shared_pseudocode.xml" hover="function: FaultRecord AArch64.ExclusiveFault(AccType acctype, boolean iswrite,&#13; boolean secondstage, boolean s2fs1walk)">AArch64.ExclusiveFault</a>(acctype, iswrite, secondstage, s2fs1walk);
            <a link="AArch64.Abort.2" file="shared_pseudocode.xml" hover="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, fault);
        else
            // Accesses are not single-copy atomic above the byte level.
            for i = 0 to 63
                <a link="AArch64.MemSingle.write.4" file="shared_pseudocode.xml" hover="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned] = bits(size*8) value">AArch64.MemSingle</a>[address+8*i, 1, acctype, aligned] = value&lt;7+8*i : 8*i&gt;;
    else
        -= <a link="impl-aarch64.MemStore64BWithRet.3" file="shared_pseudocode.xml" hover="function: bits(64) MemStore64BWithRet(bits(64) address, bits(512) value, AccType acctype)">MemStore64BWithRet</a>(address, value, acctype);  // Return status is ignored by ST64B
    return;</pstext>
    </ps>
    <ps name="aarch64/functions/memory/MemStore64BWithRet" mylink="aarch64.functions.memory.MemStore64BWithRet" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// MemStore64BWithRet()
// ====================
// Performs an atomic 64-byte store to a given virtual address returning
// the status value of the operation.

bits(64) <anchor link="impl-aarch64.MemStore64BWithRet.3" hover="function: bits(64) MemStore64BWithRet(bits(64) address, bits(512) value, AccType acctype)">MemStore64BWithRet</anchor>(bits(64) address, bits(512) value, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype)
    <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc;
    boolean iswrite = TRUE;
    constant integer size = 64;

    aligned     = <a link="AArch64.CheckAlignment.4" file="shared_pseudocode.xml" hover="function: boolean AArch64.CheckAlignment(bits(64) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch64.CheckAlignment</a>(address, size, acctype, iswrite);
    memaddrdesc = <a link="AArch64.TranslateAddress.5" file="shared_pseudocode.xml" hover="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccType acctype, boolean iswrite,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, acctype, iswrite, aligned, size);

    // Check for aborts or debug exceptions
    if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a link="AArch64.Abort.2" file="shared_pseudocode.xml" hover="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, memaddrdesc.fault);
        return <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>('1');

    // Effect on exclusives
    if memaddrdesc.memattrs.shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then
        <a link="impl-shared.ClearExclusiveByAddress.3" file="shared_pseudocode.xml" hover="function: ClearExclusiveByAddress(FullAddress paddress, integer processorid, integer size)">ClearExclusiveByAddress</a>(memaddrdesc.paddress, <a link="impl-shared.ProcessorID.0" file="shared_pseudocode.xml" hover="function: integer ProcessorID()">ProcessorID</a>(), 64);

    // Memory array access
    accdesc = <a link="impl-shared.CreateAccessDescriptor.1" file="shared_pseudocode.xml" hover="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(acctype);

    if <a link="impl-shared.HaveMTE2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() then
        if <a link="AArch64.AccessIsTagChecked.2" file="shared_pseudocode.xml" hover="function: boolean AArch64.AccessIsTagChecked(bits(64) vaddr, AccType acctype)">AArch64.AccessIsTagChecked</a>(<a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(address, 64), acctype) then
            bits(4) ptag = <a link="AArch64.PhysicalTag.1" file="shared_pseudocode.xml" hover="function: bits(4) AArch64.PhysicalTag(bits(64) vaddr)">AArch64.PhysicalTag</a>(<a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(address, 64));
            if !<a link="AArch64.CheckTag.4" file="shared_pseudocode.xml" hover="function: boolean AArch64.CheckTag(AddressDescriptor memaddrdesc, AccessDescriptor accdesc, bits(4) ptag, boolean write)">AArch64.CheckTag</a>(memaddrdesc, accdesc, ptag, iswrite) then
                <a link="AArch64.TagCheckFault.3" file="shared_pseudocode.xml" hover="function: AArch64.TagCheckFault(bits(64) vaddress, AccType acctype, boolean iswrite)">AArch64.TagCheckFault</a>(address, acctype, iswrite);
                return <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>('1');

    memstatus = <a link="impl-shared.PhysMemWrite.4" file="shared_pseudocode.xml" hover="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(memaddrdesc, size, accdesc, value);
    if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        <a link="impl-shared.HandleExternalWriteAbort.4" file="shared_pseudocode.xml" hover="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, size, accdesc);
    return memstatus.store64bstatus;</pstext>
    </ps>
    <ps name="aarch64/functions/memory/MemStore64BWithRetStatus" mylink="aarch64.functions.memory.MemStore64BWithRetStatus" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Generates the return status of memory write with ST64BV or ST64BV0
// instructions. The status indicates if the operation succeeded, failed,
// or was not supported at this memory location.
bits(64) <anchor link="impl-aarch64.MemStore64BWithRetStatus.0" hover="function: bits(64) MemStore64BWithRetStatus()">MemStore64BWithRetStatus</anchor>();</pstext>
    </ps>
    <ps name="aarch64/functions/memory/NVMem" mylink="aarch64.functions.memory.NVMem" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// NVMem[] - non-assignment form
// =============================
// This function is the load memory access for the transformed System register read access
// when Enhanced Nested Virtualisation is enabled with HCR_EL2.NV2 = 1.
// The address for the load memory access is calculated using
// the formula SignExtend(VNCR_EL2.BADDR : Offset&lt;11:0&gt;, 64) where,
//  * VNCR_EL2.BADDR holds the base address of the memory location, and
//  * Offset is the unique offset value defined architecturally for each System register that
//    supports transformation of register access to memory access.

bits(64) <anchor link="impl-aarch64.NVMem.read.1" hover="accessor: bits(64) NVMem[integer offset]">NVMem</anchor>[integer offset]
    assert offset &gt; 0;
    bits(64) address = <a link="impl-shared.SignExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) SignExtend(bits(M) x, integer N)">SignExtend</a>(VNCR_EL2.BADDR:offset&lt;11:0&gt;, 64);
    return <a link="impl-aarch64.Mem.read.3" file="shared_pseudocode.xml" hover="accessor: bits(size*8) Mem[bits(64) address, integer size, AccType acctype]">Mem</a>[address, 8, <a link="AccType_NV2REGISTER" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NV2REGISTER</a>];

// NVMem[] - assignment form
// =========================
// This function is the store memory access for the transformed System register write access
// when Enhanced Nested Virtualisation is enabled with HCR_EL2.NV2 = 1.
// The address for the store memory access is calculated using
// the formula SignExtend(VNCR_EL2.BADDR : Offset&lt;11:0&gt;, 64) where,
//  * VNCR_EL2.BADDR holds the base address of the memory location, and
//  * Offset is the unique offset value defined architecturally for each System register that
//    supports transformation of register access to memory access.

<anchor link="impl-aarch64.NVMem.write.1" hover="accessor: NVMem[integer offset] = bits(64) value">NVMem</anchor>[integer offset] = bits(64) value
    assert offset &gt; 0;
    bits(64) address = <a link="impl-shared.SignExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) SignExtend(bits(M) x, integer N)">SignExtend</a>(VNCR_EL2.BADDR:offset&lt;11:0&gt;, 64);
    Mem[address, 8, AccType_NV2REGISTER] = value;
    return;</pstext>
    </ps>
    <ps name="aarch64/functions/memory/PhysMemTagRead" mylink="aarch64.functions.memory.PhysMemTagRead" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// This is the hardware operation which perform a single-copy atomic,
// Allocation Tag granule aligned, memory access from the tag in PA space.
//
// The function address the array using desc.paddress which supplies:
// * A 52-bit physical address
// * A single NS bit to select between Secure and Non-secure parts of the array.
//
// The accdesc descriptor describes the access type: normal, exclusive, ordered, streaming,
// etc and other parameters required to access the physical memory or for setting syndrome
// register in the event of an External abort.
(PhysMemRetStatus, bits(4)) <anchor link="impl-aarch64.PhysMemTagRead.2" hover="function: (PhysMemRetStatus, bits(4)) PhysMemTagRead(AddressDescriptor desc, AccessDescriptor accdesc)">PhysMemTagRead</anchor>(<a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> desc, <a link="AccessDescriptor" file="shared_pseudocode.xml" hover="type AccessDescriptor is ( MPAMinfo mpam, AccType acctype)">AccessDescriptor</a> accdesc);</pstext>
    </ps>
    <ps name="aarch64/functions/memory/PhysMemTagWrite" mylink="aarch64.functions.memory.PhysMemTagWrite" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// This is the hardware operation which perform a single-copy atomic,
// Allocation Tag granule aligned, memory access to the tag in PA space.
//
// The function address the array using desc.paddress which supplies:
// * A 52-bit physical address
// * A single NS bit to select between Secure and Non-secure parts of the array.
//
// The accdesc descriptor describes the access type: normal, exclusive, ordered, streaming,
// etc and other parameters required to access the physical memory or for setting syndrome
// register in the event of an External abort.
PhysMemRetStatus <anchor link="impl-aarch64.PhysMemTagWrite.3" hover="function: PhysMemRetStatus PhysMemTagWrite(AddressDescriptor desc, AccessDescriptor accdesc, bits (4) value)">PhysMemTagWrite</anchor>(<a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> desc, <a link="AccessDescriptor" file="shared_pseudocode.xml" hover="type AccessDescriptor is ( MPAMinfo mpam, AccType acctype)">AccessDescriptor</a> accdesc, bits (4) value);</pstext>
    </ps>
    <ps name="aarch64/functions/memory/SetTagCheckedInstruction" mylink="aarch64.functions.memory.SetTagCheckedInstruction" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Flag the current instruction as using/not using memory tag checking.
<anchor link="impl-aarch64.SetTagCheckedInstruction.1" hover="function: SetTagCheckedInstruction(boolean checked)">SetTagCheckedInstruction</anchor>(boolean checked);</pstext>
    </ps>
    <ps name="aarch64/functions/mops/CPYPostSizeChoice" mylink="aarch64.functions.mops.CPYPostSizeChoice" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns the size of the copy that is performed by the CPYE* instructions for this
// implementation given the parameters of the destination, source and size of the copy.
// Postsize is encoded as -1*size for an option A implementation if cpysize is negative.
bits(64) <anchor link="impl-aarch64.CPYPostSizeChoice.3" hover="function: bits(64) CPYPostSizeChoice(bits(64) toaddress, bits(64) fromaddress, bits(64) cpysize)">CPYPostSizeChoice</anchor>(bits(64) toaddress, bits(64) fromaddress, bits(64) cpysize);</pstext>
    </ps>
    <ps name="aarch64/functions/mops/CPYPreSizeChoice" mylink="aarch64.functions.mops.CPYPreSizeChoice" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns the size of the copy that is performed by the CPYP* instructions for this
// implementation given the parameters of the destination, source and size of the copy.
// Presize is encoded as -1*size for an option A implementation if cpysize is negative.
bits(64) <anchor link="impl-aarch64.CPYPreSizeChoice.3" hover="function: bits(64) CPYPreSizeChoice(bits(64) toaddress, bits(64) fromaddress, bits(64) cpysize)">CPYPreSizeChoice</anchor>(bits(64) toaddress, bits(64) fromaddress, bits(64) cpysize);</pstext>
    </ps>
    <ps name="aarch64/functions/mops/CPYSizeChoice" mylink="aarch64.functions.mops.CPYSizeChoice" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns the size of the block this performed for an iteration of the copy given the
// parameters of the destination, source and size of the copy.
integer <anchor link="impl-aarch64.CPYSizeChoice.3" hover="function: integer CPYSizeChoice(bits(64) toaddress, bits(64) fromaddress, bits(64) cpysize)">CPYSizeChoice</anchor>(bits(64) toaddress, bits(64) fromaddress, bits(64) cpysize);</pstext>
    </ps>
    <ps name="aarch64/functions/mops/CheckMOPSEnabled" mylink="aarch64.functions.mops.CheckMOPSEnabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CheckMOPSEnabled()
// ==================
// Check for EL0 and EL1 access to the CPY* and SET* instructions.

<anchor link="impl-aarch64.CheckMOPSEnabled.0" hover="function: CheckMOPSEnabled()">CheckMOPSEnabled</anchor>()
    if (PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
        (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0') &amp;&amp;
        (!<a link="impl-aarch64.IsHCRXEL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean IsHCRXEL2Enabled()">IsHCRXEL2Enabled</a>() || HCRX_EL2.MSCEn == '0')) then
        UNDEFINED;

    if (PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; SCTLR_EL1.MSCEn == '0' &amp;&amp;
        (!<a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() || HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0')) then
        UNDEFINED;

    if PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a link="impl-shared.IsInHost.0" file="shared_pseudocode.xml" hover="function: boolean IsInHost()">IsInHost</a>() &amp;&amp; SCTLR_EL2.MSCEn == '0' then
        UNDEFINED;</pstext>
    </ps>
    <ps name="aarch64/functions/mops/MOPSStage" mylink="aarch64.functions.mops.MOPSStage" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="MOPSStage" hover="enumeration MOPSStage { MOPSStage_Prologue, MOPSStage_Main, MOPSStage_Epilogue }">MOPSStage</anchor> { <anchor link="MOPSStage_Prologue" hover="enumeration MOPSStage { MOPSStage_Prologue, MOPSStage_Main, MOPSStage_Epilogue }">MOPSStage_Prologue</anchor>, <anchor link="MOPSStage_Main" hover="enumeration MOPSStage { MOPSStage_Prologue, MOPSStage_Main, MOPSStage_Epilogue }">MOPSStage_Main</anchor>, <anchor link="MOPSStage_Epilogue" hover="enumeration MOPSStage { MOPSStage_Prologue, MOPSStage_Main, MOPSStage_Epilogue }">MOPSStage_Epilogue</anchor> };</pstext>
    </ps>
    <ps name="aarch64/functions/mops/MaxBlockSizeCopiedBytes" mylink="aarch64.functions.mops.MaxBlockSizeCopiedBytes" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// MaxBlockSizeCopiedBytes()
// =========================
// Returns the maximum number of bytes that can used in a single block of the copy.

integer <anchor link="impl-aarch64.MaxBlockSizeCopiedBytes.0" hover="function: integer MaxBlockSizeCopiedBytes()">MaxBlockSizeCopiedBytes</anchor>()
    return integer IMPLEMENTATION_DEFINED "Maximum bytes used in a single block of a copy";</pstext>
    </ps>
    <ps name="aarch64/functions/mops/MemCpyAccessTypes" mylink="aarch64.functions.mops.MemCpyAccessTypes" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// MemCpyAccessTypes()
// ===================
// Return the read and write access types for a CPY* instruction.

(AccType, AccType) <anchor link="impl-aarch64.MemCpyAccessTypes.1" hover="function: (AccType, AccType) MemCpyAccessTypes(bits(4) options)">MemCpyAccessTypes</anchor>(bits(4) options)
    unpriv_at_el1 = PSTATE.EL == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; !(<a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
        <a link="impl-shared.HaveNVExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveNVExt()">HaveNVExt</a>() &amp;&amp; HCR_EL2.&lt;NV,NV1&gt; == '11');
    unpriv_at_el2 = PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; <a link="impl-shared.HaveVirtHostExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; == '11';

    runpriv_at_el1 = options&lt;1&gt; == '1' &amp;&amp; unpriv_at_el1;
    runpriv_at_el2 = options&lt;1&gt; == '1' &amp;&amp; unpriv_at_el2;
    wunpriv_at_el1 = options&lt;0&gt; == '1' &amp;&amp; unpriv_at_el1;
    wunpriv_at_el2 = options&lt;0&gt; == '1' &amp;&amp; unpriv_at_el2;

    user_access_override = <a link="impl-shared.HaveUAOExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveUAOExt()">HaveUAOExt</a>() &amp;&amp; PSTATE.UAO == '1';

    <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> racctype;
    if !user_access_override &amp;&amp; (runpriv_at_el1 || runpriv_at_el2) then
        racctype = if options&lt;3&gt; == '0' then <a link="AccType_UNPRIV" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_UNPRIV</a> else <a link="AccType_UNPRIVSTREAM" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_UNPRIVSTREAM</a>;
    else
        racctype = if options&lt;3&gt; == '0' then <a link="AccType_NORMAL" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NORMAL</a> else <a link="AccType_STREAM" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_STREAM</a>;

    <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> wacctype;
    if !user_access_override &amp;&amp; (wunpriv_at_el1 || wunpriv_at_el2) then
        wacctype = if options&lt;2&gt; == '0' then <a link="AccType_UNPRIV" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_UNPRIV</a> else <a link="AccType_UNPRIVSTREAM" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_UNPRIVSTREAM</a>;
    else
        wacctype = if options&lt;2&gt; == '0' then <a link="AccType_NORMAL" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NORMAL</a> else <a link="AccType_STREAM" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_STREAM</a>;

    return (racctype, wacctype);</pstext>
    </ps>
    <ps name="aarch64/functions/mops/MemCpyDirectionChoice" mylink="aarch64.functions.mops.MemCpyDirectionChoice" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns true if in the non-overlapping case of a memcpy of size cpysize bytes
// from the source address fromaddress to destination address toaddress is done
// in the forward direction on this implementation.
boolean <anchor link="impl-aarch64.MemCpyDirectionChoice.3" hover="function: boolean MemCpyDirectionChoice(bits(64) fromaddress, bits(64) toaddress, bits(64) cpysize)">MemCpyDirectionChoice</anchor>(bits(64) fromaddress, bits(64) toaddress, bits(64) cpysize);</pstext>
    </ps>
    <ps name="aarch64/functions/mops/MemCpyOptionA" mylink="aarch64.functions.mops.MemCpyOptionA" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// MemCpyOptionA()
// ===============
// Returns TRUE if the implementation uses Option A for the
// CPY*/SET* instructions, and FALSE otherwise.

boolean <anchor link="impl-aarch64.MemCpyOptionA.0" hover="function: boolean MemCpyOptionA()">MemCpyOptionA</anchor>()
    return boolean IMPLEMENTATION_DEFINED "CPY*/SET* instructions use Option A";</pstext>
    </ps>
    <ps name="aarch64/functions/mops/MemCpyParametersIllformedE" mylink="aarch64.functions.mops.MemCpyParametersIllformedE" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns TRUE if the inputs are not well formed (in terms of their size and/or alignment)
// for a CPYE* instruction for this implementation given the parameters of the destination,
// source and size of the copy.
boolean <anchor link="impl-aarch64.MemCpyParametersIllformedE.3" hover="function: boolean MemCpyParametersIllformedE(bits(64) toaddress, bits(64) fromaddress,&#13; bits(64) cpysize)">MemCpyParametersIllformedE</anchor>(bits(64) toaddress, bits(64) fromaddress,
                                   bits(64) cpysize);</pstext>
    </ps>
    <ps name="aarch64/functions/mops/MemCpyParametersIllformedM" mylink="aarch64.functions.mops.MemCpyParametersIllformedM" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns TRUE if the inputs are not well formed (in terms of their size and/or alignment)
// for a CPYM* instruction for this implementation given the parameters of the destination,
// source and size of the copy.
boolean <anchor link="impl-aarch64.MemCpyParametersIllformedM.3" hover="function: boolean MemCpyParametersIllformedM(bits(64) toaddress, bits(64) fromaddress,&#13; bits(64) cpysize)">MemCpyParametersIllformedM</anchor>(bits(64) toaddress, bits(64) fromaddress,
                                   bits(64) cpysize);</pstext>
    </ps>
    <ps name="aarch64/functions/mops/MemCpyZeroSizeCheck" mylink="aarch64.functions.mops.MemCpyZeroSizeCheck" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns TRUE if the implementation option is checked on a copy of size zero remaining.
boolean <anchor link="impl-aarch64.MemCpyZeroSizeCheck.0" hover="function: boolean MemCpyZeroSizeCheck()">MemCpyZeroSizeCheck</anchor>();</pstext>
    </ps>
    <ps name="aarch64/functions/mops/MemSetAccessType" mylink="aarch64.functions.mops.MemSetAccessType" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// MemSetAccessType()
// ==================
// Return the access type for a SET* instruction.

AccType <anchor link="impl-aarch64.MemSetAccessType.1" hover="function: AccType MemSetAccessType(bits(2) options)">MemSetAccessType</anchor>(bits(2) options)
    unpriv_at_el1 = options&lt;0&gt; == '1' &amp;&amp; PSTATE.EL == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; !(<a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
        <a link="impl-shared.HaveNVExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveNVExt()">HaveNVExt</a>() &amp;&amp; HCR_EL2.&lt;NV,NV1&gt; == '11');
    unpriv_at_el2 = (options&lt;0&gt; == '1' &amp;&amp; PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp;
        <a link="impl-shared.HaveVirtHostExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; == '11');

    user_access_override = <a link="impl-shared.HaveUAOExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveUAOExt()">HaveUAOExt</a>() &amp;&amp; PSTATE.UAO == '1';

    <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype;
    if !user_access_override &amp;&amp; (unpriv_at_el1 || unpriv_at_el2) then
        acctype = if options&lt;1&gt; == '0' then <a link="AccType_UNPRIV" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_UNPRIV</a> else <a link="AccType_UNPRIVSTREAM" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_UNPRIVSTREAM</a>;
    else
        acctype = if options&lt;1&gt; == '0' then <a link="AccType_NORMAL" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NORMAL</a> else <a link="AccType_STREAM" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_STREAM</a>;

    return acctype;</pstext>
    </ps>
    <ps name="aarch64/functions/mops/MemSetParametersIllformedE" mylink="aarch64.functions.mops.MemSetParametersIllformedE" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns TRUE if the inputs are not well formed (in terms of their size and/or
// alignment) for a SETE* or SETGE* instruction for this implementation given the
// parameters of the destination and size of the set.
boolean <anchor link="impl-aarch64.MemSetParametersIllformedE.3" hover="function: boolean MemSetParametersIllformedE(bits(64) toaddress, bits(64) setsize,&#13; boolean IsSETGE)">MemSetParametersIllformedE</anchor>(bits(64) toaddress, bits(64) setsize,
                                   boolean IsSETGE);</pstext>
    </ps>
    <ps name="aarch64/functions/mops/MemSetParametersIllformedM" mylink="aarch64.functions.mops.MemSetParametersIllformedM" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns TRUE if the inputs are not well formed (in terms of their size and/or
// alignment) for a SETM* or SETGM* instruction for this implementation given the
// parameters of the destination and size of the copy.
boolean <anchor link="impl-aarch64.MemSetParametersIllformedM.3" hover="function: boolean MemSetParametersIllformedM(bits(64) toaddress, bits(64) setsize,&#13; boolean IsSETGM)">MemSetParametersIllformedM</anchor>(bits(64) toaddress, bits(64) setsize,
                                   boolean IsSETGM);</pstext>
    </ps>
    <ps name="aarch64/functions/mops/MemSetZeroSizeCheck" mylink="aarch64.functions.mops.MemSetZeroSizeCheck" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns TRUE if the implementation option is checked on a copy of size zero remaining.
boolean <anchor link="impl-aarch64.MemSetZeroSizeCheck.0" hover="function: boolean MemSetZeroSizeCheck()">MemSetZeroSizeCheck</anchor>();</pstext>
    </ps>
    <ps name="aarch64/functions/mops/MismatchedCpySetTargetEL" mylink="aarch64.functions.mops.MismatchedCpySetTargetEL" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// MismatchedCpySetTargetEL()
// ==========================
// Return the target exception level for an Exception_MemCpyMemSet.

bits(2) <anchor link="impl-aarch64.MismatchedCpySetTargetEL.0" hover="function: bits(2) MismatchedCpySetTargetEL()">MismatchedCpySetTargetEL</anchor>()
    bits(2) target_el;

    if <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then
        target_el = PSTATE.EL;
    elsif PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then
        target_el = <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;
    elsif (PSTATE.EL == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
        <a link="impl-aarch64.IsHCRXEL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean IsHCRXEL2Enabled()">IsHCRXEL2Enabled</a>() &amp;&amp; HCRX_EL2.MCE2 == '1') then
        target_el = <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;
    else
        target_el = <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;

    return target_el;</pstext>
    </ps>
    <ps name="aarch64/functions/mops/MismatchedMemCpyException" mylink="aarch64.functions.mops.MismatchedMemCpyException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// MismatchedMemCpyException()
// ===========================
// Generates an exception for a CPY* instruction if the version
// is inconsistent with the state of the call.

<anchor link="impl-aarch64.MismatchedMemCpyException.7" hover="function: MismatchedMemCpyException(boolean option_a, integer destreg, integer srcreg, integer sizereg,&#13; boolean wrong_option, boolean from_epilogue, bits(4) options)">MismatchedMemCpyException</anchor>(boolean option_a, integer destreg, integer srcreg, integer sizereg,
                          boolean wrong_option, boolean from_epilogue, bits(4) options)
    bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    integer vect_offset = 0x0;
    bits(2) target_el = <a link="impl-aarch64.MismatchedCpySetTargetEL.0" file="shared_pseudocode.xml" hover="function: bits(2) MismatchedCpySetTargetEL()">MismatchedCpySetTargetEL</a>();

    <a link="ExceptionRecord" file="shared_pseudocode.xml" hover="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_MemCpyMemSet" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_MemCpyMemSet</a>);
    exception.syndrome&lt;24&gt;    = '0';
    exception.syndrome&lt;23&gt;    = '0';
    exception.syndrome&lt;22:19&gt; = options;
    exception.syndrome&lt;18&gt;    = if from_epilogue then '1' else '0';
    exception.syndrome&lt;17&gt;    = if wrong_option then '1' else '0';
    exception.syndrome&lt;16&gt;    = if option_a then '1' else '0';
    // exception.syndrome&lt;15&gt; is RES0
    exception.syndrome&lt;14:10&gt; = destreg&lt;4:0&gt;;
    exception.syndrome&lt;9:5&gt;   = srcreg&lt;4:0&gt;;
    exception.syndrome&lt;4:0&gt;   = sizereg&lt;4:0&gt;;

    <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/functions/mops/MismatchedMemSetException" mylink="aarch64.functions.mops.MismatchedMemSetException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// MismatchedMemSetException()
// ===========================
// Generates an exception for a SET* instruction if the version
// is inconsistent with the state of the call.

<anchor link="impl-aarch64.MismatchedMemSetException.8" hover="function: MismatchedMemSetException(boolean option_a, integer destreg, integer datareg, integer sizereg,&#13; boolean wrong_option, boolean from_epilogue, bits(2) options,&#13; boolean is_SETG)">MismatchedMemSetException</anchor>(boolean option_a, integer destreg, integer datareg, integer sizereg,
                          boolean wrong_option, boolean from_epilogue, bits(2) options,
                          boolean is_SETG)
    bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    integer vect_offset = 0x0;
    bits(2) target_el = <a link="impl-aarch64.MismatchedCpySetTargetEL.0" file="shared_pseudocode.xml" hover="function: bits(2) MismatchedCpySetTargetEL()">MismatchedCpySetTargetEL</a>();

    <a link="ExceptionRecord" file="shared_pseudocode.xml" hover="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_MemCpyMemSet" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_MemCpyMemSet</a>);
    exception.syndrome&lt;24&gt;    = '1';
    exception.syndrome&lt;23&gt;    = if is_SETG then '1' else '0';
    // exception.syndrome&lt;22:21&gt; is RES0
    exception.syndrome&lt;20:19&gt; = options;
    exception.syndrome&lt;18&gt;    = if from_epilogue then '1' else '0';
    exception.syndrome&lt;17&gt;    = if wrong_option then '1' else '0';
    exception.syndrome&lt;16&gt;    = if option_a then '1' else '0';
    // exception.syndrome&lt;15&gt; is RES0
    exception.syndrome&lt;14:10&gt; = destreg&lt;4:0&gt;;
    exception.syndrome&lt;9:5&gt;   = datareg&lt;4:0&gt;;
    exception.syndrome&lt;4:0&gt;   = sizereg&lt;4:0&gt;;

    <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/functions/mops/SETPostSizeChoice" mylink="aarch64.functions.mops.SETPostSizeChoice" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns the size of the set that is performed by the SETE* or SETGE* instructions
// for this implementation, given the parameters of the destination and size of the set.
// Postsize is encoded as -1*size for an option A implementation if setsize is negative.
bits(64) <anchor link="impl-aarch64.SETPostSizeChoice.3" hover="function: bits(64) SETPostSizeChoice(bits(64) toaddress, bits(64) setsize, boolean IsSETGE)">SETPostSizeChoice</anchor>(bits(64) toaddress, bits(64) setsize, boolean IsSETGE);</pstext>
    </ps>
    <ps name="aarch64/functions/mops/SETPreSizeChoice" mylink="aarch64.functions.mops.SETPreSizeChoice" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns the size of the set that is performed by the SETP* or SETGP* instructions
// for this implementation, given the parameters of the destination and size of the set.
// Presize is encoded as -1*size for an option A implementation if setsize is negative.
bits(64) <anchor link="impl-aarch64.SETPreSizeChoice.3" hover="function: bits(64) SETPreSizeChoice(bits(64) toaddress, bits(64) setsize, boolean IsSETGP)">SETPreSizeChoice</anchor>(bits(64) toaddress, bits(64) setsize, boolean IsSETGP);</pstext>
    </ps>
    <ps name="aarch64/functions/mops/SETSizeChoice" mylink="aarch64.functions.mops.SETSizeChoice" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns the size of the block thisperformed for an iteration of the set given
// the parameters of the destination and size of the set. The size of the block
// is an integer multiple of AlignSize.
integer <anchor link="impl-aarch64.SETSizeChoice.3" hover="function: integer SETSizeChoice(bits(64) toaddress, bits(64) setsize, integer AlignSize)">SETSizeChoice</anchor>(bits(64) toaddress, bits(64) setsize, integer AlignSize);</pstext>
    </ps>
    <ps name="aarch64/functions/pac/addpac/AddPAC" mylink="aarch64.functions.pac.addpac.AddPAC" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AddPAC()
// ========
// Calculates the pointer authentication code for a 64-bit quantity and then
// inserts that into pointer authentication code field of that 64-bit quantity.

bits(64) <anchor link="impl-aarch64.AddPAC.4" hover="function: bits(64) AddPAC(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data)">AddPAC</anchor>(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data)
    bits(64) PAC;
    bits(64) result;
    bits(64) ext_ptr;
    bits(64) extfield;
    bit selbit;
    boolean tbi = <a link="impl-shared.EffectiveTBI.3" file="shared_pseudocode.xml" hover="function: bit EffectiveTBI(bits(64) address, boolean IsInstr, bits(2) el)">EffectiveTBI</a>(ptr, !data, PSTATE.EL) == '1';
    integer top_bit = if tbi then 55 else 63;

    // If tagged pointers are in use for a regime with two TTBRs, use bit&lt;55&gt; of
    // the pointer to select between upper and lower ranges, and preserve this.
    // This handles the awkward case where there is apparently no correct choice between
    // the upper and lower address range - ie an addr of 1xxxxxxx0... with TBI0=0 and TBI1=1
    // and 0xxxxxxx1 with TBI1=0 and TBI0=1:
    if <a link="impl-aarch64.PtrHasUpperAndLowerAddRanges.0" file="shared_pseudocode.xml" hover="function: boolean PtrHasUpperAndLowerAddRanges()">PtrHasUpperAndLowerAddRanges</a>() then
        assert <a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() IN {<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>, <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>};
        if <a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> then
            // EL1 translation regime registers
            if data then
                if TCR_EL1.TBI1 == '1' || TCR_EL1.TBI0 == '1' then
                    selbit = ptr&lt;55&gt;;
                else
                    selbit = ptr&lt;63&gt;;
            else
                if ((TCR_EL1.TBI1 == '1' &amp;&amp; TCR_EL1.TBID1 == '0') ||
                    (TCR_EL1.TBI0 == '1' &amp;&amp; TCR_EL1.TBID0 == '0')) then
                    selbit = ptr&lt;55&gt;;
                else
                    selbit = ptr&lt;63&gt;;
        else
            // EL2 translation regime registers
            if data then
                if TCR_EL2.TBI1 == '1' || TCR_EL2.TBI0 == '1' then
                    selbit = ptr&lt;55&gt;;
                else
                    selbit = ptr&lt;63&gt;;
            else
                if ((TCR_EL2.TBI1 == '1' &amp;&amp; TCR_EL2.TBID1 == '0') ||
                    (TCR_EL2.TBI0 == '1' &amp;&amp; TCR_EL2.TBID0 == '0')) then
                    selbit = ptr&lt;55&gt;;
                else
                    selbit = ptr&lt;63&gt;;
    else selbit = if tbi then ptr&lt;55&gt; else ptr&lt;63&gt;;

    if <a link="impl-aarch64.HaveEnhancedPAC2.0" file="shared_pseudocode.xml" hover="function: boolean HaveEnhancedPAC2()">HaveEnhancedPAC2</a>() &amp;&amp; <a link="impl-aarch64.ConstPACField.0" file="shared_pseudocode.xml" hover="function: boolean ConstPACField()">ConstPACField</a>() then selbit = ptr&lt;55&gt;;
    integer bottom_PAC_bit = <a link="impl-aarch64.CalculateBottomPACBit.1" file="shared_pseudocode.xml" hover="function: integer CalculateBottomPACBit(bit top_bit)">CalculateBottomPACBit</a>(selbit);

    // The pointer authentication code field takes all the available bits in between
    extfield = <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(selbit, 64);

    // Compute the pointer authentication code for a ptr with good extension bits
    if tbi then
        ext_ptr = ptr&lt;63:56&gt;:extfield&lt;(56-bottom_PAC_bit)-1:0&gt;:ptr&lt;bottom_PAC_bit-1:0&gt;;
    else
        ext_ptr = extfield&lt;(64-bottom_PAC_bit)-1:0&gt;:ptr&lt;bottom_PAC_bit-1:0&gt;;

    PAC = <a link="impl-aarch64.ComputePAC.4" file="shared_pseudocode.xml" hover="function: bits(64) ComputePAC(bits(64) data, bits(64) modifier, bits(64) key0, bits(64) key1)">ComputePAC</a>(ext_ptr, modifier, K&lt;127:64&gt;, K&lt;63:0&gt;);

    // Check if the ptr has good extension bits and corrupt the pointer authentication code if not
    if !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(ptr&lt;top_bit:bottom_PAC_bit&gt;) &amp;&amp; !<a link="impl-shared.IsOnes.1" file="shared_pseudocode.xml" hover="function: boolean IsOnes(bits(N) x)">IsOnes</a>(ptr&lt;top_bit:bottom_PAC_bit&gt;) then
        if <a link="impl-aarch64.HaveEnhancedPAC.0" file="shared_pseudocode.xml" hover="function: boolean HaveEnhancedPAC()">HaveEnhancedPAC</a>() then
            PAC = 0x0000000000000000&lt;63:0&gt;;
        elsif !<a link="impl-aarch64.HaveEnhancedPAC2.0" file="shared_pseudocode.xml" hover="function: boolean HaveEnhancedPAC2()">HaveEnhancedPAC2</a>() then
            PAC&lt;top_bit-1&gt; = NOT(PAC&lt;top_bit-1&gt;);

    // preserve the determination between upper and lower address at bit&lt;55&gt; and insert PAC
    if !<a link="impl-aarch64.HaveEnhancedPAC2.0" file="shared_pseudocode.xml" hover="function: boolean HaveEnhancedPAC2()">HaveEnhancedPAC2</a>() then
        if tbi then
            result = ptr&lt;63:56&gt;:selbit:PAC&lt;54:bottom_PAC_bit&gt;:ptr&lt;bottom_PAC_bit-1:0&gt;;
        else
            result = PAC&lt;63:56&gt;:selbit:PAC&lt;54:bottom_PAC_bit&gt;:ptr&lt;bottom_PAC_bit-1:0&gt;;
    else
        if tbi then
            result = ptr&lt;63:56&gt;:selbit:(ptr&lt;54:bottom_PAC_bit&gt; EOR PAC&lt;54:bottom_PAC_bit&gt;):ptr&lt;bottom_PAC_bit-1:0&gt;;
        else
            result = (ptr&lt;63:56&gt; EOR PAC&lt;63:56&gt;):selbit:(ptr&lt;54:bottom_PAC_bit&gt; EOR
                        PAC&lt;54:bottom_PAC_bit&gt;):ptr&lt;bottom_PAC_bit-1:0&gt;;
    return result;</pstext>
    </ps>
    <ps name="aarch64/functions/pac/addpacda/AddPACDA" mylink="aarch64.functions.pac.addpacda.AddPACDA" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AddPACDA()
// ==========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with a pointer authentication code, where the pointer authentication
// code is derived using a cryptographic algorithm as a combination of X, Y and the
// APDAKey_EL1.

bits(64) <anchor link="impl-aarch64.AddPACDA.2" hover="function: bits(64) AddPACDA(bits(64) X, bits(64) Y)">AddPACDA</anchor>(bits(64) X, bits(64) Y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APDAKey_EL1;

    APDAKey_EL1 = APDAKeyHi_EL1&lt;63:0&gt; : APDAKeyLo_EL1&lt;63:0&gt;;
    case PSTATE.EL of
        when <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>
            boolean IsEL1Regime = <a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnDA else SCTLR_EL2.EnDA;
            TrapEL2 = (<a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                        (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>
            Enable = SCTLR_EL1.EnDA;
            TrapEL2 = <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>
            Enable = SCTLR_EL2.EnDA;
            TrapEL2 = FALSE;
            TrapEL3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>
            Enable = SCTLR_EL3.EnDA;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then <a link="impl-aarch64.TrapPACUse.1" file="shared_pseudocode.xml" hover="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>);
    elsif TrapEL3 then <a link="impl-aarch64.TrapPACUse.1" file="shared_pseudocode.xml" hover="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>);
    else return <a link="impl-aarch64.AddPAC.4" file="shared_pseudocode.xml" hover="function: bits(64) AddPAC(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data)">AddPAC</a>(X, Y, APDAKey_EL1, TRUE);</pstext>
    </ps>
    <ps name="aarch64/functions/pac/addpacdb/AddPACDB" mylink="aarch64.functions.pac.addpacdb.AddPACDB" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AddPACDB()
// ==========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with a pointer authentication code, where the pointer authentication
// code is derived using a cryptographic algorithm as a combination of X, Y and the
// APDBKey_EL1.

bits(64) <anchor link="impl-aarch64.AddPACDB.2" hover="function: bits(64) AddPACDB(bits(64) X, bits(64) Y)">AddPACDB</anchor>(bits(64) X, bits(64) Y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APDBKey_EL1;

    APDBKey_EL1 = APDBKeyHi_EL1&lt;63:0&gt; : APDBKeyLo_EL1&lt;63:0&gt;;
    case PSTATE.EL of
        when <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>
            boolean IsEL1Regime = <a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnDB else SCTLR_EL2.EnDB;
            TrapEL2 = (<a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>
            Enable = SCTLR_EL1.EnDB;
            TrapEL2 = <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>
            Enable = SCTLR_EL2.EnDB;
            TrapEL2 = FALSE;
            TrapEL3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>
            Enable = SCTLR_EL3.EnDB;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then <a link="impl-aarch64.TrapPACUse.1" file="shared_pseudocode.xml" hover="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>);
    elsif TrapEL3 then <a link="impl-aarch64.TrapPACUse.1" file="shared_pseudocode.xml" hover="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>);
    else return <a link="impl-aarch64.AddPAC.4" file="shared_pseudocode.xml" hover="function: bits(64) AddPAC(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data)">AddPAC</a>(X, Y, APDBKey_EL1, TRUE);</pstext>
    </ps>
    <ps name="aarch64/functions/pac/addpacga/AddPACGA" mylink="aarch64.functions.pac.addpacga.AddPACGA" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AddPACGA()
// ==========
// Returns a 64-bit value where the lower 32 bits are 0, and the upper 32 bits contain
// a 32-bit pointer authentication code which is derived using a cryptographic
// algorithm as a combination of X, Y and the APGAKey_EL1.

bits(64) <anchor link="impl-aarch64.AddPACGA.2" hover="function: bits(64) AddPACGA(bits(64) X, bits(64) Y)">AddPACGA</anchor>(bits(64) X, bits(64) Y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(128) APGAKey_EL1;

    APGAKey_EL1 = APGAKeyHi_EL1&lt;63:0&gt; : APGAKeyLo_EL1&lt;63:0&gt;;
    case PSTATE.EL of
        when <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>
            TrapEL2 = (<a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                        (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>
            TrapEL2 = <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>
            TrapEL2 = FALSE;
            TrapEL3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if TrapEL2 then <a link="impl-aarch64.TrapPACUse.1" file="shared_pseudocode.xml" hover="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>);
    elsif TrapEL3 then <a link="impl-aarch64.TrapPACUse.1" file="shared_pseudocode.xml" hover="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>);
    else return <a link="impl-aarch64.ComputePAC.4" file="shared_pseudocode.xml" hover="function: bits(64) ComputePAC(bits(64) data, bits(64) modifier, bits(64) key0, bits(64) key1)">ComputePAC</a>(X, Y, APGAKey_EL1&lt;127:64&gt;, APGAKey_EL1&lt;63:0&gt;)&lt;63:32&gt;:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(32);</pstext>
    </ps>
    <ps name="aarch64/functions/pac/addpacia/AddPACIA" mylink="aarch64.functions.pac.addpacia.AddPACIA" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AddPACIA()
// ==========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with a pointer authentication code, where the pointer authentication
// code is derived using a cryptographic algorithm as a combination of X, Y, and the
// APIAKey_EL1.

bits(64) <anchor link="impl-aarch64.AddPACIA.2" hover="function: bits(64) AddPACIA(bits(64) X, bits(64) Y)">AddPACIA</anchor>(bits(64) X, bits(64) Y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APIAKey_EL1;

    APIAKey_EL1 = APIAKeyHi_EL1&lt;63:0&gt;:APIAKeyLo_EL1&lt;63:0&gt;;
    case PSTATE.EL of
        when <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>
            boolean IsEL1Regime = <a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnIA else SCTLR_EL2.EnIA;
            TrapEL2 = (<a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>
            Enable = SCTLR_EL1.EnIA;
            TrapEL2 = <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>
            Enable = SCTLR_EL2.EnIA;
            TrapEL2 = FALSE;
            TrapEL3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>
            Enable = SCTLR_EL3.EnIA;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then <a link="impl-aarch64.TrapPACUse.1" file="shared_pseudocode.xml" hover="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>);
    elsif TrapEL3 then <a link="impl-aarch64.TrapPACUse.1" file="shared_pseudocode.xml" hover="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>);
    else return <a link="impl-aarch64.AddPAC.4" file="shared_pseudocode.xml" hover="function: bits(64) AddPAC(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data)">AddPAC</a>(X, Y, APIAKey_EL1, FALSE);</pstext>
    </ps>
    <ps name="aarch64/functions/pac/addpacib/AddPACIB" mylink="aarch64.functions.pac.addpacib.AddPACIB" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AddPACIB()
// ==========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with a pointer authentication code, where the pointer authentication
// code is derived using a cryptographic algorithm as a combination of X, Y and the
// APIBKey_EL1.

bits(64) <anchor link="impl-aarch64.AddPACIB.2" hover="function: bits(64) AddPACIB(bits(64) X, bits(64) Y)">AddPACIB</anchor>(bits(64) X, bits(64) Y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APIBKey_EL1;

    APIBKey_EL1 = APIBKeyHi_EL1&lt;63:0&gt; : APIBKeyLo_EL1&lt;63:0&gt;;
    case PSTATE.EL of
        when <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>
            boolean IsEL1Regime = <a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnIB else SCTLR_EL2.EnIB;
            TrapEL2 = (<a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>
            Enable = SCTLR_EL1.EnIB;
            TrapEL2 = <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>
            Enable = SCTLR_EL2.EnIB;
            TrapEL2 = FALSE;
            TrapEL3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>
            Enable = SCTLR_EL3.EnIB;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then <a link="impl-aarch64.TrapPACUse.1" file="shared_pseudocode.xml" hover="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>);
    elsif TrapEL3 then <a link="impl-aarch64.TrapPACUse.1" file="shared_pseudocode.xml" hover="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>);
    else return <a link="impl-aarch64.AddPAC.4" file="shared_pseudocode.xml" hover="function: bits(64) AddPAC(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data)">AddPAC</a>(X, Y, APIBKey_EL1, FALSE);</pstext>
    </ps>
    <ps name="aarch64/functions/pac/auth/AArch64.PACFailException" mylink="aarch64.functions.pac.auth.AArch64.PACFailException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.PACFailException()
// ==========================
// Generates a PAC Fail Exception

<anchor link="AArch64.PACFailException.1" hover="function: AArch64.PACFailException(bits(2) syndrome)">AArch64.PACFailException</anchor>(bits(2) syndrome)
    route_to_el2 = PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1';
    bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_PACFail" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PACFail</a>);
    exception.syndrome&lt;1:0&gt;   = syndrome;
    exception.syndrome&lt;24:2&gt;  = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();                // RES0

    if <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>) then
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif route_to_el2 then
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/functions/pac/auth/Auth" mylink="aarch64.functions.pac.auth.Auth" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Auth()
// ======
// Restores the upper bits of the address to be all zeros or all ones (based on the
// value of bit[55]) and computes and checks the pointer authentication code. If the
// check passes, then the restored address is returned. If the check fails, the
// second-top and third-top bits of the extension bits in the pointer authentication code
// field are corrupted to ensure that accessing the address will give a translation fault.

bits(64) <anchor link="impl-aarch64.Auth.6" hover="function: bits(64) Auth(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data, bit key_number,&#13; boolean is_combined)">Auth</anchor>(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data, bit key_number,
              boolean is_combined)
    bits(64) PAC;
    bits(64) result;
    bits(64) original_ptr;
    bits(2) error_code;
    bits(64) extfield;

    // Reconstruct the extension field used of adding the PAC to the pointer
    boolean tbi = <a link="impl-shared.EffectiveTBI.3" file="shared_pseudocode.xml" hover="function: bit EffectiveTBI(bits(64) address, boolean IsInstr, bits(2) el)">EffectiveTBI</a>(ptr, !data, PSTATE.EL) == '1';
    integer bottom_PAC_bit = <a link="impl-aarch64.CalculateBottomPACBit.1" file="shared_pseudocode.xml" hover="function: integer CalculateBottomPACBit(bit top_bit)">CalculateBottomPACBit</a>(ptr&lt;55&gt;);
    extfield = <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(ptr&lt;55&gt;, 64);

    if tbi then
        original_ptr = ptr&lt;63:56&gt;:extfield&lt;(56-bottom_PAC_bit)-1:0&gt;:ptr&lt;bottom_PAC_bit-1:0&gt;;
    else
        original_ptr = extfield&lt;(64-bottom_PAC_bit)-1:0&gt;:ptr&lt;bottom_PAC_bit-1:0&gt;;

    PAC = <a link="impl-aarch64.ComputePAC.4" file="shared_pseudocode.xml" hover="function: bits(64) ComputePAC(bits(64) data, bits(64) modifier, bits(64) key0, bits(64) key1)">ComputePAC</a>(original_ptr, modifier, K&lt;127:64&gt;, K&lt;63:0&gt;);
    // Check pointer authentication code
    if tbi then
        if !<a link="impl-aarch64.HaveEnhancedPAC2.0" file="shared_pseudocode.xml" hover="function: boolean HaveEnhancedPAC2()">HaveEnhancedPAC2</a>() then
            if PAC&lt;54:bottom_PAC_bit&gt; == ptr&lt;54:bottom_PAC_bit&gt; then
                result = original_ptr;
            else
                error_code = key_number:NOT(key_number);
                result = original_ptr&lt;63:55&gt;:error_code:original_ptr&lt;52:0&gt;;
        else
            result = ptr;
            result&lt;54:bottom_PAC_bit&gt; = result&lt;54:bottom_PAC_bit&gt; EOR PAC&lt;54:bottom_PAC_bit&gt;;
            if <a link="impl-aarch64.HaveFPACCombined.0" file="shared_pseudocode.xml" hover="function: boolean HaveFPACCombined()">HaveFPACCombined</a>() || (<a link="impl-aarch64.HaveFPAC.0" file="shared_pseudocode.xml" hover="function: boolean HaveFPAC()">HaveFPAC</a>() &amp;&amp; !is_combined) then
                if result&lt;54:bottom_PAC_bit&gt; != <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(result&lt;55&gt;, (55-bottom_PAC_bit)) then
                    error_code = (if data then '1' else '0'):key_number;
                    <a link="AArch64.PACFailException.1" file="shared_pseudocode.xml" hover="function: AArch64.PACFailException(bits(2) syndrome)">AArch64.PACFailException</a>(error_code);
    else
        if !<a link="impl-aarch64.HaveEnhancedPAC2.0" file="shared_pseudocode.xml" hover="function: boolean HaveEnhancedPAC2()">HaveEnhancedPAC2</a>() then
            if PAC&lt;54:bottom_PAC_bit&gt; == ptr&lt;54:bottom_PAC_bit&gt; &amp;&amp; PAC&lt;63:56&gt; == ptr&lt;63:56&gt; then
                result = original_ptr;
            else
                error_code = key_number:NOT(key_number);
                result = original_ptr&lt;63&gt;:error_code:original_ptr&lt;60:0&gt;;
        else
            result = ptr;
            result&lt;54:bottom_PAC_bit&gt; = result&lt;54:bottom_PAC_bit&gt; EOR PAC&lt;54:bottom_PAC_bit&gt;;
            result&lt;63:56&gt; = result&lt;63:56&gt; EOR PAC&lt;63:56&gt;;
            if <a link="impl-aarch64.HaveFPACCombined.0" file="shared_pseudocode.xml" hover="function: boolean HaveFPACCombined()">HaveFPACCombined</a>() || (<a link="impl-aarch64.HaveFPAC.0" file="shared_pseudocode.xml" hover="function: boolean HaveFPAC()">HaveFPAC</a>() &amp;&amp; !is_combined) then
                if result&lt;63:bottom_PAC_bit&gt; != <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(result&lt;55&gt;, (64-bottom_PAC_bit)) then
                    error_code = (if data then '1' else '0'):key_number;
                    <a link="AArch64.PACFailException.1" file="shared_pseudocode.xml" hover="function: AArch64.PACFailException(bits(2) syndrome)">AArch64.PACFailException</a>(error_code);
    return result;</pstext>
    </ps>
    <ps name="aarch64/functions/pac/authda/AuthDA" mylink="aarch64.functions.pac.authda.AuthDA" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AuthDA()
// ========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with the extension of the address bits. The instruction checks a pointer
// authentication code in the pointer authentication code field bits of X, using the same
// algorithm and key as AddPACDA().

bits(64) <anchor link="impl-aarch64.AuthDA.3" hover="function: bits(64) AuthDA(bits(64) X, bits(64) Y, boolean is_combined)">AuthDA</anchor>(bits(64) X, bits(64) Y, boolean is_combined)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APDAKey_EL1;

    APDAKey_EL1 = APDAKeyHi_EL1&lt;63:0&gt; : APDAKeyLo_EL1&lt;63:0&gt;;
    case PSTATE.EL of
        when <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>
            boolean IsEL1Regime = <a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnDA else SCTLR_EL2.EnDA;
            TrapEL2 = (<a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>
            Enable = SCTLR_EL1.EnDA;
            TrapEL2 = <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>
            Enable = SCTLR_EL2.EnDA;
            TrapEL2 = FALSE;
            TrapEL3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>
            Enable = SCTLR_EL3.EnDA;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then <a link="impl-aarch64.TrapPACUse.1" file="shared_pseudocode.xml" hover="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>);
    elsif TrapEL3 then <a link="impl-aarch64.TrapPACUse.1" file="shared_pseudocode.xml" hover="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>);
    else  return <a link="impl-aarch64.Auth.6" file="shared_pseudocode.xml" hover="function: bits(64) Auth(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data, bit key_number,&#13; boolean is_combined)">Auth</a>(X, Y, APDAKey_EL1, TRUE, '0', is_combined);</pstext>
    </ps>
    <ps name="aarch64/functions/pac/authdb/AuthDB" mylink="aarch64.functions.pac.authdb.AuthDB" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AuthDB()
// ========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with the extension of the address bits. The instruction checks a
// pointer authentication code in the pointer authentication code field bits of X, using
// the same algorithm and key as AddPACDB().

bits(64) <anchor link="impl-aarch64.AuthDB.3" hover="function: bits(64) AuthDB(bits(64) X, bits(64) Y, boolean is_combined)">AuthDB</anchor>(bits(64) X, bits(64) Y, boolean is_combined)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APDBKey_EL1;

    APDBKey_EL1 = APDBKeyHi_EL1&lt;63:0&gt; : APDBKeyLo_EL1&lt;63:0&gt;;
    case PSTATE.EL of
        when <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>
            boolean IsEL1Regime = <a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnDB else SCTLR_EL2.EnDB;
            TrapEL2 = (<a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                        (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>
            Enable = SCTLR_EL1.EnDB;
            TrapEL2 = <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>
            Enable = SCTLR_EL2.EnDB;
            TrapEL2 = FALSE;
            TrapEL3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>
            Enable = SCTLR_EL3.EnDB;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then <a link="impl-aarch64.TrapPACUse.1" file="shared_pseudocode.xml" hover="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>);
    elsif TrapEL3 then <a link="impl-aarch64.TrapPACUse.1" file="shared_pseudocode.xml" hover="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>);
    else  return <a link="impl-aarch64.Auth.6" file="shared_pseudocode.xml" hover="function: bits(64) Auth(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data, bit key_number,&#13; boolean is_combined)">Auth</a>(X, Y, APDBKey_EL1, TRUE, '1', is_combined);</pstext>
    </ps>
    <ps name="aarch64/functions/pac/authia/AuthIA" mylink="aarch64.functions.pac.authia.AuthIA" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AuthIA()
// ========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with the extension of the address bits. The instruction checks a pointer
// authentication code in the pointer authentication code field bits of X, using the same
// algorithm and key as AddPACIA().

bits(64) <anchor link="impl-aarch64.AuthIA.3" hover="function: bits(64) AuthIA(bits(64) X, bits(64) Y, boolean is_combined)">AuthIA</anchor>(bits(64) X, bits(64) Y, boolean is_combined)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APIAKey_EL1;

    APIAKey_EL1 = APIAKeyHi_EL1&lt;63:0&gt; : APIAKeyLo_EL1&lt;63:0&gt;;
    case PSTATE.EL of
        when <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>
            boolean IsEL1Regime = <a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnIA else SCTLR_EL2.EnIA;
            TrapEL2 = (<a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>
            Enable = SCTLR_EL1.EnIA;
            TrapEL2 = <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>
            Enable = SCTLR_EL2.EnIA;
            TrapEL2 = FALSE;
            TrapEL3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>
            Enable = SCTLR_EL3.EnIA;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then <a link="impl-aarch64.TrapPACUse.1" file="shared_pseudocode.xml" hover="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>);
    elsif TrapEL3 then <a link="impl-aarch64.TrapPACUse.1" file="shared_pseudocode.xml" hover="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>);
    else  return <a link="impl-aarch64.Auth.6" file="shared_pseudocode.xml" hover="function: bits(64) Auth(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data, bit key_number,&#13; boolean is_combined)">Auth</a>(X, Y, APIAKey_EL1, FALSE, '0', is_combined);</pstext>
    </ps>
    <ps name="aarch64/functions/pac/authib/AuthIB" mylink="aarch64.functions.pac.authib.AuthIB" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AuthIB()
// ========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with the extension of the address bits. The instruction checks a pointer
// authentication code in the pointer authentication code field bits of X, using the same
// algorithm and key as AddPACIB().

bits(64) <anchor link="impl-aarch64.AuthIB.3" hover="function: bits(64) AuthIB(bits(64) X, bits(64) Y, boolean is_combined)">AuthIB</anchor>(bits(64) X, bits(64) Y, boolean is_combined)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APIBKey_EL1;

    APIBKey_EL1 = APIBKeyHi_EL1&lt;63:0&gt; : APIBKeyLo_EL1&lt;63:0&gt;;
    case PSTATE.EL of
        when <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>
            boolean IsEL1Regime = <a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnIB else SCTLR_EL2.EnIB;
            TrapEL2 = (<a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>
            Enable = SCTLR_EL1.EnIB;
            TrapEL2 = <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>
            Enable = SCTLR_EL2.EnIB;
            TrapEL2 = FALSE;
            TrapEL3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>
            Enable = SCTLR_EL3.EnIB;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then <a link="impl-aarch64.TrapPACUse.1" file="shared_pseudocode.xml" hover="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>);
    elsif TrapEL3 then <a link="impl-aarch64.TrapPACUse.1" file="shared_pseudocode.xml" hover="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>);
    else  return <a link="impl-aarch64.Auth.6" file="shared_pseudocode.xml" hover="function: bits(64) Auth(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data, bit key_number,&#13; boolean is_combined)">Auth</a>(X, Y, APIBKey_EL1, FALSE, '1', is_combined);</pstext>
    </ps>
    <ps name="aarch64/functions/pac/calcbottompacbit/CalculateBottomPACBit" mylink="aarch64.functions.pac.calcbottompacbit.CalculateBottomPACBit" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CalculateBottomPACBit()
// =======================

integer <anchor link="impl-aarch64.CalculateBottomPACBit.1" hover="function: integer CalculateBottomPACBit(bit top_bit)">CalculateBottomPACBit</anchor>(bit top_bit)
    integer tsz_field;
    boolean using64k;

    if <a link="impl-aarch64.PtrHasUpperAndLowerAddRanges.0" file="shared_pseudocode.xml" hover="function: boolean PtrHasUpperAndLowerAddRanges()">PtrHasUpperAndLowerAddRanges</a>() then
        assert <a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() IN {<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>, <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>};
        if <a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> then
            // EL1 translation regime registers
            tsz_field = if top_bit == '1' then <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(TCR_EL1.T1SZ) else <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(TCR_EL1.T0SZ);
            using64k = if top_bit == '1' then TCR_EL1.TG1 == '11' else TCR_EL1.TG0 == '01';
        else
            // EL2 translation regime registers
            assert <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>);
            tsz_field = if top_bit == '1' then <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(TCR_EL2.T1SZ) else <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(TCR_EL2.T0SZ);
            using64k = if top_bit == '1' then TCR_EL2.TG1 == '11' else TCR_EL2.TG0 == '01';
    else
        tsz_field = if PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(TCR_EL2.T0SZ) else <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(TCR_EL3.T0SZ);
        using64k = if PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then TCR_EL2.TG0 == '01' else TCR_EL3.TG0 == '01';

    max_limit_tsz_field = (if !<a link="impl-shared.HaveSmallTranslationTableExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveSmallTranslationTableExt()">HaveSmallTranslationTableExt</a>() then 39 else if using64k then 47 else 48);
    if tsz_field &gt; max_limit_tsz_field then
        // TCR_ELx.TySZ is out of range
        c = <a link="impl-shared.ConstrainUnpredictable.1" file="shared_pseudocode.xml" hover="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a link="Unpredictable_RESTnSZ" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESTnSZ</a>);
        assert c IN {<a link="Constraint_FORCE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FORCE</a>, <a link="Constraint_NONE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>};
        if c == <a link="Constraint_FORCE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FORCE</a> then tsz_field = max_limit_tsz_field;
    tszmin = if using64k &amp;&amp; <a link="AArch64.VAMax.0" file="shared_pseudocode.xml" hover="function: integer AArch64.VAMax()">AArch64.VAMax</a>() == 52 then 12 else 16;
    if tsz_field &lt; tszmin then
        c = <a link="impl-shared.ConstrainUnpredictable.1" file="shared_pseudocode.xml" hover="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a link="Unpredictable_RESTnSZ" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESTnSZ</a>);
        assert c IN {<a link="Constraint_FORCE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FORCE</a>, <a link="Constraint_NONE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>};
        if c == <a link="Constraint_FORCE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FORCE</a> then tsz_field = tszmin;
    return (64-tsz_field);</pstext>
    </ps>
    <ps name="aarch64/functions/pac/computepac/ComputePAC" mylink="aarch64.functions.pac.computepac.ComputePAC" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ComputePAC()
// ============

bits(64) <anchor link="impl-aarch64.ComputePAC.4" hover="function: bits(64) ComputePAC(bits(64) data, bits(64) modifier, bits(64) key0, bits(64) key1)">ComputePAC</anchor>(bits(64) data, bits(64) modifier, bits(64) key0, bits(64) key1)
    bits(64)  workingval;
    bits(64)  runningmod;
    bits(64)  roundkey;
    bits(64)  modk0;
    constant bits(64) Alpha = 0xC0AC29B7C97C50DD&lt;63:0&gt;;

    integer iterations;
    if <a link="impl-aarch64.HavePACQARMA3.0" file="shared_pseudocode.xml" hover="function: boolean HavePACQARMA3()">HavePACQARMA3</a>() then
        iterations = 2;
        RC[0] = 0x0000000000000000&lt;63:0&gt;;
        RC[1] = 0x13198A2E03707344&lt;63:0&gt;;
        RC[2] = 0xA4093822299F31D0&lt;63:0&gt;;
    else
        iterations = 4;
        RC[0] = 0x0000000000000000&lt;63:0&gt;;
        RC[1] = 0x13198A2E03707344&lt;63:0&gt;;
        RC[2] = 0xA4093822299F31D0&lt;63:0&gt;;
        RC[3] = 0x082EFA98EC4E6C89&lt;63:0&gt;;
        RC[4] = 0x452821E638D01377&lt;63:0&gt;;

    modk0 = key0&lt;0&gt;:key0&lt;63:2&gt;:(key0&lt;63&gt; EOR key0&lt;1&gt;);
    runningmod = modifier;
    workingval = data EOR key0;
    for i = 0 to iterations
        roundkey = key1 EOR runningmod;
        workingval  = workingval EOR roundkey;
        workingval = workingval EOR RC[i];
        if i &gt; 0 then
            workingval = <a link="impl-aarch64.PACCellShuffle.1" file="shared_pseudocode.xml" hover="function: bits(64) PACCellShuffle(bits(64) indata)">PACCellShuffle</a>(workingval);
            workingval = <a link="impl-aarch64.PACMult.1" file="shared_pseudocode.xml" hover="function: bits(64) PACMult(bits(64) Sinput)">PACMult</a>(workingval);
        if <a link="impl-aarch64.HavePACQARMA3.0" file="shared_pseudocode.xml" hover="function: boolean HavePACQARMA3()">HavePACQARMA3</a>() then
            workingval = <a link="impl-aarch64.PACSub1.1" file="shared_pseudocode.xml" hover="function: bits(64) PACSub1(bits(64) Tinput)">PACSub1</a>(workingval);
        else
            workingval = <a link="impl-aarch64.PACSub.1" file="shared_pseudocode.xml" hover="function: bits(64) PACSub(bits(64) Tinput)">PACSub</a>(workingval);
        runningmod = <a link="impl-aarch64.TweakShuffle.1" file="shared_pseudocode.xml" hover="function: bits(64) TweakShuffle(bits(64) indata)">TweakShuffle</a>(runningmod&lt;63:0&gt;);
    roundkey = modk0 EOR runningmod;
    workingval = workingval EOR roundkey;
    workingval = <a link="impl-aarch64.PACCellShuffle.1" file="shared_pseudocode.xml" hover="function: bits(64) PACCellShuffle(bits(64) indata)">PACCellShuffle</a>(workingval);
    workingval = <a link="impl-aarch64.PACMult.1" file="shared_pseudocode.xml" hover="function: bits(64) PACMult(bits(64) Sinput)">PACMult</a>(workingval);
    if <a link="impl-aarch64.HavePACQARMA3.0" file="shared_pseudocode.xml" hover="function: boolean HavePACQARMA3()">HavePACQARMA3</a>() then
        workingval = <a link="impl-aarch64.PACSub1.1" file="shared_pseudocode.xml" hover="function: bits(64) PACSub1(bits(64) Tinput)">PACSub1</a>(workingval);
    else
        workingval = <a link="impl-aarch64.PACSub.1" file="shared_pseudocode.xml" hover="function: bits(64) PACSub(bits(64) Tinput)">PACSub</a>(workingval);
    workingval = <a link="impl-aarch64.PACCellShuffle.1" file="shared_pseudocode.xml" hover="function: bits(64) PACCellShuffle(bits(64) indata)">PACCellShuffle</a>(workingval);
    workingval = <a link="impl-aarch64.PACMult.1" file="shared_pseudocode.xml" hover="function: bits(64) PACMult(bits(64) Sinput)">PACMult</a>(workingval);
    workingval = key1 EOR workingval;
    workingval = <a link="impl-aarch64.PACCellInvShuffle.1" file="shared_pseudocode.xml" hover="function: bits(64) PACCellInvShuffle(bits(64) indata)">PACCellInvShuffle</a>(workingval);
    if <a link="impl-aarch64.HavePACQARMA3.0" file="shared_pseudocode.xml" hover="function: boolean HavePACQARMA3()">HavePACQARMA3</a>() then
        workingval = <a link="impl-aarch64.PACSub1.1" file="shared_pseudocode.xml" hover="function: bits(64) PACSub1(bits(64) Tinput)">PACSub1</a>(workingval);
    else
        workingval = <a link="impl-aarch64.PACInvSub.1" file="shared_pseudocode.xml" hover="function: bits(64) PACInvSub(bits(64) Tinput)">PACInvSub</a>(workingval);
    workingval = <a link="impl-aarch64.PACMult.1" file="shared_pseudocode.xml" hover="function: bits(64) PACMult(bits(64) Sinput)">PACMult</a>(workingval);
    workingval = <a link="impl-aarch64.PACCellInvShuffle.1" file="shared_pseudocode.xml" hover="function: bits(64) PACCellInvShuffle(bits(64) indata)">PACCellInvShuffle</a>(workingval);
    workingval = workingval EOR key0;
    workingval = workingval EOR runningmod;
    for i = 0 to iterations
        if <a link="impl-aarch64.HavePACQARMA3.0" file="shared_pseudocode.xml" hover="function: boolean HavePACQARMA3()">HavePACQARMA3</a>() then
            workingval = <a link="impl-aarch64.PACSub1.1" file="shared_pseudocode.xml" hover="function: bits(64) PACSub1(bits(64) Tinput)">PACSub1</a>(workingval);
        else
            workingval = <a link="impl-aarch64.PACInvSub.1" file="shared_pseudocode.xml" hover="function: bits(64) PACInvSub(bits(64) Tinput)">PACInvSub</a>(workingval);
        if i &lt; iterations then
            workingval = <a link="impl-aarch64.PACMult.1" file="shared_pseudocode.xml" hover="function: bits(64) PACMult(bits(64) Sinput)">PACMult</a>(workingval);
            workingval = <a link="impl-aarch64.PACCellInvShuffle.1" file="shared_pseudocode.xml" hover="function: bits(64) PACCellInvShuffle(bits(64) indata)">PACCellInvShuffle</a>(workingval);
        runningmod = <a link="impl-aarch64.TweakInvShuffle.1" file="shared_pseudocode.xml" hover="function: bits(64) TweakInvShuffle(bits(64) indata)">TweakInvShuffle</a>(runningmod&lt;63:0&gt;);
        roundkey = key1 EOR runningmod;
        workingval = workingval EOR RC[iterations-i];
        workingval = workingval EOR roundkey;
        workingval = workingval EOR Alpha;
    workingval = workingval EOR modk0;

    return workingval;</pstext>
    </ps>
    <ps name="aarch64/functions/pac/computepac/PACCellInvShuffle" mylink="aarch64.functions.pac.computepac.PACCellInvShuffle" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// PACCellInvShuffle()
// ===================

bits(64) <anchor link="impl-aarch64.PACCellInvShuffle.1" hover="function: bits(64) PACCellInvShuffle(bits(64) indata)">PACCellInvShuffle</anchor>(bits(64) indata)
    bits(64) outdata;
    outdata&lt;3:0&gt; = indata&lt;15:12&gt;;
    outdata&lt;7:4&gt; = indata&lt;27:24&gt;;
    outdata&lt;11:8&gt; = indata&lt;51:48&gt;;
    outdata&lt;15:12&gt; = indata&lt;39:36&gt;;
    outdata&lt;19:16&gt; = indata&lt;59:56&gt;;
    outdata&lt;23:20&gt; = indata&lt;47:44&gt;;
    outdata&lt;27:24&gt; = indata&lt;7:4&gt;;
    outdata&lt;31:28&gt; = indata&lt;19:16&gt;;
    outdata&lt;35:32&gt; = indata&lt;35:32&gt;;
    outdata&lt;39:36&gt; = indata&lt;55:52&gt;;
    outdata&lt;43:40&gt; = indata&lt;31:28&gt;;
    outdata&lt;47:44&gt; = indata&lt;11:8&gt;;
    outdata&lt;51:48&gt; = indata&lt;23:20&gt;;
    outdata&lt;55:52&gt; = indata&lt;3:0&gt;;
    outdata&lt;59:56&gt; = indata&lt;43:40&gt;;
    outdata&lt;63:60&gt; = indata&lt;63:60&gt;;
    return outdata;</pstext>
    </ps>
    <ps name="aarch64/functions/pac/computepac/PACCellShuffle" mylink="aarch64.functions.pac.computepac.PACCellShuffle" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// PACCellShuffle()
// ================

bits(64) <anchor link="impl-aarch64.PACCellShuffle.1" hover="function: bits(64) PACCellShuffle(bits(64) indata)">PACCellShuffle</anchor>(bits(64) indata)
    bits(64) outdata;
    outdata&lt;3:0&gt; = indata&lt;55:52&gt;;
    outdata&lt;7:4&gt; = indata&lt;27:24&gt;;
    outdata&lt;11:8&gt; = indata&lt;47:44&gt;;
    outdata&lt;15:12&gt; = indata&lt;3:0&gt;;
    outdata&lt;19:16&gt; = indata&lt;31:28&gt;;
    outdata&lt;23:20&gt; = indata&lt;51:48&gt;;
    outdata&lt;27:24&gt; = indata&lt;7:4&gt;;
    outdata&lt;31:28&gt; = indata&lt;43:40&gt;;
    outdata&lt;35:32&gt; = indata&lt;35:32&gt;;
    outdata&lt;39:36&gt; = indata&lt;15:12&gt;;
    outdata&lt;43:40&gt; = indata&lt;59:56&gt;;
    outdata&lt;47:44&gt; = indata&lt;23:20&gt;;
    outdata&lt;51:48&gt; = indata&lt;11:8&gt;;
    outdata&lt;55:52&gt; = indata&lt;39:36&gt;;
    outdata&lt;59:56&gt; = indata&lt;19:16&gt;;
    outdata&lt;63:60&gt; = indata&lt;63:60&gt;;
    return outdata;</pstext>
    </ps>
    <ps name="aarch64/functions/pac/computepac/PACInvSub" mylink="aarch64.functions.pac.computepac.PACInvSub" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// PACInvSub()
// ===========

bits(64) <anchor link="impl-aarch64.PACInvSub.1" hover="function: bits(64) PACInvSub(bits(64) Tinput)">PACInvSub</anchor>(bits(64) Tinput)
    // This is a 4-bit substitution from the PRINCE-family cipher
    bits(64) Toutput;
    for i = 0 to 15
        case Tinput&lt;4*i+3:4*i&gt; of
            when '0000'  Toutput&lt;4*i+3:4*i&gt; = '0101';
            when '0001'  Toutput&lt;4*i+3:4*i&gt; = '1110';
            when '0010'  Toutput&lt;4*i+3:4*i&gt; = '1101';
            when '0011'  Toutput&lt;4*i+3:4*i&gt; = '1000';
            when '0100'  Toutput&lt;4*i+3:4*i&gt; = '1010';
            when '0101'  Toutput&lt;4*i+3:4*i&gt; = '1011';
            when '0110'  Toutput&lt;4*i+3:4*i&gt; = '0001';
            when '0111'  Toutput&lt;4*i+3:4*i&gt; = '1001';
            when '1000'  Toutput&lt;4*i+3:4*i&gt; = '0010';
            when '1001'  Toutput&lt;4*i+3:4*i&gt; = '0110';
            when '1010'  Toutput&lt;4*i+3:4*i&gt; = '1111';
            when '1011'  Toutput&lt;4*i+3:4*i&gt; = '0000';
            when '1100'  Toutput&lt;4*i+3:4*i&gt; = '0100';
            when '1101'  Toutput&lt;4*i+3:4*i&gt; = '1100';
            when '1110'  Toutput&lt;4*i+3:4*i&gt; = '0111';
            when '1111'  Toutput&lt;4*i+3:4*i&gt; = '0011';
    return Toutput;</pstext>
    </ps>
    <ps name="aarch64/functions/pac/computepac/PACMult" mylink="aarch64.functions.pac.computepac.PACMult" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// PACMult()
// =========

bits(64) <anchor link="impl-aarch64.PACMult.1" hover="function: bits(64) PACMult(bits(64) Sinput)">PACMult</anchor>(bits(64) Sinput)
    bits(4)  t0;
    bits(4)  t1;
    bits(4)  t2;
    bits(4)  t3;
    bits(64) Soutput;

    for i = 0 to 3
        t0&lt;3:0&gt; = <a link="impl-aarch64.RotCell.2" file="shared_pseudocode.xml" hover="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i+8)+3:4*(i+8)&gt;, 1) EOR <a link="impl-aarch64.RotCell.2" file="shared_pseudocode.xml" hover="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i+4)+3:4*(i+4)&gt;, 2);
        t0&lt;3:0&gt; = t0&lt;3:0&gt; EOR <a link="impl-aarch64.RotCell.2" file="shared_pseudocode.xml" hover="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i)+3:4*(i)&gt;, 1);
        t1&lt;3:0&gt; = <a link="impl-aarch64.RotCell.2" file="shared_pseudocode.xml" hover="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i+12)+3:4*(i+12)&gt;, 1) EOR <a link="impl-aarch64.RotCell.2" file="shared_pseudocode.xml" hover="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i+4)+3:4*(i+4)&gt;, 1);
        t1&lt;3:0&gt; = t1&lt;3:0&gt; EOR <a link="impl-aarch64.RotCell.2" file="shared_pseudocode.xml" hover="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i)+3:4*(i)&gt;, 2);
        t2&lt;3:0&gt; = <a link="impl-aarch64.RotCell.2" file="shared_pseudocode.xml" hover="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i+12)+3:4*(i+12)&gt;, 2) EOR <a link="impl-aarch64.RotCell.2" file="shared_pseudocode.xml" hover="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i+8)+3:4*(i+8)&gt;, 1);
        t2&lt;3:0&gt; = t2&lt;3:0&gt; EOR <a link="impl-aarch64.RotCell.2" file="shared_pseudocode.xml" hover="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i)+3:4*(i)&gt;, 1);
        t3&lt;3:0&gt; = <a link="impl-aarch64.RotCell.2" file="shared_pseudocode.xml" hover="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i+12)+3:4*(i+12)&gt;, 1) EOR <a link="impl-aarch64.RotCell.2" file="shared_pseudocode.xml" hover="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i+8)+3:4*(i+8)&gt;, 2);
        t3&lt;3:0&gt; = t3&lt;3:0&gt; EOR <a link="impl-aarch64.RotCell.2" file="shared_pseudocode.xml" hover="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i+4)+3:4*(i+4)&gt;, 1);
        Soutput&lt;4*i+3:4*i&gt; = t3&lt;3:0&gt;;
        Soutput&lt;4*(i+4)+3:4*(i+4)&gt; = t2&lt;3:0&gt;;
        Soutput&lt;4*(i+8)+3:4*(i+8)&gt; = t1&lt;3:0&gt;;
        Soutput&lt;4*(i+12)+3:4*(i+12)&gt; = t0&lt;3:0&gt;;
    return Soutput;</pstext>
    </ps>
    <ps name="aarch64/functions/pac/computepac/PACSub" mylink="aarch64.functions.pac.computepac.PACSub" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// PACSub()
// ========

bits(64) <anchor link="impl-aarch64.PACSub.1" hover="function: bits(64) PACSub(bits(64) Tinput)">PACSub</anchor>(bits(64) Tinput)
    // This is a 4-bit substitution from the PRINCE-family cipher
    bits(64) Toutput;
    for i = 0 to 15
        case Tinput&lt;4*i+3:4*i&gt; of
            when '0000'  Toutput&lt;4*i+3:4*i&gt; = '1011';
            when '0001'  Toutput&lt;4*i+3:4*i&gt; = '0110';
            when '0010'  Toutput&lt;4*i+3:4*i&gt; = '1000';
            when '0011'  Toutput&lt;4*i+3:4*i&gt; = '1111';
            when '0100'  Toutput&lt;4*i+3:4*i&gt; = '1100';
            when '0101'  Toutput&lt;4*i+3:4*i&gt; = '0000';
            when '0110'  Toutput&lt;4*i+3:4*i&gt; = '1001';
            when '0111'  Toutput&lt;4*i+3:4*i&gt; = '1110';
            when '1000'  Toutput&lt;4*i+3:4*i&gt; = '0011';
            when '1001'  Toutput&lt;4*i+3:4*i&gt; = '0111';
            when '1010'  Toutput&lt;4*i+3:4*i&gt; = '0100';
            when '1011'  Toutput&lt;4*i+3:4*i&gt; = '0101';
            when '1100'  Toutput&lt;4*i+3:4*i&gt; = '1101';
            when '1101'  Toutput&lt;4*i+3:4*i&gt; = '0010';
            when '1110'  Toutput&lt;4*i+3:4*i&gt; = '0001';
            when '1111'  Toutput&lt;4*i+3:4*i&gt; = '1010';
    return Toutput;</pstext>
    </ps>
    <ps name="aarch64/functions/pac/computepac/PacSub1" mylink="aarch64.functions.pac.computepac.PacSub1" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// PacSub1()
// =========

bits(64) <anchor link="impl-aarch64.PACSub1.1" hover="function: bits(64) PACSub1(bits(64) Tinput)">PACSub1</anchor>(bits(64) Tinput)
    // This is a 4-bit substitution from Qarma sigma1
    bits(64) Toutput;
    for i = 0 to 15
        case Tinput&lt;4*i+3:4*i&gt; of
            when '0000' Toutput&lt;4*i+3:4*i&gt; = '1010';
            when '0001' Toutput&lt;4*i+3:4*i&gt; = '1101';
            when '0010' Toutput&lt;4*i+3:4*i&gt; = '1110';
            when '0011' Toutput&lt;4*i+3:4*i&gt; = '0110';
            when '0100' Toutput&lt;4*i+3:4*i&gt; = '1111';
            when '0101' Toutput&lt;4*i+3:4*i&gt; = '0111';
            when '0110' Toutput&lt;4*i+3:4*i&gt; = '0011';
            when '0111' Toutput&lt;4*i+3:4*i&gt; = '0101';
            when '1000' Toutput&lt;4*i+3:4*i&gt; = '1001';
            when '1001' Toutput&lt;4*i+3:4*i&gt; = '1000';
            when '1010' Toutput&lt;4*i+3:4*i&gt; = '0000';
            when '1011' Toutput&lt;4*i+3:4*i&gt; = '1100';
            when '1100' Toutput&lt;4*i+3:4*i&gt; = '1011';
            when '1101' Toutput&lt;4*i+3:4*i&gt; = '0001';
            when '1110' Toutput&lt;4*i+3:4*i&gt; = '0010';
            when '1111' Toutput&lt;4*i+3:4*i&gt; = '0100';
    return Toutput;</pstext>
    </ps>
    <ps name="aarch64/functions/pac/computepac/RC" mylink="aarch64.functions.pac.computepac.RC" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">array bits(64) RC[0..4];</pstext>
    </ps>
    <ps name="aarch64/functions/pac/computepac/RotCell" mylink="aarch64.functions.pac.computepac.RotCell" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// RotCell()
// =========

bits(4) <anchor link="impl-aarch64.RotCell.2" hover="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</anchor>(bits(4) incell, integer amount)
    bits(8) tmp;
    bits(4) outcell;

    // assert amount&gt;3 || amount&lt;1;
    tmp&lt;7:0&gt; = incell&lt;3:0&gt;:incell&lt;3:0&gt;;
    outcell = tmp&lt;7-amount:4-amount&gt;;
    return outcell;</pstext>
    </ps>
    <ps name="aarch64/functions/pac/computepac/TweakCellInvRot" mylink="aarch64.functions.pac.computepac.TweakCellInvRot" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// TweakCellInvRot()
// =================

bits(4) <anchor link="impl-aarch64.TweakCellInvRot.1" hover="function: bits(4) TweakCellInvRot(bits(4) incell)">TweakCellInvRot</anchor>(bits(4) incell)
    bits(4) outcell;
    outcell&lt;3&gt; = incell&lt;2&gt;;
    outcell&lt;2&gt; = incell&lt;1&gt;;
    outcell&lt;1&gt; = incell&lt;0&gt;;
    outcell&lt;0&gt; = incell&lt;0&gt; EOR incell&lt;3&gt;;
    return outcell;</pstext>
    </ps>
    <ps name="aarch64/functions/pac/computepac/TweakCellRot" mylink="aarch64.functions.pac.computepac.TweakCellRot" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// TweakCellRot()
// ==============

bits(4) <anchor link="impl-aarch64.TweakCellRot.1" hover="function: bits(4) TweakCellRot(bits(4) incell)">TweakCellRot</anchor>(bits(4) incell)
    bits(4) outcell;
    outcell&lt;3&gt; = incell&lt;0&gt; EOR incell&lt;1&gt;;
    outcell&lt;2&gt; = incell&lt;3&gt;;
    outcell&lt;1&gt; = incell&lt;2&gt;;
    outcell&lt;0&gt; = incell&lt;1&gt;;
    return outcell;</pstext>
    </ps>
    <ps name="aarch64/functions/pac/computepac/TweakInvShuffle" mylink="aarch64.functions.pac.computepac.TweakInvShuffle" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// TweakInvShuffle()
// =================

bits(64) <anchor link="impl-aarch64.TweakInvShuffle.1" hover="function: bits(64) TweakInvShuffle(bits(64) indata)">TweakInvShuffle</anchor>(bits(64) indata)
    bits(64) outdata;
    outdata&lt;3:0&gt; = <a link="impl-aarch64.TweakCellInvRot.1" file="shared_pseudocode.xml" hover="function: bits(4) TweakCellInvRot(bits(4) incell)">TweakCellInvRot</a>(indata&lt;51:48&gt;);
    outdata&lt;7:4&gt; = indata&lt;55:52&gt;;
    outdata&lt;11:8&gt; = indata&lt;23:20&gt;;
    outdata&lt;15:12&gt; = indata&lt;27:24&gt;;
    outdata&lt;19:16&gt; = indata&lt;3:0&gt;;
    outdata&lt;23:20&gt; = indata&lt;7:4&gt;;
    outdata&lt;27:24&gt; = <a link="impl-aarch64.TweakCellInvRot.1" file="shared_pseudocode.xml" hover="function: bits(4) TweakCellInvRot(bits(4) incell)">TweakCellInvRot</a>(indata&lt;11:8&gt;);
    outdata&lt;31:28&gt; = indata&lt;15:12&gt;;
    outdata&lt;35:32&gt; = <a link="impl-aarch64.TweakCellInvRot.1" file="shared_pseudocode.xml" hover="function: bits(4) TweakCellInvRot(bits(4) incell)">TweakCellInvRot</a>(indata&lt;31:28&gt;);
    outdata&lt;39:36&gt; = <a link="impl-aarch64.TweakCellInvRot.1" file="shared_pseudocode.xml" hover="function: bits(4) TweakCellInvRot(bits(4) incell)">TweakCellInvRot</a>(indata&lt;63:60&gt;);
    outdata&lt;43:40&gt; = <a link="impl-aarch64.TweakCellInvRot.1" file="shared_pseudocode.xml" hover="function: bits(4) TweakCellInvRot(bits(4) incell)">TweakCellInvRot</a>(indata&lt;59:56&gt;);
    outdata&lt;47:44&gt; = <a link="impl-aarch64.TweakCellInvRot.1" file="shared_pseudocode.xml" hover="function: bits(4) TweakCellInvRot(bits(4) incell)">TweakCellInvRot</a>(indata&lt;19:16&gt;);
    outdata&lt;51:48&gt; = indata&lt;35:32&gt;;
    outdata&lt;55:52&gt; = indata&lt;39:36&gt;;
    outdata&lt;59:56&gt; = indata&lt;43:40&gt;;
    outdata&lt;63:60&gt; = <a link="impl-aarch64.TweakCellInvRot.1" file="shared_pseudocode.xml" hover="function: bits(4) TweakCellInvRot(bits(4) incell)">TweakCellInvRot</a>(indata&lt;47:44&gt;);
    return outdata;</pstext>
    </ps>
    <ps name="aarch64/functions/pac/computepac/TweakShuffle" mylink="aarch64.functions.pac.computepac.TweakShuffle" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// TweakShuffle()
// ==============

bits(64) <anchor link="impl-aarch64.TweakShuffle.1" hover="function: bits(64) TweakShuffle(bits(64) indata)">TweakShuffle</anchor>(bits(64) indata)
    bits(64) outdata;
    outdata&lt;3:0&gt; = indata&lt;19:16&gt;;
    outdata&lt;7:4&gt; = indata&lt;23:20&gt;;
    outdata&lt;11:8&gt; = <a link="impl-aarch64.TweakCellRot.1" file="shared_pseudocode.xml" hover="function: bits(4) TweakCellRot(bits(4) incell)">TweakCellRot</a>(indata&lt;27:24&gt;);
    outdata&lt;15:12&gt; = indata&lt;31:28&gt;;
    outdata&lt;19:16&gt; = <a link="impl-aarch64.TweakCellRot.1" file="shared_pseudocode.xml" hover="function: bits(4) TweakCellRot(bits(4) incell)">TweakCellRot</a>(indata&lt;47:44&gt;);
    outdata&lt;23:20&gt; = indata&lt;11:8&gt;;
    outdata&lt;27:24&gt; = indata&lt;15:12&gt;;
    outdata&lt;31:28&gt; = <a link="impl-aarch64.TweakCellRot.1" file="shared_pseudocode.xml" hover="function: bits(4) TweakCellRot(bits(4) incell)">TweakCellRot</a>(indata&lt;35:32&gt;);
    outdata&lt;35:32&gt; = indata&lt;51:48&gt;;
    outdata&lt;39:36&gt; = indata&lt;55:52&gt;;
    outdata&lt;43:40&gt; = indata&lt;59:56&gt;;
    outdata&lt;47:44&gt; = <a link="impl-aarch64.TweakCellRot.1" file="shared_pseudocode.xml" hover="function: bits(4) TweakCellRot(bits(4) incell)">TweakCellRot</a>(indata&lt;63:60&gt;);
    outdata&lt;51:48&gt; = <a link="impl-aarch64.TweakCellRot.1" file="shared_pseudocode.xml" hover="function: bits(4) TweakCellRot(bits(4) incell)">TweakCellRot</a>(indata&lt;3:0&gt;);
    outdata&lt;55:52&gt; = indata&lt;7:4&gt;;
    outdata&lt;59:56&gt; = <a link="impl-aarch64.TweakCellRot.1" file="shared_pseudocode.xml" hover="function: bits(4) TweakCellRot(bits(4) incell)">TweakCellRot</a>(indata&lt;43:40&gt;);
    outdata&lt;63:60&gt; = <a link="impl-aarch64.TweakCellRot.1" file="shared_pseudocode.xml" hover="function: bits(4) TweakCellRot(bits(4) incell)">TweakCellRot</a>(indata&lt;39:36&gt;);
    return outdata;</pstext>
    </ps>
    <ps name="aarch64/functions/pac/pac/ConstPACField" mylink="aarch64.functions.pac.pac.ConstPACField" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ConstPACField()
// ===============
// Returns TRUE if bit&lt;55&gt; can be used to determine the size of the PAC field, FALSE otherwise.

boolean <anchor link="impl-aarch64.ConstPACField.0" hover="function: boolean ConstPACField()">ConstPACField</anchor>()
    return boolean IMPLEMENTATION_DEFINED "Bit 55 determines the size of the PAC field";</pstext>
    </ps>
    <ps name="aarch64/functions/pac/pac/HaveEnhancedPAC" mylink="aarch64.functions.pac.pac.HaveEnhancedPAC" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveEnhancedPAC()
// =================
// Returns TRUE if support for EnhancedPAC is implemented, FALSE otherwise.

boolean <anchor link="impl-aarch64.HaveEnhancedPAC.0" hover="function: boolean HaveEnhancedPAC()">HaveEnhancedPAC</anchor>()
    return ( <a link="impl-aarch64.HavePACExt.0" file="shared_pseudocode.xml" hover="function: boolean HavePACExt()">HavePACExt</a>()
        &amp;&amp; boolean IMPLEMENTATION_DEFINED "Has enhanced PAC functionality" );</pstext>
    </ps>
    <ps name="aarch64/functions/pac/pac/HaveEnhancedPAC2" mylink="aarch64.functions.pac.pac.HaveEnhancedPAC2" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveEnhancedPAC2()
// ==================
// Returns TRUE if support for EnhancedPAC2 is implemented, FALSE otherwise.

boolean <anchor link="impl-aarch64.HaveEnhancedPAC2.0" hover="function: boolean HaveEnhancedPAC2()">HaveEnhancedPAC2</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p6" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p6</a>) || (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p3" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p3</a>) &amp;&amp; boolean IMPLEMENTATION_DEFINED "Has enhanced PAC 2 functionality");</pstext>
    </ps>
    <ps name="aarch64/functions/pac/pac/HaveFPAC" mylink="aarch64.functions.pac.pac.HaveFPAC" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveFPAC()
// ==========
// Returns TRUE if support for FPAC is implemented, FALSE otherwise.

boolean <anchor link="impl-aarch64.HaveFPAC.0" hover="function: boolean HaveFPAC()">HaveFPAC</anchor>()
    return <a link="impl-aarch64.HaveEnhancedPAC2.0" file="shared_pseudocode.xml" hover="function: boolean HaveEnhancedPAC2()">HaveEnhancedPAC2</a>() &amp;&amp; boolean IMPLEMENTATION_DEFINED "Has FPAC functionality";</pstext>
    </ps>
    <ps name="aarch64/functions/pac/pac/HaveFPACCombined" mylink="aarch64.functions.pac.pac.HaveFPACCombined" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveFPACCombined()
// ==================
// Returns TRUE if support for FPACCombined is implemented, FALSE otherwise.

boolean <anchor link="impl-aarch64.HaveFPACCombined.0" hover="function: boolean HaveFPACCombined()">HaveFPACCombined</anchor>()
    return <a link="impl-aarch64.HaveFPAC.0" file="shared_pseudocode.xml" hover="function: boolean HaveFPAC()">HaveFPAC</a>() &amp;&amp; boolean IMPLEMENTATION_DEFINED "Has FPAC Combined functionality";</pstext>
    </ps>
    <ps name="aarch64/functions/pac/pac/HavePACExt" mylink="aarch64.functions.pac.pac.HavePACExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HavePACExt()
// ============
// Returns TRUE if support for the PAC extension is implemented, FALSE otherwise.

boolean <anchor link="impl-aarch64.HavePACExt.0" hover="function: boolean HavePACExt()">HavePACExt</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p3" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p3</a>);</pstext>
    </ps>
    <ps name="aarch64/functions/pac/pac/HavePACIMP" mylink="aarch64.functions.pac.pac.HavePACIMP" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HavePACIMP()
// ============
// Returns TRUE if support for PAC IMP is implemented, FALSE otherwise.

boolean <anchor link="impl-aarch64.HavePACIMP.0" hover="function: boolean HavePACIMP()">HavePACIMP</anchor>()
    return <a link="impl-aarch64.HavePACExt.0" file="shared_pseudocode.xml" hover="function: boolean HavePACExt()">HavePACExt</a>() &amp;&amp; boolean IMPLEMENTATION_DEFINED "Has PAC IMP functionality";</pstext>
    </ps>
    <ps name="aarch64/functions/pac/pac/HavePACQARMA3" mylink="aarch64.functions.pac.pac.HavePACQARMA3" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HavePACQARMA3()
// ===============
// Returns TRUE if support for PAC QARMA3 is implemented, FALSE otherwise.

boolean <anchor link="impl-aarch64.HavePACQARMA3.0" hover="function: boolean HavePACQARMA3()">HavePACQARMA3</anchor>()
    return <a link="impl-aarch64.HavePACExt.0" file="shared_pseudocode.xml" hover="function: boolean HavePACExt()">HavePACExt</a>() &amp;&amp; boolean IMPLEMENTATION_DEFINED "Has PAC QARMA3 functionality";</pstext>
    </ps>
    <ps name="aarch64/functions/pac/pac/HavePACQARMA5" mylink="aarch64.functions.pac.pac.HavePACQARMA5" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HavePACQARMA5()
// ===============
// Returns TRUE if support for PAC QARMA5 is implemented, FALSE otherwise.

boolean <anchor link="impl-aarch64.HavePACQARMA5.0" hover="function: boolean HavePACQARMA5()">HavePACQARMA5</anchor>()
    return <a link="impl-aarch64.HavePACExt.0" file="shared_pseudocode.xml" hover="function: boolean HavePACExt()">HavePACExt</a>() &amp;&amp; boolean IMPLEMENTATION_DEFINED "Has PAC QARMA5 functionality";</pstext>
    </ps>
    <ps name="aarch64/functions/pac/pac/PtrHasUpperAndLowerAddRanges" mylink="aarch64.functions.pac.pac.PtrHasUpperAndLowerAddRanges" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// PtrHasUpperAndLowerAddRanges()
// ==============================
// Returns TRUE if the pointer has upper and lower address ranges, FALSE otherwise.

boolean <anchor link="impl-aarch64.PtrHasUpperAndLowerAddRanges.0" hover="function: boolean PtrHasUpperAndLowerAddRanges()">PtrHasUpperAndLowerAddRanges</anchor>()
    regime = <a link="impl-shared.TranslationRegime.2" file="shared_pseudocode.xml" hover="function: Regime TranslationRegime(bits(2) el, AccType acctype)">TranslationRegime</a>(PSTATE.EL, <a link="AccType_NORMAL" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NORMAL</a>);
    return <a link="impl-shared.HasUnprivileged.1" file="shared_pseudocode.xml" hover="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime);</pstext>
    </ps>
    <ps name="aarch64/functions/pac/strip/Strip" mylink="aarch64.functions.pac.strip.Strip" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Strip()
// =======
// Strip() returns a 64-bit value containing A, but replacing the pointer authentication
// code field bits with the extension of the address bits. This can apply to either
// instructions or data, where, as the use of tagged pointers is distinct, it might be
// handled differently.

bits(64) <anchor link="impl-aarch64.Strip.2" hover="function: bits(64) Strip(bits(64) A, boolean data)">Strip</anchor>(bits(64) A, boolean data)
    bits(64) original_ptr;
    bits(64) extfield;
    boolean tbi = <a link="impl-shared.EffectiveTBI.3" file="shared_pseudocode.xml" hover="function: bit EffectiveTBI(bits(64) address, boolean IsInstr, bits(2) el)">EffectiveTBI</a>(A, !data, PSTATE.EL) == '1';
    integer bottom_PAC_bit = <a link="impl-aarch64.CalculateBottomPACBit.1" file="shared_pseudocode.xml" hover="function: integer CalculateBottomPACBit(bit top_bit)">CalculateBottomPACBit</a>(A&lt;55&gt;);
    extfield = <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(A&lt;55&gt;, 64);

    if tbi then
        original_ptr = A&lt;63:56&gt;:extfield&lt;(56-bottom_PAC_bit)-1:0&gt;:A&lt;bottom_PAC_bit-1:0&gt;;
    else
        original_ptr = extfield&lt;(64-bottom_PAC_bit)-1:0&gt;:A&lt;bottom_PAC_bit-1:0&gt;;

    return original_ptr;</pstext>
    </ps>
    <ps name="aarch64/functions/pac/trappacuse/TrapPACUse" mylink="aarch64.functions.pac.trappacuse.TrapPACUse" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// TrapPACUse()
// ============
// Used for the trapping of the pointer authentication functions by higher exception
// levels.

<anchor link="impl-aarch64.TrapPACUse.1" hover="function: TrapPACUse(bits(2) target_el)">TrapPACUse</anchor>(bits(2) target_el)
    assert <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(target_el) &amp;&amp; target_el !=  <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt;= <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL);

    bits(64) preferred_exception_return = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    <a link="ExceptionRecord" file="shared_pseudocode.xml" hover="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> exception;
    vect_offset = 0;
    exception = <a link="impl-shared.ExceptionSyndrome.1" file="shared_pseudocode.xml" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a link="Exception_PACTrap" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PACTrap</a>);
    <a link="AArch64.TakeException.4" file="shared_pseudocode.xml" hover="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception_in,&#13; bits(64) preferred_exception_return, integer vect_offset_in)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</pstext>
    </ps>
    <ps name="aarch64/functions/ras/AArch64.ESBOperation" mylink="aarch64.functions.ras.AArch64.ESBOperation" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.ESBOperation()
// ======================
// Perform the AArch64 ESB operation, either for ESB executed in AArch64 state, or for
// ESB in AArch32 state when SError interrupts are routed to an Exception level using
// AArch64

<anchor link="AArch64.ESBOperation.0" hover="function: AArch64.ESBOperation()">AArch64.ESBOperation</anchor>()
    boolean mask_active;

    route_to_el3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.EA == '1';
    route_to_el2 = (<a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                    (HCR_EL2.TGE == '1' || HCR_EL2.AMO == '1'));

    target = if route_to_el3 then <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> elsif route_to_el2 then <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> else <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;

    if target == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> then
        mask_active = PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>};
    elsif <a link="impl-shared.HaveVirtHostExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; target == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; == '11' then
        mask_active = PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>};
    else
        mask_active = PSTATE.EL == target;

    mask_set = (PSTATE.A == '1' &amp;&amp; (!<a link="impl-shared.HaveDoubleFaultExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>() || SCR_EL3.EA == '0' ||
                                    PSTATE.EL != <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> || SCR_EL3.NMEA == '0'));
    intdis = <a link="impl-shared.Halted.0" file="shared_pseudocode.xml" hover="function: boolean Halted()">Halted</a>() || <a link="impl-shared.ExternalDebugInterruptsDisabled.1" file="shared_pseudocode.xml" hover="function: boolean ExternalDebugInterruptsDisabled(bits(2) target)">ExternalDebugInterruptsDisabled</a>(target);
    masked = (<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(target) &lt; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL)) || intdis || (mask_active &amp;&amp; mask_set);

    // Check for a masked Physical SError pending that can be synchronized
    // by an Error synchronization event.
    if masked &amp;&amp; <a link="impl-shared.IsSynchronizablePhysicalSErrorPending.0" file="shared_pseudocode.xml" hover="function: boolean IsSynchronizablePhysicalSErrorPending()">IsSynchronizablePhysicalSErrorPending</a>() then
        // This function might be called for an interworking case, and INTdis is masking
        // the SError interrupt.
        if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>()) then
            syndrome32 = <a link="AArch32.PhysicalSErrorSyndrome.0" file="shared_pseudocode.xml" hover="function: AArch32.SErrorSyndrome AArch32.PhysicalSErrorSyndrome()">AArch32.PhysicalSErrorSyndrome</a>();
            DISR = <a link="AArch32.ReportDeferredSError.2" file="shared_pseudocode.xml" hover="function: bits(32) AArch32.ReportDeferredSError(bits(2) AET, bit ExT)">AArch32.ReportDeferredSError</a>(syndrome32.AET, syndrome32.ExT);
        else
            implicit_esb = FALSE;
            syndrome64 = <a link="AArch64.PhysicalSErrorSyndrome.1" file="shared_pseudocode.xml" hover="function: bits(25) AArch64.PhysicalSErrorSyndrome(boolean implicit_esb)">AArch64.PhysicalSErrorSyndrome</a>(implicit_esb);
            DISR_EL1 = <a link="AArch64.ReportDeferredSError.1" file="shared_pseudocode.xml" hover="function: bits(64) AArch64.ReportDeferredSError(bits(25) syndrome)">AArch64.ReportDeferredSError</a>(syndrome64);
        <a link="impl-shared.ClearPendingPhysicalSError.0" file="shared_pseudocode.xml" hover="function: ClearPendingPhysicalSError()">ClearPendingPhysicalSError</a>();               // Set ISR_EL1.A to 0

    return;</pstext>
    </ps>
    <ps name="aarch64/functions/ras/AArch64.PhysicalSErrorSyndrome" mylink="aarch64.functions.ras.AArch64.PhysicalSErrorSyndrome" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Return the SError syndrome
bits(25) <anchor link="AArch64.PhysicalSErrorSyndrome.1" hover="function: bits(25) AArch64.PhysicalSErrorSyndrome(boolean implicit_esb)">AArch64.PhysicalSErrorSyndrome</anchor>(boolean implicit_esb);</pstext>
    </ps>
    <ps name="aarch64/functions/ras/AArch64.ReportDeferredSError" mylink="aarch64.functions.ras.AArch64.ReportDeferredSError" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.ReportDeferredSError()
// ==============================
// Generate deferred SError syndrome

bits(64) <anchor link="AArch64.ReportDeferredSError.1" hover="function: bits(64) AArch64.ReportDeferredSError(bits(25) syndrome)">AArch64.ReportDeferredSError</anchor>(bits(25) syndrome)
    bits(64) target;
    target&lt;31&gt;   = '1';              // A
    target&lt;24&gt;   = syndrome&lt;24&gt;;     // IDS
    target&lt;23:0&gt; = syndrome&lt;23:0&gt;;   // ISS
    return target;</pstext>
    </ps>
    <ps name="aarch64/functions/ras/AArch64.vESBOperation" mylink="aarch64.functions.ras.AArch64.vESBOperation" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.vESBOperation()
// =======================
// Perform the AArch64 ESB operation for virtual SError interrupts, either for ESB
// executed in AArch64 state, or for ESB in AArch32 state with EL2 using AArch64 state

<anchor link="AArch64.vESBOperation.0" hover="function: AArch64.vESBOperation()">AArch64.vESBOperation</anchor>()
    assert PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>();

    // If physical SError interrupts are routed to EL2, and TGE is not set, then a virtual
    // SError interrupt might be pending
    vSEI_enabled = HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.AMO == '1';
    vSEI_pending = vSEI_enabled &amp;&amp; HCR_EL2.VSE == '1';
    vintdis      = <a link="impl-shared.Halted.0" file="shared_pseudocode.xml" hover="function: boolean Halted()">Halted</a>() || <a link="impl-shared.ExternalDebugInterruptsDisabled.1" file="shared_pseudocode.xml" hover="function: boolean ExternalDebugInterruptsDisabled(bits(2) target)">ExternalDebugInterruptsDisabled</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>);
    vmasked      = vintdis || PSTATE.A == '1';

    // Check for a masked virtual SError pending
    if vSEI_pending &amp;&amp; vmasked then
        // This function might be called for the interworking case, and INTdis is masking
        // the virtual SError interrupt.
        if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then
            VDISR = <a link="AArch32.ReportDeferredSError.2" file="shared_pseudocode.xml" hover="function: bits(32) AArch32.ReportDeferredSError(bits(2) AET, bit ExT)">AArch32.ReportDeferredSError</a>(VDFSR&lt;15:14&gt;, VDFSR&lt;12&gt;);
        else
            VDISR_EL2 = <a link="AArch64.ReportDeferredSError.1" file="shared_pseudocode.xml" hover="function: bits(64) AArch64.ReportDeferredSError(bits(25) syndrome)">AArch64.ReportDeferredSError</a>(VSESR_EL2&lt;24:0&gt;);
        HCR_EL2.VSE = '0';                       // Clear pending virtual SError

    return;</pstext>
    </ps>
    <ps name="aarch64/functions/registers/AArch64.MaybeZeroRegisterUppers" mylink="aarch64.functions.registers.AArch64.MaybeZeroRegisterUppers" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.MaybeZeroRegisterUppers()
// =================================
// On taking an exception to  AArch64 from AArch32, it is CONSTRAINED UNPREDICTABLE whether the top
// 32 bits of registers visible at any lower Exception level using AArch32 are set to zero.

<anchor link="AArch64.MaybeZeroRegisterUppers.0" hover="function: AArch64.MaybeZeroRegisterUppers()">AArch64.MaybeZeroRegisterUppers</anchor>()
    assert <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>();         // Always called from AArch32 state before entering AArch64 state

    integer first;
    integer last;
    boolean include_R15;
    if PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then
        first = 0;  last = 14;  include_R15 = FALSE;
    elsif PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
        first = 0;  last = 30;  include_R15 = FALSE;
    else
        first = 0;  last = 30;  include_R15 = TRUE;

    for n = first to last
        if (n != 15 || include_R15) &amp;&amp; <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_ZEROUPPER" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_ZEROUPPER</a>) then
            _R[n]&lt;63:32&gt; = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();

    return;</pstext>
    </ps>
    <ps name="aarch64/functions/registers/AArch64.ResetGeneralRegisters" mylink="aarch64.functions.registers.AArch64.ResetGeneralRegisters" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.ResetGeneralRegisters()
// ===============================

<anchor link="AArch64.ResetGeneralRegisters.0" hover="function: AArch64.ResetGeneralRegisters()">AArch64.ResetGeneralRegisters</anchor>()

    for i = 0 to 30
        <a link="impl-aarch64.X.write.1" file="shared_pseudocode.xml" hover="accessor: X[integer n] = bits(width) value">X</a>[i] = bits(64) UNKNOWN;

    return;</pstext>
    </ps>
    <ps name="aarch64/functions/registers/AArch64.ResetSIMDFPRegisters" mylink="aarch64.functions.registers.AArch64.ResetSIMDFPRegisters" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.ResetSIMDFPRegisters()
// ==============================

<anchor link="AArch64.ResetSIMDFPRegisters.0" hover="function: AArch64.ResetSIMDFPRegisters()">AArch64.ResetSIMDFPRegisters</anchor>()

    for i = 0 to 31
        <a link="impl-aarch64.V.write.1" file="shared_pseudocode.xml" hover="accessor: V[integer n] = bits(width) value">V</a>[i] = bits(128) UNKNOWN;

    return;</pstext>
    </ps>
    <ps name="aarch64/functions/registers/AArch64.ResetSpecialRegisters" mylink="aarch64.functions.registers.AArch64.ResetSpecialRegisters" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.ResetSpecialRegisters()
// ===============================

<anchor link="AArch64.ResetSpecialRegisters.0" hover="function: AArch64.ResetSpecialRegisters()">AArch64.ResetSpecialRegisters</anchor>()

    // AArch64 special registers
    SP_EL0 = bits(64) UNKNOWN;
    SP_EL1 = bits(64) UNKNOWN;
    SPSR_EL1 = bits(64) UNKNOWN;
    ELR_EL1  = bits(64) UNKNOWN;
    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
        SP_EL2 = bits(64) UNKNOWN;
        SPSR_EL2 = bits(64) UNKNOWN;
        ELR_EL2  = bits(64) UNKNOWN;
    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
        SP_EL3 = bits(64) UNKNOWN;
        SPSR_EL3 = bits(64) UNKNOWN;
        ELR_EL3  = bits(64) UNKNOWN;

    // AArch32 special registers that are not architecturally mapped to AArch64 registers
    if <a link="impl-shared.HaveAArch32EL.1" file="shared_pseudocode.xml" hover="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then
        SPSR_fiq&lt;31:0&gt; = bits(32) UNKNOWN;
        SPSR_irq&lt;31:0&gt; = bits(32) UNKNOWN;
        SPSR_abt&lt;31:0&gt; = bits(32) UNKNOWN;
        SPSR_und&lt;31:0&gt; = bits(32) UNKNOWN;

    // External debug special registers
    DLR_EL0 = bits(64) UNKNOWN;
    DSPSR_EL0 = bits(64) UNKNOWN;

    return;</pstext>
    </ps>
    <ps name="aarch64/functions/registers/AArch64.ResetSystemRegisters" mylink="aarch64.functions.registers.AArch64.ResetSystemRegisters" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions"><anchor link="AArch64.ResetSystemRegisters.1" hover="function: AArch64.ResetSystemRegisters(boolean cold_reset)">AArch64.ResetSystemRegisters</anchor>(boolean cold_reset);</pstext>
    </ps>
    <ps name="aarch64/functions/registers/PC" mylink="aarch64.functions.registers.PC" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// PC - non-assignment form
// ========================
// Read program counter.

bits(64) <anchor link="impl-aarch64.PC.read.0" hover="accessor: bits(64) PC[]">PC</anchor>[]
    return _PC;</pstext>
    </ps>
    <ps name="aarch64/functions/registers/SP" mylink="aarch64.functions.registers.SP" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SP[] - assignment form
// ======================
// Write to stack pointer from either a 32-bit or a 64-bit value.

<anchor link="impl-aarch64.SP.write.0" hover="accessor: SP[] = bits(width) value">SP</anchor>[] = bits(width) value
    assert width IN {32,64};
    if PSTATE.SP == '0' then
        SP_EL0 = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
    else
        case PSTATE.EL of
            when <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>  SP_EL0 = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
            when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>  SP_EL1 = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
            when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>  SP_EL2 = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
            when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>  SP_EL3 = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
    return;

// SP[] - non-assignment form
// ==========================
// Read stack pointer with implicit slice of 8, 16, 32 or 64 bits.

bits(width) <anchor link="impl-aarch64.SP.read.0" hover="accessor: bits(width) SP[]">SP</anchor>[]
    assert width IN {8,16,32,64};
    if PSTATE.SP == '0' then
        return SP_EL0&lt;width-1:0&gt;;
    else
        case PSTATE.EL of
            when <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>  return SP_EL0&lt;width-1:0&gt;;
            when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>  return SP_EL1&lt;width-1:0&gt;;
            when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>  return SP_EL2&lt;width-1:0&gt;;
            when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>  return SP_EL3&lt;width-1:0&gt;;</pstext>
    </ps>
    <ps name="aarch64/functions/registers/V" mylink="aarch64.functions.registers.V" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// V[] - assignment form
// =====================
// Write to SIMD&amp;FP register with implicit extension from
// 8, 16, 32, 64 or 128 bits.

<anchor link="impl-aarch64.V.write.1" hover="accessor: V[integer n] = bits(width) value">V</anchor>[integer n] = bits(width) value
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    assert width IN {8,16,32,64,128};
    _V[n] = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
    return;

// V[] - non-assignment form
// =========================
// Read from SIMD&amp;FP register with implicit slice of 8, 16
// 32, 64 or 128 bits.

bits(width) <anchor link="impl-aarch64.V.read.1" hover="accessor: bits(width) V[integer n]">V</anchor>[integer n]
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    assert width IN {8,16,32,64,128};
    return _V[n]&lt;width-1:0&gt;;</pstext>
    </ps>
    <ps name="aarch64/functions/registers/Vpart" mylink="aarch64.functions.registers.Vpart" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Vpart[] - non-assignment form
// =============================
// Reads a 128-bit SIMD&amp;FP register in up to two parts:
//  part 0 returns the bottom 8, 16, 32 or 64 bits of a value held in the register;
//  part 1 returns the top half of the bottom 64 bits or the top half of the 128-bit
//  value held in the register.

bits(width) <anchor link="impl-aarch64.Vpart.read.2" hover="accessor: bits(width) Vpart[integer n, integer part]">Vpart</anchor>[integer n, integer part]
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    assert part IN {0, 1};
    if part == 0 then
        assert width IN {8,16,32,64};
        return _V[n]&lt;width-1:0&gt;;
    else
        assert width IN {32,64};
        return _V[n]&lt;(width * 2)-1:width&gt;;

// Vpart[] - assignment form
// =========================
// Writes a 128-bit SIMD&amp;FP register in up to two parts:
//  part 0 zero extends a 8, 16, 32, or 64-bit value to fill the whole register;
//  part 1 inserts a 64-bit value into the top half of the register.

<anchor link="impl-aarch64.Vpart.write.2" hover="accessor: Vpart[integer n, integer part] = bits(width) value">Vpart</anchor>[integer n, integer part] = bits(width) value
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    assert part IN {0, 1};
    if part == 0 then
        assert width IN {8,16,32,64};
        _V[n] = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
    else
        assert width == 64;
        _V[n]&lt;(width * 2)-1:width&gt; = value&lt;width-1:0&gt;;</pstext>
    </ps>
    <ps name="aarch64/functions/registers/X" mylink="aarch64.functions.registers.X" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// X[] - assignment form
// =====================
// Write to general-purpose register from either a 32-bit or a 64-bit value.

<anchor link="impl-aarch64.X.write.1" hover="accessor: X[integer n] = bits(width) value">X</anchor>[integer n] = bits(width) value
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    assert width IN {32,64};
    if n != 31 then
        _R[n] = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
    return;

// X[] - assignment form
// =====================
// Write to general-purpose register from either a 32-bit or a 64-bit value,
// where the size of the value is passed as an argument.

<anchor link="impl-aarch64.X.write.2" hover="accessor: X[integer n, integer width] = bits(width) value">X</anchor>[integer n, integer width] = bits(width) value
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    assert width IN {32,64};
    if n != 31 then
        _R[n] = <a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(value, 64);
    return;

// X[] - non-assignment form
// =========================
// Read from general-purpose register with implicit slice of 8, 16, 32 or 64 bits.

bits(width) <anchor link="impl-aarch64.X.read.1" hover="accessor: bits(width) X[integer n]">X</anchor>[integer n]
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    assert width IN {8,16,32,64};
    if n != 31 then
        return _R[n]&lt;width-1:0&gt;;
    else
        return <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(width);

// X[] - non-assignment form
// =========================
// Read from general-purpose register with an explicit slice of 8, 16, 32 or 64 bits.

bits(width) <anchor link="impl-aarch64.X.read.2" hover="accessor: bits(width) X[integer n, integer width]">X</anchor>[integer n, integer width]
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    assert width IN {8,16,32,64};
    if n != 31 then
        return _R[n]&lt;width-1:0&gt;;
    else
        return <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(width);</pstext>
    </ps>
    <ps name="aarch64/functions/sysregisters/CNTKCTL" mylink="aarch64.functions.sysregisters.CNTKCTL" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CNTKCTL[] - non-assignment form
// ===============================

CNTKCTLType <anchor link="impl-aarch64.CNTKCTL.read.0" hover="accessor: CNTKCTLType CNTKCTL[]">CNTKCTL</anchor>[]
    bits(64) r;
    if <a link="impl-shared.IsInHost.0" file="shared_pseudocode.xml" hover="function: boolean IsInHost()">IsInHost</a>() then
        r = CNTHCTL_EL2;
        return r;
    r = CNTKCTL_EL1;
    return r;</pstext>
    </ps>
    <ps name="aarch64/functions/sysregisters/CNTKCTLType" mylink="aarch64.functions.sysregisters.CNTKCTLType" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">type <anchor link="CNTKCTLType" hover="type CNTKCTLType">CNTKCTLType</anchor>;</pstext>
    </ps>
    <ps name="aarch64/functions/sysregisters/CPACR" mylink="aarch64.functions.sysregisters.CPACR" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CPACR[] - non-assignment form
// =============================

CPACRType <anchor link="impl-aarch64.CPACR.read.0" hover="accessor: CPACRType CPACR[]">CPACR</anchor>[]
    bits(64) r;
    if <a link="impl-shared.IsInHost.0" file="shared_pseudocode.xml" hover="function: boolean IsInHost()">IsInHost</a>() then
        r = CPTR_EL2;
        return r;
    r = CPACR_EL1;
    return r;</pstext>
    </ps>
    <ps name="aarch64/functions/sysregisters/CPACRType" mylink="aarch64.functions.sysregisters.CPACRType" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">type <anchor link="CPACRType" hover="type CPACRType">CPACRType</anchor>;</pstext>
    </ps>
    <ps name="aarch64/functions/sysregisters/ELR" mylink="aarch64.functions.sysregisters.ELR" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ELR[] - non-assignment form
// ===========================

bits(64) <anchor link="impl-aarch64.ELR.read.1" hover="accessor: bits(64) ELR[bits(2) el]">ELR</anchor>[bits(2) el]
    bits(64) r;
    case el of
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>  r = ELR_EL1;
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>  r = ELR_EL2;
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>  r = ELR_EL3;
        otherwise <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();
    return r;

// ELR[] - non-assignment form
// ===========================

bits(64) <anchor link="impl-aarch64.ELR.read.0" hover="accessor: bits(64) ELR[]">ELR</anchor>[]
    assert PSTATE.EL != <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>;
    return <a link="impl-aarch64.ELR.read.1" file="shared_pseudocode.xml" hover="accessor: bits(64) ELR[bits(2) el]">ELR</a>[PSTATE.EL];

// ELR[] - assignment form
// =======================

<anchor link="impl-aarch64.ELR.write.1" hover="accessor: ELR[bits(2) el] = bits(64) value">ELR</anchor>[bits(2) el] = bits(64) value
    bits(64) r = value;
    case el of
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>  ELR_EL1 = r;
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>  ELR_EL2 = r;
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>  ELR_EL3 = r;
        otherwise <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();
    return;

// ELR[] - assignment form
// =======================

<anchor link="impl-aarch64.ELR.write.0" hover="accessor: ELR[] = bits(64) value">ELR</anchor>[] = bits(64) value
    assert PSTATE.EL != <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>;
    <a link="impl-aarch64.ELR.write.1" file="shared_pseudocode.xml" hover="accessor: ELR[bits(2) el] = bits(64) value">ELR</a>[PSTATE.EL] = value;
    return;</pstext>
    </ps>
    <ps name="aarch64/functions/sysregisters/ESR" mylink="aarch64.functions.sysregisters.ESR" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ESR[] - non-assignment form
// ===========================

ESRType <anchor link="impl-aarch64.ESR.read.1" hover="accessor: ESRType ESR[bits(2) regime]">ESR</anchor>[bits(2) regime]
    bits(64) r;
    case regime of
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>  r = ESR_EL1;
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>  r = ESR_EL2;
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>  r = ESR_EL3;
        otherwise <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();
    return r;

// ESR[] - non-assignment form
// ===========================

ESRType <anchor link="impl-aarch64.ESR.read.0" hover="accessor: ESRType ESR[]">ESR</anchor>[]
    return <a link="impl-aarch64.ESR.read.1" file="shared_pseudocode.xml" hover="accessor: ESRType ESR[bits(2) regime]">ESR</a>[<a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>()];

// ESR[] - assignment form
// =======================

<anchor link="impl-aarch64.ESR.write.1" hover="accessor: ESR[bits(2) regime] = ESRType value">ESR</anchor>[bits(2) regime] = <a link="ESRType" file="shared_pseudocode.xml" hover="type ESRType">ESRType</a> value
    bits(64) r = value;
    case regime of
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>  ESR_EL1 = r;
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>  ESR_EL2 = r;
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>  ESR_EL3 = r;
        otherwise <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();
    return;

// ESR[] - assignment form
// =======================

<anchor link="impl-aarch64.ESR.write.0" hover="accessor: ESR[] = ESRType value">ESR</anchor>[] = <a link="ESRType" file="shared_pseudocode.xml" hover="type ESRType">ESRType</a> value
    <a link="impl-aarch64.ESR.write.1" file="shared_pseudocode.xml" hover="accessor: ESR[bits(2) regime] = ESRType value">ESR</a>[<a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>()] = value;</pstext>
    </ps>
    <ps name="aarch64/functions/sysregisters/ESRType" mylink="aarch64.functions.sysregisters.ESRType" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">type <anchor link="ESRType" hover="type ESRType">ESRType</anchor>;</pstext>
    </ps>
    <ps name="aarch64/functions/sysregisters/FAR" mylink="aarch64.functions.sysregisters.FAR" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FAR[] - non-assignment form
// ===========================

bits(64) <anchor link="impl-aarch64.FAR.read.1" hover="accessor: bits(64) FAR[bits(2) regime]">FAR</anchor>[bits(2) regime]
    bits(64) r;
    case regime of
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>  r = FAR_EL1;
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>  r = FAR_EL2;
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>  r = FAR_EL3;
        otherwise <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();
    return r;

// FAR[] - non-assignment form
// ===========================

bits(64) <anchor link="impl-aarch64.FAR.read.0" hover="accessor: bits(64) FAR[]">FAR</anchor>[]
    return <a link="impl-aarch64.FAR.read.1" file="shared_pseudocode.xml" hover="accessor: bits(64) FAR[bits(2) regime]">FAR</a>[<a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>()];

// FAR[] - assignment form
// =======================

<anchor link="impl-aarch64.FAR.write.1" hover="accessor: FAR[bits(2) regime] = bits(64) value">FAR</anchor>[bits(2) regime] = bits(64) value
    bits(64) r = value;
    case regime of
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>  FAR_EL1 = r;
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>  FAR_EL2 = r;
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>  FAR_EL3 = r;
        otherwise <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();
    return;

// FAR[] - assignment form
// =======================

<anchor link="impl-aarch64.FAR.write.0" hover="accessor: FAR[] = bits(64) value">FAR</anchor>[] = bits(64) value
    <a link="impl-aarch64.FAR.write.1" file="shared_pseudocode.xml" hover="accessor: FAR[bits(2) regime] = bits(64) value">FAR</a>[<a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>()] = value;
    return;</pstext>
    </ps>
    <ps name="aarch64/functions/sysregisters/MAIR" mylink="aarch64.functions.sysregisters.MAIR" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// MAIR[] - non-assignment form
// ============================

MAIRType <anchor link="impl-aarch64.MAIR.read.1" hover="accessor: MAIRType MAIR[bits(2) regime]">MAIR</anchor>[bits(2) regime]
    bits(64) r;
    case regime of
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>  r = MAIR_EL1;
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>  r = MAIR_EL2;
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>  r = MAIR_EL3;
        otherwise <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();
    return r;

// MAIR[] - non-assignment form
// ============================

MAIRType <anchor link="impl-aarch64.MAIR.read.0" hover="accessor: MAIRType MAIR[]">MAIR</anchor>[]
    return <a link="impl-aarch64.MAIR.read.1" file="shared_pseudocode.xml" hover="accessor: MAIRType MAIR[bits(2) regime]">MAIR</a>[<a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>()];</pstext>
    </ps>
    <ps name="aarch64/functions/sysregisters/MAIRType" mylink="aarch64.functions.sysregisters.MAIRType" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">type <anchor link="MAIRType" hover="type MAIRType">MAIRType</anchor>;</pstext>
    </ps>
    <ps name="aarch64/functions/sysregisters/SCTLR" mylink="aarch64.functions.sysregisters.SCTLR" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SCTLR[] - non-assignment form
// =============================

SCTLRType <anchor link="impl-aarch64.SCTLR.read.1" hover="accessor: SCTLRType SCTLR[bits(2) regime]">SCTLR</anchor>[bits(2) regime]
    bits(64) r;
    case regime of
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>  r = SCTLR_EL1;
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>  r = SCTLR_EL2;
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>  r = SCTLR_EL3;
        otherwise <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();
    return r;

// SCTLR[] - non-assignment form
// =============================

SCTLRType <anchor link="impl-aarch64.SCTLR.read.0" hover="accessor: SCTLRType SCTLR[]">SCTLR</anchor>[]
    return <a link="impl-aarch64.SCTLR.read.1" file="shared_pseudocode.xml" hover="accessor: SCTLRType SCTLR[bits(2) regime]">SCTLR</a>[<a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>()];</pstext>
    </ps>
    <ps name="aarch64/functions/sysregisters/SCTLRType" mylink="aarch64.functions.sysregisters.SCTLRType" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">type <anchor link="SCTLRType" hover="type SCTLRType">SCTLRType</anchor>;</pstext>
    </ps>
    <ps name="aarch64/functions/sysregisters/VBAR" mylink="aarch64.functions.sysregisters.VBAR" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// VBAR[] - non-assignment form
// ============================

bits(64) <anchor link="impl-aarch64.VBAR.read.1" hover="accessor: bits(64) VBAR[bits(2) regime]">VBAR</anchor>[bits(2) regime]
    bits(64) r;
    case regime of
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>  r = VBAR_EL1;
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>  r = VBAR_EL2;
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>  r = VBAR_EL3;
        otherwise <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();
    return r;

// VBAR[] - non-assignment form
// ============================

bits(64) <anchor link="impl-aarch64.VBAR.read.0" hover="accessor: bits(64) VBAR[]">VBAR</anchor>[]
    return <a link="impl-aarch64.VBAR.read.1" file="shared_pseudocode.xml" hover="accessor: bits(64) VBAR[bits(2) regime]">VBAR</a>[<a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>()];</pstext>
    </ps>
    <ps name="aarch64/functions/system/AArch64.AllocationTagAccessIsEnabled" mylink="aarch64.functions.system.AArch64.AllocationTagAccessIsEnabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.AllocationTagAccessIsEnabled()
// ======================================
// Check whether access to Allocation Tags is enabled.

boolean <anchor link="AArch64.AllocationTagAccessIsEnabled.1" hover="function: boolean AArch64.AllocationTagAccessIsEnabled(AccType acctype)">AArch64.AllocationTagAccessIsEnabled</anchor>(<a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype)
    bits(2) el = <a link="AArch64.AccessUsesEL.1" file="shared_pseudocode.xml" hover="function: bits(2) AArch64.AccessUsesEL(AccType acctype)">AArch64.AccessUsesEL</a>(acctype);

    if SCR_EL3.ATA == '0' &amp;&amp; el IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>, <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>} then
        return FALSE;
    elsif HCR_EL2.ATA == '0' &amp;&amp; el IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; != '11' then
        return FALSE;
    elsif SCTLR_EL3.ATA == '0' &amp;&amp; el == <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> then
        return FALSE;
    elsif SCTLR_EL2.ATA == '0' &amp;&amp; el == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then
        return FALSE;
    elsif SCTLR_EL1.ATA == '0' &amp;&amp; el == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> then
        return FALSE;
    elsif SCTLR_EL2.ATA0 == '0' &amp;&amp; el == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; == '11' then
        return FALSE;
    elsif SCTLR_EL1.ATA0 == '0' &amp;&amp; el == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !(<a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; == '11') then
        return FALSE;
    else
        return TRUE;</pstext>
    </ps>
    <ps name="aarch64/functions/system/AArch64.ChooseNonExcludedTag" mylink="aarch64.functions.system.AArch64.ChooseNonExcludedTag" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.ChooseNonExcludedTag()
// ==============================
// Return a tag derived from the start and the offset values, excluding
// any tags in the given mask.

bits(4) <anchor link="AArch64.ChooseNonExcludedTag.3" hover="function: bits(4) AArch64.ChooseNonExcludedTag(bits(4) tag_in, bits(4) offset_in, bits(16) exclude)">AArch64.ChooseNonExcludedTag</anchor>(bits(4) tag_in, bits(4) offset_in, bits(16) exclude)
    bits(4) tag = tag_in;
    bits(4) offset = offset_in;

    if <a link="impl-shared.IsOnes.1" file="shared_pseudocode.xml" hover="function: boolean IsOnes(bits(N) x)">IsOnes</a>(exclude) then
        return '0000';

    if offset == '0000' then
        while exclude&lt;<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(tag)&gt; == '1' do
            tag = tag + '0001';

    while offset != '0000' do
        offset = offset - '0001';
        tag = tag + '0001';
        while exclude&lt;<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(tag)&gt; == '1' do
            tag = tag + '0001';

    return tag;</pstext>
    </ps>
    <ps name="aarch64/functions/system/AArch64.ExecutingBROrBLROrRetInstr" mylink="aarch64.functions.system.AArch64.ExecutingBROrBLROrRetInstr" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.ExecutingBROrBLROrRetInstr()
// ====================================
// Returns TRUE if current instruction is a BR, BLR, RET, B[L]RA[B][Z], or RETA[B].

boolean <anchor link="AArch64.ExecutingBROrBLROrRetInstr.0" hover="function: boolean AArch64.ExecutingBROrBLROrRetInstr()">AArch64.ExecutingBROrBLROrRetInstr</anchor>()
    if !<a link="impl-shared.HaveBTIExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveBTIExt()">HaveBTIExt</a>() then return FALSE;

    instr = <a link="impl-shared.ThisInstr.0" file="shared_pseudocode.xml" hover="function: bits(32) ThisInstr()">ThisInstr</a>();
    if instr&lt;31:25&gt; == '1101011' &amp;&amp; instr&lt;20:16&gt; == '11111' then
        opc = instr&lt;24:21&gt;;
        return opc != '0101';
    else
        return FALSE;</pstext>
    </ps>
    <ps name="aarch64/functions/system/AArch64.ExecutingBTIInstr" mylink="aarch64.functions.system.AArch64.ExecutingBTIInstr" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.ExecutingBTIInstr()
// ===========================
// Returns TRUE if current instruction is a BTI.

boolean <anchor link="AArch64.ExecutingBTIInstr.0" hover="function: boolean AArch64.ExecutingBTIInstr()">AArch64.ExecutingBTIInstr</anchor>()
    if !<a link="impl-shared.HaveBTIExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveBTIExt()">HaveBTIExt</a>() then return FALSE;

    instr = <a link="impl-shared.ThisInstr.0" file="shared_pseudocode.xml" hover="function: bits(32) ThisInstr()">ThisInstr</a>();
    if instr&lt;31:22&gt; == '1101010100' &amp;&amp; instr&lt;21:12&gt; == '0000110010' &amp;&amp; instr&lt;4:0&gt; == '11111' then
        CRm  = instr&lt;11:8&gt;;
        op2  = instr&lt;7:5&gt;;
        return (CRm == '0100' &amp;&amp; op2&lt;0&gt; == '0');
    else
        return FALSE;</pstext>
    </ps>
    <ps name="aarch64/functions/system/AArch64.ExecutingERETInstr" mylink="aarch64.functions.system.AArch64.ExecutingERETInstr" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.ExecutingERETInstr()
// ============================
// Returns TRUE if current instruction is ERET.

boolean <anchor link="AArch64.ExecutingERETInstr.0" hover="function: boolean AArch64.ExecutingERETInstr()">AArch64.ExecutingERETInstr</anchor>()
    instr = <a link="impl-shared.ThisInstr.0" file="shared_pseudocode.xml" hover="function: bits(32) ThisInstr()">ThisInstr</a>();
    return instr&lt;31:12&gt; == '11010110100111110000';</pstext>
    </ps>
    <ps name="aarch64/functions/system/AArch64.ImpDefSysInstr" mylink="aarch64.functions.system.AArch64.ImpDefSysInstr" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Execute an implementation-defined system instruction with write (source operand).
<anchor link="AArch64.ImpDefSysInstr.6" hover="function: AArch64.ImpDefSysInstr(integer el, bits(3) op1, bits(4) CRn, bits(4) CRm, bits(3) op2, integer t)">AArch64.ImpDefSysInstr</anchor>(integer el, bits(3) op1, bits(4) CRn, bits(4) CRm, bits(3) op2, integer t);</pstext>
    </ps>
    <ps name="aarch64/functions/system/AArch64.ImpDefSysInstrWithResult" mylink="aarch64.functions.system.AArch64.ImpDefSysInstrWithResult" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Execute an implementation-defined system instruction with read (result operand).
<anchor link="AArch64.ImpDefSysInstrWithResult.5" hover="function: AArch64.ImpDefSysInstrWithResult(integer el, bits(3) op1, bits(4) CRn, bits(4) CRm, bits(3) op2)">AArch64.ImpDefSysInstrWithResult</anchor>(integer el, bits(3) op1, bits(4) CRn, bits(4) CRm, bits(3) op2);</pstext>
    </ps>
    <ps name="aarch64/functions/system/AArch64.ImpDefSysRegRead" mylink="aarch64.functions.system.AArch64.ImpDefSysRegRead" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Read from an implementation-defined system register and write the contents of the register to X[t].
<anchor link="AArch64.ImpDefSysRegRead.6" hover="function: AArch64.ImpDefSysRegRead(bits(2) op0, bits(3) op1, bits(4) CRn, bits(4) CRm, bits(3) op2, integer t)">AArch64.ImpDefSysRegRead</anchor>(bits(2) op0, bits(3) op1, bits(4) CRn, bits(4) CRm, bits(3) op2, integer t);</pstext>
    </ps>
    <ps name="aarch64/functions/system/AArch64.ImpDefSysRegWrite" mylink="aarch64.functions.system.AArch64.ImpDefSysRegWrite" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Write to an implementation-defined system register.
<anchor link="AArch64.ImpDefSysRegWrite.6" hover="function: AArch64.ImpDefSysRegWrite(bits(2) op0, bits(3) op1, bits(4) CRn, bits(4) CRm, bits(3) op2, integer t)">AArch64.ImpDefSysRegWrite</anchor>(bits(2) op0, bits(3) op1, bits(4) CRn, bits(4) CRm, bits(3) op2, integer t);</pstext>
    </ps>
    <ps name="aarch64/functions/system/AArch64.NextRandomTagBit" mylink="aarch64.functions.system.AArch64.NextRandomTagBit" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.NextRandomTagBit()
// ==========================
// Generate a random bit suitable for generating a random Allocation Tag.

bit <anchor link="AArch64.NextRandomTagBit.0" hover="function: bit AArch64.NextRandomTagBit()">AArch64.NextRandomTagBit</anchor>()
    bits(16) lfsr = RGSR_EL1.SEED;
    bit top = lfsr&lt;5&gt; EOR lfsr&lt;3&gt; EOR lfsr&lt;2&gt; EOR lfsr&lt;0&gt;;
    RGSR_EL1.SEED = top:lfsr&lt;15:1&gt;;
    return top;</pstext>
    </ps>
    <ps name="aarch64/functions/system/AArch64.RandomTag" mylink="aarch64.functions.system.AArch64.RandomTag" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.RandomTag()
// ===================
// Generate a random Allocation Tag.

bits(4) <anchor link="AArch64.RandomTag.0" hover="function: bits(4) AArch64.RandomTag()">AArch64.RandomTag</anchor>()
    bits(4) tag;
    for i = 0 to 3
        tag&lt;i&gt; = <a link="AArch64.NextRandomTagBit.0" file="shared_pseudocode.xml" hover="function: bit AArch64.NextRandomTagBit()">AArch64.NextRandomTagBit</a>();
    return tag;</pstext>
    </ps>
    <ps name="aarch64/functions/system/AArch64.SysInstr" mylink="aarch64.functions.system.AArch64.SysInstr" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Execute a system instruction with write (source operand).
<anchor link="AArch64.SysInstr.6" hover="function: AArch64.SysInstr(integer op0, integer op1, integer crn, integer crm, integer op2, integer t)">AArch64.SysInstr</anchor>(integer op0, integer op1, integer crn, integer crm, integer op2, integer t);</pstext>
    </ps>
    <ps name="aarch64/functions/system/AArch64.SysInstrWithResult" mylink="aarch64.functions.system.AArch64.SysInstrWithResult" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Execute a system instruction with read (result operand).
// Writes the result of the instruction to X[t].
<anchor link="AArch64.SysInstrWithResult.6" hover="function: AArch64.SysInstrWithResult(integer op0, integer op1, integer crn, integer crm, integer op2, integer t)">AArch64.SysInstrWithResult</anchor>(integer op0, integer op1, integer crn, integer crm, integer op2, integer t);</pstext>
    </ps>
    <ps name="aarch64/functions/system/AArch64.SysRegRead" mylink="aarch64.functions.system.AArch64.SysRegRead" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Read from a system register and write the contents of the register to X[t].
<anchor link="AArch64.SysRegRead.6" hover="function: AArch64.SysRegRead(integer op0, integer op1, integer crn, integer crm, integer op2, integer t)">AArch64.SysRegRead</anchor>(integer op0, integer op1, integer crn, integer crm, integer op2, integer t);</pstext>
    </ps>
    <ps name="aarch64/functions/system/AArch64.SysRegWrite" mylink="aarch64.functions.system.AArch64.SysRegWrite" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Write to a system register.
<anchor link="AArch64.SysRegWrite.6" hover="function: AArch64.SysRegWrite(integer op0, integer op1, integer crn, integer crm, integer op2, integer t)">AArch64.SysRegWrite</anchor>(integer op0, integer op1, integer crn, integer crm, integer op2, integer t);</pstext>
    </ps>
    <ps name="aarch64/functions/system/BTypeCompatible" mylink="aarch64.functions.system.BTypeCompatible" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">boolean BTypeCompatible;</pstext>
    </ps>
    <ps name="aarch64/functions/system/BTypeCompatible_BTI" mylink="aarch64.functions.system.BTypeCompatible_BTI" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// BTypeCompatible_BTI
// ===================
// This function determines whether a given hint encoding is compatible with the current value of
// PSTATE.BTYPE. A value of TRUE here indicates a valid Branch Target Identification instruction.

boolean <anchor link="impl-aarch64.BTypeCompatible_BTI.1" hover="function: boolean BTypeCompatible_BTI(bits(2) hintcode)">BTypeCompatible_BTI</anchor>(bits(2) hintcode)
    case hintcode of
        when '00'
            return FALSE;
        when '01'
            return PSTATE.BTYPE != '11';
        when '10'
            return PSTATE.BTYPE != '10';
        when '11'
            return TRUE;</pstext>
    </ps>
    <ps name="aarch64/functions/system/BTypeCompatible_PACIXSP" mylink="aarch64.functions.system.BTypeCompatible_PACIXSP" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// BTypeCompatible_PACIXSP()
// =========================
// Returns TRUE if PACIASP, PACIBSP instruction is implicit compatible with PSTATE.BTYPE,
// FALSE otherwise.

boolean <anchor link="impl-aarch64.BTypeCompatible_PACIXSP.0" hover="function: boolean BTypeCompatible_PACIXSP()">BTypeCompatible_PACIXSP</anchor>()
    if PSTATE.BTYPE IN {'01', '10'} then
        return TRUE;
    elsif PSTATE.BTYPE == '11' then
        index = if PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then 35 else 36;
        return <a link="impl-aarch64.SCTLR.read.0" file="shared_pseudocode.xml" hover="accessor: SCTLRType SCTLR[]">SCTLR</a>[]&lt;index&gt; == '0';
    else
        return FALSE;</pstext>
    </ps>
    <ps name="aarch64/functions/system/BTypeNext" mylink="aarch64.functions.system.BTypeNext" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">bits(2) BTypeNext;</pstext>
    </ps>
    <ps name="aarch64/functions/system/ChooseRandomNonExcludedTag" mylink="aarch64.functions.system.ChooseRandomNonExcludedTag" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// The ChooseRandomNonExcludedTag function is used when GCR_EL1.RRND == '1' to generate random
// Allocation Tags.
//
// The resulting Allocation Tag is selected from the set [0,15], excluding any Allocation Tag where
// exclude[tag_value] == 1. If 'exclude' is all Ones, the returned Allocation Tag is '0000'.
//
// This function is permitted to generate a non-deterministic selection from the set of non-excluded
// Allocation Tags. A reasonable implementation is described by the Pseudocode used when
// GCR_EL1.RRND is 0, but with a non-deterministic implementation of NextRandomTagBit(). Implementations
// may choose to behave the same as GCR_EL1.RRND=0.
bits(4) <anchor link="impl-aarch64.ChooseRandomNonExcludedTag.1" hover="function: bits(4) ChooseRandomNonExcludedTag(bits(16) exclude_in)">ChooseRandomNonExcludedTag</anchor>(bits(16) exclude_in);</pstext>
    </ps>
    <ps name="aarch64/functions/system/InGuardedPage" mylink="aarch64.functions.system.InGuardedPage" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">boolean InGuardedPage;</pstext>
    </ps>
    <ps name="aarch64/functions/system/IsHCRXEL2Enabled" mylink="aarch64.functions.system.IsHCRXEL2Enabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// IsHCRXEL2Enabled()
// ==================
// Returns TRUE if access to HCRX_EL2 register is enabled, and FALSE otherwise.
// Indirect read of HCRX_EL2 returns 0 when access is not enabled.

boolean <anchor link="impl-aarch64.IsHCRXEL2Enabled.0" hover="function: boolean IsHCRXEL2Enabled()">IsHCRXEL2Enabled</anchor>()
    assert(<a link="impl-shared.HaveFeatHCX.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatHCX()">HaveFeatHCX</a>());
    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.HXEn == '0' then
        return FALSE;

    return <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>();</pstext>
    </ps>
    <ps name="aarch64/functions/system/SetBTypeCompatible" mylink="aarch64.functions.system.SetBTypeCompatible" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SetBTypeCompatible()
// ====================
// Sets the value of BTypeCompatible global variable used by BTI

<anchor link="impl-aarch64.SetBTypeCompatible.1" hover="function: SetBTypeCompatible(boolean x)">SetBTypeCompatible</anchor>(boolean x)
    BTypeCompatible = x;</pstext>
    </ps>
    <ps name="aarch64/functions/system/SetBTypeNext" mylink="aarch64.functions.system.SetBTypeNext" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SetBTypeNext()
// ==============
// Set the value of BTypeNext global variable used by BTI

<anchor link="impl-aarch64.SetBTypeNext.1" hover="function: SetBTypeNext(bits(2) x)">SetBTypeNext</anchor>(bits(2) x)
    BTypeNext = x;</pstext>
    </ps>
    <ps name="aarch64/functions/system/SetInGuardedPage" mylink="aarch64.functions.system.SetInGuardedPage" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SetInGuardedPage()
// ==================
// Global state updated to denote if memory access is from a guarded page.

<anchor link="impl-aarch64.SetInGuardedPage.1" hover="function: SetInGuardedPage(boolean guardedpage)">SetInGuardedPage</anchor>(boolean guardedpage)
    InGuardedPage = guardedpage;</pstext>
    </ps>
    <ps name="aarch64/instrs/branch/eret/AArch64.ExceptionReturn" mylink="aarch64.instrs.branch.eret.AArch64.ExceptionReturn" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.ExceptionReturn()
// =========================

<anchor link="AArch64.ExceptionReturn.2" hover="function: AArch64.ExceptionReturn(bits(64) new_pc_in, bits(64) spsr)">AArch64.ExceptionReturn</anchor>(bits(64) new_pc_in, bits(64) spsr)
    bits(64) new_pc = new_pc_in;
    if <a link="impl-shared.HaveIESB.0" file="shared_pseudocode.xml" hover="function: boolean HaveIESB()">HaveIESB</a>() then
        sync_errors = <a link="impl-aarch64.SCTLR.read.0" file="shared_pseudocode.xml" hover="accessor: SCTLRType SCTLR[]">SCTLR</a>[].IESB == '1';
        if <a link="impl-shared.HaveDoubleFaultExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>() then
            sync_errors = sync_errors || (SCR_EL3.&lt;EA,NMEA&gt; == '11' &amp;&amp; PSTATE.EL == <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>);
        if sync_errors then
            <a link="impl-shared.SynchronizeErrors.0" file="shared_pseudocode.xml" hover="function: SynchronizeErrors()">SynchronizeErrors</a>();
            iesb_req = TRUE;
            <a link="impl-shared.TakeUnmaskedPhysicalSErrorInterrupts.1" file="shared_pseudocode.xml" hover="function: TakeUnmaskedPhysicalSErrorInterrupts(boolean iesb_req)">TakeUnmaskedPhysicalSErrorInterrupts</a>(iesb_req);
    <a link="impl-shared.SynchronizeContext.0" file="shared_pseudocode.xml" hover="function: SynchronizeContext()">SynchronizeContext</a>();

    // Attempts to change to an illegal state will invoke the Illegal Execution state mechanism
    bits(2) source_el = PSTATE.EL;
    boolean illegal_psr_state = <a link="impl-shared.IllegalExceptionReturn.1" file="shared_pseudocode.xml" hover="function: boolean IllegalExceptionReturn(bits(N) spsr)">IllegalExceptionReturn</a>(spsr);
    <a link="impl-shared.SetPSTATEFromPSR.2" file="shared_pseudocode.xml" hover="function: SetPSTATEFromPSR(bits(N) spsr_in, boolean illegal_psr_state)">SetPSTATEFromPSR</a>(spsr, illegal_psr_state);
    <a link="impl-shared.ClearExclusiveLocal.1" file="shared_pseudocode.xml" hover="function: ClearExclusiveLocal(integer processorid)">ClearExclusiveLocal</a>(<a link="impl-shared.ProcessorID.0" file="shared_pseudocode.xml" hover="function: integer ProcessorID()">ProcessorID</a>());
    <a link="impl-shared.SendEventLocal.0" file="shared_pseudocode.xml" hover="function: SendEventLocal()">SendEventLocal</a>();

    if illegal_psr_state &amp;&amp; spsr&lt;4&gt; == '1' then
        // If the exception return is illegal, PC[63:32,1:0] are UNKNOWN
        new_pc&lt;63:32&gt; = bits(32) UNKNOWN;
        new_pc&lt;1:0&gt; = bits(2) UNKNOWN;
    elsif <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then                // Return to AArch32
        // ELR_ELx[1:0] or ELR_ELx[0] are treated as being 0, depending on the
        // target instruction set state
        if PSTATE.T == '1' then
            new_pc&lt;0&gt; = '0';                 // T32
        else
            new_pc&lt;1:0&gt; = '00';              // A32
    else                                     // Return to AArch64
        // ELR_ELx[63:56] might include a tag
        new_pc = <a link="AArch64.BranchAddr.1" file="shared_pseudocode.xml" hover="function: bits(64) AArch64.BranchAddr(bits(64) vaddress)">AArch64.BranchAddr</a>(new_pc);

    if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
        // 32 most significant bits are ignored.
        boolean branch_conditional = FALSE;
        <a link="impl-shared.BranchTo.3" file="shared_pseudocode.xml" hover="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(new_pc&lt;31:0&gt;, <a link="BranchType_ERET" file="shared_pseudocode.xml" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType_ERET</a>, branch_conditional);
    else
        <a link="impl-shared.BranchToAddr.2" file="shared_pseudocode.xml" hover="function: BranchToAddr(bits(N) target, BranchType branch_type)">BranchToAddr</a>(new_pc, <a link="BranchType_ERET" file="shared_pseudocode.xml" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType_ERET</a>);

    <a link="impl-shared.CheckExceptionCatch.1" file="shared_pseudocode.xml" hover="function: CheckExceptionCatch(boolean exception_entry)">CheckExceptionCatch</a>(FALSE);              // Check for debug event on exception return</pstext>
    </ps>
    <ps name="aarch64/instrs/countop/CountOp" mylink="aarch64.instrs.countop.CountOp" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="CountOp" hover="enumeration CountOp     {CountOp_CLZ, CountOp_CLS, CountOp_CNT}">CountOp</anchor>     {<anchor link="CountOp_CLZ" hover="enumeration CountOp     {CountOp_CLZ, CountOp_CLS, CountOp_CNT}">CountOp_CLZ</anchor>, <anchor link="CountOp_CLS" hover="enumeration CountOp     {CountOp_CLZ, CountOp_CLS, CountOp_CNT}">CountOp_CLS</anchor>, <anchor link="CountOp_CNT" hover="enumeration CountOp     {CountOp_CLZ, CountOp_CLS, CountOp_CNT}">CountOp_CNT</anchor>};</pstext>
    </ps>
    <ps name="aarch64/instrs/extendreg/DecodeRegExtend" mylink="aarch64.instrs.extendreg.DecodeRegExtend" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// DecodeRegExtend()
// =================
// Decode a register extension option

ExtendType <anchor link="impl-aarch64.DecodeRegExtend.1" hover="function: ExtendType DecodeRegExtend(bits(3) op)">DecodeRegExtend</anchor>(bits(3) op)
    case op of
        when '000' return <a link="ExtendType_UXTB" file="shared_pseudocode.xml" hover="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_UXTB</a>;
        when '001' return <a link="ExtendType_UXTH" file="shared_pseudocode.xml" hover="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_UXTH</a>;
        when '010' return <a link="ExtendType_UXTW" file="shared_pseudocode.xml" hover="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_UXTW</a>;
        when '011' return <a link="ExtendType_UXTX" file="shared_pseudocode.xml" hover="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_UXTX</a>;
        when '100' return <a link="ExtendType_SXTB" file="shared_pseudocode.xml" hover="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_SXTB</a>;
        when '101' return <a link="ExtendType_SXTH" file="shared_pseudocode.xml" hover="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_SXTH</a>;
        when '110' return <a link="ExtendType_SXTW" file="shared_pseudocode.xml" hover="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_SXTW</a>;
        when '111' return <a link="ExtendType_SXTX" file="shared_pseudocode.xml" hover="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_SXTX</a>;</pstext>
    </ps>
    <ps name="aarch64/instrs/extendreg/ExtendReg" mylink="aarch64.instrs.extendreg.ExtendReg" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ExtendReg()
// ===========
// Perform a register extension and shift

bits(N) <anchor link="impl-aarch64.ExtendReg.3" hover="function: bits(N) ExtendReg(integer reg, ExtendType exttype, integer shift)">ExtendReg</anchor>(integer reg, <a link="ExtendType" file="shared_pseudocode.xml" hover="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType</a> exttype, integer shift)
    assert shift &gt;= 0 &amp;&amp; shift &lt;= 4;
    bits(N) val = <a link="impl-aarch64.X.read.1" file="shared_pseudocode.xml" hover="accessor: bits(width) X[integer n]">X</a>[reg];
    boolean unsigned;
    integer len;

    case exttype of
        when <a link="ExtendType_SXTB" file="shared_pseudocode.xml" hover="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_SXTB</a> unsigned = FALSE; len = 8;
        when <a link="ExtendType_SXTH" file="shared_pseudocode.xml" hover="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_SXTH</a> unsigned = FALSE; len = 16;
        when <a link="ExtendType_SXTW" file="shared_pseudocode.xml" hover="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_SXTW</a> unsigned = FALSE; len = 32;
        when <a link="ExtendType_SXTX" file="shared_pseudocode.xml" hover="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_SXTX</a> unsigned = FALSE; len = 64;
        when <a link="ExtendType_UXTB" file="shared_pseudocode.xml" hover="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_UXTB</a> unsigned = TRUE;  len = 8;
        when <a link="ExtendType_UXTH" file="shared_pseudocode.xml" hover="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_UXTH</a> unsigned = TRUE;  len = 16;
        when <a link="ExtendType_UXTW" file="shared_pseudocode.xml" hover="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_UXTW</a> unsigned = TRUE;  len = 32;
        when <a link="ExtendType_UXTX" file="shared_pseudocode.xml" hover="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_UXTX</a> unsigned = TRUE;  len = 64;

    // Note the extended width of the intermediate value and
    // that sign extension occurs from bit &lt;len+shift-1&gt;, not
    // from bit &lt;len-1&gt;. This is equivalent to the instruction
    //   [SU]BFIZ Rtmp, Rreg, #shift, #len
    // It may also be seen as a sign/zero extend followed by a shift:
    //   LSL(Extend(val&lt;len-1:0&gt;, N, unsigned), shift);

    len = <a link="impl-shared.Min.2" file="shared_pseudocode.xml" hover="function: integer Min(integer a, integer b)">Min</a>(len, N - shift);
    return <a link="impl-shared.Extend.3" file="shared_pseudocode.xml" hover="function: bits(N) Extend(bits(M) x, integer N, boolean unsigned)">Extend</a>(val&lt;len-1:0&gt; : <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(shift), N, unsigned);</pstext>
    </ps>
    <ps name="aarch64/instrs/extendreg/ExtendType" mylink="aarch64.instrs.extendreg.ExtendType" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="ExtendType" hover="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType</anchor>  {<anchor link="ExtendType_SXTB" hover="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_SXTB</anchor>, <anchor link="ExtendType_SXTH" hover="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_SXTH</anchor>, <anchor link="ExtendType_SXTW" hover="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_SXTW</anchor>, <anchor link="ExtendType_SXTX" hover="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_SXTX</anchor>,
                         <anchor link="ExtendType_UXTB" hover="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_UXTB</anchor>, <anchor link="ExtendType_UXTH" hover="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_UXTH</anchor>, <anchor link="ExtendType_UXTW" hover="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_UXTW</anchor>, <anchor link="ExtendType_UXTX" hover="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_UXTX</anchor>};</pstext>
    </ps>
    <ps name="aarch64/instrs/float/arithmetic/max-min/fpmaxminop/FPMaxMinOp" mylink="aarch64.instrs.float.arithmetic.max-min.fpmaxminop.FPMaxMinOp" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="FPMaxMinOp" hover="enumeration FPMaxMinOp  {FPMaxMinOp_MAX, FPMaxMinOp_MIN,&#13; FPMaxMinOp_MAXNUM, FPMaxMinOp_MINNUM}">FPMaxMinOp</anchor>  {<anchor link="FPMaxMinOp_MAX" hover="enumeration FPMaxMinOp  {FPMaxMinOp_MAX, FPMaxMinOp_MIN,&#13; FPMaxMinOp_MAXNUM, FPMaxMinOp_MINNUM}">FPMaxMinOp_MAX</anchor>, <anchor link="FPMaxMinOp_MIN" hover="enumeration FPMaxMinOp  {FPMaxMinOp_MAX, FPMaxMinOp_MIN,&#13; FPMaxMinOp_MAXNUM, FPMaxMinOp_MINNUM}">FPMaxMinOp_MIN</anchor>,
                         <anchor link="FPMaxMinOp_MAXNUM" hover="enumeration FPMaxMinOp  {FPMaxMinOp_MAX, FPMaxMinOp_MIN,&#13; FPMaxMinOp_MAXNUM, FPMaxMinOp_MINNUM}">FPMaxMinOp_MAXNUM</anchor>, <anchor link="FPMaxMinOp_MINNUM" hover="enumeration FPMaxMinOp  {FPMaxMinOp_MAX, FPMaxMinOp_MIN,&#13; FPMaxMinOp_MAXNUM, FPMaxMinOp_MINNUM}">FPMaxMinOp_MINNUM</anchor>};</pstext>
    </ps>
    <ps name="aarch64/instrs/float/arithmetic/unary/fpunaryop/FPUnaryOp" mylink="aarch64.instrs.float.arithmetic.unary.fpunaryop.FPUnaryOp" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="FPUnaryOp" hover="enumeration FPUnaryOp   {FPUnaryOp_ABS, FPUnaryOp_MOV,&#13; FPUnaryOp_NEG, FPUnaryOp_SQRT}">FPUnaryOp</anchor>   {<anchor link="FPUnaryOp_ABS" hover="enumeration FPUnaryOp   {FPUnaryOp_ABS, FPUnaryOp_MOV,&#13; FPUnaryOp_NEG, FPUnaryOp_SQRT}">FPUnaryOp_ABS</anchor>, <anchor link="FPUnaryOp_MOV" hover="enumeration FPUnaryOp   {FPUnaryOp_ABS, FPUnaryOp_MOV,&#13; FPUnaryOp_NEG, FPUnaryOp_SQRT}">FPUnaryOp_MOV</anchor>,
                         <anchor link="FPUnaryOp_NEG" hover="enumeration FPUnaryOp   {FPUnaryOp_ABS, FPUnaryOp_MOV,&#13; FPUnaryOp_NEG, FPUnaryOp_SQRT}">FPUnaryOp_NEG</anchor>, <anchor link="FPUnaryOp_SQRT" hover="enumeration FPUnaryOp   {FPUnaryOp_ABS, FPUnaryOp_MOV,&#13; FPUnaryOp_NEG, FPUnaryOp_SQRT}">FPUnaryOp_SQRT</anchor>};</pstext>
    </ps>
    <ps name="aarch64/instrs/float/convert/fpconvop/FPConvOp" mylink="aarch64.instrs.float.convert.fpconvop.FPConvOp" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="FPConvOp" hover="enumeration FPConvOp    {FPConvOp_CVT_FtoI, FPConvOp_CVT_ItoF,&#13; FPConvOp_MOV_FtoI, FPConvOp_MOV_ItoF&#13; , FPConvOp_CVT_FtoI_JS&#13; }">FPConvOp</anchor>    {<anchor link="FPConvOp_CVT_FtoI" hover="enumeration FPConvOp    {FPConvOp_CVT_FtoI, FPConvOp_CVT_ItoF,&#13; FPConvOp_MOV_FtoI, FPConvOp_MOV_ItoF&#13; , FPConvOp_CVT_FtoI_JS&#13; }">FPConvOp_CVT_FtoI</anchor>, <anchor link="FPConvOp_CVT_ItoF" hover="enumeration FPConvOp    {FPConvOp_CVT_FtoI, FPConvOp_CVT_ItoF,&#13; FPConvOp_MOV_FtoI, FPConvOp_MOV_ItoF&#13; , FPConvOp_CVT_FtoI_JS&#13; }">FPConvOp_CVT_ItoF</anchor>,
                         <anchor link="FPConvOp_MOV_FtoI" hover="enumeration FPConvOp    {FPConvOp_CVT_FtoI, FPConvOp_CVT_ItoF,&#13; FPConvOp_MOV_FtoI, FPConvOp_MOV_ItoF&#13; , FPConvOp_CVT_FtoI_JS&#13; }">FPConvOp_MOV_FtoI</anchor>, <anchor link="FPConvOp_MOV_ItoF" hover="enumeration FPConvOp    {FPConvOp_CVT_FtoI, FPConvOp_CVT_ItoF,&#13; FPConvOp_MOV_FtoI, FPConvOp_MOV_ItoF&#13; , FPConvOp_CVT_FtoI_JS&#13; }">FPConvOp_MOV_ItoF</anchor>
                         , <anchor link="FPConvOp_CVT_FtoI_JS" hover="enumeration FPConvOp    {FPConvOp_CVT_FtoI, FPConvOp_CVT_ItoF,&#13; FPConvOp_MOV_FtoI, FPConvOp_MOV_ItoF&#13; , FPConvOp_CVT_FtoI_JS&#13; }">FPConvOp_CVT_FtoI_JS</anchor>
};</pstext>
    </ps>
    <ps name="aarch64/instrs/integer/bitfield/bfxpreferred/BFXPreferred" mylink="aarch64.instrs.integer.bitfield.bfxpreferred.BFXPreferred" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// BFXPreferred()
// ==============
//
// Return TRUE if UBFX or SBFX is the preferred disassembly of a
// UBFM or SBFM bitfield instruction. Must exclude more specific
// aliases UBFIZ, SBFIZ, UXT[BH], SXT[BHW], LSL, LSR and ASR.

boolean <anchor link="impl-aarch64.BFXPreferred.4" hover="function: boolean BFXPreferred(bit sf, bit uns, bits(6) imms, bits(6) immr)">BFXPreferred</anchor>(bit sf, bit uns, bits(6) imms, bits(6) immr)
    integer S = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(imms);
    integer R = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(immr);

    // must not match UBFIZ/SBFIX alias
    if <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(imms) &lt; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(immr) then
        return FALSE;

    // must not match LSR/ASR/LSL alias (imms == 31 or 63)
    if imms == sf:'11111' then
        return FALSE;

    // must not match UXTx/SXTx alias
    if immr == '000000' then
        // must not match 32-bit UXT[BH] or SXT[BH]
        if sf == '0' &amp;&amp; imms IN {'000111', '001111'} then
            return FALSE;
        // must not match 64-bit SXT[BHW]
        if sf:uns == '10' &amp;&amp; imms IN {'000111', '001111', '011111'} then
            return FALSE;

    // must be UBFX/SBFX alias
    return TRUE;</pstext>
    </ps>
    <ps name="aarch64/instrs/integer/bitmasks/DecodeBitMasks" mylink="aarch64.instrs.integer.bitmasks.DecodeBitMasks" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// DecodeBitMasks()
// ================

// Decode AArch64 bitfield and logical immediate masks which use a similar encoding structure

(bits(M), bits(M)) <anchor link="impl-aarch64.DecodeBitMasks.4" hover="function: (bits(M), bits(M)) DecodeBitMasks(bit immN, bits(6) imms, bits(6) immr, boolean immediate)">DecodeBitMasks</anchor>(bit immN, bits(6) imms, bits(6) immr, boolean immediate)
    bits(64) tmask, wmask;
    bits(6) tmask_and, wmask_and;
    bits(6) tmask_or, wmask_or;
    bits(6) levels;

    // Compute log2 of element size
    // 2^len must be in range [2, M]
    len = <a link="impl-shared.HighestSetBit.1" file="shared_pseudocode.xml" hover="function: integer HighestSetBit(bits(N) x)">HighestSetBit</a>(immN:NOT(imms));
    if len &lt; 1 then UNDEFINED;
    assert M &gt;= (1 &lt;&lt; len);

    // Determine S, R and S - R parameters
    levels = <a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(<a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(len), 6);

    // For logical immediates an all-ones value of S is reserved
    // since it would generate a useless all-ones result (many times)
    if immediate &amp;&amp; (imms AND levels) == levels then
        UNDEFINED;

    S = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(imms AND levels);
    R = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(immr AND levels);
    diff = S - R;    // 6-bit subtract with borrow

    // From a software perspective, the remaining code is equivalant to:
    //   esize = 1 &lt;&lt; len;
    //   d = UInt(diff&lt;len-1:0&gt;);
    //   welem = ZeroExtend(Ones(S + 1), esize);
    //   telem = ZeroExtend(Ones(d + 1), esize);
    //   wmask = Replicate(ROR(welem, R));
    //   tmask = Replicate(telem);
    //   return (wmask, tmask);

    // Compute "top mask"
    tmask_and = diff&lt;5:0&gt; OR NOT(levels);
    tmask_or  = diff&lt;5:0&gt; AND levels;

    tmask = <a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(64);
    tmask = ((tmask
              AND <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_and&lt;0&gt;, 1) : <a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(1), 32))
               OR  <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(1) : <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_or&lt;0&gt;, 1), 32));
    // optimization of first step:
    // tmask = Replicate(tmask_and&lt;0&gt; : '1', 32);
    tmask = ((tmask
              AND <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_and&lt;1&gt;, 2) : <a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(2), 16))
               OR  <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(2) : <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_or&lt;1&gt;, 2), 16));
    tmask = ((tmask
              AND <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_and&lt;2&gt;, 4) : <a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(4), 8))
               OR  <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(4) : <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_or&lt;2&gt;, 4), 8));
    tmask = ((tmask
              AND <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_and&lt;3&gt;, 8) : <a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(8), 4))
               OR  <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(8) : <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_or&lt;3&gt;, 8), 4));
    tmask = ((tmask
              AND <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_and&lt;4&gt;, 16) : <a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(16), 2))
               OR  <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(16) : <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_or&lt;4&gt;, 16), 2));
    tmask = ((tmask
              AND <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_and&lt;5&gt;, 32) : <a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(32), 1))
               OR  <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(32) : <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_or&lt;5&gt;, 32), 1));

    // Compute "wraparound mask"
    wmask_and = immr OR NOT(levels);
    wmask_or  = immr AND levels;

    wmask = <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(64);
    wmask = ((wmask
              AND <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(1) : <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_and&lt;0&gt;, 1), 32))
               OR  <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_or&lt;0&gt;, 1) : <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(1), 32));
    // optimization of first step:
    // wmask = Replicate(wmask_or&lt;0&gt; : '0', 32);
    wmask = ((wmask
              AND <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(2) : <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_and&lt;1&gt;, 2), 16))
               OR  <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_or&lt;1&gt;, 2) : <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(2), 16));
    wmask = ((wmask
              AND <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(4) : <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_and&lt;2&gt;, 4), 8))
               OR  <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_or&lt;2&gt;, 4) : <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(4), 8));
    wmask = ((wmask
              AND <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(8) : <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_and&lt;3&gt;, 8), 4))
               OR  <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_or&lt;3&gt;, 8) : <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(8), 4));
    wmask = ((wmask
              AND <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(16) : <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_and&lt;4&gt;, 16), 2))
               OR  <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_or&lt;4&gt;, 16) : <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(16), 2));
    wmask = ((wmask
              AND <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(32) : <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_and&lt;5&gt;, 32), 1))
               OR  <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_or&lt;5&gt;, 32) : <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(32), 1));

    if diff&lt;6&gt; != '0' then // borrow from S - R
        wmask = wmask AND tmask;
    else
        wmask = wmask OR tmask;

    return (wmask&lt;M-1:0&gt;, tmask&lt;M-1:0&gt;);</pstext>
    </ps>
    <ps name="aarch64/instrs/integer/ins-ext/insert/movewide/movewideop/MoveWideOp" mylink="aarch64.instrs.integer.ins-ext.insert.movewide.movewideop.MoveWideOp" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="MoveWideOp" hover="enumeration MoveWideOp  {MoveWideOp_N, MoveWideOp_Z, MoveWideOp_K}">MoveWideOp</anchor>  {<anchor link="MoveWideOp_N" hover="enumeration MoveWideOp  {MoveWideOp_N, MoveWideOp_Z, MoveWideOp_K}">MoveWideOp_N</anchor>, <anchor link="MoveWideOp_Z" hover="enumeration MoveWideOp  {MoveWideOp_N, MoveWideOp_Z, MoveWideOp_K}">MoveWideOp_Z</anchor>, <anchor link="MoveWideOp_K" hover="enumeration MoveWideOp  {MoveWideOp_N, MoveWideOp_Z, MoveWideOp_K}">MoveWideOp_K</anchor>};</pstext>
    </ps>
    <ps name="aarch64/instrs/integer/logical/movwpreferred/MoveWidePreferred" mylink="aarch64.instrs.integer.logical.movwpreferred.MoveWidePreferred" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// MoveWidePreferred()
// ===================
//
// Return TRUE if a bitmask immediate encoding would generate an immediate
// value that could also be represented by a single MOVZ or MOVN instruction.
// Used as a condition for the preferred MOV&lt;-ORR alias.

boolean <anchor link="impl-aarch64.MoveWidePreferred.4" hover="function: boolean MoveWidePreferred(bit sf, bit immN, bits(6) imms, bits(6) immr)">MoveWidePreferred</anchor>(bit sf, bit immN, bits(6) imms, bits(6) immr)
    integer S = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(imms);
    integer R = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(immr);
    integer width = if sf == '1' then 64 else 32;

    // element size must equal total immediate size
    if sf == '1' &amp;&amp; immN:imms != '1xxxxxx' then
        return FALSE;
    if sf == '0' &amp;&amp; immN:imms != '00xxxxx' then
        return FALSE;

    // for MOVZ must contain no more than 16 ones
    if S &lt; 16 then
        // ones must not span halfword boundary when rotated
        return (-R MOD 16) &lt;= (15 - S);

    // for MOVN must contain no more than 16 zeros
    if S &gt;= width - 15 then
        // zeros must not span halfword boundary when rotated
        return (R MOD 16) &lt;= (S - (width - 15));

    return FALSE;</pstext>
    </ps>
    <ps name="aarch64/instrs/integer/shiftreg/DecodeShift" mylink="aarch64.instrs.integer.shiftreg.DecodeShift" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// DecodeShift()
// =============
// Decode shift encodings

ShiftType <anchor link="impl-aarch64.DecodeShift.1" hover="function: ShiftType DecodeShift(bits(2) op)">DecodeShift</anchor>(bits(2) op)
    case op of
        when '00'  return <a link="ShiftType_LSL" file="shared_pseudocode.xml" hover="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType_LSL</a>;
        when '01'  return <a link="ShiftType_LSR" file="shared_pseudocode.xml" hover="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType_LSR</a>;
        when '10'  return <a link="ShiftType_ASR" file="shared_pseudocode.xml" hover="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType_ASR</a>;
        when '11'  return <a link="ShiftType_ROR" file="shared_pseudocode.xml" hover="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType_ROR</a>;</pstext>
    </ps>
    <ps name="aarch64/instrs/integer/shiftreg/ShiftReg" mylink="aarch64.instrs.integer.shiftreg.ShiftReg" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ShiftReg()
// ==========
// Perform shift of a register operand

bits(N) <anchor link="impl-aarch64.ShiftReg.3" hover="function: bits(N) ShiftReg(integer reg, ShiftType shiftype, integer amount)">ShiftReg</anchor>(integer reg, <a link="ShiftType" file="shared_pseudocode.xml" hover="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType</a> shiftype, integer amount)
    bits(N) result = <a link="impl-aarch64.X.read.1" file="shared_pseudocode.xml" hover="accessor: bits(width) X[integer n]">X</a>[reg];
    case shiftype of
        when <a link="ShiftType_LSL" file="shared_pseudocode.xml" hover="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType_LSL</a> result = <a link="impl-shared.LSL.2" file="shared_pseudocode.xml" hover="function: bits(N) LSL(bits(N) x, integer shift)">LSL</a>(result, amount);
        when <a link="ShiftType_LSR" file="shared_pseudocode.xml" hover="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType_LSR</a> result = <a link="impl-shared.LSR.2" file="shared_pseudocode.xml" hover="function: bits(N) LSR(bits(N) x, integer shift)">LSR</a>(result, amount);
        when <a link="ShiftType_ASR" file="shared_pseudocode.xml" hover="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType_ASR</a> result = <a link="impl-shared.ASR.2" file="shared_pseudocode.xml" hover="function: bits(N) ASR(bits(N) x, integer shift)">ASR</a>(result, amount);
        when <a link="ShiftType_ROR" file="shared_pseudocode.xml" hover="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType_ROR</a> result = <a link="impl-shared.ROR.2" file="shared_pseudocode.xml" hover="function: bits(N) ROR(bits(N) x, integer shift)">ROR</a>(result, amount);
    return result;</pstext>
    </ps>
    <ps name="aarch64/instrs/integer/shiftreg/ShiftType" mylink="aarch64.instrs.integer.shiftreg.ShiftType" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="ShiftType" hover="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType</anchor>   {<anchor link="ShiftType_LSL" hover="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType_LSL</anchor>, <anchor link="ShiftType_LSR" hover="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType_LSR</anchor>, <anchor link="ShiftType_ASR" hover="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType_ASR</anchor>, <anchor link="ShiftType_ROR" hover="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType_ROR</anchor>};</pstext>
    </ps>
    <ps name="aarch64/instrs/logicalop/LogicalOp" mylink="aarch64.instrs.logicalop.LogicalOp" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="LogicalOp" hover="enumeration LogicalOp   {LogicalOp_AND, LogicalOp_EOR, LogicalOp_ORR}">LogicalOp</anchor>   {<anchor link="LogicalOp_AND" hover="enumeration LogicalOp   {LogicalOp_AND, LogicalOp_EOR, LogicalOp_ORR}">LogicalOp_AND</anchor>, <anchor link="LogicalOp_EOR" hover="enumeration LogicalOp   {LogicalOp_AND, LogicalOp_EOR, LogicalOp_ORR}">LogicalOp_EOR</anchor>, <anchor link="LogicalOp_ORR" hover="enumeration LogicalOp   {LogicalOp_AND, LogicalOp_EOR, LogicalOp_ORR}">LogicalOp_ORR</anchor>};</pstext>
    </ps>
    <ps name="aarch64/instrs/memory/memop/MemAtomicOp" mylink="aarch64.instrs.memory.memop.MemAtomicOp" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="MemAtomicOp" hover="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp</anchor> {<anchor link="MemAtomicOp_ADD" hover="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp_ADD</anchor>,
                         <anchor link="MemAtomicOp_BIC" hover="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp_BIC</anchor>,
                         <anchor link="MemAtomicOp_EOR" hover="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp_EOR</anchor>,
                         <anchor link="MemAtomicOp_ORR" hover="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp_ORR</anchor>,
                         <anchor link="MemAtomicOp_SMAX" hover="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp_SMAX</anchor>,
                         <anchor link="MemAtomicOp_SMIN" hover="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp_SMIN</anchor>,
                         <anchor link="MemAtomicOp_UMAX" hover="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp_UMAX</anchor>,
                         <anchor link="MemAtomicOp_UMIN" hover="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp_UMIN</anchor>,
                         <anchor link="MemAtomicOp_SWP" hover="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp_SWP</anchor>};</pstext>
    </ps>
    <ps name="aarch64/instrs/memory/memop/MemOp" mylink="aarch64.instrs.memory.memop.MemOp" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="MemOp" hover="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp</anchor> {<anchor link="MemOp_LOAD" hover="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_LOAD</anchor>, <anchor link="MemOp_STORE" hover="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_STORE</anchor>, <anchor link="MemOp_PREFETCH" hover="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_PREFETCH</anchor>};</pstext>
    </ps>
    <ps name="aarch64/instrs/memory/prefetch/Prefetch" mylink="aarch64.instrs.memory.prefetch.Prefetch" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Prefetch()
// ==========

// Decode and execute the prefetch hint on ADDRESS specified by PRFOP

<anchor link="impl-aarch64.Prefetch.2" hover="function: Prefetch(bits(64) address, bits(5) prfop)">Prefetch</anchor>(bits(64) address, bits(5) prfop)
    <a link="PrefetchHint" file="shared_pseudocode.xml" hover="enumeration PrefetchHint {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}">PrefetchHint</a> hint;
    integer target;
    boolean stream;

    case prfop&lt;4:3&gt; of
        when '00' hint = <a link="Prefetch_READ" file="shared_pseudocode.xml" hover="enumeration PrefetchHint {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}">Prefetch_READ</a>;         // PLD: prefetch for load
        when '01' hint = <a link="Prefetch_EXEC" file="shared_pseudocode.xml" hover="enumeration PrefetchHint {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}">Prefetch_EXEC</a>;         // PLI: preload instructions
        when '10' hint = <a link="Prefetch_WRITE" file="shared_pseudocode.xml" hover="enumeration PrefetchHint {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}">Prefetch_WRITE</a>;        // PST: prepare for store
        when '11' return;                       // unallocated hint
    target = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(prfop&lt;2:1&gt;);                  // target cache level
    stream = (prfop&lt;0&gt; != '0');                 // streaming (non-temporal)
    <a link="impl-shared.Hint_Prefetch.4" file="shared_pseudocode.xml" hover="function: Hint_Prefetch(bits(64) address, PrefetchHint hint, integer target, boolean stream)">Hint_Prefetch</a>(address, hint, target, stream);
    return;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/barriers/barrierop/MemBarrierOp" mylink="aarch64.instrs.system.barriers.barrierop.MemBarrierOp" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="MemBarrierOp" hover="enumeration MemBarrierOp   {  MemBarrierOp_DSB , MemBarrierOp_DMB , MemBarrierOp_ISB , MemBarrierOp_SSBB , MemBarrierOp_PSSBB , MemBarrierOp_SB }">MemBarrierOp</anchor>   {  <anchor link="MemBarrierOp_DSB" hover="enumeration MemBarrierOp   {  MemBarrierOp_DSB , MemBarrierOp_DMB , MemBarrierOp_ISB , MemBarrierOp_SSBB , MemBarrierOp_PSSBB , MemBarrierOp_SB }">MemBarrierOp_DSB</anchor>         // Data Synchronization Barrier
                            , <anchor link="MemBarrierOp_DMB" hover="enumeration MemBarrierOp   {  MemBarrierOp_DSB , MemBarrierOp_DMB , MemBarrierOp_ISB , MemBarrierOp_SSBB , MemBarrierOp_PSSBB , MemBarrierOp_SB }">MemBarrierOp_DMB</anchor>         // Data Memory Barrier
                            , <anchor link="MemBarrierOp_ISB" hover="enumeration MemBarrierOp   {  MemBarrierOp_DSB , MemBarrierOp_DMB , MemBarrierOp_ISB , MemBarrierOp_SSBB , MemBarrierOp_PSSBB , MemBarrierOp_SB }">MemBarrierOp_ISB</anchor>         // Instruction Synchronization Barrier
                            , <anchor link="MemBarrierOp_SSBB" hover="enumeration MemBarrierOp   {  MemBarrierOp_DSB , MemBarrierOp_DMB , MemBarrierOp_ISB , MemBarrierOp_SSBB , MemBarrierOp_PSSBB , MemBarrierOp_SB }">MemBarrierOp_SSBB</anchor>        // Speculative Synchronization Barrier to VA
                            , <anchor link="MemBarrierOp_PSSBB" hover="enumeration MemBarrierOp   {  MemBarrierOp_DSB , MemBarrierOp_DMB , MemBarrierOp_ISB , MemBarrierOp_SSBB , MemBarrierOp_PSSBB , MemBarrierOp_SB }">MemBarrierOp_PSSBB</anchor>       // Speculative Synchronization Barrier to PA
                            , <anchor link="MemBarrierOp_SB" hover="enumeration MemBarrierOp   {  MemBarrierOp_DSB , MemBarrierOp_DMB , MemBarrierOp_ISB , MemBarrierOp_SSBB , MemBarrierOp_PSSBB , MemBarrierOp_SB }">MemBarrierOp_SB</anchor>          // Speculation Barrier
                           };</pstext>
    </ps>
    <ps name="aarch64/instrs/system/hints/syshintop/SystemHintOp" mylink="aarch64.instrs.system.hints.syshintop.SystemHintOp" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="SystemHintOp" hover="enumeration SystemHintOp {&#13; SystemHintOp_NOP,&#13; SystemHintOp_YIELD,&#13; SystemHintOp_WFE,&#13; SystemHintOp_WFI,&#13; SystemHintOp_SEV,&#13; SystemHintOp_SEVL,&#13; SystemHintOp_DGH,&#13; SystemHintOp_ESB,&#13; SystemHintOp_PSB,&#13; SystemHintOp_TSB,&#13; SystemHintOp_BTI,&#13; SystemHintOp_WFET,&#13; SystemHintOp_WFIT,&#13; SystemHintOp_CSDB&#13; }">SystemHintOp</anchor> {
    <anchor link="SystemHintOp_NOP" hover="enumeration SystemHintOp {&#13; SystemHintOp_NOP,&#13; SystemHintOp_YIELD,&#13; SystemHintOp_WFE,&#13; SystemHintOp_WFI,&#13; SystemHintOp_SEV,&#13; SystemHintOp_SEVL,&#13; SystemHintOp_DGH,&#13; SystemHintOp_ESB,&#13; SystemHintOp_PSB,&#13; SystemHintOp_TSB,&#13; SystemHintOp_BTI,&#13; SystemHintOp_WFET,&#13; SystemHintOp_WFIT,&#13; SystemHintOp_CSDB&#13; }">SystemHintOp_NOP</anchor>,
    <anchor link="SystemHintOp_YIELD" hover="enumeration SystemHintOp {&#13; SystemHintOp_NOP,&#13; SystemHintOp_YIELD,&#13; SystemHintOp_WFE,&#13; SystemHintOp_WFI,&#13; SystemHintOp_SEV,&#13; SystemHintOp_SEVL,&#13; SystemHintOp_DGH,&#13; SystemHintOp_ESB,&#13; SystemHintOp_PSB,&#13; SystemHintOp_TSB,&#13; SystemHintOp_BTI,&#13; SystemHintOp_WFET,&#13; SystemHintOp_WFIT,&#13; SystemHintOp_CSDB&#13; }">SystemHintOp_YIELD</anchor>,
    <anchor link="SystemHintOp_WFE" hover="enumeration SystemHintOp {&#13; SystemHintOp_NOP,&#13; SystemHintOp_YIELD,&#13; SystemHintOp_WFE,&#13; SystemHintOp_WFI,&#13; SystemHintOp_SEV,&#13; SystemHintOp_SEVL,&#13; SystemHintOp_DGH,&#13; SystemHintOp_ESB,&#13; SystemHintOp_PSB,&#13; SystemHintOp_TSB,&#13; SystemHintOp_BTI,&#13; SystemHintOp_WFET,&#13; SystemHintOp_WFIT,&#13; SystemHintOp_CSDB&#13; }">SystemHintOp_WFE</anchor>,
    <anchor link="SystemHintOp_WFI" hover="enumeration SystemHintOp {&#13; SystemHintOp_NOP,&#13; SystemHintOp_YIELD,&#13; SystemHintOp_WFE,&#13; SystemHintOp_WFI,&#13; SystemHintOp_SEV,&#13; SystemHintOp_SEVL,&#13; SystemHintOp_DGH,&#13; SystemHintOp_ESB,&#13; SystemHintOp_PSB,&#13; SystemHintOp_TSB,&#13; SystemHintOp_BTI,&#13; SystemHintOp_WFET,&#13; SystemHintOp_WFIT,&#13; SystemHintOp_CSDB&#13; }">SystemHintOp_WFI</anchor>,
    <anchor link="SystemHintOp_SEV" hover="enumeration SystemHintOp {&#13; SystemHintOp_NOP,&#13; SystemHintOp_YIELD,&#13; SystemHintOp_WFE,&#13; SystemHintOp_WFI,&#13; SystemHintOp_SEV,&#13; SystemHintOp_SEVL,&#13; SystemHintOp_DGH,&#13; SystemHintOp_ESB,&#13; SystemHintOp_PSB,&#13; SystemHintOp_TSB,&#13; SystemHintOp_BTI,&#13; SystemHintOp_WFET,&#13; SystemHintOp_WFIT,&#13; SystemHintOp_CSDB&#13; }">SystemHintOp_SEV</anchor>,
    <anchor link="SystemHintOp_SEVL" hover="enumeration SystemHintOp {&#13; SystemHintOp_NOP,&#13; SystemHintOp_YIELD,&#13; SystemHintOp_WFE,&#13; SystemHintOp_WFI,&#13; SystemHintOp_SEV,&#13; SystemHintOp_SEVL,&#13; SystemHintOp_DGH,&#13; SystemHintOp_ESB,&#13; SystemHintOp_PSB,&#13; SystemHintOp_TSB,&#13; SystemHintOp_BTI,&#13; SystemHintOp_WFET,&#13; SystemHintOp_WFIT,&#13; SystemHintOp_CSDB&#13; }">SystemHintOp_SEVL</anchor>,
    <anchor link="SystemHintOp_DGH" hover="enumeration SystemHintOp {&#13; SystemHintOp_NOP,&#13; SystemHintOp_YIELD,&#13; SystemHintOp_WFE,&#13; SystemHintOp_WFI,&#13; SystemHintOp_SEV,&#13; SystemHintOp_SEVL,&#13; SystemHintOp_DGH,&#13; SystemHintOp_ESB,&#13; SystemHintOp_PSB,&#13; SystemHintOp_TSB,&#13; SystemHintOp_BTI,&#13; SystemHintOp_WFET,&#13; SystemHintOp_WFIT,&#13; SystemHintOp_CSDB&#13; }">SystemHintOp_DGH</anchor>,
    <anchor link="SystemHintOp_ESB" hover="enumeration SystemHintOp {&#13; SystemHintOp_NOP,&#13; SystemHintOp_YIELD,&#13; SystemHintOp_WFE,&#13; SystemHintOp_WFI,&#13; SystemHintOp_SEV,&#13; SystemHintOp_SEVL,&#13; SystemHintOp_DGH,&#13; SystemHintOp_ESB,&#13; SystemHintOp_PSB,&#13; SystemHintOp_TSB,&#13; SystemHintOp_BTI,&#13; SystemHintOp_WFET,&#13; SystemHintOp_WFIT,&#13; SystemHintOp_CSDB&#13; }">SystemHintOp_ESB</anchor>,
    <anchor link="SystemHintOp_PSB" hover="enumeration SystemHintOp {&#13; SystemHintOp_NOP,&#13; SystemHintOp_YIELD,&#13; SystemHintOp_WFE,&#13; SystemHintOp_WFI,&#13; SystemHintOp_SEV,&#13; SystemHintOp_SEVL,&#13; SystemHintOp_DGH,&#13; SystemHintOp_ESB,&#13; SystemHintOp_PSB,&#13; SystemHintOp_TSB,&#13; SystemHintOp_BTI,&#13; SystemHintOp_WFET,&#13; SystemHintOp_WFIT,&#13; SystemHintOp_CSDB&#13; }">SystemHintOp_PSB</anchor>,
    <anchor link="SystemHintOp_TSB" hover="enumeration SystemHintOp {&#13; SystemHintOp_NOP,&#13; SystemHintOp_YIELD,&#13; SystemHintOp_WFE,&#13; SystemHintOp_WFI,&#13; SystemHintOp_SEV,&#13; SystemHintOp_SEVL,&#13; SystemHintOp_DGH,&#13; SystemHintOp_ESB,&#13; SystemHintOp_PSB,&#13; SystemHintOp_TSB,&#13; SystemHintOp_BTI,&#13; SystemHintOp_WFET,&#13; SystemHintOp_WFIT,&#13; SystemHintOp_CSDB&#13; }">SystemHintOp_TSB</anchor>,
    <anchor link="SystemHintOp_BTI" hover="enumeration SystemHintOp {&#13; SystemHintOp_NOP,&#13; SystemHintOp_YIELD,&#13; SystemHintOp_WFE,&#13; SystemHintOp_WFI,&#13; SystemHintOp_SEV,&#13; SystemHintOp_SEVL,&#13; SystemHintOp_DGH,&#13; SystemHintOp_ESB,&#13; SystemHintOp_PSB,&#13; SystemHintOp_TSB,&#13; SystemHintOp_BTI,&#13; SystemHintOp_WFET,&#13; SystemHintOp_WFIT,&#13; SystemHintOp_CSDB&#13; }">SystemHintOp_BTI</anchor>,
    <anchor link="SystemHintOp_WFET" hover="enumeration SystemHintOp {&#13; SystemHintOp_NOP,&#13; SystemHintOp_YIELD,&#13; SystemHintOp_WFE,&#13; SystemHintOp_WFI,&#13; SystemHintOp_SEV,&#13; SystemHintOp_SEVL,&#13; SystemHintOp_DGH,&#13; SystemHintOp_ESB,&#13; SystemHintOp_PSB,&#13; SystemHintOp_TSB,&#13; SystemHintOp_BTI,&#13; SystemHintOp_WFET,&#13; SystemHintOp_WFIT,&#13; SystemHintOp_CSDB&#13; }">SystemHintOp_WFET</anchor>,
    <anchor link="SystemHintOp_WFIT" hover="enumeration SystemHintOp {&#13; SystemHintOp_NOP,&#13; SystemHintOp_YIELD,&#13; SystemHintOp_WFE,&#13; SystemHintOp_WFI,&#13; SystemHintOp_SEV,&#13; SystemHintOp_SEVL,&#13; SystemHintOp_DGH,&#13; SystemHintOp_ESB,&#13; SystemHintOp_PSB,&#13; SystemHintOp_TSB,&#13; SystemHintOp_BTI,&#13; SystemHintOp_WFET,&#13; SystemHintOp_WFIT,&#13; SystemHintOp_CSDB&#13; }">SystemHintOp_WFIT</anchor>,
    <anchor link="SystemHintOp_CSDB" hover="enumeration SystemHintOp {&#13; SystemHintOp_NOP,&#13; SystemHintOp_YIELD,&#13; SystemHintOp_WFE,&#13; SystemHintOp_WFI,&#13; SystemHintOp_SEV,&#13; SystemHintOp_SEVL,&#13; SystemHintOp_DGH,&#13; SystemHintOp_ESB,&#13; SystemHintOp_PSB,&#13; SystemHintOp_TSB,&#13; SystemHintOp_BTI,&#13; SystemHintOp_WFET,&#13; SystemHintOp_WFIT,&#13; SystemHintOp_CSDB&#13; }">SystemHintOp_CSDB</anchor>
};</pstext>
    </ps>
    <ps name="aarch64/instrs/system/register/cpsr/pstatefield/PSTATEField" mylink="aarch64.instrs.system.register.cpsr.pstatefield.PSTATEField" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="PSTATEField" hover="enumeration PSTATEField {PSTATEField_DAIFSet, PSTATEField_DAIFClr,&#13; PSTATEField_PAN, PSTATEField_UAO, PSTATEField_DIT, PSTATEField_SSBS,&#13; PSTATEField_TCO, PSTATEField_ALLINT,&#13; PSTATEField_SP&#13; }">PSTATEField</anchor> {<anchor link="PSTATEField_DAIFSet" hover="enumeration PSTATEField {PSTATEField_DAIFSet, PSTATEField_DAIFClr,&#13; PSTATEField_PAN, PSTATEField_UAO, PSTATEField_DIT, PSTATEField_SSBS,&#13; PSTATEField_TCO, PSTATEField_ALLINT,&#13; PSTATEField_SP&#13; }">PSTATEField_DAIFSet</anchor>, <anchor link="PSTATEField_DAIFClr" hover="enumeration PSTATEField {PSTATEField_DAIFSet, PSTATEField_DAIFClr,&#13; PSTATEField_PAN, PSTATEField_UAO, PSTATEField_DIT, PSTATEField_SSBS,&#13; PSTATEField_TCO, PSTATEField_ALLINT,&#13; PSTATEField_SP&#13; }">PSTATEField_DAIFClr</anchor>,
                         <anchor link="PSTATEField_PAN" hover="enumeration PSTATEField {PSTATEField_DAIFSet, PSTATEField_DAIFClr,&#13; PSTATEField_PAN, PSTATEField_UAO, PSTATEField_DIT, PSTATEField_SSBS,&#13; PSTATEField_TCO, PSTATEField_ALLINT,&#13; PSTATEField_SP&#13; }">PSTATEField_PAN</anchor>, // Armv8.1
                         <anchor link="PSTATEField_UAO" hover="enumeration PSTATEField {PSTATEField_DAIFSet, PSTATEField_DAIFClr,&#13; PSTATEField_PAN, PSTATEField_UAO, PSTATEField_DIT, PSTATEField_SSBS,&#13; PSTATEField_TCO, PSTATEField_ALLINT,&#13; PSTATEField_SP&#13; }">PSTATEField_UAO</anchor>, // Armv8.2
                         <anchor link="PSTATEField_DIT" hover="enumeration PSTATEField {PSTATEField_DAIFSet, PSTATEField_DAIFClr,&#13; PSTATEField_PAN, PSTATEField_UAO, PSTATEField_DIT, PSTATEField_SSBS,&#13; PSTATEField_TCO, PSTATEField_ALLINT,&#13; PSTATEField_SP&#13; }">PSTATEField_DIT</anchor>, // Armv8.4
                         <anchor link="PSTATEField_SSBS" hover="enumeration PSTATEField {PSTATEField_DAIFSet, PSTATEField_DAIFClr,&#13; PSTATEField_PAN, PSTATEField_UAO, PSTATEField_DIT, PSTATEField_SSBS,&#13; PSTATEField_TCO, PSTATEField_ALLINT,&#13; PSTATEField_SP&#13; }">PSTATEField_SSBS</anchor>,
                         <anchor link="PSTATEField_TCO" hover="enumeration PSTATEField {PSTATEField_DAIFSet, PSTATEField_DAIFClr,&#13; PSTATEField_PAN, PSTATEField_UAO, PSTATEField_DIT, PSTATEField_SSBS,&#13; PSTATEField_TCO, PSTATEField_ALLINT,&#13; PSTATEField_SP&#13; }">PSTATEField_TCO</anchor>, // Armv8.5
                         <anchor link="PSTATEField_ALLINT" hover="enumeration PSTATEField {PSTATEField_DAIFSet, PSTATEField_DAIFClr,&#13; PSTATEField_PAN, PSTATEField_UAO, PSTATEField_DIT, PSTATEField_SSBS,&#13; PSTATEField_TCO, PSTATEField_ALLINT,&#13; PSTATEField_SP&#13; }">PSTATEField_ALLINT</anchor>,
                         <anchor link="PSTATEField_SP" hover="enumeration PSTATEField {PSTATEField_DAIFSet, PSTATEField_DAIFClr,&#13; PSTATEField_PAN, PSTATEField_UAO, PSTATEField_DIT, PSTATEField_SSBS,&#13; PSTATEField_TCO, PSTATEField_ALLINT,&#13; PSTATEField_SP&#13; }">PSTATEField_SP</anchor>
                         };</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/at/AArch64.AT" mylink="aarch64.instrs.system.sysops.at.AArch64.AT" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.AT()
// ============
// Perform address translation as per AT instructions.

<anchor link="AArch64.AT.4" hover="function: AArch64.AT(bits(64) address, TranslationStage stage_in, bits(2) el_in, ATAccess ataccess)">AArch64.AT</anchor>(bits(64) address, <a link="TranslationStage" file="shared_pseudocode.xml" hover="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage</a> stage_in, bits(2) el_in, <a link="ATAccess" file="shared_pseudocode.xml" hover="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess</a> ataccess)
    <a link="TranslationStage" file="shared_pseudocode.xml" hover="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage</a> stage = stage_in;
    bits(2) el = el_in;
    // For stage 1 translation, when HCR_EL2.{E2H, TGE} is {1,1} and requested EL is EL1,
    // the EL2&amp;0 translation regime is used.
    if HCR_EL2.&lt;E2H, TGE&gt; == '11' &amp;&amp; el == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; stage == <a link="TranslationStage_1" file="shared_pseudocode.xml" hover="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_1</a> then
        el = <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;
    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; stage == <a link="TranslationStage_12" file="shared_pseudocode.xml" hover="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_12</a> &amp;&amp; !<a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() then
        stage = <a link="TranslationStage_1" file="shared_pseudocode.xml" hover="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_1</a>;

    acctype = if ataccess IN {<a link="ATAccess_Read" file="shared_pseudocode.xml" hover="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess_Read</a>, <a link="ATAccess_Write" file="shared_pseudocode.xml" hover="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess_Write</a>} then <a link="AccType_AT" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</a> else <a link="AccType_ATPAN" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATPAN</a>;
    iswrite = ataccess IN {<a link="ATAccess_WritePAN" file="shared_pseudocode.xml" hover="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess_WritePAN</a>, <a link="ATAccess_Write" file="shared_pseudocode.xml" hover="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess_Write</a>};
    aligned = TRUE;
    ispriv  = el != <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>;

    fault = <a link="impl-shared.NoFault.0" file="shared_pseudocode.xml" hover="function: FaultRecord NoFault()">NoFault</a>();
    fault.acctype = acctype;
    fault.write = iswrite;

    <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime;
    if stage == <a link="TranslationStage_12" file="shared_pseudocode.xml" hover="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_12</a> then
        regime = <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>;
    else
        regime = <a link="impl-shared.TranslationRegime.2" file="shared_pseudocode.xml" hover="function: Regime TranslationRegime(bits(2) el, AccType acctype)">TranslationRegime</a>(el, acctype);

    <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> addrdesc;
    ss = <a link="impl-shared.SecurityStateAtEL.1" file="shared_pseudocode.xml" hover="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(el);
    if (el == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>)) || (el != <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(el)) then
        if regime == <a link="Regime_EL2" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a> || TTBCR.EAE == '1' then
            (fault, addrdesc) = <a link="AArch32.S1TranslateLD.8" file="shared_pseudocode.xml" hover="function: (FaultRecord, AddressDescriptor) AArch32.S1TranslateLD(FaultRecord fault_in, Regime regime,&#13; SecurityState ss, bits(32) va,&#13; AccType acctype, boolean aligned,&#13; boolean iswrite, boolean ispriv)">AArch32.S1TranslateLD</a>(fault, regime, ss, address&lt;31:0&gt;, acctype,
                                                      aligned, iswrite, ispriv);
        else
            (fault, addrdesc, -) = <a link="AArch32.S1TranslateSD.8" file="shared_pseudocode.xml" hover="function: (FaultRecord, AddressDescriptor, SDFType) AArch32.S1TranslateSD(FaultRecord fault_in, Regime regime,&#13; SecurityState ss, bits(32) va,&#13; AccType acctype, boolean aligned,&#13; boolean iswrite, boolean ispriv)">AArch32.S1TranslateSD</a>(fault, regime, ss, address&lt;31:0&gt;, acctype,
                                                         aligned, iswrite, ispriv);
    else
        (fault, addrdesc) = <a link="AArch64.S1Translate.8" file="shared_pseudocode.xml" hover="function: (FaultRecord, AddressDescriptor) AArch64.S1Translate(FaultRecord fault_in, Regime regime,&#13; SecurityState ss, bits(64) va,&#13; AccType acctype, boolean aligned_in,&#13; boolean iswrite_in, boolean ispriv)">AArch64.S1Translate</a>(fault, regime, ss, address, acctype, aligned,
                                                iswrite, ispriv);

    if stage == <a link="TranslationStage_12" file="shared_pseudocode.xml" hover="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_12</a> &amp;&amp; fault.statuscode == <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; regime == <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() then
            addrdesc.vaddress = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(address);
            s2fs1walk = FALSE;
            (fault, addrdesc) = <a link="AArch32.S2Translate.8" file="shared_pseudocode.xml" hover="function: (FaultRecord, AddressDescriptor) AArch32.S2Translate(FaultRecord fault_in, AddressDescriptor ipa,&#13; SecurityState ss, boolean s2fs1walk,&#13; AccType acctype, boolean aligned,&#13; boolean iswrite, boolean ispriv)">AArch32.S2Translate</a>(fault, addrdesc, ss, s2fs1walk, acctype,
                                                    aligned, iswrite, ispriv);
        elsif regime == <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() then
            s1aarch64 = TRUE;
            s2fs1walk = FALSE;
            (fault, addrdesc) = <a link="AArch64.S2Translate.9" file="shared_pseudocode.xml" hover="function: (FaultRecord, AddressDescriptor) AArch64.S2Translate(FaultRecord fault_in, AddressDescriptor ipa,&#13; boolean s1aarch64, SecurityState ss,&#13; boolean s2fs1walk, AccType acctype,&#13; boolean aligned, boolean iswrite,&#13; boolean ispriv)">AArch64.S2Translate</a>(fault, addrdesc, s1aarch64, ss, s2fs1walk,
                                                    acctype, aligned, iswrite, ispriv);

    is_ATS1Ex = stage != <a link="TranslationStage_12" file="shared_pseudocode.xml" hover="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_12</a>;
    if fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        addrdesc = <a link="impl-shared.CreateFaultyAddressDescriptor.2" file="shared_pseudocode.xml" hover="function: AddressDescriptor CreateFaultyAddressDescriptor(bits(64) va, FaultRecord fault)">CreateFaultyAddressDescriptor</a>(address, fault);
        // Take an exception on:
        // * A Synchronous external abort occurs on translation table walk
        // * A stage 2 fault occurs on a stage 1 walk
        if <a link="impl-shared.IsExternalAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) || (PSTATE.EL == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; fault.s2fs1walk) then
            PAR_EL1 = bits(64) UNKNOWN;
            <a link="AArch64.Abort.2" file="shared_pseudocode.xml" hover="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, addrdesc.fault);

    <a link="AArch64.EncodePAR.2" file="shared_pseudocode.xml" hover="function: AArch64.EncodePAR(Regime regime, AddressDescriptor addrdesc)">AArch64.EncodePAR</a>(regime, addrdesc);
    return;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/at/AArch64.EncodePAR" mylink="aarch64.instrs.system.sysops.at.AArch64.EncodePAR" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.EncodePAR()
// ===================
// Encode PAR register with result of translation.

<anchor link="AArch64.EncodePAR.2" hover="function: AArch64.EncodePAR(Regime regime, AddressDescriptor addrdesc)">AArch64.EncodePAR</anchor>(<a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> addrdesc)
    PAR_EL1 = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();
    paspace = addrdesc.paddress.paspace;

    if !<a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(addrdesc) then
        PAR_EL1.F = '0';
        PAR_EL1&lt;11&gt; = '1'; // RES1
        if <a link="impl-shared.SecurityStateForRegime.1" file="shared_pseudocode.xml" hover="function: SecurityState SecurityStateForRegime(Regime regime)">SecurityStateForRegime</a>(regime) == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> then
            PAR_EL1.NS = if paspace == <a link="PAS_Secure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_Secure</a> then '0' else '1';
        else
            PAR_EL1.NS = bit UNKNOWN;
        PAR_EL1.SH   = ReportedPARShareability(<a link="impl-shared.PAREncodeShareability.1" file="shared_pseudocode.xml" hover="function: bits(2) PAREncodeShareability(MemoryAttributes memattrs)">PAREncodeShareability</a>(addrdesc.memattrs));
        PAR_EL1.PA   = addrdesc.paddress.address&lt;52-1:12&gt;;
        PAR_EL1.ATTR = ReportedPARAttrs(<a link="impl-shared.EncodePARAttrs.1" file="shared_pseudocode.xml" hover="function: bits(8) EncodePARAttrs(MemoryAttributes memattrs)">EncodePARAttrs</a>(addrdesc.memattrs));
        PAR_EL1&lt;10&gt; = bit IMPLEMENTATION_DEFINED "Non-Faulting PAR";
    else
        PAR_EL1.F   = '1';
        PAR_EL1.FST = <a link="AArch64.PARFaultStatus.1" file="shared_pseudocode.xml" hover="function: bits(6) AArch64.PARFaultStatus(FaultRecord fault)">AArch64.PARFaultStatus</a>(addrdesc.fault);
        PAR_EL1.PTW = if addrdesc.fault.s2fs1walk then '1' else '0';
        PAR_EL1.S   = if addrdesc.fault.secondstage then '1' else '0';
        PAR_EL1&lt;11&gt; = '1'; // RES1
        PAR_EL1&lt;63:48&gt; = bits(16) IMPLEMENTATION_DEFINED "Faulting PAR";
    return;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/at/AArch64.PARFaultStatus" mylink="aarch64.instrs.system.sysops.at.AArch64.PARFaultStatus" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.PARFaultStatus()
// ========================
// Fault status field decoding of 64-bit PAR.

bits(6) <anchor link="AArch64.PARFaultStatus.1" hover="function: bits(6) AArch64.PARFaultStatus(FaultRecord fault)">AArch64.PARFaultStatus</anchor>(<a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    bits(6) fst;

    if fault.statuscode == <a link="Fault_Domain" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Domain</a> then
        // Report Domain fault
        assert fault.level IN {1,2};
        fst&lt;1:0&gt; = if fault.level == 1 then '01' else '10';
        fst&lt;5:2&gt; = '1111';
    else
        fst = <a link="impl-shared.EncodeLDFSC.2" file="shared_pseudocode.xml" hover="function: bits(6) EncodeLDFSC(Fault statuscode, integer level)">EncodeLDFSC</a>(fault.statuscode, fault.level);
    return fst;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/dc/AArch64.DC" mylink="aarch64.instrs.system.sysops.dc.AArch64.DC" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.DC()
// ============
// Perform Data Cache Operation.

<anchor link="AArch64.DC.4" hover="function: AArch64.DC(bits(64) regval, CacheType cachetype, CacheOp cacheop, CacheOpScope opscope_in)">AArch64.DC</anchor>(bits(64) regval, <a link="CacheType" file="shared_pseudocode.xml" hover="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType</a> cachetype, <a link="CacheOp" file="shared_pseudocode.xml" hover="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp</a> cacheop, <a link="CacheOpScope" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a> opscope_in)
    <a link="CacheOpScope" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a> opscope = opscope_in;
    <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype = <a link="AccType_DC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>;
    <a link="CacheRecord" file="shared_pseudocode.xml" hover="type CacheRecord is ( AccType acctype, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, bits(64) regval, FullAddress paddress, bits(64) vaddress, integer set, integer way, integer level, Shareability shareability, boolean translated, boolean is_vmid_valid, bits(16) vmid, boolean is_asid_valid, bits(16) asid, SecurityState security, CachePASpace cpas )">CacheRecord</a> cache;

    cache.acctype = acctype;
    cache.cachetype = cachetype;
    cache.cacheop = cacheop;
    cache.opscope = opscope;

    if opscope == <a link="CacheOpScope_SetWay" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_SetWay</a> then
        ss = <a link="impl-shared.SecurityStateAtEL.1" file="shared_pseudocode.xml" hover="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(PSTATE.EL);
        cache.cpas = <a link="impl-shared.CPASAtSecurityState.1" file="shared_pseudocode.xml" hover="function: CachePASpace CPASAtSecurityState(SecurityState ss)">CPASAtSecurityState</a>(ss);
        cache.shareability = <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        (cache.set, cache.way, cache.level) = <a link="impl-shared.DecodeSW.2" file="shared_pseudocode.xml" hover="function: (integer, integer, integer) DecodeSW(bits(64) regval, CacheType cachetype)">DecodeSW</a>(regval, cachetype);
        if (cacheop == <a link="CacheOp_Invalidate" file="shared_pseudocode.xml" hover="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Invalidate</a> &amp;&amp; PSTATE.EL == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
          (HCR_EL2.SWIO == '1' || HCR_EL2.&lt;DC,VM&gt; != '00')) then
            cache.cacheop = <a link="CacheOp_CleanInvalidate" file="shared_pseudocode.xml" hover="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_CleanInvalidate</a>;

        <a link="impl-shared.CACHE_OP.1" file="shared_pseudocode.xml" hover="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
        return;

    if <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a link="impl-shared.IsInHost.0" file="shared_pseudocode.xml" hover="function: boolean IsInHost()">IsInHost</a>() then
        if PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} then
            cache.is_vmid_valid = TRUE;
            cache.vmid          = <a link="impl-aarch64.VMID.read.0" file="shared_pseudocode.xml" hover="accessor: bits(16) VMID[]">VMID</a>[];
        else
            cache.is_vmid_valid = FALSE;
    else
        cache.is_vmid_valid = FALSE;

    if PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then
        cache.is_asid_valid = TRUE;
        cache.asid          = <a link="impl-shared.ASID.read.0" file="shared_pseudocode.xml" hover="accessor: bits(16) ASID[]">ASID</a>[];
    else
        cache.is_asid_valid = FALSE;

    if opscope == <a link="CacheOpScope_PoDP" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoDP</a> &amp;&amp; boolean IMPLEMENTATION_DEFINED "Memory system does not supports PoDP" then
        opscope = <a link="CacheOpScope_PoP" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoP</a>;
    if opscope == <a link="CacheOpScope_PoP" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoP</a> &amp;&amp; boolean IMPLEMENTATION_DEFINED "Memory system does not supports PoP" then
        opscope = <a link="CacheOpScope_PoC" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoC</a>;
    need_translate = <a link="impl-shared.DCInstNeedsTranslation.1" file="shared_pseudocode.xml" hover="function: boolean DCInstNeedsTranslation(CacheOpScope opscope)">DCInstNeedsTranslation</a>(opscope);
    iswrite = cacheop == <a link="CacheOp_Invalidate" file="shared_pseudocode.xml" hover="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Invalidate</a>;
    vaddress = regval;

    size = 0;        // by default no watchpoint address
    if iswrite then
        size = integer IMPLEMENTATION_DEFINED "Data Cache Invalidate Watchpoint Size";
        assert size &gt;= 4*(2^(<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(CTR_EL0.DminLine))) &amp;&amp; size &lt;= 2048;
        assert <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(size&lt;32:0&gt; AND (size-1)&lt;32:0&gt;) == 0; // size is power of 2
        vaddress = <a link="impl-shared.Align.2" file="shared_pseudocode.xml" hover="function: integer Align(integer x, integer y)">Align</a>(regval, size);

    cache.translated = need_translate;
    cache.vaddress = vaddress;

    if need_translate then
        wasaligned = TRUE;
        memaddrdesc = <a link="AArch64.TranslateAddress.5" file="shared_pseudocode.xml" hover="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccType acctype, boolean iswrite,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(vaddress, acctype, iswrite, wasaligned, size);
        if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
            <a link="AArch64.Abort.2" file="shared_pseudocode.xml" hover="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(regval, memaddrdesc.fault);

        memattrs = memaddrdesc.memattrs;
        cache.paddress = memaddrdesc.paddress;
        cache.cpas = <a link="impl-shared.CPASAtPAS.1" file="shared_pseudocode.xml" hover="function: CachePASpace CPASAtPAS(PASpace pas)">CPASAtPAS</a>(memaddrdesc.paddress.paspace);
        if opscope IN {<a link="CacheOpScope_PoC" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoC</a>, <a link="CacheOpScope_PoP" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoP</a>, <a link="CacheOpScope_PoDP" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoDP</a>} then
            cache.shareability = memattrs.shareability;
        else
            cache.shareability = <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
    else
        cache.shareability = <a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> UNKNOWN;
        cache.paddress = <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> UNKNOWN;

    if cacheop == <a link="CacheOp_Invalidate" file="shared_pseudocode.xml" hover="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Invalidate</a> &amp;&amp; PSTATE.EL == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.&lt;DC,VM&gt; != '00' then
        cache.cacheop = <a link="CacheOp_CleanInvalidate" file="shared_pseudocode.xml" hover="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_CleanInvalidate</a>;

    <a link="impl-shared.CACHE_OP.1" file="shared_pseudocode.xml" hover="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
    return;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/dc/AArch64.MemZero" mylink="aarch64.instrs.system.sysops.dc.AArch64.MemZero" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.MemZero()
// =================

<anchor link="AArch64.MemZero.2" hover="function: AArch64.MemZero(bits(64) regval, CacheType cachetype)">AArch64.MemZero</anchor>(bits(64) regval, <a link="CacheType" file="shared_pseudocode.xml" hover="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType</a> cachetype)

    <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype = <a link="AccType_DCZVA" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DCZVA</a>;
    boolean iswrite = TRUE;
    boolean wasaligned = TRUE;

    integer size = 4*(2^(<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(DCZID_EL0.BS)));
    bits(64) vaddress = <a link="impl-shared.Align.2" file="shared_pseudocode.xml" hover="function: integer Align(integer x, integer y)">Align</a>(regval, size);

    memaddrdesc = <a link="AArch64.TranslateAddress.5" file="shared_pseudocode.xml" hover="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccType acctype, boolean iswrite,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(vaddress, acctype, iswrite, wasaligned, size);

    if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        if <a link="impl-shared.IsDebugException.1" file="shared_pseudocode.xml" hover="function: boolean IsDebugException(FaultRecord fault)">IsDebugException</a>(memaddrdesc.fault) then
            <a link="AArch64.Abort.2" file="shared_pseudocode.xml" hover="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(vaddress, memaddrdesc.fault);
        else
            <a link="AArch64.Abort.2" file="shared_pseudocode.xml" hover="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(regval, memaddrdesc.fault);
    else
        if cachetype == <a link="CacheType_Data" file="shared_pseudocode.xml" hover="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType_Data</a> then
            <a link="AArch64.DataMemZero.4" file="shared_pseudocode.xml" hover="function: AArch64.DataMemZero(bits(64) regval, bits(64) vaddress, AddressDescriptor memaddrdesc_in, integer size)">AArch64.DataMemZero</a>(regval, vaddress, memaddrdesc, size);
        elsif cachetype == <a link="CacheType_Tag" file="shared_pseudocode.xml" hover="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType_Tag</a> then
            if <a link="impl-shared.HaveMTEExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveMTEExt()">HaveMTEExt</a>() then <a link="AArch64.TagMemZero.2" file="shared_pseudocode.xml" hover="function: AArch64.TagMemZero(bits(64) vaddress_in, integer size)">AArch64.TagMemZero</a>(vaddress, size);
        elsif cachetype == <a link="CacheType_Data_Tag" file="shared_pseudocode.xml" hover="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType_Data_Tag</a> then
            if <a link="impl-shared.HaveMTEExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveMTEExt()">HaveMTEExt</a>() then <a link="AArch64.TagMemZero.2" file="shared_pseudocode.xml" hover="function: AArch64.TagMemZero(bits(64) vaddress_in, integer size)">AArch64.TagMemZero</a>(vaddress, size);
            <a link="AArch64.DataMemZero.4" file="shared_pseudocode.xml" hover="function: AArch64.DataMemZero(bits(64) regval, bits(64) vaddress, AddressDescriptor memaddrdesc_in, integer size)">AArch64.DataMemZero</a>(regval, vaddress, memaddrdesc, size);
    return;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/ic/AArch64.IC" mylink="aarch64.instrs.system.sysops.ic.AArch64.IC" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.IC()
// ============
// Perform Instruction Cache Operation.

<anchor link="AArch64.IC.1" hover="function: AArch64.IC(CacheOpScope opscope)">AArch64.IC</anchor>(<a link="CacheOpScope" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a> opscope)
    regval = bits(64) UNKNOWN;
    <a link="AArch64.IC.2" file="shared_pseudocode.xml" hover="function: AArch64.IC(bits(64) regval, CacheOpScope opscope)">AArch64.IC</a>(regval, opscope);

// AArch64.IC()
// ============
// Perform Instruction Cache Operation.

<anchor link="AArch64.IC.2" hover="function: AArch64.IC(bits(64) regval, CacheOpScope opscope)">AArch64.IC</anchor>(bits(64) regval, <a link="CacheOpScope" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a> opscope)
    <a link="CacheRecord" file="shared_pseudocode.xml" hover="type CacheRecord is ( AccType acctype, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, bits(64) regval, FullAddress paddress, bits(64) vaddress, integer set, integer way, integer level, Shareability shareability, boolean translated, boolean is_vmid_valid, bits(16) vmid, boolean is_asid_valid, bits(16) asid, SecurityState security, CachePASpace cpas )">CacheRecord</a> cache;
    <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype = <a link="AccType_IC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>;

    cache.acctype = acctype;
    cache.cachetype = <a link="CacheType_Instruction" file="shared_pseudocode.xml" hover="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType_Instruction</a>;
    cache.cacheop = <a link="CacheOp_Invalidate" file="shared_pseudocode.xml" hover="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Invalidate</a>;
    cache.opscope = opscope;

    if opscope IN {<a link="CacheOpScope_ALLU" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_ALLU</a>, <a link="CacheOpScope_ALLUIS" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_ALLUIS</a>} then
        ss = <a link="impl-shared.SecurityStateAtEL.1" file="shared_pseudocode.xml" hover="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(PSTATE.EL);
        cache.cpas = <a link="impl-shared.CPASAtSecurityState.1" file="shared_pseudocode.xml" hover="function: CachePASpace CPASAtSecurityState(SecurityState ss)">CPASAtSecurityState</a>(ss);
        if (opscope == <a link="CacheOpScope_ALLUIS" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_ALLUIS</a> || (opscope == <a link="CacheOpScope_ALLU" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_ALLU</a> &amp;&amp; PSTATE.EL == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>
            &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.FB == '1')) then
            cache.shareability = <a link="Shareability_ISH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_ISH</a>;
        else
            cache.shareability = <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        cache.regval = regval;
        <a link="impl-shared.CACHE_OP.1" file="shared_pseudocode.xml" hover="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
    else
        assert opscope == <a link="CacheOpScope_PoU" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoU</a>;

        if <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a link="impl-shared.IsInHost.0" file="shared_pseudocode.xml" hover="function: boolean IsInHost()">IsInHost</a>() then
            if PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} then
                cache.is_vmid_valid = TRUE;
                cache.vmid          = <a link="impl-aarch64.VMID.read.0" file="shared_pseudocode.xml" hover="accessor: bits(16) VMID[]">VMID</a>[];
            else
                cache.is_vmid_valid = FALSE;
        else
            cache.is_vmid_valid = FALSE;

        if PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then
            cache.is_asid_valid = TRUE;
            cache.asid          = <a link="impl-shared.ASID.read.0" file="shared_pseudocode.xml" hover="accessor: bits(16) ASID[]">ASID</a>[];
        else
            cache.is_asid_valid = FALSE;

        bits(64) vaddress = regval;
        need_translate = <a link="impl-shared.ICInstNeedsTranslation.1" file="shared_pseudocode.xml" hover="function: boolean ICInstNeedsTranslation(CacheOpScope opscope)">ICInstNeedsTranslation</a>(opscope);

        cache.vaddress = regval;
        cache.shareability = <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        cache.translated = need_translate;

        if !need_translate then
            cache.paddress = <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> UNKNOWN;
            <a link="impl-shared.CACHE_OP.1" file="shared_pseudocode.xml" hover="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
            return;
        iswrite = FALSE;
        wasaligned = TRUE;
        size = 0;
        memaddrdesc = <a link="AArch64.TranslateAddress.5" file="shared_pseudocode.xml" hover="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccType acctype, boolean iswrite,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(vaddress, acctype, iswrite, wasaligned, size);

        if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
            <a link="AArch64.Abort.2" file="shared_pseudocode.xml" hover="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(regval, memaddrdesc.fault);

        cache.cpas = <a link="impl-shared.CPASAtPAS.1" file="shared_pseudocode.xml" hover="function: CachePASpace CPASAtPAS(PASpace pas)">CPASAtPAS</a>(memaddrdesc.paddress.paspace);
        cache.paddress = memaddrdesc.paddress;
        <a link="impl-shared.CACHE_OP.1" file="shared_pseudocode.xml" hover="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
    return;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/predictionrestrict/RestrictPrediction" mylink="aarch64.instrs.system.sysops.predictionrestrict.RestrictPrediction" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// RestrictPrediction()
// ====================
// Clear all predictions in the context.

<anchor link="AArch64.RestrictPrediction.2" hover="function: AArch64.RestrictPrediction(bits(64) val, RestrictType restriction)">AArch64.RestrictPrediction</anchor>(bits(64) val, <a link="RestrictType" file="shared_pseudocode.xml" hover="enumeration RestrictType {&#13; RestrictType_DataValue,&#13; RestrictType_ControlFlow,&#13; RestrictType_CachePrefetch&#13; }">RestrictType</a> restriction)

    <a link="ExecutionCntxt" file="shared_pseudocode.xml" hover="type ExecutionCntxt is ( boolean is_vmid_valid, boolean all_vmid, bits(16) vmid, boolean is_asid_valid, boolean all_asid, bits(16) asid, bits(2) target_el, SecurityState security, RestrictType restriction )">ExecutionCntxt</a> c;
    target_el    = val&lt;25:24&gt;;

    // If the instruction is executed at an EL lower than the specified
    // level, it is treated as a NOP.
    if <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) then return;

    bit ns  = val&lt;26&gt;;
    ss = <a link="impl-shared.TargetSecurityState.1" file="shared_pseudocode.xml" hover="function: SecurityState TargetSecurityState(bit NS)">TargetSecurityState</a>(ns);

    c.security  = ss;
    c.target_el = target_el;

    if <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a link="impl-shared.IsInHost.0" file="shared_pseudocode.xml" hover="function: boolean IsInHost()">IsInHost</a>() then
        if PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} then
            c.is_vmid_valid = TRUE;
            c.all_vmid      = FALSE;
            c.vmid          = <a link="impl-aarch64.VMID.read.0" file="shared_pseudocode.xml" hover="accessor: bits(16) VMID[]">VMID</a>[];

        elsif target_el IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} then
            c.is_vmid_valid = TRUE;
            c.all_vmid      = val&lt;48&gt; == '1';
            c.vmid          = val&lt;47:32&gt;;           // Only valid if  val&lt;48&gt; == '0';
        else
            c.is_vmid_valid = FALSE;
    else
        c.is_vmid_valid = FALSE;

    if PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then
        c.is_asid_valid = TRUE;
        c.all_asid      = FALSE;
        c.asid          = <a link="impl-shared.ASID.read.0" file="shared_pseudocode.xml" hover="accessor: bits(16) ASID[]">ASID</a>[];

    elsif target_el == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then
        c.is_asid_valid = TRUE;
        c.all_asid      = val&lt;16&gt; == '1';
        c.asid          = val&lt;15:0&gt;;                  // Only valid if  val&lt;16&gt; == '0';

    else
        c.is_asid_valid = FALSE;

    c.restriction = restriction;
    <a link="impl-shared.RESTRICT_PREDICTIONS.1" file="shared_pseudocode.xml" hover="function: RESTRICT_PREDICTIONS(ExecutionCntxt c)">RESTRICT_PREDICTIONS</a>(c);</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/sysop/SysOp" mylink="aarch64.instrs.system.sysops.sysop.SysOp" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SysOp()
// =======

SystemOp <anchor link="impl-aarch64.SysOp.4" hover="function: SystemOp SysOp(bits(3) op1, bits(4) CRn, bits(4) CRm, bits(3) op2)">SysOp</anchor>(bits(3) op1, bits(4) CRn, bits(4) CRm, bits(3) op2)
    case op1:CRn:CRm:op2 of
        when '000 0111 1000 000' return <a link="Sys_AT" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;   // S1E1R
        when '100 0111 1000 000' return <a link="Sys_AT" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;   // S1E2R
        when '110 0111 1000 000' return <a link="Sys_AT" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;   // S1E3R
        when '000 0111 1000 001' return <a link="Sys_AT" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;   // S1E1W
        when '100 0111 1000 001' return <a link="Sys_AT" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;   // S1E2W
        when '110 0111 1000 001' return <a link="Sys_AT" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;   // S1E3W
        when '000 0111 1000 010' return <a link="Sys_AT" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;   // S1E0R
        when '000 0111 1000 011' return <a link="Sys_AT" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;   // S1E0W
        when '100 0111 1000 100' return <a link="Sys_AT" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;   // S12E1R
        when '100 0111 1000 101' return <a link="Sys_AT" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;   // S12E1W
        when '100 0111 1000 110' return <a link="Sys_AT" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;   // S12E0R
        when '100 0111 1000 111' return <a link="Sys_AT" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;   // S12E0W
        when '011 0111 0100 001' return <a link="Sys_DC" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;   // ZVA
        when '000 0111 0110 001' return <a link="Sys_DC" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;   // IVAC
        when '000 0111 0110 010' return <a link="Sys_DC" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;   // ISW
        when '011 0111 1010 001' return <a link="Sys_DC" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;   // CVAC
        when '000 0111 1010 010' return <a link="Sys_DC" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;   // CSW
        when '011 0111 1011 001' return <a link="Sys_DC" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;   // CVAU
        when '011 0111 1110 001' return <a link="Sys_DC" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;   // CIVAC
        when '000 0111 1110 010' return <a link="Sys_DC" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;   // CISW
        when '011 0111 1101 001' return <a link="Sys_DC" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;   // CVADP
        when '000 0111 0001 000' return <a link="Sys_IC" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_IC</a>;   // IALLUIS
        when '000 0111 0101 000' return <a link="Sys_IC" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_IC</a>;   // IALLU
        when '011 0111 0101 001' return <a link="Sys_IC" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_IC</a>;   // IVAU
        when '100 1000 0000 001' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // IPAS2E1IS
        when '100 1000 0000 101' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // IPAS2LE1IS
        when '000 1000 0011 000' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VMALLE1IS
        when '100 1000 0011 000' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // ALLE2IS
        when '110 1000 0011 000' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // ALLE3IS
        when '000 1000 0011 001' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VAE1IS
        when '100 1000 0011 001' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VAE2IS
        when '110 1000 0011 001' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VAE3IS
        when '000 1000 0011 010' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // ASIDE1IS
        when '000 1000 0011 011' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VAAE1IS
        when '100 1000 0011 100' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // ALLE1IS
        when '000 1000 0011 101' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VALE1IS
        when '100 1000 0011 101' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VALE2IS
        when '110 1000 0011 101' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VALE3IS
        when '100 1000 0011 110' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VMALLS12E1IS
        when '000 1000 0011 111' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VAALE1IS
        when '100 1000 0100 001' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // IPAS2E1
        when '100 1000 0100 101' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // IPAS2LE1
        when '000 1000 0111 000' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VMALLE1
        when '100 1000 0111 000' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // ALLE2
        when '110 1000 0111 000' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // ALLE3
        when '000 1000 0111 001' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VAE1
        when '100 1000 0111 001' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VAE2
        when '110 1000 0111 001' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VAE3
        when '000 1000 0111 010' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // ASIDE1
        when '000 1000 0111 011' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VAAE1
        when '100 1000 0111 100' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // ALLE1
        when '000 1000 0111 101' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VALE1
        when '100 1000 0111 101' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VALE2
        when '110 1000 0111 101' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VALE3
        when '100 1000 0111 110' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VMALLS12E1
        when '000 1000 0111 111' return <a link="Sys_TLBI" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VAALE1
    return <a link="Sys_SYS" file="shared_pseudocode.xml" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_SYS</a>;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/sysop/SystemOp" mylink="aarch64.instrs.system.sysops.sysop.SystemOp" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="SystemOp" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">SystemOp</anchor> {<anchor link="Sys_AT" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</anchor>, <anchor link="Sys_DC" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</anchor>, <anchor link="Sys_IC" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_IC</anchor>, <anchor link="Sys_TLBI" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</anchor>, <anchor link="Sys_SYS" hover="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_SYS</anchor>};</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/AArch32.DTLBI_ALL" mylink="aarch64.instrs.system.sysops.tlbi.AArch32.DTLBI_ALL" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.DTLBI_ALL()
// ===================
// Invalidate all data TLB entries for the indicated translation regime with the
// the indicated security state for all TLBs within the indicated shareability domain.
// Invalidation applies to all applicable stage 1 and stage 2 entries.
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.

<anchor link="AArch32.DTLBI_ALL.4" hover="function: AArch32.DTLBI_ALL(SecurityState security, Regime regime, Shareability shareability, TLBIMemAttr attr)">AArch32.DTLBI_ALL</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> security, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a link="TLBIMemAttr" file="shared_pseudocode.xml" hover="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr)
    assert PSTATE.EL IN {<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>};

    <a link="TLBIRecord" file="shared_pseudocode.xml" hover="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a link="TLBIOp_DALL" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_DALL</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a link="TLBILevel_Any" file="shared_pseudocode.xml" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a>;
    r.attr         = attr;

    <a link="impl-aarch64.TLBI.1" file="shared_pseudocode.xml" hover="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a link="impl-aarch64.Broadcast.2" file="shared_pseudocode.xml" hover="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/AArch32.DTLBI_ASID" mylink="aarch64.instrs.system.sysops.tlbi.AArch32.DTLBI_ASID" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.DTLBI_ASID()
// ====================
// Invalidate all data TLB stage 1 entries matching the indicated VMID (where regime supports)
// and ASID in the parameter Rt in the indicated translation regime with the
// indicated security state for all TLBs within the indicated shareability domain.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<anchor link="AArch32.DTLBI_ASID.6" hover="function: AArch32.DTLBI_ASID(SecurityState security, Regime regime, bits(16) vmid, Shareability shareability,&#13; TLBIMemAttr attr, bits(32) Rt)">AArch32.DTLBI_ASID</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> security, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid, <a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability,
                   <a link="TLBIMemAttr" file="shared_pseudocode.xml" hover="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr, bits(32) Rt)
    assert PSTATE.EL IN {<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>};

    <a link="TLBIRecord" file="shared_pseudocode.xml" hover="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a link="TLBIOp_DASID" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_DASID</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = <a link="TLBILevel_Any" file="shared_pseudocode.xml" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a>;
    r.attr         = attr;
    r.asid         = <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(8) : Rt&lt;7:0&gt;;

    <a link="impl-aarch64.TLBI.1" file="shared_pseudocode.xml" hover="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a link="impl-aarch64.Broadcast.2" file="shared_pseudocode.xml" hover="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/AArch32.DTLBI_VA" mylink="aarch64.instrs.system.sysops.tlbi.AArch32.DTLBI_VA" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.DTLBI_VA()
// ==================
// Invalidate by VA all stage 1 data TLB entries in the indicated shareability domain
// matching the indicated VMID and ASID (where regime supports VMID, ASID) in the indicated regime
// with the indicated security state.
// ASID, VA and related parameters are derived from Rt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// When the indicated level is
//     TLBILevel_Any  : this applies to TLB entries at all levels
//     TLBILevel_Last : this applies to TLB entries at last level only
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<anchor link="AArch32.DTLBI_VA.7" hover="function: AArch32.DTLBI_VA(SecurityState security, Regime regime, bits(16) vmid,&#13; Shareability shareability, TLBILevel level,  TLBIMemAttr attr, bits(32) Rt)">AArch32.DTLBI_VA</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> security, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                 <a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a link="TLBILevel" file="shared_pseudocode.xml" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel</a> level,  <a link="TLBIMemAttr" file="shared_pseudocode.xml" hover="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr, bits(32) Rt)
    assert PSTATE.EL IN {<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>};

    <a link="TLBIRecord" file="shared_pseudocode.xml" hover="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a link="TLBIOp_DVA" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_DVA</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.asid         = <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(8) : Rt&lt;7:0&gt;;
    r.address      = <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(32) : Rt&lt;31:12&gt; : <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(12);

    <a link="impl-aarch64.TLBI.1" file="shared_pseudocode.xml" hover="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a link="impl-aarch64.Broadcast.2" file="shared_pseudocode.xml" hover="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/AArch32.ITLBI_ALL" mylink="aarch64.instrs.system.sysops.tlbi.AArch32.ITLBI_ALL" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.ITLBI_ALL()
// ===================
// Invalidate all instruction TLB entries for the indicated translation regime with the
// the indicated security state for all TLBs within the indicated shareability domain.
// Invalidation applies to all applicable stage 1 and stage 2 entries.
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.

<anchor link="AArch32.ITLBI_ALL.4" hover="function: AArch32.ITLBI_ALL(SecurityState security, Regime regime, Shareability shareability, TLBIMemAttr attr)">AArch32.ITLBI_ALL</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> security, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a link="TLBIMemAttr" file="shared_pseudocode.xml" hover="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr)
    assert PSTATE.EL IN {<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>};

    <a link="TLBIRecord" file="shared_pseudocode.xml" hover="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a link="TLBIOp_IALL" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_IALL</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a link="TLBILevel_Any" file="shared_pseudocode.xml" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a>;
    r.attr         = attr;

    <a link="impl-aarch64.TLBI.1" file="shared_pseudocode.xml" hover="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a link="impl-aarch64.Broadcast.2" file="shared_pseudocode.xml" hover="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/AArch32.ITLBI_ASID" mylink="aarch64.instrs.system.sysops.tlbi.AArch32.ITLBI_ASID" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.ITLBI_ASID()
// ====================
// Invalidate all instruction TLB stage 1 entries matching the indicated VMID (where regime supports)
// and ASID in the parameter Rt in the indicated translation regime with the
// indicated security state for all TLBs within the indicated shareability domain.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<anchor link="AArch32.ITLBI_ASID.6" hover="function: AArch32.ITLBI_ASID(SecurityState security, Regime regime, bits(16) vmid, Shareability shareability,&#13; TLBIMemAttr attr, bits(32) Rt)">AArch32.ITLBI_ASID</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> security, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid, <a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability,
                   <a link="TLBIMemAttr" file="shared_pseudocode.xml" hover="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr, bits(32) Rt)
    assert PSTATE.EL IN {<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>};

    <a link="TLBIRecord" file="shared_pseudocode.xml" hover="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a link="TLBIOp_IASID" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_IASID</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = <a link="TLBILevel_Any" file="shared_pseudocode.xml" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a>;
    r.attr         = attr;
    r.asid         = <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(8) : Rt&lt;7:0&gt;;

    <a link="impl-aarch64.TLBI.1" file="shared_pseudocode.xml" hover="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a link="impl-aarch64.Broadcast.2" file="shared_pseudocode.xml" hover="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/AArch32.ITLBI_VA" mylink="aarch64.instrs.system.sysops.tlbi.AArch32.ITLBI_VA" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.ITLBI_VA()
// ==================
// Invalidate by VA all stage 1 instruction TLB entries in the indicated shareability domain
// matching the indicated VMID and ASID (where regime supports VMID, ASID) in the indicated regime
// with the indicated security state.
// ASID, VA and related parameters are derived from Rt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// When the indicated level is
//     TLBILevel_Any  : this applies to TLB entries at all levels
//     TLBILevel_Last : this applies to TLB entries at last level only
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<anchor link="AArch32.ITLBI_VA.7" hover="function: AArch32.ITLBI_VA(SecurityState security, Regime regime, bits(16) vmid,&#13; Shareability shareability, TLBILevel level,  TLBIMemAttr attr, bits(32) Rt)">AArch32.ITLBI_VA</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> security, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                 <a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a link="TLBILevel" file="shared_pseudocode.xml" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel</a> level,  <a link="TLBIMemAttr" file="shared_pseudocode.xml" hover="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr, bits(32) Rt)
    assert PSTATE.EL IN {<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>};

    <a link="TLBIRecord" file="shared_pseudocode.xml" hover="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a link="TLBIOp_IVA" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_IVA</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.asid         = <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(8) : Rt&lt;7:0&gt;;
    r.address      = <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(32) : Rt&lt;31:12&gt; : <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(12);

    <a link="impl-aarch64.TLBI.1" file="shared_pseudocode.xml" hover="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a link="impl-aarch64.Broadcast.2" file="shared_pseudocode.xml" hover="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/AArch32.TLBI_ALL" mylink="aarch64.instrs.system.sysops.tlbi.AArch32.TLBI_ALL" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.TLBI_ALL()
// ==================
// Invalidate all entries for the indicated translation regime with the
// the indicated security state for all TLBs within the indicated shareability domain.
// Invalidation applies to all applicable stage 1 and stage 2 entries.
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<anchor link="AArch32.TLBI_ALL.4" hover="function: AArch32.TLBI_ALL(SecurityState security, Regime regime, Shareability shareability, TLBIMemAttr attr)">AArch32.TLBI_ALL</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> security, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a link="TLBIMemAttr" file="shared_pseudocode.xml" hover="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr)
    assert PSTATE.EL IN {<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>};

    <a link="TLBIRecord" file="shared_pseudocode.xml" hover="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a link="TLBIOp_ALL" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_ALL</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a link="TLBILevel_Any" file="shared_pseudocode.xml" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a>;
    r.attr         = attr;

    <a link="impl-aarch64.TLBI.1" file="shared_pseudocode.xml" hover="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a link="impl-aarch64.Broadcast.2" file="shared_pseudocode.xml" hover="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/AArch32.TLBI_ASID" mylink="aarch64.instrs.system.sysops.tlbi.AArch32.TLBI_ASID" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.TLBI_ASID()
// ===================
// Invalidate all stage 1 entries matching the indicated VMID (where regime supports)
// and ASID in the parameter Rt in the indicated translation regime with the
// indicated security state for all TLBs within the indicated shareability domain.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<anchor link="AArch32.TLBI_ASID.6" hover="function: AArch32.TLBI_ASID(SecurityState security, Regime regime, bits(16) vmid, Shareability shareability,&#13; TLBIMemAttr attr, bits(32) Rt)">AArch32.TLBI_ASID</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> security, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid, <a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability,
                  <a link="TLBIMemAttr" file="shared_pseudocode.xml" hover="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr, bits(32) Rt)
    assert PSTATE.EL IN {<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>};

    <a link="TLBIRecord" file="shared_pseudocode.xml" hover="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a link="TLBIOp_ASID" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_ASID</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = <a link="TLBILevel_Any" file="shared_pseudocode.xml" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a>;
    r.attr         = attr;
    r.asid         = <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(8) : Rt&lt;7:0&gt;;

    <a link="impl-aarch64.TLBI.1" file="shared_pseudocode.xml" hover="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a link="impl-aarch64.Broadcast.2" file="shared_pseudocode.xml" hover="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/AArch32.TLBI_IPAS2" mylink="aarch64.instrs.system.sysops.tlbi.AArch32.TLBI_IPAS2" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.TLBI_IPAS2()
// ====================
// Invalidate by IPA all stage 2 only TLB entries in the indicated shareability
// domain matching the indicated VMID in the indicated regime with the indicated security state.
// Note: stage 1 and stage 2 combined entries are not in the scope of this operation.
// IPA and related parameters of the are derived from Rt.
// When the indicated level is
//     TLBILevel_Any  : this applies to TLB entries at all levels
//     TLBILevel_Last : this applies to TLB entries at last level only
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<anchor link="AArch32.TLBI_IPAS2.7" hover="function: AArch32.TLBI_IPAS2(SecurityState security, Regime regime, bits(16) vmid,&#13; Shareability shareability, TLBILevel level, TLBIMemAttr attr, bits(32) Rt)">AArch32.TLBI_IPAS2</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> security, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                   <a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a link="TLBILevel" file="shared_pseudocode.xml" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel</a> level, <a link="TLBIMemAttr" file="shared_pseudocode.xml" hover="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr, bits(32) Rt)
    assert PSTATE.EL IN {<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>};
    assert security == <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a>;

    <a link="TLBIRecord" file="shared_pseudocode.xml" hover="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a link="TLBIOp_IPAS2" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_IPAS2</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.address      = <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(24) : Rt&lt;27:0&gt; : <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(12);
    r.ipaspace     = <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a>;

    <a link="impl-aarch64.TLBI.1" file="shared_pseudocode.xml" hover="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a link="impl-aarch64.Broadcast.2" file="shared_pseudocode.xml" hover="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/AArch32.TLBI_VA" mylink="aarch64.instrs.system.sysops.tlbi.AArch32.TLBI_VA" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.TLBI_VA()
// =================
// Invalidate by VA all stage 1 TLB entries in the indicated shareability domain
// matching the indicated VMID and ASID (where regime supports VMID, ASID) in the indicated regime
// with the indicated security state.
// ASID, VA and related parameters are derived from Rt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// When the indicated level is
//     TLBILevel_Any  : this applies to TLB entries at all levels
//     TLBILevel_Last : this applies to TLB entries at last level only
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<anchor link="AArch32.TLBI_VA.7" hover="function: AArch32.TLBI_VA(SecurityState security, Regime regime, bits(16) vmid,&#13; Shareability shareability, TLBILevel level,  TLBIMemAttr attr, bits(32) Rt)">AArch32.TLBI_VA</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> security, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                <a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a link="TLBILevel" file="shared_pseudocode.xml" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel</a> level,  <a link="TLBIMemAttr" file="shared_pseudocode.xml" hover="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr, bits(32) Rt)
    assert PSTATE.EL IN {<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>};

    <a link="TLBIRecord" file="shared_pseudocode.xml" hover="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a link="TLBIOp_VA" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_VA</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.asid         = <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(8) : Rt&lt;7:0&gt;;
    r.address      = <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(32) : Rt&lt;31:12&gt; : <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(12);

    <a link="impl-aarch64.TLBI.1" file="shared_pseudocode.xml" hover="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a link="impl-aarch64.Broadcast.2" file="shared_pseudocode.xml" hover="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/AArch32.TLBI_VAA" mylink="aarch64.instrs.system.sysops.tlbi.AArch32.TLBI_VAA" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.TLBI_VAA()
// ==================
// Invalidate by VA all stage 1 TLB entries in the indicated shareability domain
// matching the indicated VMID (where regime supports VMID) and all ASID in the indicated regime
// with the indicated security state.
// VA and related parameters are derived from Rt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// When the indicated level is
//     TLBILevel_Any  : this applies to TLB entries at all levels
//     TLBILevel_Last : this applies to TLB entries at last level only
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<anchor link="AArch32.TLBI_VAA.7" hover="function: AArch32.TLBI_VAA(SecurityState security, Regime regime, bits(16) vmid,&#13; Shareability shareability, TLBILevel level, TLBIMemAttr attr,  bits(32) Rt)">AArch32.TLBI_VAA</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> security, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                 <a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a link="TLBILevel" file="shared_pseudocode.xml" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel</a> level, <a link="TLBIMemAttr" file="shared_pseudocode.xml" hover="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr,  bits(32) Rt)
    assert PSTATE.EL IN {<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>};

    <a link="TLBIRecord" file="shared_pseudocode.xml" hover="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a link="TLBIOp_VAA" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_VAA</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.address      = <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(32) : Rt&lt;31:12&gt; : <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(12);

    <a link="impl-aarch64.TLBI.1" file="shared_pseudocode.xml" hover="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a link="impl-aarch64.Broadcast.2" file="shared_pseudocode.xml" hover="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/AArch32.TLBI_VMALL" mylink="aarch64.instrs.system.sysops.tlbi.AArch32.TLBI_VMALL" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.TLBI_VMALL()
// ====================
// Invalidate all stage 1 entries for the indicated translation regime with the
// the indicated security state for all TLBs within the indicated shareability
// domain that match the indicated VMID (where applicable).
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// Note: stage 2 only entries are not in the scope of this operation.
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<anchor link="AArch32.TLBI_VMALL.5" hover="function: AArch32.TLBI_VMALL(SecurityState security, Regime regime, bits(16) vmid,&#13; Shareability shareability, TLBIMemAttr attr)">AArch32.TLBI_VMALL</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> security, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                   <a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a link="TLBIMemAttr" file="shared_pseudocode.xml" hover="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr)
    assert PSTATE.EL IN {<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>};

    <a link="TLBIRecord" file="shared_pseudocode.xml" hover="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a link="TLBIOp_VMALL" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_VMALL</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a link="TLBILevel_Any" file="shared_pseudocode.xml" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a>;
    r.vmid         = vmid;
    r.attr         = attr;

    <a link="impl-aarch64.TLBI.1" file="shared_pseudocode.xml" hover="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a link="impl-aarch64.Broadcast.2" file="shared_pseudocode.xml" hover="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/AArch32.TLBI_VMALLS12" mylink="aarch64.instrs.system.sysops.tlbi.AArch32.TLBI_VMALLS12" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.TLBI_VMALLS12()
// =======================
// Invalidate all stage 1 and stage 2 entries for the indicated translation
// regime with the indicated security state for all TLBs within the indicated
// shareability domain that match the indicated VMID.
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<anchor link="AArch32.TLBI_VMALLS12.5" hover="function: AArch32.TLBI_VMALLS12(SecurityState security, Regime regime, bits(16) vmid,&#13; Shareability shareability, TLBIMemAttr attr)">AArch32.TLBI_VMALLS12</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> security, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                      <a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a link="TLBIMemAttr" file="shared_pseudocode.xml" hover="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr)
    assert PSTATE.EL IN {<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>};

    <a link="TLBIRecord" file="shared_pseudocode.xml" hover="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a link="TLBIOp_VMALLS12" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_VMALLS12</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a link="TLBILevel_Any" file="shared_pseudocode.xml" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a>;
    r.vmid         = vmid;
    r.attr         = attr;

    <a link="impl-aarch64.TLBI.1" file="shared_pseudocode.xml" hover="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a link="impl-aarch64.Broadcast.2" file="shared_pseudocode.xml" hover="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_ALL" mylink="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_ALL" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.TLBI_ALL()
// ==================
// Invalidate all entries for the indicated translation regime with the
// the indicated security state for all TLBs within the indicated shareability domain.
// Invalidation applies to all applicable stage 1 and stage 2 entries.
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<anchor link="AArch64.TLBI_ALL.4" hover="function: AArch64.TLBI_ALL(SecurityState security, Regime regime, Shareability shareability, TLBIMemAttr attr)">AArch64.TLBI_ALL</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> security, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a link="TLBIMemAttr" file="shared_pseudocode.xml" hover="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr)
    assert PSTATE.EL IN {<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>};

    <a link="TLBIRecord" file="shared_pseudocode.xml" hover="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a link="TLBIOp_ALL" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_ALL</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a link="TLBILevel_Any" file="shared_pseudocode.xml" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a>;
    r.attr         = attr;

    <a link="impl-aarch64.TLBI.1" file="shared_pseudocode.xml" hover="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a link="impl-aarch64.Broadcast.2" file="shared_pseudocode.xml" hover="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_ASID" mylink="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_ASID" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.TLBI_ASID()
// ===================
// Invalidate all stage 1 entries matching the indicated VMID (where regime supports)
// and ASID in the parameter Xt in the indicated translation regime with the
// indicated security state for all TLBs within the indicated shareability domain.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<anchor link="AArch64.TLBI_ASID.6" hover="function: AArch64.TLBI_ASID(SecurityState security, Regime regime, bits(16) vmid, Shareability shareability,&#13; TLBIMemAttr attr, bits(64) Xt)">AArch64.TLBI_ASID</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> security, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid, <a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability,
                  <a link="TLBIMemAttr" file="shared_pseudocode.xml" hover="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr, bits(64) Xt)
    assert PSTATE.EL IN {<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>};

    <a link="TLBIRecord" file="shared_pseudocode.xml" hover="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a link="TLBIOp_ASID" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_ASID</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = <a link="TLBILevel_Any" file="shared_pseudocode.xml" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a>;
    r.attr         = attr;
    r.asid         = Xt&lt;63:48&gt;;

    <a link="impl-aarch64.TLBI.1" file="shared_pseudocode.xml" hover="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a link="impl-aarch64.Broadcast.2" file="shared_pseudocode.xml" hover="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_IPAS2" mylink="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_IPAS2" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.TLBI_IPAS2()
// ====================
// Invalidate by IPA all stage 2 only TLB entries in the indicated shareability
// domain matching the indicated VMID in the indicated regime with the indicated security state.
// Note: stage 1 and stage 2 combined entries are not in the scope of this operation.
// IPA and related parameters of the are derived from Xt.
// When the indicated level is
//     TLBILevel_Any  : this applies to TLB entries at all levels
//     TLBILevel_Last : this applies to TLB entries at last level only
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<anchor link="AArch64.TLBI_IPAS2.7" hover="function: AArch64.TLBI_IPAS2(SecurityState security, Regime regime, bits(16) vmid,&#13; Shareability shareability, TLBILevel level, TLBIMemAttr attr, bits(64) Xt)">AArch64.TLBI_IPAS2</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> security, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                   <a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a link="TLBILevel" file="shared_pseudocode.xml" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel</a> level, <a link="TLBIMemAttr" file="shared_pseudocode.xml" hover="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr, bits(64) Xt)
    assert PSTATE.EL IN {<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>};

    <a link="TLBIRecord" file="shared_pseudocode.xml" hover="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a link="TLBIOp_IPAS2" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_IPAS2</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.address      = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(Xt&lt;39:0&gt; : <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(12));

    case security of
        when <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a>
            r.ipaspace = <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a>;
        when <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>
            r.ipaspace = if Xt&lt;63&gt; == '1' then <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a> else <a link="PAS_Secure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_Secure</a>;

    <a link="impl-aarch64.TLBI.1" file="shared_pseudocode.xml" hover="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a link="impl-aarch64.Broadcast.2" file="shared_pseudocode.xml" hover="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_RIPAS2" mylink="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_RIPAS2" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.TLBI_RIPAS2()
// =====================
// Range invalidate by IPA all stage 2 only TLB entries in the indicated
// shareability domain matching the indicated VMID in the indicated regime with the indicated
// security state.
// Note: stage 1 and stage 2 combined entries are not in the scope of this operation.
// The range of IPA and related parameters of the are derived from Xt.
// When the indicated level is
//     TLBILevel_Any  : this applies to TLB entries at all levels
//     TLBILevel_Last : this applies to TLB entries at last level only
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<anchor link="AArch64.TLBI_RIPAS2.7" hover="function: AArch64.TLBI_RIPAS2(SecurityState security, Regime regime, bits(16) vmid,&#13; Shareability shareability, TLBILevel level, TLBIMemAttr attr, bits(64) Xt)">AArch64.TLBI_RIPAS2</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> security, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                    <a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a link="TLBILevel" file="shared_pseudocode.xml" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel</a> level, <a link="TLBIMemAttr" file="shared_pseudocode.xml" hover="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr, bits(64) Xt)
    assert PSTATE.EL IN {<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>};

    <a link="TLBIRecord" file="shared_pseudocode.xml" hover="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a link="TLBIOp_RIPAS2" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_RIPAS2</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;

    bits(2) tg        = Xt&lt;47:46&gt;;
    integer scale     = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(Xt&lt;45:44&gt;);
    integer num       = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(Xt&lt;43:39&gt;);
    integer baseaddr  = <a link="impl-shared.SInt.1" file="shared_pseudocode.xml" hover="function: integer SInt(bits(N) x)">SInt</a>(Xt&lt;36:0&gt;);

    boolean valid;

    (valid, r.tg, r.address, r.end_address) = <a link="impl-aarch64.TLBIRange.2" file="shared_pseudocode.xml" hover="function: (boolean, bits(2), bits(64), bits(64)) TLBIRange(Regime regime, bits(64) Xt)">TLBIRange</a>(regime, Xt);

    if !valid then return;

    case security of
        when <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a>
            r.ipaspace = <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a>;
        when <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>
            r.ipaspace = if Xt&lt;63&gt; == '1' then <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a> else <a link="PAS_Secure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_Secure</a>;

    <a link="impl-aarch64.TLBI.1" file="shared_pseudocode.xml" hover="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a link="impl-aarch64.Broadcast.2" file="shared_pseudocode.xml" hover="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_RVA" mylink="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_RVA" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.TLBI_RVA()
// ==================
// Range invalidate by VA range all stage 1 TLB entries in the indicated
// shareability domain matching the indicated VMID and ASID (where regime
// supports VMID, ASID) in the indicated regime with the indicated security state.
// ASID, and range related parameters are derived from Xt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// When the indicated level is
//     TLBILevel_Any  : this applies to TLB entries at all levels
//     TLBILevel_Last : this applies to TLB entries at last level only
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<anchor link="AArch64.TLBI_RVA.7" hover="function: AArch64.TLBI_RVA(SecurityState security, Regime regime, bits(16) vmid,&#13; Shareability shareability, TLBILevel level, TLBIMemAttr attr, bits(64)  Xt)">AArch64.TLBI_RVA</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> security, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                 <a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a link="TLBILevel" file="shared_pseudocode.xml" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel</a> level, <a link="TLBIMemAttr" file="shared_pseudocode.xml" hover="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr, bits(64)  Xt)
    assert PSTATE.EL IN {<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>};

    <a link="TLBIRecord" file="shared_pseudocode.xml" hover="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a link="TLBIOp_RVA" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_RVA</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.asid         = Xt&lt;63:48&gt;;

    boolean valid;

    (valid, r.tg, r.address, r.end_address) = <a link="impl-aarch64.TLBIRange.2" file="shared_pseudocode.xml" hover="function: (boolean, bits(2), bits(64), bits(64)) TLBIRange(Regime regime, bits(64) Xt)">TLBIRange</a>(regime, Xt);

    if !valid then return;

    <a link="impl-aarch64.TLBI.1" file="shared_pseudocode.xml" hover="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a link="impl-aarch64.Broadcast.2" file="shared_pseudocode.xml" hover="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_RVAA" mylink="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_RVAA" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.TLBI_RVAA()
// ===================
// Range invalidate by VA range all stage 1 TLB entries in the indicated
// shareability domain matching the indicated VMID (where regimesupports VMID)
// and all ASID in the indicated regime with the indicated security state.
// VA range related parameters are derived from Xt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// When the indicated level is
//     TLBILevel_Any  : this applies to TLB entries at all levels
//     TLBILevel_Last : this applies to TLB entries at last level only
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<anchor link="AArch64.TLBI_RVAA.7" hover="function: AArch64.TLBI_RVAA(SecurityState security, Regime  regime, bits(16) vmid,&#13; Shareability shareability, TLBILevel level, TLBIMemAttr attr, bits(64) Xt)">AArch64.TLBI_RVAA</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> security, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a>  regime, bits(16) vmid,
                  <a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a link="TLBILevel" file="shared_pseudocode.xml" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel</a> level, <a link="TLBIMemAttr" file="shared_pseudocode.xml" hover="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr, bits(64) Xt)
    assert PSTATE.EL IN {<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>};

    <a link="TLBIRecord" file="shared_pseudocode.xml" hover="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a link="TLBIOp_RVAA" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_RVAA</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;

    bits(2) tg        = Xt&lt;47:46&gt;;
    integer scale     = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(Xt&lt;45:44&gt;);
    integer num       = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(Xt&lt;43:39&gt;);
    integer baseaddr  = <a link="impl-shared.SInt.1" file="shared_pseudocode.xml" hover="function: integer SInt(bits(N) x)">SInt</a>(Xt&lt;36:0&gt;);

    boolean valid;

    (valid, r.tg, r.address, r.end_address) = <a link="impl-aarch64.TLBIRange.2" file="shared_pseudocode.xml" hover="function: (boolean, bits(2), bits(64), bits(64)) TLBIRange(Regime regime, bits(64) Xt)">TLBIRange</a>(regime, Xt);

    if !valid then return;

    <a link="impl-aarch64.TLBI.1" file="shared_pseudocode.xml" hover="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a link="impl-aarch64.Broadcast.2" file="shared_pseudocode.xml" hover="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_VA" mylink="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_VA" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.TLBI_VA()
// =================
// Invalidate by VA all stage 1 TLB entries in the indicated shareability domain
// matching the indicated VMID and ASID (where regime supports VMID, ASID) in the indicated regime
// with the indicated security state.
// ASID, VA and related parameters are derived from Xt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// When the indicated level is
//     TLBILevel_Any  : this applies to TLB entries at all levels
//     TLBILevel_Last : this applies to TLB entries at last level only
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<anchor link="AArch64.TLBI_VA.7" hover="function: AArch64.TLBI_VA(SecurityState security, Regime regime, bits(16) vmid,&#13; Shareability shareability, TLBILevel level,  TLBIMemAttr attr, bits(64) Xt)">AArch64.TLBI_VA</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> security, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                <a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a link="TLBILevel" file="shared_pseudocode.xml" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel</a> level,  <a link="TLBIMemAttr" file="shared_pseudocode.xml" hover="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr, bits(64) Xt)
    assert PSTATE.EL IN {<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>};

    <a link="TLBIRecord" file="shared_pseudocode.xml" hover="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a link="TLBIOp_VA" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_VA</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.asid         = Xt&lt;63:48&gt;;
    r.address      = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(Xt&lt;43:0&gt; : <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(12));

    <a link="impl-aarch64.TLBI.1" file="shared_pseudocode.xml" hover="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a link="impl-aarch64.Broadcast.2" file="shared_pseudocode.xml" hover="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_VAA" mylink="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_VAA" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.TLBI_VAA()
// ==================
// Invalidate by VA all stage 1 TLB entries in the indicated shareability domain
// matching the indicated VMID (where regime supports VMID) and all ASID in the indicated regime
// with the indicated security state.
// VA and related parameters are derived from Xt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// When the indicated level is
//     TLBILevel_Any  : this applies to TLB entries at all levels
//     TLBILevel_Last : this applies to TLB entries at last level only
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<anchor link="AArch64.TLBI_VAA.7" hover="function: AArch64.TLBI_VAA(SecurityState security, Regime regime, bits(16) vmid,&#13; Shareability shareability, TLBILevel level, TLBIMemAttr attr,  bits(64) Xt)">AArch64.TLBI_VAA</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> security, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                 <a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a link="TLBILevel" file="shared_pseudocode.xml" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel</a> level, <a link="TLBIMemAttr" file="shared_pseudocode.xml" hover="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr,  bits(64) Xt)
    assert PSTATE.EL IN {<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>};

    <a link="TLBIRecord" file="shared_pseudocode.xml" hover="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a link="TLBIOp_VAA" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_VAA</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.address      = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(Xt&lt;43:0&gt; : <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(12));

    <a link="impl-aarch64.TLBI.1" file="shared_pseudocode.xml" hover="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a link="impl-aarch64.Broadcast.2" file="shared_pseudocode.xml" hover="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_VMALL" mylink="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_VMALL" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.TLBI_VMALL()
// ====================
// Invalidate all stage 1 entries for the indicated translation regime with the
// the indicated security state for all TLBs within the indicated shareability
// domain that match the indicated VMID (where applicable).
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// Note: stage 2 only entries are not in the scope of this operation.
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<anchor link="AArch64.TLBI_VMALL.5" hover="function: AArch64.TLBI_VMALL(SecurityState security, Regime regime, bits(16) vmid,&#13; Shareability shareability, TLBIMemAttr attr)">AArch64.TLBI_VMALL</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> security, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                   <a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a link="TLBIMemAttr" file="shared_pseudocode.xml" hover="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr)
    assert PSTATE.EL IN {<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>};

    <a link="TLBIRecord" file="shared_pseudocode.xml" hover="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a link="TLBIOp_VMALL" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_VMALL</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a link="TLBILevel_Any" file="shared_pseudocode.xml" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a>;
    r.vmid         = vmid;
    r.attr         = attr;

    <a link="impl-aarch64.TLBI.1" file="shared_pseudocode.xml" hover="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a link="impl-aarch64.Broadcast.2" file="shared_pseudocode.xml" hover="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_VMALLS12" mylink="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_VMALLS12" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.TLBI_VMALLS12()
// =======================
// Invalidate all stage 1 and stage 2 entries for the indicated translation
// regime with the indicated security state for all TLBs within the indicated
// shareability domain that match the indicated VMID.
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<anchor link="AArch64.TLBI_VMALLS12.5" hover="function: AArch64.TLBI_VMALLS12(SecurityState security, Regime regime, bits(16) vmid,&#13; Shareability shareability, TLBIMemAttr attr)">AArch64.TLBI_VMALLS12</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> security, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                      <a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a link="TLBIMemAttr" file="shared_pseudocode.xml" hover="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr)
    assert PSTATE.EL IN {<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>};

    <a link="TLBIRecord" file="shared_pseudocode.xml" hover="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a link="TLBIOp_VMALLS12" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_VMALLS12</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a link="TLBILevel_Any" file="shared_pseudocode.xml" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a>;
    r.vmid         = vmid;
    r.attr         = attr;

    <a link="impl-aarch64.TLBI.1" file="shared_pseudocode.xml" hover="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a link="impl-aarch64.Broadcast.2" file="shared_pseudocode.xml" hover="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/ASID_NONE" mylink="aarch64.instrs.system.sysops.tlbi.ASID_NONE" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">constant bits(16) <anchor link="ASID_NONE" hover="constant bits(16) ASID_NONE = Zeros()">ASID_NONE</anchor> = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/Broadcast" mylink="aarch64.instrs.system.sysops.tlbi.Broadcast" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Broadcast()
// ===========
// IMPLEMENTATION DEFINED function to broadcast TLBI operation within the indicated shareability
// domain.

<anchor link="impl-aarch64.Broadcast.2" hover="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</anchor>(<a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a link="TLBIRecord" file="shared_pseudocode.xml" hover="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r)
    IMPLEMENTATION_DEFINED;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/DecodeTLBITG" mylink="aarch64.instrs.system.sysops.tlbi.DecodeTLBITG" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// DecodeTLBITG()
// ==============
// Decode translation granule size in TLBI range instructions

TGx <anchor link="impl-aarch64.DecodeTLBITG.1" hover="function: TGx DecodeTLBITG(bits(2) tg)">DecodeTLBITG</anchor>(bits(2) tg)
    case tg of
        when '01'   return <a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
        when '10'   return <a link="TGx_16KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>;
        when '11'   return <a link="TGx_64KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a>;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/HasLargeAddress" mylink="aarch64.instrs.system.sysops.tlbi.HasLargeAddress" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HasLargeAddress()
// =================
// Returns TRUE if the regime is configured for 52 bit addresses, FALSE otherwise.

boolean <anchor link="impl-aarch64.HasLargeAddress.1" hover="function: boolean HasLargeAddress(Regime regime)">HasLargeAddress</anchor>(<a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime)
    if !<a link="impl-shared.Have52BitIPAAndPASpaceExt.0" file="shared_pseudocode.xml" hover="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
        return FALSE;
    case regime of
        when <a link="Regime_EL3" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>
            return TCR_EL3&lt;32&gt; == '1';
        when <a link="Regime_EL2" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>
            return TCR_EL2&lt;32&gt; == '1';
        when <a link="Regime_EL20" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>
            return TCR_EL2&lt;59&gt; == '1';
        when <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>
            return TCR_EL1&lt;59&gt; == '1';
        otherwise
            <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/TLBI" mylink="aarch64.instrs.system.sysops.tlbi.TLBI" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// TLBI()
// ======
// Performs TLB maintenance of operation on TLB to invalidate the matching transition table entries.

<anchor link="impl-aarch64.TLBI.1" hover="function: TLBI(TLBIRecord r)">TLBI</anchor>(<a link="TLBIRecord" file="shared_pseudocode.xml" hover="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r)
    IMPLEMENTATION_DEFINED;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/TLBILevel" mylink="aarch64.instrs.system.sysops.tlbi.TLBILevel" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="TLBILevel" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel</anchor> {
    <anchor link="TLBILevel_Any" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</anchor>,
    <anchor link="TLBILevel_Last" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Last</anchor>
};</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/TLBIMatch" mylink="aarch64.instrs.system.sysops.tlbi.TLBIMatch" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// TLBIMatch()
// ===========
// Determine whether the TLB entry lies within the scope of inavlidation

boolean <anchor link="impl-aarch64.TLBIMatch.2" hover="function: boolean TLBIMatch(TLBIRecord tlbi, TLBRecord entry)">TLBIMatch</anchor>(<a link="TLBIRecord" file="shared_pseudocode.xml" hover="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> tlbi, <a link="TLBRecord" file="shared_pseudocode.xml" hover="type TLBRecord is ( TLBContext context, TTWState walkstate, integer blocksize, integer contigsize, bits(64) s1descriptor, bits(64) s2descriptor )">TLBRecord</a> entry)
    boolean match;
    case tlbi.op of
        when <a link="TLBIOp_DALL" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_DALL</a>, <a link="TLBIOp_IALL" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_IALL</a>
            match = (tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime);
        when <a link="TLBIOp_DASID" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_DASID</a>, <a link="TLBIOp_IASID" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_IASID</a>
            match = (entry.context.includes_s1 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a link="impl-shared.UseVMID.1" file="shared_pseudocode.xml" hover="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid) &amp;&amp;
                     (<a link="impl-shared.UseASID.1" file="shared_pseudocode.xml" hover="function: boolean UseASID(TLBContext access)">UseASID</a>(entry.context) &amp;&amp; entry.context.nG == '1' &amp;&amp;
                        tlbi.asid  == entry.context.asid));
        when <a link="TLBIOp_DVA" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_DVA</a>, <a link="TLBIOp_IVA" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_IVA</a>
            match = (entry.context.includes_s1 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a link="impl-shared.UseVMID.1" file="shared_pseudocode.xml" hover="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid) &amp;&amp;
                     (!<a link="impl-shared.UseASID.1" file="shared_pseudocode.xml" hover="function: boolean UseASID(TLBContext access)">UseASID</a>(entry.context) || tlbi.asid == entry.context.asid ||
                        entry.context.nG == '0') &amp;&amp;
                     tlbi.address&lt;55:entry.blocksize&gt; == entry.context.ia&lt;55:entry.blocksize&gt; &amp;&amp;
                     (tlbi.level == <a link="TLBILevel_Any" file="shared_pseudocode.xml" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a> || !entry.walkstate.istable));
        when <a link="TLBIOp_ALL" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_ALL</a>
            relax_regime = (tlbi.from_aarch64 &amp;&amp;
                            tlbi.regime IN {<a link="Regime_EL20" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>, <a link="Regime_EL2" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>} &amp;&amp;
                            entry.context.regime IN {<a link="Regime_EL20" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>, <a link="Regime_EL2" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>});
            match = (tlbi.security == entry.context.ss &amp;&amp;
                     (tlbi.regime  == entry.context.regime || relax_regime));
        when <a link="TLBIOp_ASID" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_ASID</a>
            match = (entry.context.includes_s1 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a link="impl-shared.UseVMID.1" file="shared_pseudocode.xml" hover="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid) &amp;&amp;
                     (<a link="impl-shared.UseASID.1" file="shared_pseudocode.xml" hover="function: boolean UseASID(TLBContext access)">UseASID</a>(entry.context) &amp;&amp; entry.context.nG == '1' &amp;&amp;
                        tlbi.asid  == entry.context.asid));
        when <a link="TLBIOp_IPAS2" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_IPAS2</a>
            match = (!entry.context.includes_s1 &amp;&amp; entry.context.includes_s2 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a link="impl-shared.UseVMID.1" file="shared_pseudocode.xml" hover="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid) &amp;&amp;
                     tlbi.ipaspace == entry.context.ipaspace &amp;&amp;
                     tlbi.address&lt;51:entry.blocksize&gt; == entry.context.ia&lt;51:entry.blocksize&gt; &amp;&amp;
                     (tlbi.level == <a link="TLBILevel_Any" file="shared_pseudocode.xml" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a> || !entry.walkstate.istable));
        when <a link="TLBIOp_VAA" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_VAA</a>
            match = (entry.context.includes_s1 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a link="impl-shared.UseVMID.1" file="shared_pseudocode.xml" hover="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid) &amp;&amp;
                     tlbi.address&lt;55:entry.blocksize&gt; == entry.context.ia&lt;55:entry.blocksize&gt; &amp;&amp;
                     (tlbi.level == <a link="TLBILevel_Any" file="shared_pseudocode.xml" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a> || !entry.walkstate.istable));
        when <a link="TLBIOp_VA" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_VA</a>
            match = (entry.context.includes_s1 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a link="impl-shared.UseVMID.1" file="shared_pseudocode.xml" hover="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid) &amp;&amp;
                     (!<a link="impl-shared.UseASID.1" file="shared_pseudocode.xml" hover="function: boolean UseASID(TLBContext access)">UseASID</a>(entry.context) || tlbi.asid == entry.context.asid ||
                        entry.context.nG == '0') &amp;&amp;
                     tlbi.address&lt;55:entry.blocksize&gt; == entry.context.ia&lt;55:entry.blocksize&gt; &amp;&amp;
                     (tlbi.level == <a link="TLBILevel_Any" file="shared_pseudocode.xml" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a> || !entry.walkstate.istable));
        when <a link="TLBIOp_VMALL" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_VMALL</a>
            match = (entry.context.includes_s1 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a link="impl-shared.UseVMID.1" file="shared_pseudocode.xml" hover="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid));
        when <a link="TLBIOp_VMALLS12" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_VMALLS12</a>
            match = (tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a link="impl-shared.UseVMID.1" file="shared_pseudocode.xml" hover="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid));
        when <a link="TLBIOp_RIPAS2" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_RIPAS2</a>
            match = (!entry.context.includes_s1 &amp;&amp; entry.context.includes_s2 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a link="impl-shared.UseVMID.1" file="shared_pseudocode.xml" hover="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid) &amp;&amp;
                     tlbi.ipaspace == entry.context.ipaspace &amp;&amp;
                     (tlbi.tg != '00' &amp;&amp; <a link="impl-aarch64.DecodeTLBITG.1" file="shared_pseudocode.xml" hover="function: TGx DecodeTLBITG(bits(2) tg)">DecodeTLBITG</a>(tlbi.tg) == entry.context.tg) &amp;&amp;
                     <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(tlbi.address)     &lt;= <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(entry.context.ia) &amp;&amp;
                     <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(tlbi.end_address) &gt;  <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(entry.context.ia));
        when <a link="TLBIOp_RVAA" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_RVAA</a>
            match = (entry.context.includes_s1 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a link="impl-shared.UseVMID.1" file="shared_pseudocode.xml" hover="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid) &amp;&amp;
                     (tlbi.tg != '00' &amp;&amp; <a link="impl-aarch64.DecodeTLBITG.1" file="shared_pseudocode.xml" hover="function: TGx DecodeTLBITG(bits(2) tg)">DecodeTLBITG</a>(tlbi.tg) == entry.context.tg) &amp;&amp;
                     <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(tlbi.address)     &lt;= <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(entry.context.ia) &amp;&amp;
                     <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(tlbi.end_address) &gt;  <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(entry.context.ia));
        when <a link="TLBIOp_RVA" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_RVA</a>
            match = (entry.context.includes_s1 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a link="impl-shared.UseVMID.1" file="shared_pseudocode.xml" hover="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid) &amp;&amp;
                     (!<a link="impl-shared.UseASID.1" file="shared_pseudocode.xml" hover="function: boolean UseASID(TLBContext access)">UseASID</a>(entry.context) || tlbi.asid == entry.context.asid ||
                        entry.context.nG == '0') &amp;&amp;
                     (tlbi.tg != '00' &amp;&amp; <a link="impl-aarch64.DecodeTLBITG.1" file="shared_pseudocode.xml" hover="function: TGx DecodeTLBITG(bits(2) tg)">DecodeTLBITG</a>(tlbi.tg) == entry.context.tg) &amp;&amp;
                     <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(tlbi.address)     &lt;= <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(entry.context.ia) &amp;&amp;
                     <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(tlbi.end_address) &gt;  <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(entry.context.ia));

    if tlbi.attr == <a link="TLBI_ExcludeXS" file="shared_pseudocode.xml" hover="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBI_ExcludeXS</a> &amp;&amp; entry.context.xs == '1' then
        match = FALSE;

    return match;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/TLBIMemAttr" mylink="aarch64.instrs.system.sysops.tlbi.TLBIMemAttr" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="TLBIMemAttr" hover="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</anchor> {
    <anchor link="TLBI_AllAttr" hover="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBI_AllAttr</anchor>,
    <anchor link="TLBI_ExcludeXS" hover="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBI_ExcludeXS</anchor>
};</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/TLBIOp" mylink="aarch64.instrs.system.sysops.tlbi.TLBIOp" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="TLBIOp" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp</anchor> {
    <anchor link="TLBIOp_DALL" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_DALL</anchor>,          // AArch32 Data TLBI operations - deprecated
    <anchor link="TLBIOp_DASID" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_DASID</anchor>,
    <anchor link="TLBIOp_DVA" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_DVA</anchor>,
    <anchor link="TLBIOp_IALL" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_IALL</anchor>,          // AArch32 Instruction TLBI operations - deprecated
    <anchor link="TLBIOp_IASID" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_IASID</anchor>,
    <anchor link="TLBIOp_IVA" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_IVA</anchor>,
    <anchor link="TLBIOp_ALL" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_ALL</anchor>,
    <anchor link="TLBIOp_ASID" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_ASID</anchor>,
    <anchor link="TLBIOp_IPAS2" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_IPAS2</anchor>,
    <anchor link="TLBIOp_VAA" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_VAA</anchor>,
    <anchor link="TLBIOp_VA" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_VA</anchor>,
    <anchor link="TLBIOp_VMALL" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_VMALL</anchor>,
    <anchor link="TLBIOp_VMALLS12" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_VMALLS12</anchor>,
    <anchor link="TLBIOp_RIPAS2" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_RIPAS2</anchor>,
    <anchor link="TLBIOp_RVAA" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_RVAA</anchor>,
    <anchor link="TLBIOp_RVA" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp_RVA</anchor>,
};</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/TLBIRange" mylink="aarch64.instrs.system.sysops.tlbi.TLBIRange" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// TLBIRange()
// ===========
// Extract the input address range information from encoded Xt.

(boolean, bits(2), bits(64), bits(64)) <anchor link="impl-aarch64.TLBIRange.2" hover="function: (boolean, bits(2), bits(64), bits(64)) TLBIRange(Regime regime, bits(64) Xt)">TLBIRange</anchor>(<a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(64) Xt)
    boolean  valid = TRUE;
    bits(64) start = <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(64);
    bits(64) end   = <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(64);

    bits(2) tg        = Xt&lt;47:46&gt;;
    integer scale     = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(Xt&lt;45:44&gt;);
    integer num       = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(Xt&lt;43:39&gt;);
    integer tg_bits;

    if tg == '00' then
        return (FALSE, tg, start, end);

    case tg of
        when '01' // 4KB
            tg_bits = 12;
            if <a link="impl-aarch64.HasLargeAddress.1" file="shared_pseudocode.xml" hover="function: boolean HasLargeAddress(Regime regime)">HasLargeAddress</a>(regime) then
                start&lt;52:16&gt; = Xt&lt;36:0&gt;;
                start&lt;63:53&gt; = <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(Xt&lt;36&gt;, 11);
            else
                start&lt;48:12&gt; = Xt&lt;36:0&gt;;
                start&lt;63:49&gt; = <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(Xt&lt;36&gt;, 15);
        when '10' // 16KB
            tg_bits = 14;
            if <a link="impl-aarch64.HasLargeAddress.1" file="shared_pseudocode.xml" hover="function: boolean HasLargeAddress(Regime regime)">HasLargeAddress</a>(regime) then
                start&lt;52:16&gt; = Xt&lt;36:0&gt;;
                start&lt;63:53&gt; = <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(Xt&lt;36&gt;, 11);
            else
                start&lt;50:14&gt; = Xt&lt;36:0&gt;;
                start&lt;63:51&gt; = <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(Xt&lt;36&gt;, 13);
        when '11' // 64KB
            tg_bits = 16;
            start&lt;52:16&gt; = Xt&lt;36:0&gt;;
            start&lt;63:53&gt; = <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(Xt&lt;36&gt;, 11);
        otherwise
            <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();

    integer range = (num+1) &lt;&lt; (5*scale + 1 + tg_bits);
    end   = start + range&lt;63:0&gt;;

    if end&lt;52&gt; != start&lt;52&gt; then
        // overflow, saturate it
        end = <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(start&lt;52&gt;, 64-52) : <a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(52);

    return (valid, tg, start, end);</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/TLBIRecord" mylink="aarch64.instrs.system.sysops.tlbi.TLBIRecord" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">type <anchor link="TLBIRecord" hover="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</anchor> is (
    <a link="TLBIOp" file="shared_pseudocode.xml" hover="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; }">TLBIOp</a>          op,
    boolean         from_aarch64, // originated as an AArch64 operation
    <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a>   security,
    <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a>          regime,
    bits(16)        vmid,
    bits(16)        asid,
    <a link="TLBILevel" file="shared_pseudocode.xml" hover="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel</a>       level,
    <a link="TLBIMemAttr" file="shared_pseudocode.xml" hover="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a>     attr,
    <a link="PASpace" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PASpace</a>         ipaspace,     // For operations that take IPA as input address
    bits(64)        address,      // input address, for range operations, start address
    bits(64)        end_address,  // for range operations, end address
    bits(2)         tg,           // for range operations, translation granule
)</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/VMID" mylink="aarch64.instrs.system.sysops.tlbi.VMID" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// VMID[]
// ======
// Effective VMID.

bits(16) <anchor link="impl-aarch64.VMID.read.0" hover="accessor: bits(16) VMID[]">VMID</anchor>[]
    if <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
            if <a link="impl-shared.Have16bitVMID.0" file="shared_pseudocode.xml" hover="function: boolean Have16bitVMID()">Have16bitVMID</a>() &amp;&amp; VTCR_EL2.VS == '1' then
                return VTTBR_EL2.VMID;
            else
                return <a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(VTTBR_EL2.VMID&lt;7:0&gt;, 16);
        else
            return <a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(VTTBR.VMID, 16);
    elsif <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; <a link="impl-shared.HaveSecureEL2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() then
        return <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(16);
    else
        return <a link="VMID_NONE" file="shared_pseudocode.xml" hover="constant bits(16) VMID_NONE = Zeros()">VMID_NONE</a>;</pstext>
    </ps>
    <ps name="aarch64/instrs/system/sysops/tlbi/VMID_NONE" mylink="aarch64.instrs.system.sysops.tlbi.VMID_NONE" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">constant bits(16) <anchor link="VMID_NONE" hover="constant bits(16) VMID_NONE = Zeros()">VMID_NONE</anchor> = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();</pstext>
    </ps>
    <ps name="aarch64/instrs/vector/arithmetic/binary/uniform/logical/bsl-eor/vbitop/VBitOp" mylink="aarch64.instrs.vector.arithmetic.binary.uniform.logical.bsl-eor.vbitop.VBitOp" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="VBitOp" hover="enumeration VBitOp      {VBitOp_VBIF, VBitOp_VBIT, VBitOp_VBSL, VBitOp_VEOR}">VBitOp</anchor>      {<anchor link="VBitOp_VBIF" hover="enumeration VBitOp      {VBitOp_VBIF, VBitOp_VBIT, VBitOp_VBSL, VBitOp_VEOR}">VBitOp_VBIF</anchor>, <anchor link="VBitOp_VBIT" hover="enumeration VBitOp      {VBitOp_VBIF, VBitOp_VBIT, VBitOp_VBSL, VBitOp_VEOR}">VBitOp_VBIT</anchor>, <anchor link="VBitOp_VBSL" hover="enumeration VBitOp      {VBitOp_VBIF, VBitOp_VBIT, VBitOp_VBSL, VBitOp_VEOR}">VBitOp_VBSL</anchor>, <anchor link="VBitOp_VEOR" hover="enumeration VBitOp      {VBitOp_VBIF, VBitOp_VBIT, VBitOp_VBSL, VBitOp_VEOR}">VBitOp_VEOR</anchor>};</pstext>
    </ps>
    <ps name="aarch64/instrs/vector/arithmetic/unary/cmp/compareop/CompareOp" mylink="aarch64.instrs.vector.arithmetic.unary.cmp.compareop.CompareOp" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="CompareOp" hover="enumeration CompareOp   {CompareOp_GT, CompareOp_GE, CompareOp_EQ,&#13; CompareOp_LE, CompareOp_LT}">CompareOp</anchor>   {<anchor link="CompareOp_GT" hover="enumeration CompareOp   {CompareOp_GT, CompareOp_GE, CompareOp_EQ,&#13; CompareOp_LE, CompareOp_LT}">CompareOp_GT</anchor>, <anchor link="CompareOp_GE" hover="enumeration CompareOp   {CompareOp_GT, CompareOp_GE, CompareOp_EQ,&#13; CompareOp_LE, CompareOp_LT}">CompareOp_GE</anchor>, <anchor link="CompareOp_EQ" hover="enumeration CompareOp   {CompareOp_GT, CompareOp_GE, CompareOp_EQ,&#13; CompareOp_LE, CompareOp_LT}">CompareOp_EQ</anchor>,
                         <anchor link="CompareOp_LE" hover="enumeration CompareOp   {CompareOp_GT, CompareOp_GE, CompareOp_EQ,&#13; CompareOp_LE, CompareOp_LT}">CompareOp_LE</anchor>, <anchor link="CompareOp_LT" hover="enumeration CompareOp   {CompareOp_GT, CompareOp_GE, CompareOp_EQ,&#13; CompareOp_LE, CompareOp_LT}">CompareOp_LT</anchor>};</pstext>
    </ps>
    <ps name="aarch64/instrs/vector/logical/immediateop/ImmediateOp" mylink="aarch64.instrs.vector.logical.immediateop.ImmediateOp" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="ImmediateOp" hover="enumeration ImmediateOp {ImmediateOp_MOVI, ImmediateOp_MVNI,&#13; ImmediateOp_ORR, ImmediateOp_BIC}">ImmediateOp</anchor> {<anchor link="ImmediateOp_MOVI" hover="enumeration ImmediateOp {ImmediateOp_MOVI, ImmediateOp_MVNI,&#13; ImmediateOp_ORR, ImmediateOp_BIC}">ImmediateOp_MOVI</anchor>, <anchor link="ImmediateOp_MVNI" hover="enumeration ImmediateOp {ImmediateOp_MOVI, ImmediateOp_MVNI,&#13; ImmediateOp_ORR, ImmediateOp_BIC}">ImmediateOp_MVNI</anchor>,
                         <anchor link="ImmediateOp_ORR" hover="enumeration ImmediateOp {ImmediateOp_MOVI, ImmediateOp_MVNI,&#13; ImmediateOp_ORR, ImmediateOp_BIC}">ImmediateOp_ORR</anchor>, <anchor link="ImmediateOp_BIC" hover="enumeration ImmediateOp {ImmediateOp_MOVI, ImmediateOp_MVNI,&#13; ImmediateOp_ORR, ImmediateOp_BIC}">ImmediateOp_BIC</anchor>};</pstext>
    </ps>
    <ps name="aarch64/instrs/vector/reduce/reduceop/Reduce" mylink="aarch64.instrs.vector.reduce.reduceop.Reduce" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Reduce()
// ========

bits(esize) <anchor link="impl-aarch64.Reduce.3" hover="function: bits(esize) Reduce(ReduceOp op, bits(N) input, integer esize)">Reduce</anchor>(<a link="ReduceOp" file="shared_pseudocode.xml" hover="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp</a> op, bits(N) input, integer esize)
    boolean altfp = <a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; FPCR.AH == '1';
    return <a link="impl-aarch64.Reduce.4" file="shared_pseudocode.xml" hover="function: bits(esize) Reduce(ReduceOp op, bits(N) input, integer esize, boolean altfp)">Reduce</a>(op, input, esize, altfp);

// Reduce()
// ========
// Perform the operation 'op' on pairs of elements from the input vector,
// reducing the vector to a scalar result. The 'altfp' argument controls
// alternative floating-point behaviour.

bits(esize) <anchor link="impl-aarch64.Reduce.4" hover="function: bits(esize) Reduce(ReduceOp op, bits(N) input, integer esize, boolean altfp)">Reduce</anchor>(<a link="ReduceOp" file="shared_pseudocode.xml" hover="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp</a> op, bits(N) input, integer esize, boolean altfp)
    integer half;
    bits(esize) hi;
    bits(esize) lo;
    bits(esize) result;

    if N == esize then
        return input&lt;esize-1:0&gt;;

    half = N DIV 2;
    hi = <a link="impl-aarch64.Reduce.4" file="shared_pseudocode.xml" hover="function: bits(esize) Reduce(ReduceOp op, bits(N) input, integer esize, boolean altfp)">Reduce</a>(op, input&lt;N-1:half&gt;, esize, altfp);
    lo = <a link="impl-aarch64.Reduce.4" file="shared_pseudocode.xml" hover="function: bits(esize) Reduce(ReduceOp op, bits(N) input, integer esize, boolean altfp)">Reduce</a>(op, input&lt;half-1:0&gt;, esize, altfp);

    case op of
        when <a link="ReduceOp_FMINNUM" file="shared_pseudocode.xml" hover="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp_FMINNUM</a>
            result = <a link="impl-shared.FPMinNum.3" file="shared_pseudocode.xml" hover="function: bits(N) FPMinNum(bits(N) op1_in, bits(N) op2_in, FPCRType fpcr)">FPMinNum</a>(lo, hi, FPCR[]);
        when <a link="ReduceOp_FMAXNUM" file="shared_pseudocode.xml" hover="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp_FMAXNUM</a>
            result = <a link="impl-shared.FPMaxNum.3" file="shared_pseudocode.xml" hover="function: bits(N) FPMaxNum(bits(N) op1_in, bits(N) op2_in, FPCRType fpcr)">FPMaxNum</a>(lo, hi, FPCR[]);
        when <a link="ReduceOp_FMIN" file="shared_pseudocode.xml" hover="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp_FMIN</a>
            result = <a link="impl-shared.FPMin.4" file="shared_pseudocode.xml" hover="function: bits(N) FPMin(bits(N) op1, bits(N) op2, FPCRType fpcr_in, boolean altfp)">FPMin</a>(lo, hi, FPCR[], altfp);
        when <a link="ReduceOp_FMAX" file="shared_pseudocode.xml" hover="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp_FMAX</a>
            result = <a link="impl-shared.FPMax.4" file="shared_pseudocode.xml" hover="function: bits(N) FPMax(bits(N) op1, bits(N) op2, FPCRType fpcr_in, boolean altfp)">FPMax</a>(lo, hi, FPCR[], altfp);
        when <a link="ReduceOp_FADD" file="shared_pseudocode.xml" hover="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp_FADD</a>
            result = <a link="impl-shared.FPAdd.3" file="shared_pseudocode.xml" hover="function: bits(N) FPAdd(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPAdd</a>(lo, hi, FPCR[]);
        when <a link="ReduceOp_ADD" file="shared_pseudocode.xml" hover="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp_ADD</a>
            result = lo + hi;

    return result;</pstext>
    </ps>
    <ps name="aarch64/instrs/vector/reduce/reduceop/ReduceOp" mylink="aarch64.instrs.vector.reduce.reduceop.ReduceOp" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="ReduceOp" hover="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp</anchor> {<anchor link="ReduceOp_FMINNUM" hover="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp_FMINNUM</anchor>, <anchor link="ReduceOp_FMAXNUM" hover="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp_FMAXNUM</anchor>,
                      <anchor link="ReduceOp_FMIN" hover="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp_FMIN</anchor>, <anchor link="ReduceOp_FMAX" hover="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp_FMAX</anchor>,
                      <anchor link="ReduceOp_FADD" hover="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp_FADD</anchor>, <anchor link="ReduceOp_ADD" hover="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp_ADD</anchor>};</pstext>
    </ps>
    <ps name="aarch64/translation/debug/AArch64.CheckBreakpoint" mylink="aarch64.translation.debug.AArch64.CheckBreakpoint" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.CheckBreakpoint()
// =========================
// Called before executing the instruction of length "size" bytes at "vaddress" in an AArch64
// translation regime, when either debug exceptions are enabled, or halting debug is enabled
// and halting is allowed.

FaultRecord <anchor link="AArch64.CheckBreakpoint.3" hover="function: FaultRecord AArch64.CheckBreakpoint(bits(64) vaddress, AccType acctype_in, integer size)">AArch64.CheckBreakpoint</anchor>(bits(64) vaddress, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype_in, integer size)
    assert !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());
    assert (<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; size IN {2,4}) || size == 4;
    <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype = acctype_in;

    match = FALSE;

    for i = 0 to <a link="impl-shared.NumBreakpointsImplemented.0" file="shared_pseudocode.xml" hover="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() - 1
        match_i = <a link="AArch64.BreakpointMatch.4" file="shared_pseudocode.xml" hover="function: boolean AArch64.BreakpointMatch(integer n, bits(64) vaddress,&#13; AccType acctype, integer size)">AArch64.BreakpointMatch</a>(i, vaddress, acctype, size);
        match = match || match_i;

    if match &amp;&amp; <a link="impl-shared.HaltOnBreakpointOrWatchpoint.0" file="shared_pseudocode.xml" hover="function: boolean HaltOnBreakpointOrWatchpoint()">HaltOnBreakpointOrWatchpoint</a>() then
        reason = <a link="DebugHalt_Breakpoint" file="shared_pseudocode.xml" hover="constant bits(6) DebugHalt_Breakpoint = '000111'">DebugHalt_Breakpoint</a>;
        <a link="impl-shared.Halt.1" file="shared_pseudocode.xml" hover="function: Halt(bits(6) reason)">Halt</a>(reason);
    elsif match then
        acctype = <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a>;
        iswrite = FALSE;
        return <a link="AArch64.DebugFault.2" file="shared_pseudocode.xml" hover="function: FaultRecord AArch64.DebugFault(AccType acctype, boolean iswrite)">AArch64.DebugFault</a>(acctype, iswrite);
    else
        return <a link="impl-shared.NoFault.0" file="shared_pseudocode.xml" hover="function: FaultRecord NoFault()">NoFault</a>();</pstext>
    </ps>
    <ps name="aarch64/translation/debug/AArch64.CheckDebug" mylink="aarch64.translation.debug.AArch64.CheckDebug" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.CheckDebug()
// ====================
// Called on each access to check for a debug exception or entry to Debug state.

FaultRecord <anchor link="AArch64.CheckDebug.4" hover="function: FaultRecord AArch64.CheckDebug(bits(64) vaddress, AccType acctype, boolean iswrite, integer size)">AArch64.CheckDebug</anchor>(bits(64) vaddress, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite, integer size)

    <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault = <a link="impl-shared.NoFault.0" file="shared_pseudocode.xml" hover="function: FaultRecord NoFault()">NoFault</a>();
    boolean generate_exception;

    d_side = (acctype != <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a>);
    if <a link="impl-shared.HaveNV2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveNV2Ext()">HaveNV2Ext</a>() &amp;&amp; acctype == <a link="AccType_NV2REGISTER" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NV2REGISTER</a> then
        mask = '0';
        generate_exception = <a link="AArch64.GenerateDebugExceptionsFrom.3" file="shared_pseudocode.xml" hover="function: boolean AArch64.GenerateDebugExceptionsFrom(bits(2) from, boolean secure, bit mask)">AArch64.GenerateDebugExceptionsFrom</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, <a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>(), mask) &amp;&amp; MDSCR_EL1.MDE == '1';
    else
        generate_exception = <a link="AArch64.GenerateDebugExceptions.0" file="shared_pseudocode.xml" hover="function: boolean AArch64.GenerateDebugExceptions()">AArch64.GenerateDebugExceptions</a>() &amp;&amp; MDSCR_EL1.MDE == '1';
    halt = <a link="impl-shared.HaltOnBreakpointOrWatchpoint.0" file="shared_pseudocode.xml" hover="function: boolean HaltOnBreakpointOrWatchpoint()">HaltOnBreakpointOrWatchpoint</a>();

    if generate_exception || halt then
        if d_side then
            fault = <a link="AArch64.CheckWatchpoint.4" file="shared_pseudocode.xml" hover="function: FaultRecord AArch64.CheckWatchpoint(bits(64) vaddress, AccType acctype,&#13; boolean iswrite_in, integer size)">AArch64.CheckWatchpoint</a>(vaddress, acctype, iswrite, size);
        else
            fault = <a link="AArch64.CheckBreakpoint.3" file="shared_pseudocode.xml" hover="function: FaultRecord AArch64.CheckBreakpoint(bits(64) vaddress, AccType acctype_in, integer size)">AArch64.CheckBreakpoint</a>(vaddress, acctype, size);

    return fault;</pstext>
    </ps>
    <ps name="aarch64/translation/debug/AArch64.CheckWatchpoint" mylink="aarch64.translation.debug.AArch64.CheckWatchpoint" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.CheckWatchpoint()
// =========================
// Called before accessing the memory location of "size" bytes at "address",
// when either debug exceptions are enabled for the access, or halting debug
// is enabled and halting is allowed.

FaultRecord <anchor link="AArch64.CheckWatchpoint.4" hover="function: FaultRecord AArch64.CheckWatchpoint(bits(64) vaddress, AccType acctype,&#13; boolean iswrite_in, integer size)">AArch64.CheckWatchpoint</anchor>(bits(64) vaddress, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype,
                                    boolean iswrite_in, integer size)
    assert !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="impl-shared.S1TranslationRegime.0" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());
    boolean iswrite = iswrite_in;

    if acctype IN {<a link="AccType_TTW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_TTW</a>, <a link="AccType_IC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>, <a link="AccType_AT" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</a>, <a link="AccType_ATPAN" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATPAN</a>} then
        return <a link="impl-shared.NoFault.0" file="shared_pseudocode.xml" hover="function: FaultRecord NoFault()">NoFault</a>();
    if acctype == <a link="AccType_DC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a> then
        if !iswrite then
            return <a link="impl-shared.NoFault.0" file="shared_pseudocode.xml" hover="function: FaultRecord NoFault()">NoFault</a>();

    match = FALSE;
    match_on_read = FALSE;
    ispriv = <a link="AArch64.AccessUsesEL.1" file="shared_pseudocode.xml" hover="function: bits(2) AArch64.AccessUsesEL(AccType acctype)">AArch64.AccessUsesEL</a>(acctype) != <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>;

    for i = 0 to <a link="impl-shared.NumWatchpointsImplemented.0" file="shared_pseudocode.xml" hover="function: integer NumWatchpointsImplemented()">NumWatchpointsImplemented</a>() - 1
        if <a link="AArch64.WatchpointMatch.6" file="shared_pseudocode.xml" hover="function: boolean AArch64.WatchpointMatch(integer n, bits(64) vaddress, integer size, boolean ispriv,&#13; AccType acctype, boolean iswrite)">AArch64.WatchpointMatch</a>(i, vaddress, size, ispriv, acctype, iswrite) then
            match = TRUE;
            if DBGWCR_EL1[i].LSC&lt;0&gt; == '1' then
                match_on_read = TRUE;

    if match &amp;&amp; acctype == <a link="AccType_ATOMICRW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a> then
        iswrite = !match_on_read;

    if match &amp;&amp; <a link="impl-shared.HaltOnBreakpointOrWatchpoint.0" file="shared_pseudocode.xml" hover="function: boolean HaltOnBreakpointOrWatchpoint()">HaltOnBreakpointOrWatchpoint</a>() then
        reason = <a link="DebugHalt_Watchpoint" file="shared_pseudocode.xml" hover="constant bits(6) DebugHalt_Watchpoint = '101011'">DebugHalt_Watchpoint</a>;
        EDWAR = vaddress;
        <a link="impl-shared.Halt.1" file="shared_pseudocode.xml" hover="function: Halt(bits(6) reason)">Halt</a>(reason);
    elsif match then
        return <a link="AArch64.DebugFault.2" file="shared_pseudocode.xml" hover="function: FaultRecord AArch64.DebugFault(AccType acctype, boolean iswrite)">AArch64.DebugFault</a>(acctype, iswrite);
    else
        return <a link="impl-shared.NoFault.0" file="shared_pseudocode.xml" hover="function: FaultRecord NoFault()">NoFault</a>();</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_addrcalc/AArch64.BlockBase" mylink="aarch64.translation.vmsa_addrcalc.AArch64.BlockBase" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.BlockBase()
// ===================
// Extract the address embedded in a block descriptor pointing to the base of
// a memory block

bits(52) <anchor link="AArch64.BlockBase.4" hover="function: bits(52) AArch64.BlockBase(bits(64) descriptor, bit ds, TGx tgx, integer level)">AArch64.BlockBase</anchor>(bits(64) descriptor, bit ds, <a link="TGx" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, integer level)
    bits(52) blockbase = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();

    if tgx == <a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a> &amp;&amp; level == 2 then
        blockbase&lt;47:21&gt; = descriptor&lt;47:21&gt;;
    elsif tgx == <a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a> &amp;&amp; level == 1 then
        blockbase&lt;47:30&gt; = descriptor&lt;47:30&gt;;
    elsif tgx == <a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a> &amp;&amp; level == 0 then
        blockbase&lt;47:39&gt; = descriptor&lt;47:39&gt;;
    elsif tgx == <a link="TGx_16KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a> &amp;&amp; level == 2 then
        blockbase&lt;47:25&gt; = descriptor&lt;47:25&gt;;
    elsif tgx == <a link="TGx_16KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a> &amp;&amp; level == 1 then
        blockbase&lt;47:36&gt; = descriptor&lt;47:36&gt;;
    elsif tgx == <a link="TGx_64KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> &amp;&amp; level == 2 then
        blockbase&lt;47:29&gt; = descriptor&lt;47:29&gt;;
    elsif tgx == <a link="TGx_64KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> &amp;&amp; level == 1 then
        blockbase&lt;47:42&gt; = descriptor&lt;47:42&gt;;
    else
        <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();

    if <a link="impl-shared.Have52BitPAExt.0" file="shared_pseudocode.xml" hover="function: boolean Have52BitPAExt()">Have52BitPAExt</a>() &amp;&amp; tgx == <a link="TGx_64KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> then
        blockbase&lt;51:48&gt; = descriptor&lt;15:12&gt;;
    elsif ds == '1' then
        blockbase&lt;51:48&gt; = descriptor&lt;9:8&gt;:descriptor&lt;49:48&gt;;

    return blockbase;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_addrcalc/AArch64.IASize" mylink="aarch64.translation.vmsa_addrcalc.AArch64.IASize" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.IASize()
// ================
// Retrieve the number of bits containing the input address

integer <anchor link="AArch64.IASize.1" hover="function: integer AArch64.IASize(bits(6) txsz)">AArch64.IASize</anchor>(bits(6) txsz)
    return 64 - <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(txsz);</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_addrcalc/AArch64.NextTableBase" mylink="aarch64.translation.vmsa_addrcalc.AArch64.NextTableBase" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.NextTableBase()
// =======================
// Extract the address embedded in a table descriptor pointing to the base of
// the next level table of descriptors

bits(52) <anchor link="AArch64.NextTableBase.3" hover="function: bits(52) AArch64.NextTableBase(bits(64) descriptor, bit ds, TGx tgx)">AArch64.NextTableBase</anchor>(bits(64) descriptor, bit ds, <a link="TGx" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx)
    bits(52) tablebase = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();

    case tgx of
        when <a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>  tablebase&lt;47:12&gt; = descriptor&lt;47:12&gt;;
        when <a link="TGx_16KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a> tablebase&lt;47:14&gt; = descriptor&lt;47:14&gt;;
        when <a link="TGx_64KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> tablebase&lt;47:16&gt; = descriptor&lt;47:16&gt;;

    if <a link="impl-shared.Have52BitPAExt.0" file="shared_pseudocode.xml" hover="function: boolean Have52BitPAExt()">Have52BitPAExt</a>() &amp;&amp; tgx == <a link="TGx_64KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> then
        tablebase&lt;51:48&gt; = descriptor&lt;15:12&gt;;
    elsif ds == '1' then
        tablebase&lt;51:48&gt; = descriptor&lt;9:8&gt;:descriptor&lt;49:48&gt;;

    return tablebase;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_addrcalc/AArch64.PageBase" mylink="aarch64.translation.vmsa_addrcalc.AArch64.PageBase" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.PageBase()
// ==================
// Extract the address embedded in a page descriptor pointing to the base of
// a memory page

bits(52) <anchor link="AArch64.PageBase.3" hover="function: bits(52) AArch64.PageBase(bits(64) descriptor, bit ds, TGx tgx)">AArch64.PageBase</anchor>(bits(64) descriptor, bit ds, <a link="TGx" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx)
    bits(52) pagebase = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();

    case tgx of
        when <a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>  pagebase&lt;47:12&gt; = descriptor&lt;47:12&gt;;
        when <a link="TGx_16KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a> pagebase&lt;47:14&gt; = descriptor&lt;47:14&gt;;
        when <a link="TGx_64KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> pagebase&lt;47:16&gt; = descriptor&lt;47:16&gt;;

    if <a link="impl-shared.Have52BitPAExt.0" file="shared_pseudocode.xml" hover="function: boolean Have52BitPAExt()">Have52BitPAExt</a>() &amp;&amp; tgx == <a link="TGx_64KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> then
        pagebase&lt;51:48&gt; = descriptor&lt;15:12&gt;;
    elsif ds == '1' then
        pagebase&lt;51:48&gt; = descriptor&lt;9:8&gt;:descriptor&lt;49:48&gt;;

    return pagebase;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_addrcalc/AArch64.PhysicalAddressSize" mylink="aarch64.translation.vmsa_addrcalc.AArch64.PhysicalAddressSize" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.PhysicalAddressSize()
// =============================
// Retrieve the number of bits bounding the physical address

integer <anchor link="AArch64.PhysicalAddressSize.2" hover="function: integer AArch64.PhysicalAddressSize(bits(3) encoded_ps, TGx tgx)">AArch64.PhysicalAddressSize</anchor>(bits(3) encoded_ps, <a link="TGx" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx)
    integer ps;
    integer max_ps;

    case encoded_ps of
        when '000'  ps = 32;
        when '001'  ps = 36;
        when '010'  ps = 40;
        when '011'  ps = 42;
        when '100'  ps = 44;
        when '101'  ps = 48;
        when '110'  ps = 52;
        otherwise
            ps = integer IMPLEMENTATION_DEFINED "Reserved Intermediate Physical Address size value";

    if tgx != <a link="TGx_64KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> &amp;&amp; !<a link="impl-shared.Have52BitIPAAndPASpaceExt.0" file="shared_pseudocode.xml" hover="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
        max_ps = <a link="impl-shared.Min.2" file="shared_pseudocode.xml" hover="function: integer Min(integer a, integer b)">Min</a>(48, <a link="AArch64.PAMax.0" file="shared_pseudocode.xml" hover="function: integer AArch64.PAMax()">AArch64.PAMax</a>());
    else
        max_ps = <a link="AArch64.PAMax.0" file="shared_pseudocode.xml" hover="function: integer AArch64.PAMax()">AArch64.PAMax</a>();

    return <a link="impl-shared.Min.2" file="shared_pseudocode.xml" hover="function: integer Min(integer a, integer b)">Min</a>(ps, max_ps);</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_addrcalc/AArch64.S1StartLevel" mylink="aarch64.translation.vmsa_addrcalc.AArch64.S1StartLevel" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S1StartLevel()
// ======================
// Compute the initial lookup level when performing a stage 1 translation
// table walk

integer <anchor link="AArch64.S1StartLevel.1" hover="function: integer AArch64.S1StartLevel(S1TTWParams walkparams)">AArch64.S1StartLevel</anchor>(<a link="S1TTWParams" file="shared_pseudocode.xml" hover="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams)
    // Input Address size
    iasize   = <a link="AArch64.IASize.1" file="shared_pseudocode.xml" hover="function: integer AArch64.IASize(bits(6) txsz)">AArch64.IASize</a>(walkparams.txsz);
    granulebits = <a link="impl-shared.TGxGranuleBits.1" file="shared_pseudocode.xml" hover="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(walkparams.tgx);
    stride      = granulebits - 3;

    return <a link="FINAL_LEVEL" file="shared_pseudocode.xml" hover="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - (((iasize-1) - granulebits) DIV stride);</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_addrcalc/AArch64.S2SLTTEntryAddress" mylink="aarch64.translation.vmsa_addrcalc.AArch64.S2SLTTEntryAddress" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S2SLTTEntryAddress()
// ============================
// Compute the first stage 2 translation table descriptor address within the
// table pointed to by the base at the start level

FullAddress <anchor link="AArch64.S2SLTTEntryAddress.3" hover="function: FullAddress AArch64.S2SLTTEntryAddress(S2TTWParams walkparams, bits(52) ipa,&#13; FullAddress tablebase)">AArch64.S2SLTTEntryAddress</anchor>(<a link="S2TTWParams" file="shared_pseudocode.xml" hover="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams, bits(52) ipa,
                                       <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> tablebase)
    startlevel  = <a link="AArch64.S2StartLevel.1" file="shared_pseudocode.xml" hover="function: integer AArch64.S2StartLevel(S2TTWParams walkparams)">AArch64.S2StartLevel</a>(walkparams);
    iasize      = <a link="AArch64.IASize.1" file="shared_pseudocode.xml" hover="function: integer AArch64.IASize(bits(6) txsz)">AArch64.IASize</a>(walkparams.txsz);
    granulebits = <a link="impl-shared.TGxGranuleBits.1" file="shared_pseudocode.xml" hover="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(walkparams.tgx);
    stride      = granulebits - 3;
    levels      = <a link="FINAL_LEVEL" file="shared_pseudocode.xml" hover="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - startlevel;

    bits(52) index;
    lsb   = levels*stride + granulebits;
    msb   = iasize - 1;
    index = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(ipa&lt;msb:lsb&gt;:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(3));

    <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> descaddress;
    descaddress.address = tablebase.address OR index;
    descaddress.paspace = tablebase.paspace;

    return descaddress;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_addrcalc/AArch64.S2StartLevel" mylink="aarch64.translation.vmsa_addrcalc.AArch64.S2StartLevel" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S2StartLevel()
// ======================
// Determine the initial lookup level when performing a stage 2 translation
// table walk

integer <anchor link="AArch64.S2StartLevel.1" hover="function: integer AArch64.S2StartLevel(S2TTWParams walkparams)">AArch64.S2StartLevel</anchor>(<a link="S2TTWParams" file="shared_pseudocode.xml" hover="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams)
    case walkparams.tgx of
        when <a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>
            case walkparams.sl2:walkparams.sl0 of
                when '000' return 2;
                when '001' return 1;
                when '010' return 0;
                when '011' return 3;
                when '100' return -1;
        when <a link="TGx_16KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>
            case walkparams.sl0 of
                when '00' return 3;
                when '01' return 2;
                when '10' return 1;
                when '11' return 0;
        when <a link="TGx_64KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a>
            case walkparams.sl0 of
                when '00' return 3;
                when '01' return 2;
                when '10' return 1;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_addrcalc/AArch64.TTBaseAddress" mylink="aarch64.translation.vmsa_addrcalc.AArch64.TTBaseAddress" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.TTBaseAddress()
// =======================
// Retrieve the PA/IPA pointing to the base of the initial translation table

bits(52) <anchor link="AArch64.TTBaseAddress.6" hover="function: bits(52) AArch64.TTBaseAddress(bits(64) ttb, bits(6) txsz, bits(3) ps,&#13; bit ds, TGx tgx, integer startlevel)">AArch64.TTBaseAddress</anchor>(bits(64) ttb, bits(6) txsz, bits(3) ps,
                                   bit ds, <a link="TGx" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, integer startlevel)
    bits(52) tablebase = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();

    // Input Address size
    iasize      = <a link="AArch64.IASize.1" file="shared_pseudocode.xml" hover="function: integer AArch64.IASize(bits(6) txsz)">AArch64.IASize</a>(txsz);
    granulebits = <a link="impl-shared.TGxGranuleBits.1" file="shared_pseudocode.xml" hover="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(tgx);
    stride      = granulebits - 3;
    levels      = <a link="FINAL_LEVEL" file="shared_pseudocode.xml" hover="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - startlevel;

    // Base address is aligned to size of the initial translation table in bytes
    tsize = (iasize - (levels*stride + granulebits)) + 3;

    if (<a link="impl-shared.Have52BitPAExt.0" file="shared_pseudocode.xml" hover="function: boolean Have52BitPAExt()">Have52BitPAExt</a>() &amp;&amp; tgx == <a link="TGx_64KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> &amp;&amp; ps == '110') || (ds == '1') then
        tsize = <a link="impl-shared.Max.2" file="shared_pseudocode.xml" hover="function: integer Max(integer a, integer b)">Max</a>(tsize, 6);
        tablebase&lt;51:6&gt; = ttb&lt;5:2&gt;:ttb&lt;47:6&gt;;
    else
        tablebase&lt;47:1&gt; = ttb&lt;47:1&gt;;

    tablebase = <a link="impl-shared.Align.2" file="shared_pseudocode.xml" hover="function: integer Align(integer x, integer y)">Align</a>(tablebase, 1 &lt;&lt; tsize);
    return tablebase;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_addrcalc/AArch64.TTEntryAddress" mylink="aarch64.translation.vmsa_addrcalc.AArch64.TTEntryAddress" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.TTEntryAddress()
// ========================
// Compute translation table descriptor address within the table pointed to by
// the table base

FullAddress <anchor link="AArch64.TTEntryAddress.5" hover="function: FullAddress AArch64.TTEntryAddress(integer level, TGx tgx, bits(6) txsz,&#13; bits(64) ia, FullAddress tablebase)">AArch64.TTEntryAddress</anchor>(integer level, <a link="TGx" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, bits(6) txsz,
                                   bits(64) ia, <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> tablebase)
    // Input Address size
    iasize      = <a link="AArch64.IASize.1" file="shared_pseudocode.xml" hover="function: integer AArch64.IASize(bits(6) txsz)">AArch64.IASize</a>(txsz);
    granulebits = <a link="impl-shared.TGxGranuleBits.1" file="shared_pseudocode.xml" hover="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(tgx);
    stride      = granulebits - 3;
    levels      = <a link="FINAL_LEVEL" file="shared_pseudocode.xml" hover="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - level;

    bits(52) index;
    lsb   = levels*stride + granulebits;
    msb   = <a link="impl-shared.Min.2" file="shared_pseudocode.xml" hover="function: integer Min(integer a, integer b)">Min</a>(iasize - 1, (lsb + stride) - 1);
    index = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(ia&lt;msb:lsb&gt;:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(3));

    <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> descaddress;
    descaddress.address = tablebase.address OR index;
    descaddress.paspace = tablebase.paspace;

    return descaddress;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_faults/AArch64.AddrTop" mylink="aarch64.translation.vmsa_faults.AArch64.AddrTop" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.AddrTop()
// =================
// Get the top bit position of the virtual address.
// Bits above are not accounted as part of the translation process.

integer <anchor link="AArch64.AddrTop.3" hover="function: integer AArch64.AddrTop(bit tbid, AccType acctype, bit tbi)">AArch64.AddrTop</anchor>(bit tbid, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, bit tbi)
    if tbid == '1' &amp;&amp; acctype == <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> then
        return 63;

    if tbi == '1' then
        return 55;
    else
        return 63;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_faults/AArch64.ContiguousBitFaults" mylink="aarch64.translation.vmsa_faults.AArch64.ContiguousBitFaults" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.ContiguousBitFaults()
// =============================
// If contiguous bit is set, returns whether the translation size exceeds the
// input address size and if the implementation generates a fault

boolean <anchor link="AArch64.ContiguousBitFaults.3" hover="function: boolean AArch64.ContiguousBitFaults(bits(6) txsz, TGx tgx, integer level)">AArch64.ContiguousBitFaults</anchor>(bits(6) txsz, <a link="TGx" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, integer level)
    // Input Address size
    iasize = <a link="AArch64.IASize.1" file="shared_pseudocode.xml" hover="function: integer AArch64.IASize(bits(6) txsz)">AArch64.IASize</a>(txsz);
    // Translation size
    tsize  = <a link="impl-shared.TranslationSize.2" file="shared_pseudocode.xml" hover="function: integer TranslationSize(TGx tgx, integer level)">TranslationSize</a>(tgx, level) + <a link="impl-shared.ContiguousSize.2" file="shared_pseudocode.xml" hover="function: integer ContiguousSize(TGx tgx, integer level)">ContiguousSize</a>(tgx, level);

    fault = boolean IMPLEMENTATION_DEFINED "Translation fault on misprogrammed contiguous bit";

    return tsize &gt; iasize &amp;&amp; fault;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_faults/AArch64.DebugFault" mylink="aarch64.translation.vmsa_faults.AArch64.DebugFault" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.DebugFault()
// ====================
// Return a fault record indicating a hardware watchpoint/breakpoint

FaultRecord <anchor link="AArch64.DebugFault.2" hover="function: FaultRecord AArch64.DebugFault(AccType acctype, boolean iswrite)">AArch64.DebugFault</anchor>(<a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite)
    <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault;

    fault.statuscode  = <a link="Fault_Debug" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Debug</a>;
    fault.acctype     = acctype;
    fault.write       = iswrite;
    fault.secondstage = FALSE;
    fault.s2fs1walk   = FALSE;

    return fault;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_faults/AArch64.ExclusiveFault" mylink="aarch64.translation.vmsa_faults.AArch64.ExclusiveFault" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.ExclusiveFault()
// ========================

FaultRecord <anchor link="AArch64.ExclusiveFault.4" hover="function: FaultRecord AArch64.ExclusiveFault(AccType acctype, boolean iswrite,&#13; boolean secondstage, boolean s2fs1walk)">AArch64.ExclusiveFault</anchor>(<a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite,
                                   boolean secondstage, boolean s2fs1walk)
    <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault;

    fault.statuscode  = <a link="Fault_Exclusive" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Exclusive</a>;
    fault.acctype     = acctype;
    fault.write       = iswrite;
    fault.secondstage = secondstage;
    fault.s2fs1walk   = s2fs1walk;

    return fault;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_faults/AArch64.IPAIsOutOfRange" mylink="aarch64.translation.vmsa_faults.AArch64.IPAIsOutOfRange" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.IPAIsOutOfRange()
// =========================
// Check bits not resolved by translation are ZERO

boolean <anchor link="AArch64.IPAIsOutOfRange.2" hover="function: boolean AArch64.IPAIsOutOfRange(bits(52) ipa, S2TTWParams walkparams)">AArch64.IPAIsOutOfRange</anchor>(bits(52) ipa, <a link="S2TTWParams" file="shared_pseudocode.xml" hover="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams)
    //Input Address size
    iasize = <a link="AArch64.IASize.1" file="shared_pseudocode.xml" hover="function: integer AArch64.IASize(bits(6) txsz)">AArch64.IASize</a>(walkparams.txsz);

    if iasize &lt; 52 then
        return !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(ipa&lt;51:iasize&gt;);
    else
        return FALSE;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_faults/AArch64.OAOutOfRange" mylink="aarch64.translation.vmsa_faults.AArch64.OAOutOfRange" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.OAOutOfRange()
// ======================
// Returns whether output address is expressed in the configured size number of bits

boolean <anchor link="AArch64.OAOutOfRange.4" hover="function: boolean AArch64.OAOutOfRange(TTWState walkstate, bits(3) ps, TGx tgx, bits(64) ia)">AArch64.OAOutOfRange</anchor>(<a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate, bits(3) ps, <a link="TGx" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, bits(64) ia)
    // Output Address size
    oasize = <a link="AArch64.PhysicalAddressSize.2" file="shared_pseudocode.xml" hover="function: integer AArch64.PhysicalAddressSize(bits(3) encoded_ps, TGx tgx)">AArch64.PhysicalAddressSize</a>(ps, tgx);

    if oasize &lt; 52 then
        if walkstate.istable then
            baseaddress = walkstate.baseaddress.address;
            return !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(baseaddress&lt;51:oasize&gt;);
        else
            // Output address
            oa = <a link="impl-shared.StageOA.3" file="shared_pseudocode.xml" hover="function: FullAddress StageOA(bits(64) ia, TGx tgx, TTWState walkstate)">StageOA</a>(ia, tgx, walkstate);
            return !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(oa.address&lt;51:oasize&gt;);
    else
        return FALSE;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_faults/AArch64.S1HasAlignmentFault" mylink="aarch64.translation.vmsa_faults.AArch64.S1HasAlignmentFault" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S1HasAlignmentFault()
// =============================
// Returns whether stage 1 output fails alignment requirement on data accesses
// to Device memory

boolean <anchor link="AArch64.S1HasAlignmentFault.4" hover="function: boolean AArch64.S1HasAlignmentFault(AccType acctype, boolean aligned,&#13; bit ntlsmd, MemoryAttributes memattrs)">AArch64.S1HasAlignmentFault</anchor>(<a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned,
                                    bit ntlsmd, <a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs)
    if acctype == <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> || memattrs.memtype != <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
        return FALSE;

    if acctype == <a link="AccType_A32LSMD" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_A32LSMD</a> &amp;&amp; ntlsmd == '0' &amp;&amp; memattrs.device != <a link="DeviceType_GRE" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_GRE</a> then
        return TRUE;

    return !aligned || acctype == <a link="AccType_DCZVA" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DCZVA</a>;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_faults/AArch64.S1HasPermissionsFault" mylink="aarch64.translation.vmsa_faults.AArch64.S1HasPermissionsFault" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S1HasPermissionsFault()
// ===============================
// Returns whether stage 1 access violates permissions of target memory

boolean <anchor link="AArch64.S1HasPermissionsFault.7" hover="function: boolean AArch64.S1HasPermissionsFault(Regime regime, SecurityState ss, TTWState walkstate,&#13; S1TTWParams walkparams, boolean ispriv, AccType acctype,&#13; boolean iswrite)">AArch64.S1HasPermissionsFault</anchor>(<a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate,
                                      <a link="S1TTWParams" file="shared_pseudocode.xml" hover="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams, boolean ispriv, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype,
                                      boolean iswrite)
    bit r;
    bit w;
    bit x;
    permissions = walkstate.permissions;

    if <a link="impl-shared.HasUnprivileged.1" file="shared_pseudocode.xml" hover="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then
        bit pr;
        bit pw;
        bit ur;
        bit uw;
        // Apply leaf permissions
        case permissions.ap&lt;2:1&gt; of
            when '00' (pr,pw,ur,uw) = ('1','1','0','0'); // Privileged access
            when '01' (pr,pw,ur,uw) = ('1','1','1','1'); // No effect
            when '10' (pr,pw,ur,uw) = ('1','0','0','0'); // Read-only, privileged access
            when '11' (pr,pw,ur,uw) = ('1','0','1','0'); // Read-only

        // Apply hierarchical permissions
        case permissions.ap_table of
            when '00' (pr,pw,ur,uw) = ( pr, pw, ur, uw); // No effect
            when '01' (pr,pw,ur,uw) = ( pr, pw,'0','0'); // Privileged access
            when '10' (pr,pw,ur,uw) = ( pr,'0', ur,'0'); // Read-only
            when '11' (pr,pw,ur,uw) = ( pr,'0','0','0'); // Read-only, privileged access

        // Locations writable by unprivileged cannot be executed by privileged
        px = NOT(permissions.pxn OR permissions.pxn_table OR uw);
        ux = NOT(permissions.uxn OR permissions.uxn_table);

        pan_access = !(acctype IN {<a link="AccType_DC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>, <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a>, <a link="AccType_AT" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</a>, <a link="AccType_NV2REGISTER" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NV2REGISTER</a>});
        if <a link="impl-shared.HavePANExt.0" file="shared_pseudocode.xml" hover="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; pan_access &amp;&amp; !(regime == <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; walkparams.nv1 == '1') then
            bit pan;
            if (boolean IMPLEMENTATION_DEFINED "SCR_EL3.SIF affects EPAN" &amp;&amp;
                    <a link="impl-shared.CurrentSecurityState.0" file="shared_pseudocode.xml" hover="function: SecurityState CurrentSecurityState()">CurrentSecurityState</a>() == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp;
                    walkstate.baseaddress.paspace == <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a> &amp;&amp;
                    walkparams.sif == '1') then
                ux = '0';

            pan = PSTATE.PAN AND (ur OR uw OR (walkparams.epan AND ux));
            pr = pr AND NOT(pan);
            pw = pw AND NOT(pan);

        (r,w,x) = if ispriv then (pr,pw,px) else (ur,uw,ux);
    else
        // Apply leaf permissions
        case permissions.ap&lt;2&gt; of
            when '0' (r,w) = ('1','1'); // No effect
            when '1' (r,w) = ('1','0'); // Read-only

        // Apply hierarchical permissions
        case permissions.ap_table&lt;1&gt; of
            when '0' (r,w) = ( r , w ); // No effect
            when '1' (r,w) = ( r ,'0'); // Read-only

        x = NOT(permissions.xn OR permissions.xn_table);

    // Prevent execution from writable locations if WXN is set
    x = x AND NOT(walkparams.wxn AND w);
    // Prevent execution from Non-secure space by PE in secure state if SIF is set
    if ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp; walkstate.baseaddress.paspace == <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a> then
        x = x AND NOT(walkparams.sif);

    if acctype == <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> then
        if (<a link="impl-shared.ConstrainUnpredictable.1" file="shared_pseudocode.xml" hover="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a link="Unpredictable_INSTRDEVICE" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_INSTRDEVICE</a>) == <a link="Constraint_FAULT" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a> &amp;&amp;
                walkstate.memattrs.memtype == <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>) then
            return TRUE;

        return x == '0';
    elsif acctype == <a link="AccType_DC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a> then
        if iswrite then
            return w == '0';
        else
            // DC from privileged context which do no write cannot permission fault
            return !ispriv &amp;&amp; (r == '0' ||
                (<a link="impl-shared.IsCMOWControlledInstruction.0" file="shared_pseudocode.xml" hover="function: boolean IsCMOWControlledInstruction()">IsCMOWControlledInstruction</a>() &amp;&amp; walkparams.cmow == '1' &amp;&amp; w == '0'));
    elsif acctype == <a link="AccType_IC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a> then
        // IC instructions do not write
        assert !iswrite;
        impdef_ic_fault = boolean IMPLEMENTATION_DEFINED "Permission fault on <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> IC_IVAU execution";

        // IC from privileged context cannot permission fault
        return !ispriv &amp;&amp; ((r == '0' &amp;&amp; impdef_ic_fault) ||
            (<a link="impl-shared.IsCMOWControlledInstruction.0" file="shared_pseudocode.xml" hover="function: boolean IsCMOWControlledInstruction()">IsCMOWControlledInstruction</a>() &amp;&amp; walkparams.cmow == '1' &amp;&amp; w == '0'));
    elsif iswrite then
        return w == '0';
    else
        return r == '0';</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_faults/AArch64.S1InvalidTxSZ" mylink="aarch64.translation.vmsa_faults.AArch64.S1InvalidTxSZ" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S1InvalidTxSZ()
// =======================
// Detect erroneous configuration of stage 1 TxSZ field if the implementation
// does not constrain the value of TxSZ

boolean <anchor link="AArch64.S1InvalidTxSZ.1" hover="function: boolean AArch64.S1InvalidTxSZ(S1TTWParams walkparams)">AArch64.S1InvalidTxSZ</anchor>(<a link="S1TTWParams" file="shared_pseudocode.xml" hover="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams)
    mintxsz = <a link="AArch64.S1MinTxSZ.2" file="shared_pseudocode.xml" hover="function: integer AArch64.S1MinTxSZ(bit ds, TGx tgx)">AArch64.S1MinTxSZ</a>(walkparams.ds, walkparams.tgx);
    maxtxsz = <a link="AArch64.MaxTxSZ.1" file="shared_pseudocode.xml" hover="function: integer AArch64.MaxTxSZ(TGx tgx)">AArch64.MaxTxSZ</a>(walkparams.tgx);

    return <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(walkparams.txsz) &lt; mintxsz || <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(walkparams.txsz) &gt; maxtxsz;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_faults/AArch64.S2HasAlignmentFault" mylink="aarch64.translation.vmsa_faults.AArch64.S2HasAlignmentFault" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S2HasAlignmentFault()
// =============================
// Returns whether stage 2 output fails alignment requirement on data accesses
// to Device memory

boolean <anchor link="AArch64.S2HasAlignmentFault.3" hover="function: boolean AArch64.S2HasAlignmentFault(AccType acctype, boolean aligned, MemoryAttributes memattrs)">AArch64.S2HasAlignmentFault</anchor>(<a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned, <a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs)
    if acctype == <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> || memattrs.memtype != <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
        return FALSE;

    return !aligned || acctype == <a link="AccType_DCZVA" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DCZVA</a>;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_faults/AArch64.S2HasPermissionsFault" mylink="aarch64.translation.vmsa_faults.AArch64.S2HasPermissionsFault" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S2HasPermissionsFault()
// ===============================
// Returns whether stage 2 access violates permissions of target memory

boolean <anchor link="AArch64.S2HasPermissionsFault.7" hover="function: boolean AArch64.S2HasPermissionsFault(boolean s2fs1walk, TTWState walkstate, SecurityState ss,&#13; S2TTWParams walkparams, boolean ispriv, AccType acctype,&#13; boolean iswrite)">AArch64.S2HasPermissionsFault</anchor>(boolean s2fs1walk, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate, <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss,
                                      <a link="S2TTWParams" file="shared_pseudocode.xml" hover="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams, boolean ispriv, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype,
                                      boolean iswrite)
    permissions = walkstate.permissions;
    memtype = walkstate.memattrs.memtype;

    r = permissions.s2ap&lt;0&gt;;
    w = permissions.s2ap&lt;1&gt;;

    bit px;
    bit ux;
    case (permissions.s2xn:permissions.s2xnx) of
        when '00' (px,ux) = ('1','1');
        when '01' (px,ux) = ('0','1');
        when '10' (px,ux) = ('0','0');
        when '11' (px,ux) = ('1','0');

    x = if ispriv then px else ux;

    if s2fs1walk &amp;&amp; walkparams.ptw == '1' &amp;&amp; memtype == <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
        return TRUE;
    elsif acctype == <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> then
        constraint = <a link="impl-shared.ConstrainUnpredictable.1" file="shared_pseudocode.xml" hover="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a link="Unpredictable_INSTRDEVICE" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_INSTRDEVICE</a>);
        if constraint == <a link="Constraint_FAULT" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a> &amp;&amp; memtype == <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
            return TRUE;
        return x == '0';
    elsif acctype == <a link="AccType_DC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a> then
        // AArch32 DC maintenance instructions operating by VA cannot fault.
        if iswrite then
            return !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; w == '0';
        else
            return ((!ispriv &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; r == '0') ||
                (<a link="impl-shared.IsCMOWControlledInstruction.0" file="shared_pseudocode.xml" hover="function: boolean IsCMOWControlledInstruction()">IsCMOWControlledInstruction</a>() &amp;&amp; walkparams.cmow == '1' &amp;&amp; w == '0'));
    elsif acctype == <a link="AccType_IC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a> then
        // IC instructions do not write
        assert !iswrite;
        impdef_ic_fault = boolean IMPLEMENTATION_DEFINED "Permission fault on <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> IC_IVAU execution";

        return ((!ispriv &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; r == '0' &amp;&amp; impdef_ic_fault) ||
            (<a link="impl-shared.IsCMOWControlledInstruction.0" file="shared_pseudocode.xml" hover="function: boolean IsCMOWControlledInstruction()">IsCMOWControlledInstruction</a>() &amp;&amp; walkparams.cmow == '1' &amp;&amp; w == '0'));
    elsif iswrite then
        return w == '0';
    else
        return r == '0';</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_faults/AArch64.S2InconsistentSL" mylink="aarch64.translation.vmsa_faults.AArch64.S2InconsistentSL" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S2InconsistentSL()
// ==========================
// Detect inconsistent configuration of stage 2 TxSZ and SL fields

boolean <anchor link="AArch64.S2InconsistentSL.1" hover="function: boolean AArch64.S2InconsistentSL(S2TTWParams walkparams)">AArch64.S2InconsistentSL</anchor>(<a link="S2TTWParams" file="shared_pseudocode.xml" hover="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams)
    startlevel  = <a link="AArch64.S2StartLevel.1" file="shared_pseudocode.xml" hover="function: integer AArch64.S2StartLevel(S2TTWParams walkparams)">AArch64.S2StartLevel</a>(walkparams);
    levels      = <a link="FINAL_LEVEL" file="shared_pseudocode.xml" hover="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - startlevel;
    granulebits = <a link="impl-shared.TGxGranuleBits.1" file="shared_pseudocode.xml" hover="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(walkparams.tgx);
    stride      = granulebits - 3;

    // Input address size must at least be large enough to be resolved from the start level
    sl_min_iasize = (
        levels * stride // Bits resolved by table walk, except initial level
        + granulebits   // Bits directly mapped to output address
        + 1);           // At least 1 more bit to be decoded by initial level

    // Can accomodate 1 more stride in the level + concatenation of up to 2^4 tables
    sl_max_iasize = sl_min_iasize + (stride-1) + 4;
    // Configured Input Address size
    iasize        = <a link="AArch64.IASize.1" file="shared_pseudocode.xml" hover="function: integer AArch64.IASize(bits(6) txsz)">AArch64.IASize</a>(walkparams.txsz);

    return iasize &lt; sl_min_iasize || iasize &gt; sl_max_iasize;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_faults/AArch64.S2InvalidSL" mylink="aarch64.translation.vmsa_faults.AArch64.S2InvalidSL" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S2InvalidSL()
// =====================
// Detect invalid configuration of SL field

boolean <anchor link="AArch64.S2InvalidSL.1" hover="function: boolean AArch64.S2InvalidSL(S2TTWParams walkparams)">AArch64.S2InvalidSL</anchor>(<a link="S2TTWParams" file="shared_pseudocode.xml" hover="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams)
    case walkparams.tgx of
        when <a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>
            case walkparams.sl2:walkparams.sl0 of
                when '1x1' return TRUE;
                when '11x' return TRUE;
                when '010' return <a link="AArch64.PAMax.0" file="shared_pseudocode.xml" hover="function: integer AArch64.PAMax()">AArch64.PAMax</a>() &lt; 44;
                when '011' return !<a link="impl-shared.HaveSmallTranslationTableExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveSmallTranslationTableExt()">HaveSmallTranslationTableExt</a>();
                otherwise  return FALSE;
        when <a link="TGx_16KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>
            case walkparams.ds:walkparams.sl0 of
                when '011' return TRUE;
                when '010' return <a link="AArch64.PAMax.0" file="shared_pseudocode.xml" hover="function: integer AArch64.PAMax()">AArch64.PAMax</a>() &lt; 42;
                otherwise  return FALSE;
        when <a link="TGx_64KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a>
            case walkparams.sl0 of
                when '11'  return TRUE;
                when '10'  return <a link="AArch64.PAMax.0" file="shared_pseudocode.xml" hover="function: integer AArch64.PAMax()">AArch64.PAMax</a>() &lt; 44;
                otherwise  return FALSE;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_faults/AArch64.S2InvalidTxSZ" mylink="aarch64.translation.vmsa_faults.AArch64.S2InvalidTxSZ" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S2InvalidTxSZ()
// =======================
// Detect erroneous configuration of stage 2 TxSZ field if the implementation
// does not constrain the value of TxSZ

boolean <anchor link="AArch64.S2InvalidTxSZ.2" hover="function: boolean AArch64.S2InvalidTxSZ(S2TTWParams walkparams, boolean s1aarch64)">AArch64.S2InvalidTxSZ</anchor>(<a link="S2TTWParams" file="shared_pseudocode.xml" hover="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams, boolean s1aarch64)
    mintxsz = <a link="AArch64.S2MinTxSZ.3" file="shared_pseudocode.xml" hover="function: integer AArch64.S2MinTxSZ(bit ds, TGx tgx, boolean s1aarch64)">AArch64.S2MinTxSZ</a>(walkparams.ds, walkparams.tgx, s1aarch64);
    maxtxsz = <a link="AArch64.MaxTxSZ.1" file="shared_pseudocode.xml" hover="function: integer AArch64.MaxTxSZ(TGx tgx)">AArch64.MaxTxSZ</a>(walkparams.tgx);

    return <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(walkparams.txsz) &lt; mintxsz || <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(walkparams.txsz) &gt; maxtxsz;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_faults/AArch64.VAIsOutOfRange" mylink="aarch64.translation.vmsa_faults.AArch64.VAIsOutOfRange" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.VAIsOutOfRange()
// ========================
// Check bits not resolved by translation are identical and of accepted value

boolean <anchor link="AArch64.VAIsOutOfRange.4" hover="function: boolean AArch64.VAIsOutOfRange(bits(64) va, AccType acctype, Regime regime, S1TTWParams walkparams)">AArch64.VAIsOutOfRange</anchor>(bits(64) va, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a link="S1TTWParams" file="shared_pseudocode.xml" hover="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams)
    addrtop = <a link="AArch64.AddrTop.3" file="shared_pseudocode.xml" hover="function: integer AArch64.AddrTop(bit tbid, AccType acctype, bit tbi)">AArch64.AddrTop</a>(walkparams.tbid, acctype, walkparams.tbi);
    // Input Address size
    iasize  = <a link="AArch64.IASize.1" file="shared_pseudocode.xml" hover="function: integer AArch64.IASize(bits(6) txsz)">AArch64.IASize</a>(walkparams.txsz);

    if <a link="impl-shared.HasUnprivileged.1" file="shared_pseudocode.xml" hover="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then
        if <a link="AArch64.GetVARange.1" file="shared_pseudocode.xml" hover="function: VARange AArch64.GetVARange(bits(64) va)">AArch64.GetVARange</a>(va) == <a link="VARange_LOWER" file="shared_pseudocode.xml" hover="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
            return !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(va&lt;addrtop:iasize&gt;);
        else
            return !<a link="impl-shared.IsOnes.1" file="shared_pseudocode.xml" hover="function: boolean IsOnes(bits(N) x)">IsOnes</a>(va&lt;addrtop:iasize&gt;);
    else
        return !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(va&lt;addrtop:iasize&gt;);</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_memattr/AArch64.IsS2ResultTagged" mylink="aarch64.translation.vmsa_memattr.AArch64.IsS2ResultTagged" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.IsS2ResultTagged()
// ==========================
// Determine whether the combined output memory attributes of stage 1 and
// stage 2 indicate tagged memory

boolean <anchor link="AArch64.IsS2ResultTagged.2" hover="function: boolean AArch64.IsS2ResultTagged(MemoryAttributes s2_memattrs, boolean s1_tagged)">AArch64.IsS2ResultTagged</anchor>(<a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> s2_memattrs, boolean s1_tagged)
    return (
        s1_tagged                                &amp;&amp;
        (s2_memattrs.memtype == <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>)  &amp;&amp;
        (s2_memattrs.inner.attrs == <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>)  &amp;&amp;
        (s2_memattrs.inner.hints == <a link="MemHint_RWA" file="shared_pseudocode.xml" hover="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>) &amp;&amp;
        (!s2_memattrs.inner.transient)           &amp;&amp;
        (s2_memattrs.outer.attrs == <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>)  &amp;&amp;
        (s2_memattrs.outer.hints == <a link="MemHint_RWA" file="shared_pseudocode.xml" hover="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>) &amp;&amp;
        (!s2_memattrs.outer.transient)
    );</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_memattr/AArch64.S2ApplyFWBMemAttrs" mylink="aarch64.translation.vmsa_memattr.AArch64.S2ApplyFWBMemAttrs" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S2ApplyFWBMemAttrs()
// ============================
// Apply stage 2 forced Write-Back on stage 1 memory attributes.

MemoryAttributes <anchor link="AArch64.S2ApplyFWBMemAttrs.3" hover="function: MemoryAttributes AArch64.S2ApplyFWBMemAttrs(MemoryAttributes s1_memattrs,&#13; bits(4) s2_attr, bits(2) s2_sh)">AArch64.S2ApplyFWBMemAttrs</anchor>(<a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> s1_memattrs,
                                            bits(4) s2_attr, bits(2) s2_sh)
    <a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs;

    if s2_attr&lt;2&gt; == '0' then          // S2 Device, S1 any
        s2_device = <a link="impl-shared.DecodeDevice.1" file="shared_pseudocode.xml" hover="function: DeviceType DecodeDevice(bits(2) device)">DecodeDevice</a>(s2_attr&lt;1:0&gt;);
        memattrs.memtype = <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
        if s1_memattrs.memtype == <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
            memattrs.device = <a link="impl-shared.S2CombineS1Device.2" file="shared_pseudocode.xml" hover="function: DeviceType S2CombineS1Device(DeviceType s1_device, DeviceType s2_device)">S2CombineS1Device</a>(s1_memattrs.device, s2_device);
        else
            memattrs.device = s2_device;

    elsif s2_attr&lt;1:0&gt; == '11' then    // S2 attr = S1 attr
        memattrs = s1_memattrs;

    elsif s2_attr&lt;1:0&gt; == '10' then    // Force writeback
        memattrs.memtype = <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
        memattrs.inner.attrs = <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
        memattrs.outer.attrs = <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;

        if (s1_memattrs.memtype == <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> &amp;&amp;
                s1_memattrs.inner.attrs != <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>) then
            memattrs.inner.hints     = s1_memattrs.inner.hints;
            memattrs.inner.transient = s1_memattrs.inner.transient;
        else
            memattrs.inner.hints     = <a link="MemHint_RWA" file="shared_pseudocode.xml" hover="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
            memattrs.inner.transient = FALSE;

        if (s1_memattrs.memtype == <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> &amp;&amp;
                s1_memattrs.outer.attrs != <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>) then
            memattrs.outer.hints     = s1_memattrs.outer.hints;
            memattrs.outer.transient = s1_memattrs.outer.transient;
        else
            memattrs.outer.hints     = <a link="MemHint_RWA" file="shared_pseudocode.xml" hover="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
            memattrs.outer.transient = FALSE;

    else                               // Non-cacheable unless S1 is device
        if s1_memattrs.memtype == <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
            memattrs = s1_memattrs;
        else
            <a link="MemAttrHints" file="shared_pseudocode.xml" hover="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> cacheability_attr;
            cacheability_attr.attrs = <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;

            memattrs.memtype = <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.inner   = cacheability_attr;
            memattrs.outer   = cacheability_attr;

    s2_shareability = <a link="impl-shared.DecodeShareability.1" file="shared_pseudocode.xml" hover="function: Shareability DecodeShareability(bits(2) sh)">DecodeShareability</a>(s2_sh);
    memattrs.shareability = <a link="impl-shared.S2CombineS1Shareability.2" file="shared_pseudocode.xml" hover="function: Shareability S2CombineS1Shareability(Shareability s1_shareability,&#13; Shareability s2_shareability)">S2CombineS1Shareability</a>(s1_memattrs.shareability, s2_shareability);
    memattrs.tagged       = <a link="AArch64.IsS2ResultTagged.2" file="shared_pseudocode.xml" hover="function: boolean AArch64.IsS2ResultTagged(MemoryAttributes s2_memattrs, boolean s1_tagged)">AArch64.IsS2ResultTagged</a>(memattrs, s1_memattrs.tagged);

    memattrs.shareability = <a link="impl-shared.EffectiveShareability.1" file="shared_pseudocode.xml" hover="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(memattrs);
    return memattrs;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_tlbcontext/AArch64.GetS1TLBContext" mylink="aarch64.translation.vmsa_tlbcontext.AArch64.GetS1TLBContext" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.GetS1TLBContext()
// =========================
// Gather translation context for accesses with VA to match against TLB entries

TLBContext <anchor link="AArch64.GetS1TLBContext.4" hover="function: TLBContext AArch64.GetS1TLBContext(Regime regime, SecurityState ss, bits(64) va, TGx tg)">AArch64.GetS1TLBContext</anchor>(<a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(64) va, <a link="TGx" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tg)
    <a link="TLBContext" file="shared_pseudocode.xml" hover="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, bits(64) ia, TGx tg, bit cnp, bit xs )">TLBContext</a> tlbcontext;

    case regime of
        when <a link="Regime_EL3" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>  tlbcontext = <a link="AArch64.TLBContextEL3.3" file="shared_pseudocode.xml" hover="function: TLBContext AArch64.TLBContextEL3(SecurityState ss, bits(64) va, TGx tg)">AArch64.TLBContextEL3</a>(ss, va, tg);
        when <a link="Regime_EL2" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  tlbcontext = <a link="AArch64.TLBContextEL2.3" file="shared_pseudocode.xml" hover="function: TLBContext AArch64.TLBContextEL2(SecurityState ss, bits(64) va, TGx tg)">AArch64.TLBContextEL2</a>(ss, va, tg);
        when <a link="Regime_EL20" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> tlbcontext = <a link="AArch64.TLBContextEL20.3" file="shared_pseudocode.xml" hover="function: TLBContext AArch64.TLBContextEL20(SecurityState ss, bits(64) va, TGx tg)">AArch64.TLBContextEL20</a>(ss, va, tg);
        when <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> tlbcontext = <a link="AArch64.TLBContextEL10.3" file="shared_pseudocode.xml" hover="function: TLBContext AArch64.TLBContextEL10(SecurityState ss, bits(64) va, TGx tg)">AArch64.TLBContextEL10</a>(ss, va, tg);

    tlbcontext.includes_s1  = TRUE;
    // The following may be amended for EL1&amp;0 Regime if caching of stage 2 is successful
    tlbcontext.includes_s2  = FALSE;
    return tlbcontext;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_tlbcontext/AArch64.GetS2TLBContext" mylink="aarch64.translation.vmsa_tlbcontext.AArch64.GetS2TLBContext" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.GetS2TLBContext()
// =========================
// Gather translation context for accesses with IPA to match against TLB entries

TLBContext <anchor link="AArch64.GetS2TLBContext.3" hover="function: TLBContext AArch64.GetS2TLBContext(SecurityState ss, FullAddress ipa, TGx tg)">AArch64.GetS2TLBContext</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss, <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> ipa, <a link="TGx" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tg)
    assert <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>();

    <a link="TLBContext" file="shared_pseudocode.xml" hover="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, bits(64) ia, TGx tg, bit cnp, bit xs )">TLBContext</a> tlbcontext;

    tlbcontext.ss       = ss;
    tlbcontext.regime   = <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>;
    tlbcontext.ipaspace = ipa.paspace;
    tlbcontext.vmid     = <a link="impl-aarch64.VMID.read.0" file="shared_pseudocode.xml" hover="accessor: bits(16) VMID[]">VMID</a>[];
    tlbcontext.tg       = tg;
    tlbcontext.ia       = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(ipa.address);
    if <a link="impl-shared.HaveCommonNotPrivateTransExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveCommonNotPrivateTransExt()">HaveCommonNotPrivateTransExt</a>() then
        tlbcontext.cnp = if ipa.paspace == <a link="PAS_Secure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_Secure</a> then VSTTBR_EL2.CnP else VTTBR_EL2.CnP;
    else
        tlbcontext.cnp = '0';

    tlbcontext.includes_s1  = FALSE;
    tlbcontext.includes_s2  = TRUE;
    return tlbcontext;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_tlbcontext/AArch64.TLBContextEL10" mylink="aarch64.translation.vmsa_tlbcontext.AArch64.TLBContextEL10" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.TLBContextEL10()
// ========================
// Gather translation context for accesses under EL10 regime to match against TLB entries

TLBContext <anchor link="AArch64.TLBContextEL10.3" hover="function: TLBContext AArch64.TLBContextEL10(SecurityState ss, bits(64) va, TGx tg)">AArch64.TLBContextEL10</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(64) va, <a link="TGx" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tg)
    <a link="TLBContext" file="shared_pseudocode.xml" hover="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, bits(64) ia, TGx tg, bit cnp, bit xs )">TLBContext</a> tlbcontext;

    tlbcontext.ss     = ss;
    tlbcontext.regime = <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>;
    tlbcontext.vmid   = <a link="impl-aarch64.VMID.read.0" file="shared_pseudocode.xml" hover="accessor: bits(16) VMID[]">VMID</a>[];
    tlbcontext.asid   = if TCR_EL1.A1 == '0' then TTBR0_EL1.ASID else TTBR1_EL1.ASID;
    tlbcontext.tg     = tg;
    tlbcontext.ia     = va;

    if <a link="impl-shared.HaveCommonNotPrivateTransExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveCommonNotPrivateTransExt()">HaveCommonNotPrivateTransExt</a>() then
        if <a link="AArch64.GetVARange.1" file="shared_pseudocode.xml" hover="function: VARange AArch64.GetVARange(bits(64) va)">AArch64.GetVARange</a>(va) == <a link="VARange_LOWER" file="shared_pseudocode.xml" hover="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
            tlbcontext.cnp = TTBR0_EL1.CnP;
        else
            tlbcontext.cnp = TTBR1_EL1.CnP;
    else
        tlbcontext.cnp = '0';

    return tlbcontext;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_tlbcontext/AArch64.TLBContextEL2" mylink="aarch64.translation.vmsa_tlbcontext.AArch64.TLBContextEL2" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.TLBContextEL2()
// =======================
// Gather translation context for accesses under EL2 regime to match against TLB entries

TLBContext <anchor link="AArch64.TLBContextEL2.3" hover="function: TLBContext AArch64.TLBContextEL2(SecurityState ss, bits(64) va, TGx tg)">AArch64.TLBContextEL2</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(64) va, <a link="TGx" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tg)
    <a link="TLBContext" file="shared_pseudocode.xml" hover="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, bits(64) ia, TGx tg, bit cnp, bit xs )">TLBContext</a> tlbcontext;

    tlbcontext.ss     = ss;
    tlbcontext.regime = <a link="Regime_EL2" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>;
    tlbcontext.tg     = tg;
    tlbcontext.ia     = va;
    tlbcontext.cnp    = if <a link="impl-shared.HaveCommonNotPrivateTransExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveCommonNotPrivateTransExt()">HaveCommonNotPrivateTransExt</a>() then TTBR0_EL2.CnP else '0';

    return tlbcontext;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_tlbcontext/AArch64.TLBContextEL20" mylink="aarch64.translation.vmsa_tlbcontext.AArch64.TLBContextEL20" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.TLBContextEL20()
// ========================
// Gather translation context for accesses under EL20 regime to match against TLB entries

TLBContext <anchor link="AArch64.TLBContextEL20.3" hover="function: TLBContext AArch64.TLBContextEL20(SecurityState ss, bits(64) va, TGx tg)">AArch64.TLBContextEL20</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(64) va, <a link="TGx" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tg)
    <a link="TLBContext" file="shared_pseudocode.xml" hover="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, bits(64) ia, TGx tg, bit cnp, bit xs )">TLBContext</a> tlbcontext;

    tlbcontext.ss     = ss;
    tlbcontext.regime = <a link="Regime_EL20" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>;
    tlbcontext.asid   = if TCR_EL2.A1 == '0' then TTBR0_EL2.ASID else TTBR1_EL2.ASID;
    tlbcontext.tg     = tg;
    tlbcontext.ia     = va;

    if <a link="impl-shared.HaveCommonNotPrivateTransExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveCommonNotPrivateTransExt()">HaveCommonNotPrivateTransExt</a>() then
        if <a link="AArch64.GetVARange.1" file="shared_pseudocode.xml" hover="function: VARange AArch64.GetVARange(bits(64) va)">AArch64.GetVARange</a>(va) == <a link="VARange_LOWER" file="shared_pseudocode.xml" hover="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
            tlbcontext.cnp = TTBR0_EL2.CnP;
        else
            tlbcontext.cnp = TTBR1_EL2.CnP;
    else
        tlbcontext.cnp = '0';

    return tlbcontext;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_tlbcontext/AArch64.TLBContextEL3" mylink="aarch64.translation.vmsa_tlbcontext.AArch64.TLBContextEL3" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.TLBContextEL3()
// =======================
// Gather translation context for accesses under EL3 regime to match against TLB entries

TLBContext <anchor link="AArch64.TLBContextEL3.3" hover="function: TLBContext AArch64.TLBContextEL3(SecurityState ss, bits(64) va, TGx tg)">AArch64.TLBContextEL3</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(64) va, <a link="TGx" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tg)
    <a link="TLBContext" file="shared_pseudocode.xml" hover="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, bits(64) ia, TGx tg, bit cnp, bit xs )">TLBContext</a> tlbcontext;

    tlbcontext.ss     = ss;
    tlbcontext.regime = <a link="Regime_EL3" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>;
    tlbcontext.tg     = tg;
    tlbcontext.ia     = va;
    tlbcontext.cnp    = if <a link="impl-shared.HaveCommonNotPrivateTransExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveCommonNotPrivateTransExt()">HaveCommonNotPrivateTransExt</a>() then TTBR0_EL3.CnP else '0';

    return tlbcontext;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_translation/AArch64.AccessUsesEL" mylink="aarch64.translation.vmsa_translation.AArch64.AccessUsesEL" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.AccessUsesEL()
// ======================
// Returns the Exception Level of the regime that will manage the translation for a given access type.

bits(2) <anchor link="AArch64.AccessUsesEL.1" hover="function: bits(2) AArch64.AccessUsesEL(AccType acctype)">AArch64.AccessUsesEL</anchor>(<a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype)
    if acctype IN {<a link="AccType_UNPRIV" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_UNPRIV</a>, <a link="AccType_UNPRIVSTREAM" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_UNPRIVSTREAM</a>} then
        return <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>;
    elsif acctype == <a link="AccType_NV2REGISTER" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NV2REGISTER</a> then
        return <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;
    else
        return PSTATE.EL;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_translation/AArch64.FaultAllowsSetAccessFlag" mylink="aarch64.translation.vmsa_translation.AArch64.FaultAllowsSetAccessFlag" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.FaultAllowsSetAccessFlag()
// ==================================
// Determine whether the access flag could be set by HW given the fault status

boolean <anchor link="AArch64.FaultAllowsSetAccessFlag.1" hover="function: boolean AArch64.FaultAllowsSetAccessFlag(FaultRecord fault)">AArch64.FaultAllowsSetAccessFlag</anchor>(<a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    if fault.statuscode == <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return TRUE;
    elsif fault.statuscode IN {<a link="Fault_Alignment" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>, <a link="Fault_Permission" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>} then
        return <a link="impl-shared.ConstrainUnpredictable.1" file="shared_pseudocode.xml" hover="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a link="Unpredictable_AFUPDATE" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_AFUPDATE</a>) == <a link="Constraint_TRUE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>;
    else
        return FALSE;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_translation/AArch64.FullTranslate" mylink="aarch64.translation.vmsa_translation.AArch64.FullTranslate" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.FullTranslate()
// =======================
// Address translation as specified by VMSA
// Alignment check NOT due to memory type is expected to be done before translation

AddressDescriptor <anchor link="AArch64.FullTranslate.4" hover="function: AddressDescriptor AArch64.FullTranslate(bits(64) va, AccType acctype,&#13; boolean iswrite, boolean aligned)">AArch64.FullTranslate</anchor>(bits(64) va, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype,
                                        boolean iswrite, boolean aligned)

    fault = <a link="impl-shared.NoFault.0" file="shared_pseudocode.xml" hover="function: FaultRecord NoFault()">NoFault</a>();
    fault.acctype = acctype;
    fault.write   = iswrite;

    ispriv = PSTATE.EL != <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !(acctype IN {<a link="AccType_UNPRIV" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_UNPRIV</a>, <a link="AccType_UNPRIVSTREAM" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_UNPRIVSTREAM</a>});
    regime = <a link="impl-shared.TranslationRegime.2" file="shared_pseudocode.xml" hover="function: Regime TranslationRegime(bits(2) el, AccType acctype)">TranslationRegime</a>(PSTATE.EL, acctype);
    ss = <a link="impl-shared.SecurityStateAtEL.1" file="shared_pseudocode.xml" hover="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(PSTATE.EL);

    <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> ipa;
    (fault, ipa) = <a link="AArch64.S1Translate.8" file="shared_pseudocode.xml" hover="function: (FaultRecord, AddressDescriptor) AArch64.S1Translate(FaultRecord fault_in, Regime regime,&#13; SecurityState ss, bits(64) va,&#13; AccType acctype, boolean aligned_in,&#13; boolean iswrite_in, boolean ispriv)">AArch64.S1Translate</a>(fault, regime, ss, va, acctype, aligned, iswrite, ispriv);

    if fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return <a link="impl-shared.CreateFaultyAddressDescriptor.2" file="shared_pseudocode.xml" hover="function: AddressDescriptor CreateFaultyAddressDescriptor(bits(64) va, FaultRecord fault)">CreateFaultyAddressDescriptor</a>(va, fault);

    if regime == <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() then
        s1aarch64 = TRUE;
        s2fs1walk = FALSE;
        <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> pa;
        (fault, pa) = <a link="AArch64.S2Translate.9" file="shared_pseudocode.xml" hover="function: (FaultRecord, AddressDescriptor) AArch64.S2Translate(FaultRecord fault_in, AddressDescriptor ipa,&#13; boolean s1aarch64, SecurityState ss,&#13; boolean s2fs1walk, AccType acctype,&#13; boolean aligned, boolean iswrite,&#13; boolean ispriv)">AArch64.S2Translate</a>(fault, ipa, s1aarch64, ss, s2fs1walk,
                                          acctype, aligned, iswrite, ispriv);

        if fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
            return <a link="impl-shared.CreateFaultyAddressDescriptor.2" file="shared_pseudocode.xml" hover="function: AddressDescriptor CreateFaultyAddressDescriptor(bits(64) va, FaultRecord fault)">CreateFaultyAddressDescriptor</a>(va, fault);
        else
            return pa;
    else
        return ipa;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_translation/AArch64.MemSwapTableDesc" mylink="aarch64.translation.vmsa_translation.AArch64.MemSwapTableDesc" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.MemSwapTableDesc()
// ==========================
// Perform HW update of table descriptor as an atomic operation

(FaultRecord, bits(64)) <anchor link="AArch64.MemSwapTableDesc.5" hover="function: (FaultRecord, bits(64)) AArch64.MemSwapTableDesc(FaultRecord fault_in, bits(64) prev_desc,&#13; bits(64) new_desc, bit ee,&#13; AddressDescriptor descupdateaddress)">AArch64.MemSwapTableDesc</anchor>(<a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault_in, bits(64) prev_desc,
                                                 bits(64) new_desc, bit ee,
                                                 <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> descupdateaddress)
    descupdateaccess = <a link="impl-shared.CreateAccessDescriptor.1" file="shared_pseudocode.xml" hover="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(<a link="AccType_ATOMICRW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a>);
    <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault = fault_in;

    // All observers in the shareability domain observe the
    // following memory read and write accesses atomically.
    (memstatus, mem_desc) = <a link="impl-shared.PhysMemRead.3" file="shared_pseudocode.xml" hover="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(descupdateaddress, 8, descupdateaccess);
    if ee == '1' then
        mem_desc = <a link="impl-shared.BigEndianReverse.1" file="shared_pseudocode.xml" hover="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(mem_desc);

    if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        iswrite = FALSE;
        fault = <a link="impl-shared.HandleExternalTTWAbort.6" file="shared_pseudocode.xml" hover="function: FaultRecord HandleExternalTTWAbort(PhysMemRetStatus memretstatus, boolean iswrite,&#13; AddressDescriptor memaddrdesc,&#13; AccessDescriptor accdesc, integer size,&#13; FaultRecord input_fault)">HandleExternalTTWAbort</a>(memstatus, iswrite, descupdateaddress, descupdateaccess,
                                       8, fault);
        if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(fault.statuscode) then
            fault.acctype = <a link="AccType_ATOMICRW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a>;
            return (fault, bits(64) UNKNOWN);

    if mem_desc == prev_desc  then
        ordered_new_desc = if ee == '1' then <a link="impl-shared.BigEndianReverse.1" file="shared_pseudocode.xml" hover="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(new_desc) else new_desc;
        memstatus = <a link="impl-shared.PhysMemWrite.4" file="shared_pseudocode.xml" hover="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(descupdateaddress, 8, descupdateaccess, ordered_new_desc);

        if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            iswrite = TRUE;
            fault = <a link="impl-shared.HandleExternalTTWAbort.6" file="shared_pseudocode.xml" hover="function: FaultRecord HandleExternalTTWAbort(PhysMemRetStatus memretstatus, boolean iswrite,&#13; AddressDescriptor memaddrdesc,&#13; AccessDescriptor accdesc, integer size,&#13; FaultRecord input_fault)">HandleExternalTTWAbort</a>(memstatus, iswrite, descupdateaddress, descupdateaccess,
                                           8, fault);
            fault.acctype = memstatus.acctype;
            if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(fault.statuscode) then
                fault.acctype = <a link="AccType_ATOMICRW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a>;
                return (fault, bits(64) UNKNOWN);

        // Reflect what is now in memory (in little endian format)
        mem_desc = new_desc;

    return (fault, mem_desc);</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_translation/AArch64.S1DisabledOutput" mylink="aarch64.translation.vmsa_translation.AArch64.S1DisabledOutput" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S1DisabledOutput()
// ==========================
// Map the the VA to IPA/PA and assign default memory attributes

(FaultRecord, AddressDescriptor) <anchor link="AArch64.S1DisabledOutput.6" hover="function: (FaultRecord, AddressDescriptor) AArch64.S1DisabledOutput(FaultRecord fault_in, Regime regime,&#13; SecurityState ss, bits(64) va,&#13; AccType acctype, boolean aligned)">AArch64.S1DisabledOutput</anchor>(<a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault_in, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime,
                                                          <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(64) va,
                                                          <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned)

    walkparams = <a link="AArch64.GetS1TTWParams.2" file="shared_pseudocode.xml" hover="function: S1TTWParams AArch64.GetS1TTWParams(Regime regime, bits(64) va)">AArch64.GetS1TTWParams</a>(regime, va);
    <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault = fault_in;

    // No memory page is guarded when stage 1 address translation is disabled
    <a link="impl-aarch64.SetInGuardedPage.1" file="shared_pseudocode.xml" hover="function: SetInGuardedPage(boolean guardedpage)">SetInGuardedPage</a>(FALSE);

    // Output Address
    <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> oa;
    oa.address = va&lt;51:0&gt;;
    case ss of
        when <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>    oa.paspace = <a link="PAS_Secure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_Secure</a>;
        when <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a> oa.paspace = <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a>;

    <a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs;
    if regime == <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; walkparams.dc == '1' then
        <a link="MemAttrHints" file="shared_pseudocode.xml" hover="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> default_cacheability;
        default_cacheability.attrs     = <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
        default_cacheability.hints     = <a link="MemHint_RWA" file="shared_pseudocode.xml" hover="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
        default_cacheability.transient = FALSE;

        memattrs.memtype      = <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
        memattrs.outer        = default_cacheability;
        memattrs.inner        = default_cacheability;
        memattrs.shareability = <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        memattrs.tagged       = walkparams.dct == '1';
        memattrs.xs           = '0';
    elsif acctype == <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> then
        <a link="MemAttrHints" file="shared_pseudocode.xml" hover="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> i_cache_attr;
        if <a link="AArch64.S1ICacheEnabled.1" file="shared_pseudocode.xml" hover="function: boolean AArch64.S1ICacheEnabled(Regime regime)">AArch64.S1ICacheEnabled</a>(regime) then
            i_cache_attr.attrs     = <a link="MemAttr_WT" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
            i_cache_attr.hints     = <a link="MemHint_RA" file="shared_pseudocode.xml" hover="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
            i_cache_attr.transient = FALSE;
        else
            i_cache_attr.attrs     = <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;

        memattrs.memtype      = <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
        memattrs.outer        = i_cache_attr;
        memattrs.inner        = i_cache_attr;
        memattrs.shareability = <a link="Shareability_OSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        memattrs.tagged       = FALSE;
        memattrs.xs           = '1';
    else
        memattrs.memtype      = <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
        memattrs.device       = <a link="DeviceType_nGnRnE" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a>;
        memattrs.shareability = <a link="Shareability_OSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        memattrs.xs           = '1';

    fault.level = 0;
    addrtop     = <a link="AArch64.AddrTop.3" file="shared_pseudocode.xml" hover="function: integer AArch64.AddrTop(bit tbid, AccType acctype, bit tbi)">AArch64.AddrTop</a>(walkparams.tbid, acctype, walkparams.tbi);
    if !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(va&lt;addrtop:<a link="AArch64.PAMax.0" file="shared_pseudocode.xml" hover="function: integer AArch64.PAMax()">AArch64.PAMax</a>()&gt;) then
        fault.statuscode = <a link="Fault_AddressSize" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
    elsif <a link="AArch64.S1HasAlignmentFault.4" file="shared_pseudocode.xml" hover="function: boolean AArch64.S1HasAlignmentFault(AccType acctype, boolean aligned,&#13; bit ntlsmd, MemoryAttributes memattrs)">AArch64.S1HasAlignmentFault</a>(acctype, aligned, walkparams.ntlsmd, memattrs) then
        fault.statuscode = <a link="Fault_Alignment" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>;

    if fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return (fault, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);
    else
        ipa = <a link="impl-shared.CreateAddressDescriptor.3" file="shared_pseudocode.xml" hover="function: AddressDescriptor CreateAddressDescriptor(bits(64) va, FullAddress pa,&#13; MemoryAttributes memattrs)">CreateAddressDescriptor</a>(va, oa, memattrs);
        return (fault, ipa);</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_translation/AArch64.S1Translate" mylink="aarch64.translation.vmsa_translation.AArch64.S1Translate" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S1Translate()
// =====================
// Translate VA to IPA/PA depending on the regime

(FaultRecord, AddressDescriptor) <anchor link="AArch64.S1Translate.8" hover="function: (FaultRecord, AddressDescriptor) AArch64.S1Translate(FaultRecord fault_in, Regime regime,&#13; SecurityState ss, bits(64) va,&#13; AccType acctype, boolean aligned_in,&#13; boolean iswrite_in, boolean ispriv)">AArch64.S1Translate</anchor>(<a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault_in, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime,
                                                     <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(64) va,
                                                     <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned_in,
                                                     boolean iswrite_in, boolean ispriv)
    <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault = fault_in;
    boolean aligned = aligned_in;
    boolean iswrite = iswrite_in;
    // Prepare fault fields in case a fault is detected
    fault.secondstage = FALSE;
    fault.s2fs1walk   = FALSE;

    if !<a link="AArch64.S1Enabled.1" file="shared_pseudocode.xml" hover="function: boolean AArch64.S1Enabled(Regime regime)">AArch64.S1Enabled</a>(regime) then
        return <a link="AArch64.S1DisabledOutput.6" file="shared_pseudocode.xml" hover="function: (FaultRecord, AddressDescriptor) AArch64.S1DisabledOutput(FaultRecord fault_in, Regime regime,&#13; SecurityState ss, bits(64) va,&#13; AccType acctype, boolean aligned)">AArch64.S1DisabledOutput</a>(fault, regime, ss, va, acctype, aligned);

    walkparams = <a link="AArch64.GetS1TTWParams.2" file="shared_pseudocode.xml" hover="function: S1TTWParams AArch64.GetS1TTWParams(Regime regime, bits(64) va)">AArch64.GetS1TTWParams</a>(regime, va);

    if (<a link="AArch64.S1InvalidTxSZ.1" file="shared_pseudocode.xml" hover="function: boolean AArch64.S1InvalidTxSZ(S1TTWParams walkparams)">AArch64.S1InvalidTxSZ</a>(walkparams) ||
            (!ispriv &amp;&amp; walkparams.e0pd == '1') ||
            <a link="AArch64.VAIsOutOfRange.4" file="shared_pseudocode.xml" hover="function: boolean AArch64.VAIsOutOfRange(bits(64) va, AccType acctype, Regime regime, S1TTWParams walkparams)">AArch64.VAIsOutOfRange</a>(va, acctype, regime, walkparams)) then
        fault.statuscode = <a link="Fault_Translation" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        fault.level      = 0;
        return (fault, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> descaddress;
    <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate;
    bits(64) descriptor;
    bits(64) new_desc;
    bits(64) mem_desc;
    repeat
        (fault, descaddress, walkstate, descriptor) = <a link="AArch64.S1Walk.8" file="shared_pseudocode.xml" hover="function: (FaultRecord, AddressDescriptor, TTWState, bits(64)) AArch64.S1Walk(FaultRecord fault_in,&#13; S1TTWParams walkparams, bits(64) va, Regime regime, SecurityState ss,&#13; AccType acctype, boolean iswrite_in, boolean ispriv)">AArch64.S1Walk</a>(fault, walkparams, va, regime,
                                                                     ss, acctype, iswrite, ispriv);

        if fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
            return (fault, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

        if acctype == <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> then
            // Flag the fetched instruction is from a guarded page
            <a link="impl-aarch64.SetInGuardedPage.1" file="shared_pseudocode.xml" hover="function: SetInGuardedPage(boolean guardedpage)">SetInGuardedPage</a>(walkstate.guardedpage == '1');

        if <a link="AArch64.S1HasAlignmentFault.4" file="shared_pseudocode.xml" hover="function: boolean AArch64.S1HasAlignmentFault(AccType acctype, boolean aligned,&#13; bit ntlsmd, MemoryAttributes memattrs)">AArch64.S1HasAlignmentFault</a>(acctype, aligned, walkparams.ntlsmd,
                                       walkstate.memattrs) then
            fault.statuscode = <a link="Fault_Alignment" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>;
        elsif <a link="impl-shared.IsAtomicRW.1" file="shared_pseudocode.xml" hover="function: boolean IsAtomicRW(AccType acctype)">IsAtomicRW</a>(acctype) then
            if <a link="AArch64.S1HasPermissionsFault.7" file="shared_pseudocode.xml" hover="function: boolean AArch64.S1HasPermissionsFault(Regime regime, SecurityState ss, TTWState walkstate,&#13; S1TTWParams walkparams, boolean ispriv, AccType acctype,&#13; boolean iswrite)">AArch64.S1HasPermissionsFault</a>(regime, ss, walkstate, walkparams,
                                             ispriv, acctype, FALSE) then
                // The permission fault was not caused by lack of write permissions
                fault.statuscode = <a link="Fault_Permission" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
                fault.write      = FALSE;
            elsif <a link="AArch64.S1HasPermissionsFault.7" file="shared_pseudocode.xml" hover="function: boolean AArch64.S1HasPermissionsFault(Regime regime, SecurityState ss, TTWState walkstate,&#13; S1TTWParams walkparams, boolean ispriv, AccType acctype,&#13; boolean iswrite)">AArch64.S1HasPermissionsFault</a>(regime, ss, walkstate, walkparams,
                                                ispriv, acctype, TRUE) then
                // The permission fault _was_ caused by lack of write permissions
                fault.statuscode = <a link="Fault_Permission" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
                fault.write      = TRUE;
        elsif <a link="AArch64.S1HasPermissionsFault.7" file="shared_pseudocode.xml" hover="function: boolean AArch64.S1HasPermissionsFault(Regime regime, SecurityState ss, TTWState walkstate,&#13; S1TTWParams walkparams, boolean ispriv, AccType acctype,&#13; boolean iswrite)">AArch64.S1HasPermissionsFault</a>(regime, ss, walkstate, walkparams,
                                            ispriv, acctype, iswrite) then
            fault.statuscode = <a link="Fault_Permission" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;

        new_desc = descriptor;
        if walkparams.ha == '1' &amp;&amp; <a link="AArch64.FaultAllowsSetAccessFlag.1" file="shared_pseudocode.xml" hover="function: boolean AArch64.FaultAllowsSetAccessFlag(FaultRecord fault)">AArch64.FaultAllowsSetAccessFlag</a>(fault) then
            // Set descriptor AF bit
            new_desc&lt;10&gt; = '1';

        // If HW update of dirty bit is enabled, the walk state permissions
        // will already reflect a configuration permitting writes.
        // The update of the descriptor occurs only if the descriptor bits in
        // memory do not reflect that and the access instigates a write.
        if (fault.statuscode == <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> &amp;&amp;
                walkparams.ha  == '1' &amp;&amp;
                walkparams.hd  == '1' &amp;&amp;
                descriptor&lt;51&gt; == '1' &amp;&amp; // Descriptor DBM bit
                (<a link="impl-shared.IsAtomicRW.1" file="shared_pseudocode.xml" hover="function: boolean IsAtomicRW(AccType acctype)">IsAtomicRW</a>(acctype) || iswrite) &amp;&amp;
                !(acctype IN {<a link="AccType_AT" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</a>, <a link="AccType_ATPAN" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATPAN</a>, <a link="AccType_IC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>, <a link="AccType_DC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>})) then
            // Clear descriptor AP[2] bit permitting stage 1 writes
            new_desc&lt;7&gt; = '0';

        <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> descupdateaddress;
        <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> s2fault;
        // Either the access flag was clear or AP&lt;2&gt; is set
        if new_desc != descriptor then
            if regime == <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() then
                s1aarch64 = TRUE;
                s2fs1walk = TRUE;
                aligned   = TRUE;
                iswrite   = TRUE;
                (s2fault, descupdateaddress) = <a link="AArch64.S2Translate.9" file="shared_pseudocode.xml" hover="function: (FaultRecord, AddressDescriptor) AArch64.S2Translate(FaultRecord fault_in, AddressDescriptor ipa,&#13; boolean s1aarch64, SecurityState ss,&#13; boolean s2fs1walk, AccType acctype,&#13; boolean aligned, boolean iswrite,&#13; boolean ispriv)">AArch64.S2Translate</a>(fault, descaddress, s1aarch64,
                                                                   ss, s2fs1walk, <a link="AccType_ATOMICRW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a>,
                                                                   aligned, iswrite, ispriv);

                if s2fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
                    return (s2fault, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);
            else
                descupdateaddress = descaddress;

            (fault, mem_desc) = <a link="AArch64.MemSwapTableDesc.5" file="shared_pseudocode.xml" hover="function: (FaultRecord, bits(64)) AArch64.MemSwapTableDesc(FaultRecord fault_in, bits(64) prev_desc,&#13; bits(64) new_desc, bit ee,&#13; AddressDescriptor descupdateaddress)">AArch64.MemSwapTableDesc</a>(fault, descriptor, new_desc,
                                                         walkparams.ee, descupdateaddress);

    until new_desc == descriptor || mem_desc == new_desc;

    if fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return (fault, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    // Output Address
    oa = <a link="impl-shared.StageOA.3" file="shared_pseudocode.xml" hover="function: FullAddress StageOA(bits(64) ia, TGx tgx, TTWState walkstate)">StageOA</a>(va, walkparams.tgx, walkstate);
    <a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs;
    if (acctype == <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> &amp;&amp;
        (walkstate.memattrs.memtype == <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> || !<a link="AArch64.S1ICacheEnabled.1" file="shared_pseudocode.xml" hover="function: boolean AArch64.S1ICacheEnabled(Regime regime)">AArch64.S1ICacheEnabled</a>(regime))) then
        // Treat memory attributes as Normal Non-Cacheable
        memattrs = <a link="impl-shared.NormalNCMemAttr.0" file="shared_pseudocode.xml" hover="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
        memattrs.xs = walkstate.memattrs.xs;
    elsif (acctype != <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> &amp;&amp; !<a link="AArch64.S1DCacheEnabled.1" file="shared_pseudocode.xml" hover="function: boolean AArch64.S1DCacheEnabled(Regime regime)">AArch64.S1DCacheEnabled</a>(regime) &amp;&amp;
             walkstate.memattrs.memtype == <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>) then
        // Treat memory attributes as Normal Non-Cacheable
        memattrs = <a link="impl-shared.NormalNCMemAttr.0" file="shared_pseudocode.xml" hover="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
        memattrs.xs = walkstate.memattrs.xs;

        // The effect of SCTLR_ELx.C when '0' is Constrained UNPREDICTABLE
        // on the Tagged attribute
        if <a link="impl-shared.HaveMTE2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() &amp;&amp; walkstate.memattrs.tagged then
            memattrs.tagged = <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_S1CTAGGED" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_S1CTAGGED</a>);
    else
        memattrs = walkstate.memattrs;

    // Shareability value of stage 1 translation subject to stage 2 is IMPLEMENTATION DEFINED
    // to be either effective value or descriptor value
    if (regime == <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.VM == '1' &amp;&amp;
            !(boolean IMPLEMENTATION_DEFINED "Apply effective shareability at stage 1")) then
        memattrs.shareability = walkstate.memattrs.shareability;
    else
        memattrs.shareability = <a link="impl-shared.EffectiveShareability.1" file="shared_pseudocode.xml" hover="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(memattrs);

    if acctype == <a link="AccType_ATOMICLS64" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICLS64</a> &amp;&amp; memattrs.memtype == <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> then
        if memattrs.inner.attrs != <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> || memattrs.outer.attrs != <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> then
            fault.statuscode = <a link="Fault_Exclusive" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Exclusive</a>;
            return (fault, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    ipa = <a link="impl-shared.CreateAddressDescriptor.3" file="shared_pseudocode.xml" hover="function: AddressDescriptor CreateAddressDescriptor(bits(64) va, FullAddress pa,&#13; MemoryAttributes memattrs)">CreateAddressDescriptor</a>(va, oa, memattrs);
    return (fault, ipa);</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_translation/AArch64.S2Translate" mylink="aarch64.translation.vmsa_translation.AArch64.S2Translate" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S2Translate()
// =====================
// Translate stage 1 IPA to PA and combine memory attributes

(FaultRecord, AddressDescriptor) <anchor link="AArch64.S2Translate.9" hover="function: (FaultRecord, AddressDescriptor) AArch64.S2Translate(FaultRecord fault_in, AddressDescriptor ipa,&#13; boolean s1aarch64, SecurityState ss,&#13; boolean s2fs1walk, AccType acctype,&#13; boolean aligned, boolean iswrite,&#13; boolean ispriv)">AArch64.S2Translate</anchor>(<a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault_in, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> ipa,
                                                     boolean s1aarch64, <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss,
                                                     boolean s2fs1walk, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype,
                                                     boolean aligned, boolean iswrite,
                                                     boolean ispriv)
    walkparams = <a link="AArch64.GetS2TTWParams.3" file="shared_pseudocode.xml" hover="function: S2TTWParams AArch64.GetS2TTWParams(SecurityState ss, PASpace ipaspace, boolean s1aarch64)">AArch64.GetS2TTWParams</a>(ss, ipa.paddress.paspace, s1aarch64);
    <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault = fault_in;

    // Prepare fault fields in case a fault is detected
    fault.statuscode  = <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>; // Ignore any faults from stage 1
    fault.secondstage = TRUE;
    fault.s2fs1walk   = s2fs1walk;
    fault.ipaddress   = ipa.paddress;

    if walkparams.vm != '1' then
        // Stage 2 translation is disabled
        return (fault, ipa);

    if (<a link="AArch64.S2InvalidTxSZ.2" file="shared_pseudocode.xml" hover="function: boolean AArch64.S2InvalidTxSZ(S2TTWParams walkparams, boolean s1aarch64)">AArch64.S2InvalidTxSZ</a>(walkparams, s1aarch64) ||
            <a link="AArch64.S2InvalidSL.1" file="shared_pseudocode.xml" hover="function: boolean AArch64.S2InvalidSL(S2TTWParams walkparams)">AArch64.S2InvalidSL</a>(walkparams) ||
            <a link="AArch64.S2InconsistentSL.1" file="shared_pseudocode.xml" hover="function: boolean AArch64.S2InconsistentSL(S2TTWParams walkparams)">AArch64.S2InconsistentSL</a>(walkparams) ||
            <a link="AArch64.IPAIsOutOfRange.2" file="shared_pseudocode.xml" hover="function: boolean AArch64.IPAIsOutOfRange(bits(52) ipa, S2TTWParams walkparams)">AArch64.IPAIsOutOfRange</a>(ipa.paddress.address, walkparams)) then
        fault.statuscode = <a link="Fault_Translation" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        fault.level      = 0;
        return (fault, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> descaddress;
    <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate;
    bits(64) descriptor;
    bits(64) new_desc;
    bits(64) mem_desc;
    repeat
        (fault, descaddress, walkstate, descriptor) = <a link="AArch64.S2Walk.7" file="shared_pseudocode.xml" hover="function: (FaultRecord, AddressDescriptor, TTWState, bits(64)) AArch64.S2Walk(&#13; FaultRecord fault_in, AddressDescriptor ipa, S2TTWParams walkparams, SecurityState ss,&#13; AccType acctype, boolean iswrite, boolean s1aarch64)">AArch64.S2Walk</a>(fault, ipa, walkparams, ss,
                                                                     acctype, iswrite, s1aarch64);

        if fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
            return (fault, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

        if <a link="AArch64.S2HasAlignmentFault.3" file="shared_pseudocode.xml" hover="function: boolean AArch64.S2HasAlignmentFault(AccType acctype, boolean aligned, MemoryAttributes memattrs)">AArch64.S2HasAlignmentFault</a>(acctype, aligned, walkstate.memattrs) then
            fault.statuscode = <a link="Fault_Alignment" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>;
        elsif <a link="impl-shared.IsAtomicRW.1" file="shared_pseudocode.xml" hover="function: boolean IsAtomicRW(AccType acctype)">IsAtomicRW</a>(acctype) then
            if <a link="AArch64.S2HasPermissionsFault.7" file="shared_pseudocode.xml" hover="function: boolean AArch64.S2HasPermissionsFault(boolean s2fs1walk, TTWState walkstate, SecurityState ss,&#13; S2TTWParams walkparams, boolean ispriv, AccType acctype,&#13; boolean iswrite)">AArch64.S2HasPermissionsFault</a>(s2fs1walk, walkstate, ss, walkparams,
                                             ispriv, acctype, FALSE) then
                // The permission fault was not caused by lack of write permissions
                fault.statuscode = <a link="Fault_Permission" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
                fault.write      = FALSE;
            elsif <a link="AArch64.S2HasPermissionsFault.7" file="shared_pseudocode.xml" hover="function: boolean AArch64.S2HasPermissionsFault(boolean s2fs1walk, TTWState walkstate, SecurityState ss,&#13; S2TTWParams walkparams, boolean ispriv, AccType acctype,&#13; boolean iswrite)">AArch64.S2HasPermissionsFault</a>(s2fs1walk, walkstate, ss, walkparams,
                                                ispriv, acctype, TRUE) then
                // The permission fault _was_ caused by lack of write permissions.
                // However, HW updates, which are atomic writes for stage 1
                // descriptors, permissions fault reflect the original access.
                fault.statuscode = <a link="Fault_Permission" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
                if !fault.s2fs1walk then
                    fault.write  = TRUE;
        elsif <a link="AArch64.S2HasPermissionsFault.7" file="shared_pseudocode.xml" hover="function: boolean AArch64.S2HasPermissionsFault(boolean s2fs1walk, TTWState walkstate, SecurityState ss,&#13; S2TTWParams walkparams, boolean ispriv, AccType acctype,&#13; boolean iswrite)">AArch64.S2HasPermissionsFault</a>(s2fs1walk, walkstate, ss, walkparams,
                                            ispriv, acctype, iswrite) then
            fault.statuscode = <a link="Fault_Permission" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;

        new_desc = descriptor;
        if walkparams.ha == '1' &amp;&amp; <a link="AArch64.FaultAllowsSetAccessFlag.1" file="shared_pseudocode.xml" hover="function: boolean AArch64.FaultAllowsSetAccessFlag(FaultRecord fault)">AArch64.FaultAllowsSetAccessFlag</a>(fault) then
            // Set descriptor AF bit
            new_desc&lt;10&gt; = '1';

        // If HW update of dirty bit is enabled, the walk state permissions
        // will already reflect a configuration permitting writes.
        // The update of the descriptor occurs only if the descriptor bits in
        // memory do not reflect that and the access instigates a write.
        if (fault.statuscode == <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> &amp;&amp;
                walkparams.ha  == '1' &amp;&amp;
                walkparams.hd  == '1' &amp;&amp;
                descriptor&lt;51&gt; == '1' &amp;&amp; // Descriptor DBM bit
                (<a link="impl-shared.IsAtomicRW.1" file="shared_pseudocode.xml" hover="function: boolean IsAtomicRW(AccType acctype)">IsAtomicRW</a>(acctype) || iswrite) &amp;&amp;
                !(acctype IN {<a link="AccType_AT" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</a>, <a link="AccType_ATPAN" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATPAN</a>, <a link="AccType_IC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>, <a link="AccType_DC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>})) then
            // Set descriptor S2AP[1] bit permitting stage 2 writes
            new_desc&lt;7&gt; = '1';

        // Either the access flag was clear or S2AP&lt;1&gt; is clear
        if new_desc != descriptor then
            (fault, mem_desc) = <a link="AArch64.MemSwapTableDesc.5" file="shared_pseudocode.xml" hover="function: (FaultRecord, bits(64)) AArch64.MemSwapTableDesc(FaultRecord fault_in, bits(64) prev_desc,&#13; bits(64) new_desc, bit ee,&#13; AddressDescriptor descupdateaddress)">AArch64.MemSwapTableDesc</a>(fault, descriptor, new_desc,
                                                         walkparams.ee, descaddress);

    until new_desc == descriptor || mem_desc == new_desc;

    if fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return (fault, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    ipa_64 = <a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(ipa.paddress.address, 64);
    // Output Address
    oa = <a link="impl-shared.StageOA.3" file="shared_pseudocode.xml" hover="function: FullAddress StageOA(bits(64) ia, TGx tgx, TTWState walkstate)">StageOA</a>(ipa_64, walkparams.tgx, walkstate);
    <a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> s2_memattrs;
    if ((s2fs1walk &amp;&amp;
            walkstate.memattrs.memtype == <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> &amp;&amp; walkparams.ptw == '0') ||
        (acctype == <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> &amp;&amp;
            (walkstate.memattrs.memtype == <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> || HCR_EL2.ID == '1')) ||
        (acctype != <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> &amp;&amp;
             walkstate.memattrs.memtype == <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> &amp;&amp; HCR_EL2.CD == '1')) then
        // Treat memory attributes as Normal Non-Cacheable
        s2_memattrs = <a link="impl-shared.NormalNCMemAttr.0" file="shared_pseudocode.xml" hover="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
        s2_memattrs.xs = walkstate.memattrs.xs;
    else
        s2_memattrs = walkstate.memattrs;

    if !s2fs1walk &amp;&amp; acctype == <a link="AccType_ATOMICLS64" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICLS64</a> &amp;&amp; s2_memattrs.memtype == <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> then
        if s2_memattrs.inner.attrs != <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> || s2_memattrs.outer.attrs != <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> then
            fault.statuscode = <a link="Fault_Exclusive" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Exclusive</a>;
            return (fault, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    <a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs;
    if walkparams.fwb == '0' then
        memattrs = <a link="impl-shared.S2CombineS1MemAttrs.2" file="shared_pseudocode.xml" hover="function: MemoryAttributes S2CombineS1MemAttrs(MemoryAttributes s1_memattrs,&#13; MemoryAttributes s2_memattrs)">S2CombineS1MemAttrs</a>(ipa.memattrs, s2_memattrs);
    else
        memattrs = s2_memattrs;

    pa = <a link="impl-shared.CreateAddressDescriptor.3" file="shared_pseudocode.xml" hover="function: AddressDescriptor CreateAddressDescriptor(bits(64) va, FullAddress pa,&#13; MemoryAttributes memattrs)">CreateAddressDescriptor</a>(ipa.vaddress, oa, memattrs);
    return (fault, pa);</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_translation/AArch64.TranslateAddress" mylink="aarch64.translation.vmsa_translation.AArch64.TranslateAddress" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.TranslateAddress()
// ==========================
// Main entry point for translating an address

AddressDescriptor <anchor link="AArch64.TranslateAddress.5" hover="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccType acctype, boolean iswrite,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</anchor>(bits(64) va, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite,
                                           boolean aligned, integer size)

    result = <a link="AArch64.FullTranslate.4" file="shared_pseudocode.xml" hover="function: AddressDescriptor AArch64.FullTranslate(bits(64) va, AccType acctype,&#13; boolean iswrite, boolean aligned)">AArch64.FullTranslate</a>(va, acctype, iswrite, aligned);

    if !<a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(result) then
        result.fault = <a link="AArch64.CheckDebug.4" file="shared_pseudocode.xml" hover="function: FaultRecord AArch64.CheckDebug(bits(64) vaddress, AccType acctype, boolean iswrite, integer size)">AArch64.CheckDebug</a>(va, acctype, iswrite, size);

    // Update virtual address for abort functions
    result.vaddress = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va);

    return result;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_ttentry/AArch64.BlockDescSupported" mylink="aarch64.translation.vmsa_ttentry.AArch64.BlockDescSupported" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.BlockDescSupported()
// ============================
// Determine whether a block descriptor is valid for the given granule size
// and level

boolean <anchor link="AArch64.BlockDescSupported.3" hover="function: boolean AArch64.BlockDescSupported(bit ds, TGx tgx, integer level)">AArch64.BlockDescSupported</anchor>(bit ds, <a link="TGx" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, integer level)
    case tgx of
        when <a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>  return level == 2 || level == 1 || (level == 0 &amp;&amp; ds == '1');
        when <a link="TGx_16KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a> return level == 2 || (level == 1 &amp;&amp; ds == '1');
        when <a link="TGx_64KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> return level == 2 || (level == 1 &amp;&amp; <a link="AArch64.PAMax.0" file="shared_pseudocode.xml" hover="function: integer AArch64.PAMax()">AArch64.PAMax</a>() == 52);

    return FALSE;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_ttentry/AArch64.BlocknTFaults" mylink="aarch64.translation.vmsa_ttentry.AArch64.BlocknTFaults" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.BlocknTFaults()
// =======================
// Identify whether the nT bit in a block descriptor is effectively set
// causing a translation fault

boolean <anchor link="AArch64.BlocknTFaults.1" hover="function: boolean AArch64.BlocknTFaults(bits(64) descriptor)">AArch64.BlocknTFaults</anchor>(bits(64) descriptor)
    if !<a link="impl-shared.HaveBlockBBM.0" file="shared_pseudocode.xml" hover="function: boolean HaveBlockBBM()">HaveBlockBBM</a>() then
        return FALSE;

    bbm_level = <a link="AArch64.BlockBBMSupportLevel.0" file="shared_pseudocode.xml" hover="function: integer AArch64.BlockBBMSupportLevel()">AArch64.BlockBBMSupportLevel</a>();
    nT_faults = boolean IMPLEMENTATION_DEFINED "BBM level 1 or 2 support nT bit causes Translation <a link="Fault" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a>";

    return bbm_level IN {1, 2} &amp;&amp; descriptor&lt;16&gt; == '1' &amp;&amp; nT_faults;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_ttentry/AArch64.ContiguousBit" mylink="aarch64.translation.vmsa_ttentry.AArch64.ContiguousBit" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.ContiguousBit()
// =======================
// Get the value of the contiguous bit

bit <anchor link="AArch64.ContiguousBit.3" hover="function: bit AArch64.ContiguousBit(TGx tgx, integer level, bits(64) descriptor)">AArch64.ContiguousBit</anchor>(<a link="TGx" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, integer level, bits(64) descriptor)
    if tgx == <a link="TGx_64KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> &amp;&amp; level == 1 &amp;&amp; !<a link="impl-shared.Have52BitVAExt.0" file="shared_pseudocode.xml" hover="function: boolean Have52BitVAExt()">Have52BitVAExt</a>() then
        return '0'; // RES0
    if tgx == <a link="TGx_16KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a> &amp;&amp; level == 1 then
        return '0'; // RES0
    if tgx == <a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>  &amp;&amp; level == 0 then
        return '0'; // RES0

    return descriptor&lt;52&gt;;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_ttentry/AArch64.DecodeDescriptorType" mylink="aarch64.translation.vmsa_ttentry.AArch64.DecodeDescriptorType" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.DecodeDescriptorType()
// ==============================
// Determine whether the descriptor is a page, block or table

DescriptorType <anchor link="AArch64.DecodeDescriptorType.4" hover="function: DescriptorType AArch64.DecodeDescriptorType(bits(64) descriptor, bit ds,&#13; TGx tgx, integer level)">AArch64.DecodeDescriptorType</anchor>(bits(64) descriptor, bit ds,
                                            <a link="TGx" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, integer level)
    if descriptor&lt;1:0&gt; == '11' &amp;&amp; level == <a link="FINAL_LEVEL" file="shared_pseudocode.xml" hover="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> then
        return <a link="DescriptorType_Page" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Page</a>;
    elsif descriptor&lt;1:0&gt; == '11' then
        return <a link="DescriptorType_Table" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Table</a>;
    elsif descriptor&lt;1:0&gt; == '01' then
        if <a link="AArch64.BlockDescSupported.3" file="shared_pseudocode.xml" hover="function: boolean AArch64.BlockDescSupported(bit ds, TGx tgx, integer level)">AArch64.BlockDescSupported</a>(ds, tgx, level) then
            return <a link="DescriptorType_Block" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Block</a>;
        else
            return <a link="DescriptorType_Invalid" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Invalid</a>;
    else
        return <a link="DescriptorType_Invalid" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Invalid</a>;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_ttentry/AArch64.S1ApplyOutputPerms" mylink="aarch64.translation.vmsa_ttentry.AArch64.S1ApplyOutputPerms" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S1ApplyOutputPerms()
// ============================
// Apply output permissions encoded in stage 1 page/block descriptors

Permissions <anchor link="AArch64.S1ApplyOutputPerms.4" hover="function: Permissions AArch64.S1ApplyOutputPerms(Permissions permissions_in, bits(64) descriptor,&#13; Regime regime, S1TTWParams walkparams)">AArch64.S1ApplyOutputPerms</anchor>(<a link="Permissions" file="shared_pseudocode.xml" hover="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(2) s2ap, bit s2xnx, bit s2xn )">Permissions</a> permissions_in, bits(64) descriptor,
                                       <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a link="S1TTWParams" file="shared_pseudocode.xml" hover="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams)
    <a link="Permissions" file="shared_pseudocode.xml" hover="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(2) s2ap, bit s2xnx, bit s2xn )">Permissions</a> permissions = permissions_in;
    if regime == <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; walkparams.nv1 == '1' then
        permissions.ap&lt;2:1&gt; = descriptor&lt;7&gt;:'0';
        permissions.pxn     = descriptor&lt;54&gt;;
    elsif <a link="impl-shared.HasUnprivileged.1" file="shared_pseudocode.xml" hover="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then
        permissions.ap&lt;2:1&gt; = descriptor&lt;7:6&gt;;
        permissions.uxn     = descriptor&lt;54&gt;;
        permissions.pxn     = descriptor&lt;53&gt;;
    else
        permissions.ap&lt;2:1&gt; = descriptor&lt;7&gt;:'1';
        permissions.xn      = descriptor&lt;54&gt;;

    // Descriptors marked with DBM set have the effective value of AP[2] cleared.
    // This implies no permission faults caused by lack of write permissions are
    // reported, and the Dirty bit can be set.
    if walkparams.ha == '1' &amp;&amp; walkparams.hd == '1' &amp;&amp; descriptor&lt;51&gt; == '1' then
        permissions.ap&lt;2&gt; = '0';

    return permissions;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_ttentry/AArch64.S1ApplyTablePerms" mylink="aarch64.translation.vmsa_ttentry.AArch64.S1ApplyTablePerms" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S1ApplyTablePerms()
// ===========================
// Apply hierarchical permissions encoded in stage 1 table descriptors

Permissions <anchor link="AArch64.S1ApplyTablePerms.4" hover="function: Permissions AArch64.S1ApplyTablePerms(Permissions permissions_in, bits(64) descriptor,&#13; Regime regime, S1TTWParams walkparams)">AArch64.S1ApplyTablePerms</anchor>(<a link="Permissions" file="shared_pseudocode.xml" hover="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(2) s2ap, bit s2xnx, bit s2xn )">Permissions</a> permissions_in, bits(64) descriptor,
                                      <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a link="S1TTWParams" file="shared_pseudocode.xml" hover="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams)
    <a link="Permissions" file="shared_pseudocode.xml" hover="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(2) s2ap, bit s2xnx, bit s2xn )">Permissions</a> permissions = permissions_in;
    if regime == <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; walkparams.nv1 == '1' then
        ap_table  = descriptor&lt;62&gt;:'0';
        pxn_table = descriptor&lt;60&gt;;
        permissions.ap_table  = permissions.ap_table  OR ap_table;
        permissions.pxn_table = permissions.pxn_table OR pxn_table;

    elsif <a link="impl-shared.HasUnprivileged.1" file="shared_pseudocode.xml" hover="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then
        ap_table  = descriptor&lt;62:61&gt;;
        uxn_table = descriptor&lt;60&gt;;
        pxn_table = descriptor&lt;59&gt;;
        permissions.ap_table  = permissions.ap_table  OR ap_table;
        permissions.uxn_table = permissions.uxn_table OR uxn_table;
        permissions.pxn_table = permissions.pxn_table OR pxn_table;
    else
        ap_table = descriptor&lt;62&gt;:'0';
        xn_table = descriptor&lt;60&gt;;
        permissions.ap_table = permissions.ap_table OR ap_table;
        permissions.xn_table = permissions.xn_table OR xn_table;

    return permissions;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_ttentry/AArch64.S2ApplyOutputPerms" mylink="aarch64.translation.vmsa_ttentry.AArch64.S2ApplyOutputPerms" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S2ApplyOutputPerms()
// ============================
// Apply output permissions encoded in stage 2 page/block descriptors

Permissions <anchor link="AArch64.S2ApplyOutputPerms.2" hover="function: Permissions AArch64.S2ApplyOutputPerms(bits(64) descriptor, S2TTWParams walkparams)">AArch64.S2ApplyOutputPerms</anchor>(bits(64) descriptor, <a link="S2TTWParams" file="shared_pseudocode.xml" hover="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams)
    <a link="Permissions" file="shared_pseudocode.xml" hover="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(2) s2ap, bit s2xnx, bit s2xn )">Permissions</a> permissions;

    permissions.s2ap = descriptor&lt;7:6&gt;;
    permissions.s2xn = descriptor&lt;54&gt;;

    if <a link="impl-shared.HaveExtendedExecuteNeverExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveExtendedExecuteNeverExt()">HaveExtendedExecuteNeverExt</a>() then
        permissions.s2xnx = descriptor&lt;53&gt;;
    else
        permissions.s2xnx = '0';

    // Descriptors marked with DBM set have the effective value of S2AP[1] set.
    // This implies no permission faults caused by lack of write permissions are
    // reported, and the Dirty bit can be set.
    if walkparams.ha == '1' &amp;&amp; walkparams.hd == '1' &amp;&amp; descriptor&lt;51&gt; == '1' then
        permissions.s2ap&lt;1&gt; = '1';

    return permissions;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walk/AArch64.S1InitialTTWState" mylink="aarch64.translation.vmsa_walk.AArch64.S1InitialTTWState" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S1InitialTTWState()
// ===========================
// Set properties of first access to translation tables in stage 1

TTWState <anchor link="AArch64.S1InitialTTWState.4" hover="function: TTWState AArch64.S1InitialTTWState(S1TTWParams walkparams, bits(64) va, Regime regime,&#13; SecurityState ss)">AArch64.S1InitialTTWState</anchor>(<a link="S1TTWParams" file="shared_pseudocode.xml" hover="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams, bits(64) va, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime,
                                   <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss)
    <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a>    walkstate;
    <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> tablebase;
    <a link="Permissions" file="shared_pseudocode.xml" hover="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(2) s2ap, bit s2xnx, bit s2xn )">Permissions</a> permissions;

    startlevel  = <a link="AArch64.S1StartLevel.1" file="shared_pseudocode.xml" hover="function: integer AArch64.S1StartLevel(S1TTWParams walkparams)">AArch64.S1StartLevel</a>(walkparams);
    ttbr        = <a link="AArch64.S1TTBR.2" file="shared_pseudocode.xml" hover="function: bits(64) AArch64.S1TTBR(Regime regime, bits(64) va)">AArch64.S1TTBR</a>(regime, va);
    case ss of
        when <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>    tablebase.paspace = <a link="PAS_Secure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_Secure</a>;
        when <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a> tablebase.paspace = <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a>;

    tablebase.address = <a link="AArch64.TTBaseAddress.6" file="shared_pseudocode.xml" hover="function: bits(52) AArch64.TTBaseAddress(bits(64) ttb, bits(6) txsz, bits(3) ps,&#13; bit ds, TGx tgx, integer startlevel)">AArch64.TTBaseAddress</a>(ttbr, walkparams.txsz, walkparams.ps, walkparams.ds,
                                              walkparams.tgx, startlevel);

    permissions.ap_table = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();
    if <a link="impl-shared.HasUnprivileged.1" file="shared_pseudocode.xml" hover="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then
        permissions.uxn_table = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();
        permissions.pxn_table = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();
    else
        permissions.xn_table  = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();

    walkstate.baseaddress = tablebase;
    walkstate.level       = startlevel;
    walkstate.istable     = TRUE;
    // In regimes that support global and non-global translations, translation
    // table entries from lookup levels other than the final level of lookup
    // are treated as being non-global
    walkstate.nG          = if <a link="impl-shared.HasUnprivileged.1" file="shared_pseudocode.xml" hover="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then '1' else '0';
    walkstate.memattrs    = <a link="impl-shared.WalkMemAttrs.3" file="shared_pseudocode.xml" hover="function: MemoryAttributes WalkMemAttrs(bits(2) sh, bits(2) irgn, bits(2) orgn)">WalkMemAttrs</a>(walkparams.sh, walkparams.irgn, walkparams.orgn);
    walkstate.permissions = permissions;

    return walkstate;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walk/AArch64.S1NextWalkStateLast" mylink="aarch64.translation.vmsa_walk.AArch64.S1NextWalkStateLast" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S1NextWalkStateLast()
// =============================
// Decode stage 1 page or block descriptor as output to this stage of translation

TTWState <anchor link="AArch64.S1NextWalkStateLast.5" hover="function: TTWState AArch64.S1NextWalkStateLast(TTWState currentstate, Regime regime, SecurityState ss,&#13; S1TTWParams walkparams, bits(64) descriptor)">AArch64.S1NextWalkStateLast</anchor>(<a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> currentstate, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss,
                                     <a link="S1TTWParams" file="shared_pseudocode.xml" hover="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams, bits(64) descriptor)
    <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a>    nextstate;
    <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> baseaddress;

    if currentstate.level == <a link="FINAL_LEVEL" file="shared_pseudocode.xml" hover="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> then
        baseaddress.address = <a link="AArch64.PageBase.3" file="shared_pseudocode.xml" hover="function: bits(52) AArch64.PageBase(bits(64) descriptor, bit ds, TGx tgx)">AArch64.PageBase</a>(descriptor, walkparams.ds, walkparams.tgx);
    else
        baseaddress.address = <a link="AArch64.BlockBase.4" file="shared_pseudocode.xml" hover="function: bits(52) AArch64.BlockBase(bits(64) descriptor, bit ds, TGx tgx, integer level)">AArch64.BlockBase</a>(descriptor, walkparams.ds, walkparams.tgx,
                                                currentstate.level);

    if currentstate.baseaddress.paspace == <a link="PAS_Secure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_Secure</a> then
        // Determine PA space of the block from NS bit
        baseaddress.paspace = if descriptor&lt;5&gt; == '0' then <a link="PAS_Secure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_Secure</a> else <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a>;
    else
        baseaddress.paspace = <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a>;

    nextstate.istable     = FALSE;
    nextstate.level       = currentstate.level;
    nextstate.baseaddress = baseaddress;

    attrindx = descriptor&lt;4:2&gt;;
    sh = if walkparams.ds == '1' then walkparams.sh else descriptor&lt;9:8&gt;;
    attr = <a link="impl-shared.MAIRAttr.2" file="shared_pseudocode.xml" hover="function: bits(8) MAIRAttr(integer index, MAIRType mair)">MAIRAttr</a>(<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(attrindx), walkparams.mair);
    s1aarch64 = TRUE;

    nextstate.memattrs    = <a link="impl-shared.S1DecodeMemAttrs.3" file="shared_pseudocode.xml" hover="function: MemoryAttributes S1DecodeMemAttrs(bits(8) attr_in, bits(2) sh, boolean s1aarch64)">S1DecodeMemAttrs</a>(attr, sh, s1aarch64);
    nextstate.permissions = <a link="AArch64.S1ApplyOutputPerms.4" file="shared_pseudocode.xml" hover="function: Permissions AArch64.S1ApplyOutputPerms(Permissions permissions_in, bits(64) descriptor,&#13; Regime regime, S1TTWParams walkparams)">AArch64.S1ApplyOutputPerms</a>(currentstate.permissions, descriptor,
                                                       regime, walkparams);
    nextstate.contiguous  = <a link="AArch64.ContiguousBit.3" file="shared_pseudocode.xml" hover="function: bit AArch64.ContiguousBit(TGx tgx, integer level, bits(64) descriptor)">AArch64.ContiguousBit</a>(walkparams.tgx, currentstate.level, descriptor);

    if !<a link="impl-shared.HasUnprivileged.1" file="shared_pseudocode.xml" hover="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then
        nextstate.nG = '0';
    elsif ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp; currentstate.baseaddress.paspace == <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a> then
        // In Secure state, a translation must be treated as non-global,
        // regardless of the value of the nG bit,
        // if NSTable is set to 1 at any level of the translation table walk
        nextstate.nG = '1';
    else
        nextstate.nG = descriptor&lt;11&gt;;

    nextstate.guardedpage = descriptor&lt;50&gt;;

    return nextstate;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walk/AArch64.S1NextWalkStateTable" mylink="aarch64.translation.vmsa_walk.AArch64.S1NextWalkStateTable" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S1NextWalkStateTable()
// ==============================
// Decode stage 1 table descriptor to transition to the next level

TTWState <anchor link="AArch64.S1NextWalkStateTable.4" hover="function: TTWState AArch64.S1NextWalkStateTable(TTWState currentstate, Regime regime, S1TTWParams walkparams,&#13; bits(64) descriptor)">AArch64.S1NextWalkStateTable</anchor>(<a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> currentstate, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a link="S1TTWParams" file="shared_pseudocode.xml" hover="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams,
                                      bits(64) descriptor)
    <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a>    nextstate;
    <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> tablebase;

    tablebase.address = <a link="AArch64.NextTableBase.3" file="shared_pseudocode.xml" hover="function: bits(52) AArch64.NextTableBase(bits(64) descriptor, bit ds, TGx tgx)">AArch64.NextTableBase</a>(descriptor, walkparams.ds, walkparams.tgx);
    if currentstate.baseaddress.paspace == <a link="PAS_Secure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_Secure</a> then
        // Determine PA space of the next table from NSTable bit
        tablebase.paspace = if descriptor&lt;63&gt; == '0' then <a link="PAS_Secure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_Secure</a> else <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a>;
    else
        // Otherwise bit 63 is RES0 and there is no NSTable bit
        tablebase.paspace = currentstate.baseaddress.paspace;

    nextstate.istable     = TRUE;
    nextstate.nG          = currentstate.nG;
    nextstate.level       = currentstate.level + 1;
    nextstate.baseaddress = tablebase;
    nextstate.memattrs    = currentstate.memattrs;

    if walkparams.hpd == '0' then
        nextstate.permissions = <a link="AArch64.S1ApplyTablePerms.4" file="shared_pseudocode.xml" hover="function: Permissions AArch64.S1ApplyTablePerms(Permissions permissions_in, bits(64) descriptor,&#13; Regime regime, S1TTWParams walkparams)">AArch64.S1ApplyTablePerms</a>(currentstate.permissions, descriptor,
                                                          regime, walkparams);
    else
        nextstate.permissions = currentstate.permissions;

    return nextstate;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walk/AArch64.S1Walk" mylink="aarch64.translation.vmsa_walk.AArch64.S1Walk" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S1Walk()
// ================
// Traverse stage 1 translation tables obtaining the final descriptor
// as well as the address leading to that descriptor

(FaultRecord, AddressDescriptor, TTWState, bits(64)) <anchor link="AArch64.S1Walk.8" hover="function: (FaultRecord, AddressDescriptor, TTWState, bits(64)) AArch64.S1Walk(FaultRecord fault_in,&#13; S1TTWParams walkparams, bits(64) va, Regime regime, SecurityState ss,&#13; AccType acctype, boolean iswrite_in, boolean ispriv)">AArch64.S1Walk</anchor>(<a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault_in,
        <a link="S1TTWParams" file="shared_pseudocode.xml" hover="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams, bits(64) va, <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss,
        <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite_in, boolean ispriv)
    <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault = fault_in;
    boolean iswrite = iswrite_in;
    if <a link="impl-shared.HasUnprivileged.1" file="shared_pseudocode.xml" hover="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) &amp;&amp; <a link="AArch64.S1EPD.2" file="shared_pseudocode.xml" hover="function: bit AArch64.S1EPD(Regime regime, bits(64) va)">AArch64.S1EPD</a>(regime, va) == '1' then
        fault.statuscode = <a link="Fault_Translation" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        fault.level      = 0;
        return (fault, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(64) UNKNOWN);

    walkstate = <a link="AArch64.S1InitialTTWState.4" file="shared_pseudocode.xml" hover="function: TTWState AArch64.S1InitialTTWState(S1TTWParams walkparams, bits(64) va, Regime regime,&#13; SecurityState ss)">AArch64.S1InitialTTWState</a>(walkparams, va, regime, ss);

    // Detect Address Size Fault by TTB
    if <a link="AArch64.OAOutOfRange.4" file="shared_pseudocode.xml" hover="function: boolean AArch64.OAOutOfRange(TTWState walkstate, bits(3) ps, TGx tgx, bits(64) ia)">AArch64.OAOutOfRange</a>(walkstate, walkparams.ps, walkparams.tgx, va) then
        fault.statuscode = <a link="Fault_AddressSize" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
        fault.level      = 0;
        return (fault, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(64) UNKNOWN);

    bits(64) descriptor;
    <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> walkaddress;

    walkaddress.vaddress = va;
    if !<a link="AArch64.S1DCacheEnabled.1" file="shared_pseudocode.xml" hover="function: boolean AArch64.S1DCacheEnabled(Regime regime)">AArch64.S1DCacheEnabled</a>(regime) then
        walkaddress.memattrs = <a link="impl-shared.NormalNCMemAttr.0" file="shared_pseudocode.xml" hover="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
        walkaddress.memattrs.xs = walkstate.memattrs.xs;
    else
        walkaddress.memattrs = walkstate.memattrs;

    // Shareability value of stage 1 translation subject to stage 2 is IMPLEMENTATION DEFINED
    // to be either effective value or descriptor value
    if (regime == <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.VM == '1' &amp;&amp;
            !(boolean IMPLEMENTATION_DEFINED "Apply effective shareability at stage 1")) then
        walkaddress.memattrs.shareability = walkstate.memattrs.shareability;
    else
        walkaddress.memattrs.shareability = <a link="impl-shared.EffectiveShareability.1" file="shared_pseudocode.xml" hover="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(walkaddress.memattrs);

    <a link="DescriptorType" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType</a> desctype;
    repeat
        fault.level = walkstate.level;
        <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> descaddress = <a link="AArch64.TTEntryAddress.5" file="shared_pseudocode.xml" hover="function: FullAddress AArch64.TTEntryAddress(integer level, TGx tgx, bits(6) txsz,&#13; bits(64) ia, FullAddress tablebase)">AArch64.TTEntryAddress</a>(walkstate.level, walkparams.tgx,
                                                         walkparams.txsz, va,
                                                         walkstate.baseaddress);

        walkaddress.paddress = descaddress;

        if regime == <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() then
            s1aarch64 = TRUE;
            s2fs1walk = TRUE;
            aligned   = TRUE;
            iswrite   = FALSE;
            (s2fault, s2walkaddress) = <a link="AArch64.S2Translate.9" file="shared_pseudocode.xml" hover="function: (FaultRecord, AddressDescriptor) AArch64.S2Translate(FaultRecord fault_in, AddressDescriptor ipa,&#13; boolean s1aarch64, SecurityState ss,&#13; boolean s2fs1walk, AccType acctype,&#13; boolean aligned, boolean iswrite,&#13; boolean ispriv)">AArch64.S2Translate</a>(fault, walkaddress, s1aarch64, ss,
                                                           s2fs1walk, <a link="AccType_TTW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_TTW</a>, aligned,
                                                           iswrite, ispriv);

            if s2fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
                return (s2fault, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(64) UNKNOWN);

            (fault, descriptor) = <a link="impl-shared.FetchDescriptor.3" file="shared_pseudocode.xml" hover="function: (FaultRecord, bits(N)) FetchDescriptor(bit ee, AddressDescriptor walkaddress, FaultRecord fault_in)">FetchDescriptor</a>(walkparams.ee, s2walkaddress, fault);
        else
            (fault, descriptor) = <a link="impl-shared.FetchDescriptor.3" file="shared_pseudocode.xml" hover="function: (FaultRecord, bits(N)) FetchDescriptor(bit ee, AddressDescriptor walkaddress, FaultRecord fault_in)">FetchDescriptor</a>(walkparams.ee, walkaddress, fault);

        if fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
            return (fault, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(64) UNKNOWN);

        desctype = <a link="AArch64.DecodeDescriptorType.4" file="shared_pseudocode.xml" hover="function: DescriptorType AArch64.DecodeDescriptorType(bits(64) descriptor, bit ds,&#13; TGx tgx, integer level)">AArch64.DecodeDescriptorType</a>(descriptor, walkparams.ds, walkparams.tgx,
                                                walkstate.level);

        case desctype of
            when <a link="DescriptorType_Table" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Table</a>
                walkstate = <a link="AArch64.S1NextWalkStateTable.4" file="shared_pseudocode.xml" hover="function: TTWState AArch64.S1NextWalkStateTable(TTWState currentstate, Regime regime, S1TTWParams walkparams,&#13; bits(64) descriptor)">AArch64.S1NextWalkStateTable</a>(walkstate, regime, walkparams,
                                                         descriptor);

                // Detect Address Size Fault by table descriptor
                if <a link="AArch64.OAOutOfRange.4" file="shared_pseudocode.xml" hover="function: boolean AArch64.OAOutOfRange(TTWState walkstate, bits(3) ps, TGx tgx, bits(64) ia)">AArch64.OAOutOfRange</a>(walkstate, walkparams.ps, walkparams.tgx, va) then
                    fault.statuscode = <a link="Fault_AddressSize" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
                    return (fault, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(64) UNKNOWN);

            when <a link="DescriptorType_Page" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Page</a>, <a link="DescriptorType_Block" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Block</a>
                walkstate = <a link="AArch64.S1NextWalkStateLast.5" file="shared_pseudocode.xml" hover="function: TTWState AArch64.S1NextWalkStateLast(TTWState currentstate, Regime regime, SecurityState ss,&#13; S1TTWParams walkparams, bits(64) descriptor)">AArch64.S1NextWalkStateLast</a>(walkstate, regime, ss,
                                                        walkparams, descriptor);

            when <a link="DescriptorType_Invalid" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Invalid</a>
                fault.statuscode = <a link="Fault_Translation" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
                return (fault, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(64) UNKNOWN);

            otherwise
                <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();

    until desctype IN {<a link="DescriptorType_Page" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Page</a>, <a link="DescriptorType_Block" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Block</a>};

    if (walkstate.contiguous == '1' &amp;&amp;
            <a link="AArch64.ContiguousBitFaults.3" file="shared_pseudocode.xml" hover="function: boolean AArch64.ContiguousBitFaults(bits(6) txsz, TGx tgx, integer level)">AArch64.ContiguousBitFaults</a>(walkparams.txsz, walkparams.tgx, walkstate.level)) then
        fault.statuscode = <a link="Fault_Translation" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
    elsif desctype == <a link="DescriptorType_Block" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Block</a> &amp;&amp; <a link="AArch64.BlocknTFaults.1" file="shared_pseudocode.xml" hover="function: boolean AArch64.BlocknTFaults(bits(64) descriptor)">AArch64.BlocknTFaults</a>(descriptor) then
        fault.statuscode = <a link="Fault_Translation" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
    // Detect Address Size Fault by final output
    elsif <a link="AArch64.OAOutOfRange.4" file="shared_pseudocode.xml" hover="function: boolean AArch64.OAOutOfRange(TTWState walkstate, bits(3) ps, TGx tgx, bits(64) ia)">AArch64.OAOutOfRange</a>(walkstate, walkparams.ps, walkparams.tgx, va) then
        fault.statuscode = <a link="Fault_AddressSize" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
    // Check descriptor AF bit
    elsif (descriptor&lt;10&gt; == '0' &amp;&amp; walkparams.ha == '0' &amp;&amp;
            !(acctype IN {<a link="AccType_DC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>, <a link="AccType_IC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>} &amp;&amp;
            !boolean IMPLEMENTATION_DEFINED "Generate access flag fault on IC/DC operations")) then
        fault.statuscode = <a link="Fault_AccessFlag" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>;

    return (fault, walkaddress, walkstate, descriptor);</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walk/AArch64.S2InitialTTWState" mylink="aarch64.translation.vmsa_walk.AArch64.S2InitialTTWState" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S2InitialTTWState()
// ===========================
// Set properties of first access to translation tables in stage 2

TTWState <anchor link="AArch64.S2InitialTTWState.2" hover="function: TTWState AArch64.S2InitialTTWState(SecurityState ss, S2TTWParams walkparams)">AArch64.S2InitialTTWState</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss, <a link="S2TTWParams" file="shared_pseudocode.xml" hover="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams)
    <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a>    walkstate;
    <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> tablebase;

    ttbr              = VTTBR_EL2;
    startlevel        = <a link="AArch64.S2StartLevel.1" file="shared_pseudocode.xml" hover="function: integer AArch64.S2StartLevel(S2TTWParams walkparams)">AArch64.S2StartLevel</a>(walkparams);
    tablebase.paspace = <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a>;
    tablebase.address = <a link="AArch64.TTBaseAddress.6" file="shared_pseudocode.xml" hover="function: bits(52) AArch64.TTBaseAddress(bits(64) ttb, bits(6) txsz, bits(3) ps,&#13; bit ds, TGx tgx, integer startlevel)">AArch64.TTBaseAddress</a>(ttbr, walkparams.txsz, walkparams.ps, walkparams.ds,
                                              walkparams.tgx, startlevel);

    walkstate.baseaddress = tablebase;
    walkstate.level       = startlevel;
    walkstate.istable     = TRUE;
    walkstate.memattrs    = <a link="impl-shared.WalkMemAttrs.3" file="shared_pseudocode.xml" hover="function: MemoryAttributes WalkMemAttrs(bits(2) sh, bits(2) irgn, bits(2) orgn)">WalkMemAttrs</a>(walkparams.sh, walkparams.irgn, walkparams.orgn);

    return walkstate;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walk/AArch64.S2NextWalkStateLast" mylink="aarch64.translation.vmsa_walk.AArch64.S2NextWalkStateLast" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S2NextWalkStateLast()
// =============================
// Decode stage 2 page or block descriptor as output to this stage of translation

TTWState <anchor link="AArch64.S2NextWalkStateLast.5" hover="function: TTWState AArch64.S2NextWalkStateLast(TTWState currentstate, SecurityState ss,&#13; S2TTWParams walkparams, AddressDescriptor ipa,&#13; bits(64) descriptor)">AArch64.S2NextWalkStateLast</anchor>(<a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> currentstate, <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss,
                                     <a link="S2TTWParams" file="shared_pseudocode.xml" hover="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> ipa,
                                     bits(64) descriptor)
    <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a>    nextstate;
    <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> baseaddress;

    if ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> then
        baseaddress.paspace = <a link="AArch64.SS2OutputPASpace.2" file="shared_pseudocode.xml" hover="function: PASpace AArch64.SS2OutputPASpace(S2TTWParams walkparams, PASpace ipaspace)">AArch64.SS2OutputPASpace</a>(walkparams, ipa.paddress.paspace);
    else
        baseaddress.paspace = <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a>;

    if currentstate.level == <a link="FINAL_LEVEL" file="shared_pseudocode.xml" hover="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> then
        baseaddress.address = <a link="AArch64.PageBase.3" file="shared_pseudocode.xml" hover="function: bits(52) AArch64.PageBase(bits(64) descriptor, bit ds, TGx tgx)">AArch64.PageBase</a>(descriptor, walkparams.ds, walkparams.tgx);
    else
        baseaddress.address = <a link="AArch64.BlockBase.4" file="shared_pseudocode.xml" hover="function: bits(52) AArch64.BlockBase(bits(64) descriptor, bit ds, TGx tgx, integer level)">AArch64.BlockBase</a>(descriptor, walkparams.ds, walkparams.tgx,
                                                currentstate.level);

    nextstate.istable     = FALSE;
    nextstate.level       = currentstate.level;
    nextstate.baseaddress = baseaddress;
    nextstate.permissions = <a link="AArch64.S2ApplyOutputPerms.2" file="shared_pseudocode.xml" hover="function: Permissions AArch64.S2ApplyOutputPerms(bits(64) descriptor, S2TTWParams walkparams)">AArch64.S2ApplyOutputPerms</a>(descriptor, walkparams);

    s2_attr = descriptor&lt;5:2&gt;;
    s2_sh   = if walkparams.ds == '1' then walkparams.sh else descriptor&lt;9:8&gt;;
    s2_fnxs = descriptor&lt;11&gt;;
    if walkparams.fwb == '1' then
        nextstate.memattrs = <a link="AArch64.S2ApplyFWBMemAttrs.3" file="shared_pseudocode.xml" hover="function: MemoryAttributes AArch64.S2ApplyFWBMemAttrs(MemoryAttributes s1_memattrs,&#13; bits(4) s2_attr, bits(2) s2_sh)">AArch64.S2ApplyFWBMemAttrs</a>(ipa.memattrs, s2_attr, s2_sh);
        if s2_attr&lt;1:0&gt; == '10' then    // Force writeback
            nextstate.memattrs.xs = '0';
        else
            nextstate.memattrs.xs = if s2_fnxs == '1' then '0' else ipa.memattrs.xs;
    else
        nextstate.memattrs = <a link="impl-shared.S2DecodeMemAttrs.2" file="shared_pseudocode.xml" hover="function: MemoryAttributes S2DecodeMemAttrs(bits(4) attr, bits(2) sh)">S2DecodeMemAttrs</a>(s2_attr, s2_sh);
        nextstate.memattrs.xs = if s2_fnxs == '1' then '0' else ipa.memattrs.xs;
    nextstate.contiguous = <a link="AArch64.ContiguousBit.3" file="shared_pseudocode.xml" hover="function: bit AArch64.ContiguousBit(TGx tgx, integer level, bits(64) descriptor)">AArch64.ContiguousBit</a>(walkparams.tgx, currentstate.level, descriptor);

    return nextstate;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walk/AArch64.S2NextWalkStateTable" mylink="aarch64.translation.vmsa_walk.AArch64.S2NextWalkStateTable" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S2NextWalkStateTable()
// ==============================
// Decode stage 2 table descriptor to transition to the next level

TTWState <anchor link="AArch64.S2NextWalkStateTable.3" hover="function: TTWState AArch64.S2NextWalkStateTable(TTWState currentstate, S2TTWParams walkparams,&#13; bits(64) descriptor)">AArch64.S2NextWalkStateTable</anchor>(<a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> currentstate, <a link="S2TTWParams" file="shared_pseudocode.xml" hover="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams,
                                      bits(64) descriptor)
    <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a>    nextstate;
    <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> tablebase;

    tablebase.address = <a link="AArch64.NextTableBase.3" file="shared_pseudocode.xml" hover="function: bits(52) AArch64.NextTableBase(bits(64) descriptor, bit ds, TGx tgx)">AArch64.NextTableBase</a>(descriptor, walkparams.ds, walkparams.tgx);
    tablebase.paspace = currentstate.baseaddress.paspace;

    nextstate.istable     = TRUE;
    nextstate.level       = currentstate.level + 1;
    nextstate.baseaddress = tablebase;
    nextstate.memattrs    = currentstate.memattrs;

    return nextstate;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walk/AArch64.S2Walk" mylink="aarch64.translation.vmsa_walk.AArch64.S2Walk" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S2Walk()
// ================
// Traverse stage 2 translation tables obtaining the final descriptor
// as well as the address leading to that descriptor

(FaultRecord, AddressDescriptor, TTWState, bits(64)) <anchor link="AArch64.S2Walk.7" hover="function: (FaultRecord, AddressDescriptor, TTWState, bits(64)) AArch64.S2Walk(&#13; FaultRecord fault_in, AddressDescriptor ipa, S2TTWParams walkparams, SecurityState ss,&#13; AccType acctype, boolean iswrite, boolean s1aarch64)">AArch64.S2Walk</anchor>(
        <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault_in, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> ipa, <a link="S2TTWParams" file="shared_pseudocode.xml" hover="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams, <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss,
        <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite, boolean s1aarch64)

    <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault = fault_in;
    ipa_64 = <a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(ipa.paddress.address, 64);

    <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate;
    if ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> then
        walkstate = <a link="AArch64.SS2InitialTTWState.2" file="shared_pseudocode.xml" hover="function: TTWState AArch64.SS2InitialTTWState(S2TTWParams walkparams, PASpace ipaspace)">AArch64.SS2InitialTTWState</a>(walkparams, ipa.paddress.paspace);
    else
        walkstate = <a link="AArch64.S2InitialTTWState.2" file="shared_pseudocode.xml" hover="function: TTWState AArch64.S2InitialTTWState(SecurityState ss, S2TTWParams walkparams)">AArch64.S2InitialTTWState</a>(ss, walkparams);

    // Detect Address Size Fault by TTB
    if <a link="AArch64.OAOutOfRange.4" file="shared_pseudocode.xml" hover="function: boolean AArch64.OAOutOfRange(TTWState walkstate, bits(3) ps, TGx tgx, bits(64) ia)">AArch64.OAOutOfRange</a>(walkstate, walkparams.ps, walkparams.tgx, ipa_64) then
        fault.statuscode = <a link="Fault_AddressSize" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
        fault.level      = 0;
        return (fault, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(64) UNKNOWN);

    bits(64) descriptor;
    <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> walkaddress;

    walkaddress.vaddress = ipa.vaddress;
    if HCR_EL2.CD == '1' then
        walkaddress.memattrs = <a link="impl-shared.NormalNCMemAttr.0" file="shared_pseudocode.xml" hover="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
        walkaddress.memattrs.xs = walkstate.memattrs.xs;
    else
        walkaddress.memattrs = walkstate.memattrs;

    walkaddress.memattrs.shareability = <a link="impl-shared.EffectiveShareability.1" file="shared_pseudocode.xml" hover="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(walkaddress.memattrs);

    <a link="DescriptorType" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType</a> desctype;
    repeat
        fault.level = walkstate.level;

        <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> descaddress;
        if walkstate.level == <a link="AArch64.S2StartLevel.1" file="shared_pseudocode.xml" hover="function: integer AArch64.S2StartLevel(S2TTWParams walkparams)">AArch64.S2StartLevel</a>(walkparams) then
            // Initial lookup might index into concatenated tables
            descaddress = <a link="AArch64.S2SLTTEntryAddress.3" file="shared_pseudocode.xml" hover="function: FullAddress AArch64.S2SLTTEntryAddress(S2TTWParams walkparams, bits(52) ipa,&#13; FullAddress tablebase)">AArch64.S2SLTTEntryAddress</a>(walkparams, ipa.paddress.address,
                                                     walkstate.baseaddress);
        else
            ipa_64 = <a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(ipa.paddress.address, 64);
            descaddress = <a link="AArch64.TTEntryAddress.5" file="shared_pseudocode.xml" hover="function: FullAddress AArch64.TTEntryAddress(integer level, TGx tgx, bits(6) txsz,&#13; bits(64) ia, FullAddress tablebase)">AArch64.TTEntryAddress</a>(walkstate.level, walkparams.tgx, walkparams.txsz,
                                                 ipa_64, walkstate.baseaddress);

        walkaddress.paddress = descaddress;
        (fault, descriptor) = <a link="impl-shared.FetchDescriptor.3" file="shared_pseudocode.xml" hover="function: (FaultRecord, bits(N)) FetchDescriptor(bit ee, AddressDescriptor walkaddress, FaultRecord fault_in)">FetchDescriptor</a>(walkparams.ee, walkaddress, fault);

        if fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
            return (fault, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(64) UNKNOWN);

        desctype = <a link="AArch64.DecodeDescriptorType.4" file="shared_pseudocode.xml" hover="function: DescriptorType AArch64.DecodeDescriptorType(bits(64) descriptor, bit ds,&#13; TGx tgx, integer level)">AArch64.DecodeDescriptorType</a>(descriptor, walkparams.ds, walkparams.tgx,
                                                walkstate.level);

        case desctype of
            when <a link="DescriptorType_Table" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Table</a>
                walkstate = <a link="AArch64.S2NextWalkStateTable.3" file="shared_pseudocode.xml" hover="function: TTWState AArch64.S2NextWalkStateTable(TTWState currentstate, S2TTWParams walkparams,&#13; bits(64) descriptor)">AArch64.S2NextWalkStateTable</a>(walkstate, walkparams, descriptor);

                // Detect Address Size Fault by table descriptor
                if <a link="AArch64.OAOutOfRange.4" file="shared_pseudocode.xml" hover="function: boolean AArch64.OAOutOfRange(TTWState walkstate, bits(3) ps, TGx tgx, bits(64) ia)">AArch64.OAOutOfRange</a>(walkstate, walkparams.ps, walkparams.tgx, ipa_64) then
                    fault.statuscode = <a link="Fault_AddressSize" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
                    return (fault, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(64) UNKNOWN);

            when <a link="DescriptorType_Page" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Page</a>, <a link="DescriptorType_Block" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Block</a>
                walkstate = <a link="AArch64.S2NextWalkStateLast.5" file="shared_pseudocode.xml" hover="function: TTWState AArch64.S2NextWalkStateLast(TTWState currentstate, SecurityState ss,&#13; S2TTWParams walkparams, AddressDescriptor ipa,&#13; bits(64) descriptor)">AArch64.S2NextWalkStateLast</a>(walkstate, ss, walkparams, ipa,
                                                        descriptor);

            when <a link="DescriptorType_Invalid" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Invalid</a>
                fault.statuscode = <a link="Fault_Translation" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
                return (fault, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(64) UNKNOWN);

            otherwise
                <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();

    until desctype IN {<a link="DescriptorType_Page" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Page</a>, <a link="DescriptorType_Block" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Block</a>};

    if (walkstate.contiguous == '1' &amp;&amp;
            <a link="AArch64.ContiguousBitFaults.3" file="shared_pseudocode.xml" hover="function: boolean AArch64.ContiguousBitFaults(bits(6) txsz, TGx tgx, integer level)">AArch64.ContiguousBitFaults</a>(walkparams.txsz, walkparams.tgx, walkstate.level)) then
        fault.statuscode = <a link="Fault_Translation" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
    elsif desctype == <a link="DescriptorType_Block" file="shared_pseudocode.xml" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Block</a> &amp;&amp; <a link="AArch64.BlocknTFaults.1" file="shared_pseudocode.xml" hover="function: boolean AArch64.BlocknTFaults(bits(64) descriptor)">AArch64.BlocknTFaults</a>(descriptor) then
        fault.statuscode = <a link="Fault_Translation" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
    // Detect Address Size Fault by final output
    elsif <a link="AArch64.OAOutOfRange.4" file="shared_pseudocode.xml" hover="function: boolean AArch64.OAOutOfRange(TTWState walkstate, bits(3) ps, TGx tgx, bits(64) ia)">AArch64.OAOutOfRange</a>(walkstate, walkparams.ps, walkparams.tgx, ipa_64) then
        fault.statuscode = <a link="Fault_AddressSize" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
    // Check descriptor AF bit
    elsif (descriptor&lt;10&gt; == '0' &amp;&amp; walkparams.ha == '0' &amp;&amp;
            !(acctype IN {<a link="AccType_DC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>, <a link="AccType_IC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>} &amp;&amp;
            !boolean IMPLEMENTATION_DEFINED "Generate access flag fault on IC/DC operations")) then
        fault.statuscode = <a link="Fault_AccessFlag" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>;

    return (fault, walkaddress, walkstate, descriptor);</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walk/AArch64.SS2InitialTTWState" mylink="aarch64.translation.vmsa_walk.AArch64.SS2InitialTTWState" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.SS2InitialTTWState()
// ============================
// Set properties of first access to translation tables in Secure stage 2

TTWState <anchor link="AArch64.SS2InitialTTWState.2" hover="function: TTWState AArch64.SS2InitialTTWState(S2TTWParams walkparams, PASpace ipaspace)">AArch64.SS2InitialTTWState</anchor>(<a link="S2TTWParams" file="shared_pseudocode.xml" hover="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams, <a link="PASpace" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PASpace</a> ipaspace)
    <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a>    walkstate;
    <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> tablebase;

    bits(64) ttbr;
    if ipaspace == <a link="PAS_Secure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_Secure</a> then
        ttbr = VSTTBR_EL2;
    else
        ttbr = VTTBR_EL2;

    if ipaspace == <a link="PAS_Secure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_Secure</a> then
        if walkparams.sw == '0' then
            tablebase.paspace = <a link="PAS_Secure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_Secure</a>;
        else
            tablebase.paspace = <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a>;
    else
        if walkparams.nsw == '0' then
            tablebase.paspace = <a link="PAS_Secure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_Secure</a>;
        else
            tablebase.paspace = <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a>;

    startlevel        = <a link="AArch64.S2StartLevel.1" file="shared_pseudocode.xml" hover="function: integer AArch64.S2StartLevel(S2TTWParams walkparams)">AArch64.S2StartLevel</a>(walkparams);
    tablebase.address = <a link="AArch64.TTBaseAddress.6" file="shared_pseudocode.xml" hover="function: bits(52) AArch64.TTBaseAddress(bits(64) ttb, bits(6) txsz, bits(3) ps,&#13; bit ds, TGx tgx, integer startlevel)">AArch64.TTBaseAddress</a>(ttbr, walkparams.txsz, walkparams.ps, walkparams.ds,
                                              walkparams.tgx, startlevel);

    walkstate.baseaddress = tablebase;
    walkstate.level       = startlevel;
    walkstate.istable     = TRUE;
    walkstate.memattrs    = <a link="impl-shared.WalkMemAttrs.3" file="shared_pseudocode.xml" hover="function: MemoryAttributes WalkMemAttrs(bits(2) sh, bits(2) irgn, bits(2) orgn)">WalkMemAttrs</a>(walkparams.sh, walkparams.irgn, walkparams.orgn);

    return walkstate;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walk/AArch64.SS2OutputPASpace" mylink="aarch64.translation.vmsa_walk.AArch64.SS2OutputPASpace" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.SS2OutputPASpace()
// ==========================
// Assign PA Space to output of Secure stage 2 translation

PASpace <anchor link="AArch64.SS2OutputPASpace.2" hover="function: PASpace AArch64.SS2OutputPASpace(S2TTWParams walkparams, PASpace ipaspace)">AArch64.SS2OutputPASpace</anchor>(<a link="S2TTWParams" file="shared_pseudocode.xml" hover="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams, <a link="PASpace" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PASpace</a> ipaspace)
    if ipaspace == <a link="PAS_Secure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_Secure</a> then
        if walkparams.&lt;sw,sa&gt; == '00' then
            return <a link="PAS_Secure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_Secure</a>;
        else
            return <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a>;
    else
        if walkparams.&lt;sw,sa,nsw,nsa&gt; == '0000' then
            return <a link="PAS_Secure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_Secure</a>;
        else
            return <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a>;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walkparams/AArch64.BBMSupportLevel" mylink="aarch64.translation.vmsa_walkparams.AArch64.BBMSupportLevel" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.BBMSupportLevel()
// =========================
// Returns the level of FEAT_BBM supported

integer <anchor link="AArch64.BlockBBMSupportLevel.0" hover="function: integer AArch64.BlockBBMSupportLevel()">AArch64.BlockBBMSupportLevel</anchor>()
    if !<a link="impl-shared.HaveBlockBBM.0" file="shared_pseudocode.xml" hover="function: boolean HaveBlockBBM()">HaveBlockBBM</a>() then
        return integer UNKNOWN;
    else
        return integer IMPLEMENTATION_DEFINED "Block BBM support level";</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walkparams/AArch64.DecodeTG0" mylink="aarch64.translation.vmsa_walkparams.AArch64.DecodeTG0" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.DecodeTG0()
// ===================
// Decode granule size configuration bits TG0

TGx <anchor link="AArch64.DecodeTG0.1" hover="function: TGx AArch64.DecodeTG0(bits(2) tg0_in)">AArch64.DecodeTG0</anchor>(bits(2) tg0_in)
    bits(2) tg0 = tg0_in;
    if tg0 == '11' then
        tg0 = bits(2) IMPLEMENTATION_DEFINED "Reserved TG0 encoding granule size";

    case tg0 of
        when '00'   return <a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
        when '01'   return <a link="TGx_64KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a>;
        when '10'   return <a link="TGx_16KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walkparams/AArch64.DecodeTG1" mylink="aarch64.translation.vmsa_walkparams.AArch64.DecodeTG1" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.DecodeTG1()
// ===================
// Decode granule size configuration bits TG1

TGx <anchor link="AArch64.DecodeTG1.1" hover="function: TGx AArch64.DecodeTG1(bits(2) tg1_in)">AArch64.DecodeTG1</anchor>(bits(2) tg1_in)
    bits(2) tg1 = tg1_in;
    if tg1 == '00' then
        tg1 = bits(2) IMPLEMENTATION_DEFINED "Reserved TG1 encoding granule size";

    case tg1 of
        when '10'   return <a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
        when '11'   return <a link="TGx_64KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a>;
        when '01'   return <a link="TGx_16KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walkparams/AArch64.GetS1TTWParams" mylink="aarch64.translation.vmsa_walkparams.AArch64.GetS1TTWParams" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.GetS1TTWParams()
// ========================
// Returns stage 1 translation table walk parameters from respective controlling
// system registers.

S1TTWParams <anchor link="AArch64.GetS1TTWParams.2" hover="function: S1TTWParams AArch64.GetS1TTWParams(Regime regime, bits(64) va)">AArch64.GetS1TTWParams</anchor>(<a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(64) va)
    <a link="S1TTWParams" file="shared_pseudocode.xml" hover="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams;

    varange = <a link="AArch64.GetVARange.1" file="shared_pseudocode.xml" hover="function: VARange AArch64.GetVARange(bits(64) va)">AArch64.GetVARange</a>(va);

    case regime of
        when <a link="Regime_EL3" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>  walkparams = <a link="AArch64.S1TTWParamsEL3.0" file="shared_pseudocode.xml" hover="function: S1TTWParams AArch64.S1TTWParamsEL3()">AArch64.S1TTWParamsEL3</a>();
        when <a link="Regime_EL2" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  walkparams = <a link="AArch64.S1TTWParamsEL2.0" file="shared_pseudocode.xml" hover="function: S1TTWParams AArch64.S1TTWParamsEL2()">AArch64.S1TTWParamsEL2</a>();
        when <a link="Regime_EL20" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> walkparams = <a link="AArch64.S1TTWParamsEL20.1" file="shared_pseudocode.xml" hover="function: S1TTWParams AArch64.S1TTWParamsEL20(VARange varange)">AArch64.S1TTWParamsEL20</a>(varange);
        when <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> walkparams = <a link="AArch64.S1TTWParamsEL10.1" file="shared_pseudocode.xml" hover="function: S1TTWParams AArch64.S1TTWParamsEL10(VARange varange)">AArch64.S1TTWParamsEL10</a>(varange);

    maxtxsz = <a link="AArch64.MaxTxSZ.1" file="shared_pseudocode.xml" hover="function: integer AArch64.MaxTxSZ(TGx tgx)">AArch64.MaxTxSZ</a>(walkparams.tgx);
    mintxsz = <a link="AArch64.S1MinTxSZ.2" file="shared_pseudocode.xml" hover="function: integer AArch64.S1MinTxSZ(bit ds, TGx tgx)">AArch64.S1MinTxSZ</a>(walkparams.ds, walkparams.tgx);
    if <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(walkparams.txsz) &gt; maxtxsz then
        if !(boolean IMPLEMENTATION_DEFINED "<a link="Fault" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> on TxSZ value above maximum") then
            walkparams.txsz = maxtxsz&lt;5:0&gt;;
    elsif !<a link="impl-shared.Have52BitVAExt.0" file="shared_pseudocode.xml" hover="function: boolean Have52BitVAExt()">Have52BitVAExt</a>() &amp;&amp; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(walkparams.txsz) &lt; mintxsz then
        if !(boolean IMPLEMENTATION_DEFINED "<a link="Fault" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> on TxSZ value below minimum") then
            walkparams.txsz = mintxsz&lt;5:0&gt;;

    return walkparams;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walkparams/AArch64.GetS2TTWParams" mylink="aarch64.translation.vmsa_walkparams.AArch64.GetS2TTWParams" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.GetS2TTWParams()
// ========================
// Gather walk parameters for stage 2 translation

S2TTWParams <anchor link="AArch64.GetS2TTWParams.3" hover="function: S2TTWParams AArch64.GetS2TTWParams(SecurityState ss, PASpace ipaspace, boolean s1aarch64)">AArch64.GetS2TTWParams</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss, <a link="PASpace" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PASpace</a> ipaspace, boolean s1aarch64)
    <a link="S2TTWParams" file="shared_pseudocode.xml" hover="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams;

    if ss == <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a> then
        walkparams = <a link="AArch64.NSS2TTWParams.1" file="shared_pseudocode.xml" hover="function: S2TTWParams AArch64.NSS2TTWParams(boolean s1aarch64)">AArch64.NSS2TTWParams</a>(s1aarch64);
    elsif <a link="impl-shared.HaveSecureEL2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() &amp;&amp; ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> then
        walkparams = <a link="AArch64.SS2TTWParams.2" file="shared_pseudocode.xml" hover="function: S2TTWParams AArch64.SS2TTWParams(PASpace ipaspace, boolean s1aarch64)">AArch64.SS2TTWParams</a>(ipaspace, s1aarch64);
    else
        <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();

    maxtxsz = <a link="AArch64.MaxTxSZ.1" file="shared_pseudocode.xml" hover="function: integer AArch64.MaxTxSZ(TGx tgx)">AArch64.MaxTxSZ</a>(walkparams.tgx);
    mintxsz = <a link="AArch64.S2MinTxSZ.3" file="shared_pseudocode.xml" hover="function: integer AArch64.S2MinTxSZ(bit ds, TGx tgx, boolean s1aarch64)">AArch64.S2MinTxSZ</a>(walkparams.ds, walkparams.tgx, s1aarch64);
    if <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(walkparams.txsz) &gt; maxtxsz then
        if !(boolean IMPLEMENTATION_DEFINED "<a link="Fault" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> on TxSZ value above maximum") then
            walkparams.txsz = maxtxsz&lt;5:0&gt;;
    elsif !<a link="impl-shared.Have52BitPAExt.0" file="shared_pseudocode.xml" hover="function: boolean Have52BitPAExt()">Have52BitPAExt</a>() &amp;&amp; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(walkparams.txsz) &lt; mintxsz then
        if !(boolean IMPLEMENTATION_DEFINED "<a link="Fault" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> on TxSZ value below minimum") then
            walkparams.txsz = mintxsz&lt;5:0&gt;;

    return walkparams;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walkparams/AArch64.GetVARange" mylink="aarch64.translation.vmsa_walkparams.AArch64.GetVARange" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.GetVARange()
// ====================
// Determines if the VA that is to be translated lies in LOWER or UPPER address range.

VARange <anchor link="AArch64.GetVARange.1" hover="function: VARange AArch64.GetVARange(bits(64) va)">AArch64.GetVARange</anchor>(bits(64) va)
    if va&lt;55&gt; == '0' then
        return <a link="VARange_LOWER" file="shared_pseudocode.xml" hover="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a>;
    else
        return <a link="VARange_UPPER" file="shared_pseudocode.xml" hover="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_UPPER</a>;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walkparams/AArch64.MaxTxSZ" mylink="aarch64.translation.vmsa_walkparams.AArch64.MaxTxSZ" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.MaxTxSZ()
// =================
// Retrieve the maximum value of TxSZ indicating minimum input address size for both
// stages of translation

integer <anchor link="AArch64.MaxTxSZ.1" hover="function: integer AArch64.MaxTxSZ(TGx tgx)">AArch64.MaxTxSZ</anchor>(<a link="TGx" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx)
    if <a link="impl-shared.HaveSmallTranslationTableExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveSmallTranslationTableExt()">HaveSmallTranslationTableExt</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
        case tgx of
            when <a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>   return 48;
            when <a link="TGx_16KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>  return 48;
            when <a link="TGx_64KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a>  return 47;
    return 39;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walkparams/AArch64.NSS2TTWParams" mylink="aarch64.translation.vmsa_walkparams.AArch64.NSS2TTWParams" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.NSS2TTWParams()
// =======================
// Gather walk parameters specific for Non-secure stage 2 translation

S2TTWParams <anchor link="AArch64.NSS2TTWParams.1" hover="function: S2TTWParams AArch64.NSS2TTWParams(boolean s1aarch64)">AArch64.NSS2TTWParams</anchor>(boolean s1aarch64)
    <a link="S2TTWParams" file="shared_pseudocode.xml" hover="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams;

    walkparams.vm   = HCR_EL2.VM OR HCR_EL2.DC;
    walkparams.tgx  = <a link="AArch64.DecodeTG0.1" file="shared_pseudocode.xml" hover="function: TGx AArch64.DecodeTG0(bits(2) tg0_in)">AArch64.DecodeTG0</a>(VTCR_EL2.TG0);
    walkparams.txsz = VTCR_EL2.T0SZ;
    walkparams.sl0  = VTCR_EL2.SL0;
    walkparams.ps   = VTCR_EL2.PS;
    walkparams.irgn = VTCR_EL2.IRGN0;
    walkparams.orgn = VTCR_EL2.ORGN0;
    walkparams.sh   = VTCR_EL2.SH0;
    walkparams.ee   = SCTLR_EL2.EE;

    walkparams.ptw = if HCR_EL2.TGE == '0'         then HCR_EL2.PTW else '0';
    walkparams.fwb = if <a link="impl-shared.HaveStage2MemAttrControl.0" file="shared_pseudocode.xml" hover="function: boolean HaveStage2MemAttrControl()">HaveStage2MemAttrControl</a>() then HCR_EL2.FWB else '0';
    walkparams.ha  = if <a link="impl-shared.HaveAccessFlagUpdateExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveAccessFlagUpdateExt()">HaveAccessFlagUpdateExt</a>()  then VTCR_EL2.HA else '0';
    walkparams.hd  = if <a link="impl-shared.HaveDirtyBitModifierExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveDirtyBitModifierExt()">HaveDirtyBitModifierExt</a>()  then VTCR_EL2.HD else '0';
    if walkparams.tgx IN {<a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>, <a link="TGx_16KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>} &amp;&amp; <a link="impl-shared.Have52BitIPAAndPASpaceExt.0" file="shared_pseudocode.xml" hover="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
        walkparams.ds = VTCR_EL2.DS;
    else
        walkparams.ds = '0';
    if walkparams.tgx == <a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a> &amp;&amp; <a link="impl-shared.Have52BitIPAAndPASpaceExt.0" file="shared_pseudocode.xml" hover="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
        walkparams.sl2 = VTCR_EL2.SL2 AND VTCR_EL2.DS;
    else
        walkparams.sl2 = '0';
    walkparams.cmow = if <a link="impl-shared.HaveFeatCMOW.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatCMOW()">HaveFeatCMOW</a>() &amp;&amp; <a link="impl-aarch64.IsHCRXEL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean IsHCRXEL2Enabled()">IsHCRXEL2Enabled</a>() then HCRX_EL2.CMOW else '0';

    return walkparams;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walkparams/AArch64.PAMax" mylink="aarch64.translation.vmsa_walkparams.AArch64.PAMax" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.PAMax()
// ===============
// Returns the IMPLEMENTATION DEFINED maximum number of bits capable of representing
// physical address for this processor

integer <anchor link="AArch64.PAMax.0" hover="function: integer AArch64.PAMax()">AArch64.PAMax</anchor>()
    return integer IMPLEMENTATION_DEFINED "Maximum Physical Address Size";</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walkparams/AArch64.S1DCacheEnabled" mylink="aarch64.translation.vmsa_walkparams.AArch64.S1DCacheEnabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S1DCacheEnabled()
// =========================
// Determine cacheability of stage 1 data accesses

boolean <anchor link="AArch64.S1DCacheEnabled.1" hover="function: boolean AArch64.S1DCacheEnabled(Regime regime)">AArch64.S1DCacheEnabled</anchor>(<a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime)
    case regime of
        when <a link="Regime_EL3" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>  return SCTLR_EL3.C == '1';
        when <a link="Regime_EL2" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  return SCTLR_EL2.C == '1';
        when <a link="Regime_EL20" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> return SCTLR_EL2.C == '1';
        when <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> return SCTLR_EL1.C == '1';</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walkparams/AArch64.S1EPD" mylink="aarch64.translation.vmsa_walkparams.AArch64.S1EPD" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S1EPD()
// ===============
// Determine whether stage 1 translation table walk is allowed for the VA range

bit <anchor link="AArch64.S1EPD.2" hover="function: bit AArch64.S1EPD(Regime regime, bits(64) va)">AArch64.S1EPD</anchor>(<a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(64) va)
    assert <a link="impl-shared.HasUnprivileged.1" file="shared_pseudocode.xml" hover="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime);
    varange = <a link="AArch64.GetVARange.1" file="shared_pseudocode.xml" hover="function: VARange AArch64.GetVARange(bits(64) va)">AArch64.GetVARange</a>(va);

    case regime of
        when <a link="Regime_EL20" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> return if varange == <a link="VARange_LOWER" file="shared_pseudocode.xml" hover="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then TCR_EL2.EPD0 else TCR_EL2.EPD1;
        when <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> return if varange == <a link="VARange_LOWER" file="shared_pseudocode.xml" hover="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then TCR_EL1.EPD0 else TCR_EL1.EPD1;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walkparams/AArch64.S1Enabled" mylink="aarch64.translation.vmsa_walkparams.AArch64.S1Enabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S1Enabled()
// ===================
// Determine if stage 1 for the acting translation regime is enabled

boolean <anchor link="AArch64.S1Enabled.1" hover="function: boolean AArch64.S1Enabled(Regime regime)">AArch64.S1Enabled</anchor>(<a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime)
    case regime of
        when <a link="Regime_EL3" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>  return SCTLR_EL3.M == '1';
        when <a link="Regime_EL2" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  return SCTLR_EL2.M == '1';
        when <a link="Regime_EL20" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> return SCTLR_EL2.M == '1';
        when <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> return (!<a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() || HCR_EL2.&lt;DC,TGE&gt; == '00') &amp;&amp; SCTLR_EL1.M == '1';</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walkparams/AArch64.S1ICacheEnabled" mylink="aarch64.translation.vmsa_walkparams.AArch64.S1ICacheEnabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S1ICacheEnabled()
// =========================
// Determine cacheability of stage 1 instruction fetches

boolean <anchor link="AArch64.S1ICacheEnabled.1" hover="function: boolean AArch64.S1ICacheEnabled(Regime regime)">AArch64.S1ICacheEnabled</anchor>(<a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime)
    case regime of
        when <a link="Regime_EL3" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>  return SCTLR_EL3.I == '1';
        when <a link="Regime_EL2" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  return SCTLR_EL2.I == '1';
        when <a link="Regime_EL20" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> return SCTLR_EL2.I == '1';
        when <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> return SCTLR_EL1.I == '1';</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walkparams/AArch64.S1MinTxSZ" mylink="aarch64.translation.vmsa_walkparams.AArch64.S1MinTxSZ" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S1MinTxSZ()
// ===================
// Retrieve the minimum value of TxSZ indicating maximum input address size for stage 1

integer <anchor link="AArch64.S1MinTxSZ.2" hover="function: integer AArch64.S1MinTxSZ(bit ds, TGx tgx)">AArch64.S1MinTxSZ</anchor>(bit ds, <a link="TGx" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx)
    if (<a link="impl-shared.Have52BitVAExt.0" file="shared_pseudocode.xml" hover="function: boolean Have52BitVAExt()">Have52BitVAExt</a>() &amp;&amp; tgx == <a link="TGx_64KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a>) || ds == '1' then
        return 12;

    return 16;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walkparams/AArch64.S1TTBR" mylink="aarch64.translation.vmsa_walkparams.AArch64.S1TTBR" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S1TTBR()
// ================
// Identify stage 1 table base register for the acting translation regime

bits(64) <anchor link="AArch64.S1TTBR.2" hover="function: bits(64) AArch64.S1TTBR(Regime regime, bits(64) va)">AArch64.S1TTBR</anchor>(<a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(64) va)
    varange = <a link="AArch64.GetVARange.1" file="shared_pseudocode.xml" hover="function: VARange AArch64.GetVARange(bits(64) va)">AArch64.GetVARange</a>(va);

    case regime of
        when <a link="Regime_EL3" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>  return TTBR0_EL3;
        when <a link="Regime_EL2" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  return TTBR0_EL2;
        when <a link="Regime_EL20" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> return if varange == <a link="VARange_LOWER" file="shared_pseudocode.xml" hover="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then TTBR0_EL2 else TTBR1_EL2;
        when <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> return if varange == <a link="VARange_LOWER" file="shared_pseudocode.xml" hover="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then TTBR0_EL1 else TTBR1_EL1;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walkparams/AArch64.S1TTWParamsEL10" mylink="aarch64.translation.vmsa_walkparams.AArch64.S1TTWParamsEL10" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S1TTWParamsEL10()
// =========================
// Gather stage 1 translation table walk parameters for EL1&amp;0 regime
// (with EL2 enabled or disabled)

S1TTWParams <anchor link="AArch64.S1TTWParamsEL10.1" hover="function: S1TTWParams AArch64.S1TTWParamsEL10(VARange varange)">AArch64.S1TTWParamsEL10</anchor>(<a link="VARange" file="shared_pseudocode.xml" hover="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange</a> varange)
    <a link="S1TTWParams" file="shared_pseudocode.xml" hover="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams;

    if varange == <a link="VARange_LOWER" file="shared_pseudocode.xml" hover="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
        walkparams.tgx  = <a link="AArch64.DecodeTG0.1" file="shared_pseudocode.xml" hover="function: TGx AArch64.DecodeTG0(bits(2) tg0_in)">AArch64.DecodeTG0</a>(TCR_EL1.TG0);
        walkparams.txsz = TCR_EL1.T0SZ;
        walkparams.irgn = TCR_EL1.IRGN0;
        walkparams.orgn = TCR_EL1.ORGN0;
        walkparams.sh   = TCR_EL1.SH0;
        walkparams.tbi  = TCR_EL1.TBI0;

        walkparams.tbid = if <a link="impl-aarch64.HavePACExt.0" file="shared_pseudocode.xml" hover="function: boolean HavePACExt()">HavePACExt</a>()           then TCR_EL1.TBID0 else '0';
        walkparams.e0pd = if <a link="impl-shared.HaveE0PDExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveE0PDExt()">HaveE0PDExt</a>()          then TCR_EL1.E0PD0 else '0';
        walkparams.hpd  = if <a link="AArch64.HaveHPDExt.0" file="shared_pseudocode.xml" hover="function: boolean AArch64.HaveHPDExt()">AArch64.HaveHPDExt</a>()   then TCR_EL1.HPD0  else '0';
    else
        walkparams.tgx  = <a link="AArch64.DecodeTG1.1" file="shared_pseudocode.xml" hover="function: TGx AArch64.DecodeTG1(bits(2) tg1_in)">AArch64.DecodeTG1</a>(TCR_EL1.TG1);
        walkparams.txsz = TCR_EL1.T1SZ;
        walkparams.irgn = TCR_EL1.IRGN1;
        walkparams.orgn = TCR_EL1.ORGN1;
        walkparams.sh   = TCR_EL1.SH1;
        walkparams.tbi  = TCR_EL1.TBI1;

        walkparams.tbid = if <a link="impl-aarch64.HavePACExt.0" file="shared_pseudocode.xml" hover="function: boolean HavePACExt()">HavePACExt</a>()           then TCR_EL1.TBID1 else '0';
        walkparams.e0pd = if <a link="impl-shared.HaveE0PDExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveE0PDExt()">HaveE0PDExt</a>()          then TCR_EL1.E0PD1 else '0';
        walkparams.hpd  = if <a link="AArch64.HaveHPDExt.0" file="shared_pseudocode.xml" hover="function: boolean AArch64.HaveHPDExt()">AArch64.HaveHPDExt</a>()   then TCR_EL1.HPD1  else '0';

    walkparams.mair = MAIR_EL1;
    walkparams.wxn  = SCTLR_EL1.WXN;
    walkparams.ps   = TCR_EL1.IPS;
    walkparams.ee   = SCTLR_EL1.EE;
    walkparams.sif  = SCR_EL3.SIF;

    if <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() then
        walkparams.dc  = HCR_EL2.DC;
        walkparams.dct = if <a link="impl-shared.HaveMTE2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() then HCR_EL2.DCT else '0';

    if <a link="impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveTrapLoadStoreMultipleDeviceExt()">HaveTrapLoadStoreMultipleDeviceExt</a>() then
        walkparams.ntlsmd = SCTLR_EL1.nTLSMD;
    else
        walkparams.ntlsmd = '1';

    if <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if HCR_EL2.&lt;NV,NV1&gt; == '01' then
            case <a link="impl-shared.ConstrainUnpredictable.1" file="shared_pseudocode.xml" hover="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a link="Unpredictable_NVNV1" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_NVNV1</a>) of
                when <a link="Constraint_NVNV1_00" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NVNV1_00</a> walkparams.nv1 = '0';
                when <a link="Constraint_NVNV1_01" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NVNV1_01</a> walkparams.nv1 = '1';
                when <a link="Constraint_NVNV1_11" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NVNV1_11</a> walkparams.nv1 = '1';
        else
            walkparams.nv1 = HCR_EL2.NV1;
    else
        walkparams.nv1 = '0';

    walkparams.epan = if <a link="impl-shared.HavePAN3Ext.0" file="shared_pseudocode.xml" hover="function: boolean HavePAN3Ext()">HavePAN3Ext</a>()             then SCTLR_EL1.EPAN else '0';
    walkparams.cmow = if <a link="impl-shared.HaveFeatCMOW.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatCMOW()">HaveFeatCMOW</a>()            then SCTLR_EL1.CMOW else '0';
    walkparams.ha   = if <a link="impl-shared.HaveAccessFlagUpdateExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveAccessFlagUpdateExt()">HaveAccessFlagUpdateExt</a>() then TCR_EL1.HA else '0';
    walkparams.hd   = if <a link="impl-shared.HaveDirtyBitModifierExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveDirtyBitModifierExt()">HaveDirtyBitModifierExt</a>() then TCR_EL1.HD else '0';
    if walkparams.tgx IN {<a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>, <a link="TGx_16KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>} &amp;&amp; <a link="impl-shared.Have52BitIPAAndPASpaceExt.0" file="shared_pseudocode.xml" hover="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
        walkparams.ds = TCR_EL1.DS;
    else
        walkparams.ds = '0';

    return walkparams;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walkparams/AArch64.S1TTWParamsEL2" mylink="aarch64.translation.vmsa_walkparams.AArch64.S1TTWParamsEL2" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S1TTWParamsEL2()
// ========================
// Gather stage 1 translation table walk parameters for EL2 regime

S1TTWParams <anchor link="AArch64.S1TTWParamsEL2.0" hover="function: S1TTWParams AArch64.S1TTWParamsEL2()">AArch64.S1TTWParamsEL2</anchor>()
    <a link="S1TTWParams" file="shared_pseudocode.xml" hover="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams;

    walkparams.tgx  = <a link="AArch64.DecodeTG0.1" file="shared_pseudocode.xml" hover="function: TGx AArch64.DecodeTG0(bits(2) tg0_in)">AArch64.DecodeTG0</a>(TCR_EL2.TG0);
    walkparams.txsz = TCR_EL2.T0SZ;
    walkparams.ps   = TCR_EL2.PS;
    walkparams.irgn = TCR_EL2.IRGN0;
    walkparams.orgn = TCR_EL2.ORGN0;
    walkparams.sh   = TCR_EL2.SH0;
    walkparams.tbi  = TCR_EL2.TBI;
    walkparams.mair = MAIR_EL2;
    walkparams.wxn  = SCTLR_EL2.WXN;
    walkparams.ee   = SCTLR_EL2.EE;
    walkparams.sif  = SCR_EL3.SIF;

    walkparams.tbid = if <a link="impl-aarch64.HavePACExt.0" file="shared_pseudocode.xml" hover="function: boolean HavePACExt()">HavePACExt</a>()              then TCR_EL2.TBID else '0';
    walkparams.hpd  = if <a link="AArch64.HaveHPDExt.0" file="shared_pseudocode.xml" hover="function: boolean AArch64.HaveHPDExt()">AArch64.HaveHPDExt</a>()      then TCR_EL2.HPD  else '0';
    walkparams.ha   = if <a link="impl-shared.HaveAccessFlagUpdateExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveAccessFlagUpdateExt()">HaveAccessFlagUpdateExt</a>() then TCR_EL2.HA   else '0';
    walkparams.hd   = if <a link="impl-shared.HaveDirtyBitModifierExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveDirtyBitModifierExt()">HaveDirtyBitModifierExt</a>() then TCR_EL2.HD   else '0';
    if walkparams.tgx IN {<a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>, <a link="TGx_16KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>} &amp;&amp; <a link="impl-shared.Have52BitIPAAndPASpaceExt.0" file="shared_pseudocode.xml" hover="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
        walkparams.ds = TCR_EL2.DS;
    else
        walkparams.ds = '0';

    return walkparams;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walkparams/AArch64.S1TTWParamsEL20" mylink="aarch64.translation.vmsa_walkparams.AArch64.S1TTWParamsEL20" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S1TTWParamsEL20()
// =========================
// Gather stage 1 translation table walk parameters for EL2&amp;0 regime

S1TTWParams <anchor link="AArch64.S1TTWParamsEL20.1" hover="function: S1TTWParams AArch64.S1TTWParamsEL20(VARange varange)">AArch64.S1TTWParamsEL20</anchor>(<a link="VARange" file="shared_pseudocode.xml" hover="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange</a> varange)
    <a link="S1TTWParams" file="shared_pseudocode.xml" hover="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams;

    if varange == <a link="VARange_LOWER" file="shared_pseudocode.xml" hover="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
        walkparams.tgx  = <a link="AArch64.DecodeTG0.1" file="shared_pseudocode.xml" hover="function: TGx AArch64.DecodeTG0(bits(2) tg0_in)">AArch64.DecodeTG0</a>(TCR_EL2.TG0);
        walkparams.txsz = TCR_EL2.T0SZ;
        walkparams.irgn = TCR_EL2.IRGN0;
        walkparams.orgn = TCR_EL2.ORGN0;
        walkparams.sh   = TCR_EL2.SH0;
        walkparams.tbi  = TCR_EL2.TBI0;

        walkparams.tbid = if <a link="impl-aarch64.HavePACExt.0" file="shared_pseudocode.xml" hover="function: boolean HavePACExt()">HavePACExt</a>()           then TCR_EL2.TBID0 else '0';
        walkparams.e0pd = if <a link="impl-shared.HaveE0PDExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveE0PDExt()">HaveE0PDExt</a>()          then TCR_EL2.E0PD0 else '0';
        walkparams.hpd  = if <a link="AArch64.HaveHPDExt.0" file="shared_pseudocode.xml" hover="function: boolean AArch64.HaveHPDExt()">AArch64.HaveHPDExt</a>()   then TCR_EL2.HPD0  else '0';
    else
        walkparams.tgx  = <a link="AArch64.DecodeTG1.1" file="shared_pseudocode.xml" hover="function: TGx AArch64.DecodeTG1(bits(2) tg1_in)">AArch64.DecodeTG1</a>(TCR_EL2.TG1);
        walkparams.txsz = TCR_EL2.T1SZ;
        walkparams.irgn = TCR_EL2.IRGN1;
        walkparams.orgn = TCR_EL2.ORGN1;
        walkparams.sh   = TCR_EL2.SH1;
        walkparams.tbi  = TCR_EL2.TBI1;

        walkparams.tbid = if <a link="impl-aarch64.HavePACExt.0" file="shared_pseudocode.xml" hover="function: boolean HavePACExt()">HavePACExt</a>()           then TCR_EL2.TBID1 else '0';
        walkparams.e0pd = if <a link="impl-shared.HaveE0PDExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveE0PDExt()">HaveE0PDExt</a>()          then TCR_EL2.E0PD1 else '0';
        walkparams.hpd  = if <a link="AArch64.HaveHPDExt.0" file="shared_pseudocode.xml" hover="function: boolean AArch64.HaveHPDExt()">AArch64.HaveHPDExt</a>()   then TCR_EL2.HPD1  else '0';

    walkparams.mair = MAIR_EL2;
    walkparams.wxn  = SCTLR_EL2.WXN;
    walkparams.ps   = TCR_EL2.IPS;
    walkparams.ee   = SCTLR_EL2.EE;
    walkparams.sif  = SCR_EL3.SIF;

    if <a link="impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveTrapLoadStoreMultipleDeviceExt()">HaveTrapLoadStoreMultipleDeviceExt</a>() then
        walkparams.ntlsmd = SCTLR_EL2.nTLSMD;
    else
        walkparams.ntlsmd = '1';

    walkparams.epan = if <a link="impl-shared.HavePAN3Ext.0" file="shared_pseudocode.xml" hover="function: boolean HavePAN3Ext()">HavePAN3Ext</a>()             then SCTLR_EL2.EPAN else '0';
    walkparams.cmow = if <a link="impl-shared.HaveFeatCMOW.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatCMOW()">HaveFeatCMOW</a>()            then SCTLR_EL2.CMOW else '0';
    walkparams.ha   = if <a link="impl-shared.HaveAccessFlagUpdateExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveAccessFlagUpdateExt()">HaveAccessFlagUpdateExt</a>() then TCR_EL2.HA else '0';
    walkparams.hd   = if <a link="impl-shared.HaveDirtyBitModifierExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveDirtyBitModifierExt()">HaveDirtyBitModifierExt</a>() then TCR_EL2.HD else '0';
    if walkparams.tgx IN {<a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>, <a link="TGx_16KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>} &amp;&amp; <a link="impl-shared.Have52BitIPAAndPASpaceExt.0" file="shared_pseudocode.xml" hover="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
        walkparams.ds = TCR_EL2.DS;
    else
        walkparams.ds = '0';

    return walkparams;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walkparams/AArch64.S1TTWParamsEL3" mylink="aarch64.translation.vmsa_walkparams.AArch64.S1TTWParamsEL3" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S1TTWParamsEL3()
// ========================
// Gather stage 1 translation table walk parameters for EL3 regime

S1TTWParams <anchor link="AArch64.S1TTWParamsEL3.0" hover="function: S1TTWParams AArch64.S1TTWParamsEL3()">AArch64.S1TTWParamsEL3</anchor>()
    <a link="S1TTWParams" file="shared_pseudocode.xml" hover="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams;

    walkparams.tgx  = <a link="AArch64.DecodeTG0.1" file="shared_pseudocode.xml" hover="function: TGx AArch64.DecodeTG0(bits(2) tg0_in)">AArch64.DecodeTG0</a>(TCR_EL3.TG0);
    walkparams.txsz = TCR_EL3.T0SZ;
    walkparams.ps   = TCR_EL3.PS;
    walkparams.irgn = TCR_EL3.IRGN0;
    walkparams.orgn = TCR_EL3.ORGN0;
    walkparams.sh   = TCR_EL3.SH0;
    walkparams.tbi  = TCR_EL3.TBI;
    walkparams.mair = MAIR_EL3;
    walkparams.wxn  = SCTLR_EL3.WXN;
    walkparams.ee   = SCTLR_EL3.EE;
    walkparams.sif  = SCR_EL3.SIF;

    walkparams.tbid = if <a link="impl-aarch64.HavePACExt.0" file="shared_pseudocode.xml" hover="function: boolean HavePACExt()">HavePACExt</a>()              then TCR_EL3.TBID else '0';
    walkparams.hpd  = if <a link="AArch64.HaveHPDExt.0" file="shared_pseudocode.xml" hover="function: boolean AArch64.HaveHPDExt()">AArch64.HaveHPDExt</a>()      then TCR_EL3.HPD  else '0';
    walkparams.ha   = if <a link="impl-shared.HaveAccessFlagUpdateExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveAccessFlagUpdateExt()">HaveAccessFlagUpdateExt</a>() then TCR_EL3.HA   else '0';
    walkparams.hd   = if <a link="impl-shared.HaveDirtyBitModifierExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveDirtyBitModifierExt()">HaveDirtyBitModifierExt</a>() then TCR_EL3.HD   else '0';
    if walkparams.tgx IN {<a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>, <a link="TGx_16KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>} &amp;&amp; <a link="impl-shared.Have52BitIPAAndPASpaceExt.0" file="shared_pseudocode.xml" hover="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
        walkparams.ds = TCR_EL3.DS;
    else
        walkparams.ds = '0';

    return walkparams;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walkparams/AArch64.S2MinTxSZ" mylink="aarch64.translation.vmsa_walkparams.AArch64.S2MinTxSZ" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.S2MinTxSZ()
// ===================
// Retrieve the minimum value of TxSZ indicating maximum input address size for stage 2

integer <anchor link="AArch64.S2MinTxSZ.3" hover="function: integer AArch64.S2MinTxSZ(bit ds, TGx tgx, boolean s1aarch64)">AArch64.S2MinTxSZ</anchor>(bit ds, <a link="TGx" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, boolean s1aarch64)
    ips = <a link="AArch64.PAMax.0" file="shared_pseudocode.xml" hover="function: integer AArch64.PAMax()">AArch64.PAMax</a>();

    if <a link="impl-shared.Have52BitPAExt.0" file="shared_pseudocode.xml" hover="function: boolean Have52BitPAExt()">Have52BitPAExt</a>() &amp;&amp; tgx != <a link="TGx_64KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> &amp;&amp; ds == '0' then
        ips = <a link="impl-shared.Min.2" file="shared_pseudocode.xml" hover="function: integer Min(integer a, integer b)">Min</a>(48, <a link="AArch64.PAMax.0" file="shared_pseudocode.xml" hover="function: integer AArch64.PAMax()">AArch64.PAMax</a>());

    min_txsz = 64 - ips;
    if !s1aarch64 then
        // EL1 is AArch32
        min_txsz = <a link="impl-shared.Min.2" file="shared_pseudocode.xml" hover="function: integer Min(integer a, integer b)">Min</a>(min_txsz, 24);

    return min_txsz;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walkparams/AArch64.SS2TTWParams" mylink="aarch64.translation.vmsa_walkparams.AArch64.SS2TTWParams" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.SS2TTWParams()
// ======================
// Gather walk parameters specific for secure stage 2 translation

S2TTWParams <anchor link="AArch64.SS2TTWParams.2" hover="function: S2TTWParams AArch64.SS2TTWParams(PASpace ipaspace, boolean s1aarch64)">AArch64.SS2TTWParams</anchor>(<a link="PASpace" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PASpace</a> ipaspace, boolean s1aarch64)
    <a link="S2TTWParams" file="shared_pseudocode.xml" hover="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams;

    if ipaspace == <a link="PAS_Secure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_Secure</a> then
        walkparams.tgx  = <a link="AArch64.DecodeTG0.1" file="shared_pseudocode.xml" hover="function: TGx AArch64.DecodeTG0(bits(2) tg0_in)">AArch64.DecodeTG0</a>(VSTCR_EL2.TG0);
        walkparams.txsz = VSTCR_EL2.T0SZ;
        walkparams.sl0  = VSTCR_EL2.SL0;
        if walkparams.tgx == <a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a> &amp;&amp; <a link="impl-shared.Have52BitIPAAndPASpaceExt.0" file="shared_pseudocode.xml" hover="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
            walkparams.sl2 = VSTCR_EL2.SL2 AND VTCR_EL2.DS;
        else
            walkparams.sl2 = '0';
    elsif ipaspace == <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a> then
        walkparams.tgx  = <a link="AArch64.DecodeTG0.1" file="shared_pseudocode.xml" hover="function: TGx AArch64.DecodeTG0(bits(2) tg0_in)">AArch64.DecodeTG0</a>(VTCR_EL2.TG0);
        walkparams.txsz = VTCR_EL2.T0SZ;
        walkparams.sl0  = VTCR_EL2.SL0;
        if walkparams.tgx == <a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a> &amp;&amp; <a link="impl-shared.Have52BitIPAAndPASpaceExt.0" file="shared_pseudocode.xml" hover="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
            walkparams.sl2 = VTCR_EL2.SL2 AND VTCR_EL2.DS;
        else
            walkparams.sl2 = '0';
    else
        <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();

    walkparams.sw   = VSTCR_EL2.SW;
    walkparams.nsw  = VTCR_EL2.NSW;
    walkparams.sa   = VSTCR_EL2.SA;
    walkparams.nsa  = VTCR_EL2.NSA;
    walkparams.vm   = HCR_EL2.VM OR HCR_EL2.DC;
    walkparams.ps   = VTCR_EL2.PS;
    walkparams.irgn = VTCR_EL2.IRGN0;
    walkparams.orgn = VTCR_EL2.ORGN0;
    walkparams.sh   = VTCR_EL2.SH0;
    walkparams.ee   = SCTLR_EL2.EE;

    walkparams.ptw = if HCR_EL2.TGE == '0'         then HCR_EL2.PTW else '0';
    walkparams.fwb = if <a link="impl-shared.HaveStage2MemAttrControl.0" file="shared_pseudocode.xml" hover="function: boolean HaveStage2MemAttrControl()">HaveStage2MemAttrControl</a>() then HCR_EL2.FWB else '0';
    walkparams.ha  = if <a link="impl-shared.HaveAccessFlagUpdateExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveAccessFlagUpdateExt()">HaveAccessFlagUpdateExt</a>()  then VTCR_EL2.HA else '0';
    walkparams.hd  = if <a link="impl-shared.HaveDirtyBitModifierExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveDirtyBitModifierExt()">HaveDirtyBitModifierExt</a>()  then VTCR_EL2.HD else '0';
    if walkparams.tgx IN {<a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>, <a link="TGx_16KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>} &amp;&amp; <a link="impl-shared.Have52BitIPAAndPASpaceExt.0" file="shared_pseudocode.xml" hover="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
        walkparams.ds = VTCR_EL2.DS;
    else
        walkparams.ds = '0';
    walkparams.cmow = if <a link="impl-shared.HaveFeatCMOW.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatCMOW()">HaveFeatCMOW</a>() &amp;&amp; <a link="impl-aarch64.IsHCRXEL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean IsHCRXEL2Enabled()">IsHCRXEL2Enabled</a>() then HCRX_EL2.CMOW else '0';

    return walkparams;</pstext>
    </ps>
    <ps name="aarch64/translation/vmsa_walkparams/AArch64.VAMax" mylink="aarch64.translation.vmsa_walkparams.AArch64.VAMax" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.VAMax()
// ===============
// Returns the IMPLEMENTATION DEFINED maximum number of bits capable of representing
// the virtual address for this processor

integer <anchor link="AArch64.VAMax.0" hover="function: integer AArch64.VAMax()">AArch64.VAMax</anchor>()
    return integer IMPLEMENTATION_DEFINED "Maximum Virtual Address Size";</pstext>
    </ps>
    <ps name="shared/debug/ClearStickyErrors/ClearStickyErrors" mylink="shared.debug.ClearStickyErrors.ClearStickyErrors" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ClearStickyErrors()
// ===================

<anchor link="impl-shared.ClearStickyErrors.0" hover="function: ClearStickyErrors()">ClearStickyErrors</anchor>()
    EDSCR.TXU = '0';            // Clear TX underrun flag
    EDSCR.RXO = '0';            // Clear RX overrun flag

    if <a link="impl-shared.Halted.0" file="shared_pseudocode.xml" hover="function: boolean Halted()">Halted</a>() then            // in Debug state
        EDSCR.ITO = '0';        // Clear ITR overrun flag

    // If halted and the ITR is not empty then it is UNPREDICTABLE whether the EDSCR.ERR is cleared.
    // The UNPREDICTABLE behavior also affects the instructions in flight, but this is not described
    // in the pseudocode.
    if <a link="impl-shared.Halted.0" file="shared_pseudocode.xml" hover="function: boolean Halted()">Halted</a>() &amp;&amp; EDSCR.ITE == '0' &amp;&amp; <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_CLEARERRITEZERO" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_CLEARERRITEZERO</a>) then
        return;
    EDSCR.ERR = '0';            // Clear cumulative error flag

    return;</pstext>
    </ps>
    <ps name="shared/debug/DebugTarget/DebugTarget" mylink="shared.debug.DebugTarget.DebugTarget" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// DebugTarget()
// =============
// Returns the debug exception target Exception level

bits(2) <anchor link="impl-shared.DebugTarget.0" hover="function: bits(2) DebugTarget()">DebugTarget</anchor>()
    secure = <a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>();
    return <a link="impl-shared.DebugTargetFrom.1" file="shared_pseudocode.xml" hover="function: bits(2) DebugTargetFrom(boolean secure)">DebugTargetFrom</a>(secure);</pstext>
    </ps>
    <ps name="shared/debug/DebugTarget/DebugTargetFrom" mylink="shared.debug.DebugTarget.DebugTargetFrom" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// DebugTargetFrom()
// =================

bits(2) <anchor link="impl-shared.DebugTargetFrom.1" hover="function: bits(2) DebugTargetFrom(boolean secure)">DebugTargetFrom</anchor>(boolean secure)
    boolean route_to_el2;
    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; (!secure || (<a link="impl-shared.HaveSecureEL2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() &amp;&amp;
            (!<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) ||SCR_EL3.EEL2 == '1'))) then
        if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
            route_to_el2 = (HDCR.TDE == '1' || HCR.TGE == '1');
        else
            route_to_el2 = (MDCR_EL2.TDE == '1' || HCR_EL2.TGE == '1');
    else
        route_to_el2 = FALSE;

    bits(2) target;
    if route_to_el2 then
        target = <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;
    elsif <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a link="impl-shared.HaveAArch64.0" file="shared_pseudocode.xml" hover="function: boolean HaveAArch64()">HaveAArch64</a>() &amp;&amp; secure then
        target = <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>;
    else
        target = <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;

    return target;</pstext>
    </ps>
    <ps name="shared/debug/DoubleLockStatus/DoubleLockStatus" mylink="shared.debug.DoubleLockStatus.DoubleLockStatus" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// DoubleLockStatus()
// ==================
// Returns the state of the OS Double Lock.
//    FALSE if OSDLR_EL1.DLK == 0 or DBGPRCR_EL1.CORENPDRQ == 1 or the PE is in Debug state.
//    TRUE if OSDLR_EL1.DLK == 1 and DBGPRCR_EL1.CORENPDRQ == 0 and the PE is in Non-debug state.

boolean <anchor link="impl-shared.DoubleLockStatus.0" hover="function: boolean DoubleLockStatus()">DoubleLockStatus</anchor>()
    if !<a link="impl-shared.HaveDoubleLock.0" file="shared_pseudocode.xml" hover="function: boolean HaveDoubleLock()">HaveDoubleLock</a>() then
        return FALSE;
    elsif <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then
        return DBGOSDLR.DLK == '1' &amp;&amp; DBGPRCR.CORENPDRQ == '0' &amp;&amp; !<a link="impl-shared.Halted.0" file="shared_pseudocode.xml" hover="function: boolean Halted()">Halted</a>();
    else
        return OSDLR_EL1.DLK == '1' &amp;&amp; DBGPRCR_EL1.CORENPDRQ == '0' &amp;&amp; !<a link="impl-shared.Halted.0" file="shared_pseudocode.xml" hover="function: boolean Halted()">Halted</a>();</pstext>
    </ps>
    <ps name="shared/debug/OSLockStatus/OSLockStatus" mylink="shared.debug.OSLockStatus.OSLockStatus" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// OSLockStatus()
// ==============
// Returns the state of the OS Lock.

boolean <anchor link="impl-shared.OSLockStatus.0" hover="function: boolean OSLockStatus()">OSLockStatus</anchor>()
    return (if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then DBGOSLSR.OSLK else OSLSR_EL1.OSLK) == '1';</pstext>
    </ps>
    <ps name="shared/debug/SoftwareLockStatus/Component" mylink="shared.debug.SoftwareLockStatus.Component" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="Component" hover="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component</anchor> {
        <anchor link="Component_PMU" hover="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component_PMU</anchor>,
        <anchor link="Component_Debug" hover="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component_Debug</anchor>,
        <anchor link="Component_CTI" hover="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component_CTI</anchor>
};</pstext>
    </ps>
    <ps name="shared/debug/SoftwareLockStatus/GetAccessComponent" mylink="shared.debug.SoftwareLockStatus.GetAccessComponent" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns the accessed component.
Component <anchor link="impl-shared.GetAccessComponent.0" hover="function: Component GetAccessComponent()">GetAccessComponent</anchor>();</pstext>
    </ps>
    <ps name="shared/debug/SoftwareLockStatus/SoftwareLockStatus" mylink="shared.debug.SoftwareLockStatus.SoftwareLockStatus" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SoftwareLockStatus()
// ====================
// Returns the state of the Software Lock.

boolean <anchor link="impl-shared.SoftwareLockStatus.0" hover="function: boolean SoftwareLockStatus()">SoftwareLockStatus</anchor>()
    <a link="Component" file="shared_pseudocode.xml" hover="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component</a> component = <a link="impl-shared.GetAccessComponent.0" file="shared_pseudocode.xml" hover="function: Component GetAccessComponent()">GetAccessComponent</a>();
    if !<a link="impl-shared.HaveSoftwareLock.1" file="shared_pseudocode.xml" hover="function: boolean HaveSoftwareLock(Component component)">HaveSoftwareLock</a>(component) then
        return FALSE;
    case component of
        when <a link="Component_Debug" file="shared_pseudocode.xml" hover="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component_Debug</a>
            return EDLSR.SLK == '1';
        when <a link="Component_PMU" file="shared_pseudocode.xml" hover="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component_PMU</a>
            return PMLSR.SLK == '1';
        when <a link="Component_CTI" file="shared_pseudocode.xml" hover="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component_CTI</a>
            return CTILSR.SLK == '1';
        otherwise
            <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();</pstext>
    </ps>
    <ps name="shared/debug/authentication/AccessState" mylink="shared.debug.authentication.AccessState" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns the Security state of the access.
SecurityState <anchor link="impl-shared.AccessState.0" hover="function: SecurityState AccessState()">AccessState</anchor>();</pstext>
    </ps>
    <ps name="shared/debug/authentication/AllowExternalDebugAccess" mylink="shared.debug.authentication.AllowExternalDebugAccess" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AllowExternalDebugAccess()
// ==========================
// Returns TRUE if an external debug interface access to the External debug registers
// is allowed, FALSE otherwise.

boolean <anchor link="impl-shared.AllowExternalDebugAccess.0" hover="function: boolean AllowExternalDebugAccess()">AllowExternalDebugAccess</anchor>()
    // The access may also be subject to OS Lock, power-down, etc.
    return <a link="impl-shared.AllowExternalDebugAccess.1" file="shared_pseudocode.xml" hover="function: boolean AllowExternalDebugAccess(SecurityState access_state)">AllowExternalDebugAccess</a>(<a link="impl-shared.AccessState.0" file="shared_pseudocode.xml" hover="function: SecurityState AccessState()">AccessState</a>());

// AllowExternalDebugAccess()
// ==========================
// Returns TRUE if an external debug interface access to the External debug registers
// is allowed for the given Security state, FALSE otherwise.

boolean <anchor link="impl-shared.AllowExternalDebugAccess.1" hover="function: boolean AllowExternalDebugAccess(SecurityState access_state)">AllowExternalDebugAccess</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> access_state)
    // The access may also be subject to OS Lock, power-down, etc.
    if <a link="impl-shared.HaveSecureExtDebugView.0" file="shared_pseudocode.xml" hover="function: boolean HaveSecureExtDebugView()">HaveSecureExtDebugView</a>() then
        if access_state == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> then return TRUE;
    else
        if !<a link="impl-shared.ExternalInvasiveDebugEnabled.0" file="shared_pseudocode.xml" hover="function: boolean ExternalInvasiveDebugEnabled()">ExternalInvasiveDebugEnabled</a>() then return FALSE;
        if <a link="impl-shared.ExternalSecureInvasiveDebugEnabled.0" file="shared_pseudocode.xml" hover="function: boolean ExternalSecureInvasiveDebugEnabled()">ExternalSecureInvasiveDebugEnabled</a>() then return TRUE;

    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
        EDAD_bit = if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then SDCR.EDAD else MDCR_EL3.EDAD;
        return EDAD_bit == '0';
    else
        return <a link="impl-shared.NonSecureOnlyImplementation.0" file="shared_pseudocode.xml" hover="function: boolean NonSecureOnlyImplementation()">NonSecureOnlyImplementation</a>();</pstext>
    </ps>
    <ps name="shared/debug/authentication/AllowExternalPMUAccess" mylink="shared.debug.authentication.AllowExternalPMUAccess" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AllowExternalPMUAccess()
// ========================
// Returns TRUE if an external debug interface access to the PMU registers is
// allowed, FALSE otherwise.

boolean <anchor link="impl-shared.AllowExternalPMUAccess.0" hover="function: boolean AllowExternalPMUAccess()">AllowExternalPMUAccess</anchor>()
    // The access may also be subject to OS Lock, power-down, etc.
    return <a link="impl-shared.AllowExternalPMUAccess.1" file="shared_pseudocode.xml" hover="function: boolean AllowExternalPMUAccess(SecurityState access_state)">AllowExternalPMUAccess</a>(<a link="impl-shared.AccessState.0" file="shared_pseudocode.xml" hover="function: SecurityState AccessState()">AccessState</a>());

// AllowExternalPMUAccess()
// ========================
// Returns TRUE if an external debug interface access to the PMU registers is
// allowed for the given Security state, FALSE otherwise.

boolean <anchor link="impl-shared.AllowExternalPMUAccess.1" hover="function: boolean AllowExternalPMUAccess(SecurityState access_state)">AllowExternalPMUAccess</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> access_state)
    // The access may also be subject to OS Lock, power-down, etc.
    if <a link="impl-shared.HaveSecureExtDebugView.0" file="shared_pseudocode.xml" hover="function: boolean HaveSecureExtDebugView()">HaveSecureExtDebugView</a>() then
        if access_state == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> then return TRUE;
    else
        if !<a link="impl-shared.ExternalInvasiveDebugEnabled.0" file="shared_pseudocode.xml" hover="function: boolean ExternalInvasiveDebugEnabled()">ExternalInvasiveDebugEnabled</a>() then return FALSE;
        if <a link="impl-shared.ExternalSecureInvasiveDebugEnabled.0" file="shared_pseudocode.xml" hover="function: boolean ExternalSecureInvasiveDebugEnabled()">ExternalSecureInvasiveDebugEnabled</a>() then return TRUE;

    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
        EPMAD_bit = if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then SDCR.EPMAD else MDCR_EL3.EPMAD;
        return EPMAD_bit == '0';
    else
        return <a link="impl-shared.NonSecureOnlyImplementation.0" file="shared_pseudocode.xml" hover="function: boolean NonSecureOnlyImplementation()">NonSecureOnlyImplementation</a>();</pstext>
    </ps>
    <ps name="shared/debug/authentication/Debug_authentication" mylink="shared.debug.authentication.Debug_authentication" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">signal DBGEN;
signal NIDEN;
signal SPIDEN;
signal SPNIDEN;</pstext>
    </ps>
    <ps name="shared/debug/authentication/ExternalInvasiveDebugEnabled" mylink="shared.debug.authentication.ExternalInvasiveDebugEnabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ExternalInvasiveDebugEnabled()
// ==============================
// The definition of this function is IMPLEMENTATION DEFINED.
// In the recommended interface, this function returns the state of the DBGEN signal.

boolean <anchor link="impl-shared.ExternalInvasiveDebugEnabled.0" hover="function: boolean ExternalInvasiveDebugEnabled()">ExternalInvasiveDebugEnabled</anchor>()
    return DBGEN == HIGH;</pstext>
    </ps>
    <ps name="shared/debug/authentication/ExternalNoninvasiveDebugAllowed" mylink="shared.debug.authentication.ExternalNoninvasiveDebugAllowed" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ExternalNoninvasiveDebugAllowed()
// =================================
// Returns TRUE if Trace and PC Sample-based Profiling are allowed

boolean <anchor link="impl-shared.ExternalNoninvasiveDebugAllowed.0" hover="function: boolean ExternalNoninvasiveDebugAllowed()">ExternalNoninvasiveDebugAllowed</anchor>()
    if !<a link="impl-shared.ExternalNoninvasiveDebugEnabled.0" file="shared_pseudocode.xml" hover="function: boolean ExternalNoninvasiveDebugEnabled()">ExternalNoninvasiveDebugEnabled</a>() then return FALSE;
    ss = <a link="impl-shared.SecurityStateAtEL.1" file="shared_pseudocode.xml" hover="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(PSTATE.EL);
    if (<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp;
        ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp; SDER.SUNIDEN == '1') then
        return TRUE;
    case ss of
        when <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a> return TRUE;
        when <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>    return <a link="impl-shared.ExternalSecureNoninvasiveDebugEnabled.0" file="shared_pseudocode.xml" hover="function: boolean ExternalSecureNoninvasiveDebugEnabled()">ExternalSecureNoninvasiveDebugEnabled</a>();</pstext>
    </ps>
    <ps name="shared/debug/authentication/ExternalNoninvasiveDebugEnabled" mylink="shared.debug.authentication.ExternalNoninvasiveDebugEnabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ExternalNoninvasiveDebugEnabled()
// =================================
// This function returns TRUE if the FEAT_Debugv8p4 is implemented.
// Otherwise, this function is IMPLEMENTATION DEFINED, and, in the
// recommended interface, ExternalNoninvasiveDebugEnabled returns
// the state of the (DBGEN OR NIDEN) signal.

boolean <anchor link="impl-shared.ExternalNoninvasiveDebugEnabled.0" hover="function: boolean ExternalNoninvasiveDebugEnabled()">ExternalNoninvasiveDebugEnabled</anchor>()
    return !<a link="impl-shared.HaveNoninvasiveDebugAuth.0" file="shared_pseudocode.xml" hover="function: boolean HaveNoninvasiveDebugAuth()">HaveNoninvasiveDebugAuth</a>() || <a link="impl-shared.ExternalInvasiveDebugEnabled.0" file="shared_pseudocode.xml" hover="function: boolean ExternalInvasiveDebugEnabled()">ExternalInvasiveDebugEnabled</a>() || NIDEN == HIGH;</pstext>
    </ps>
    <ps name="shared/debug/authentication/ExternalSecureInvasiveDebugEnabled" mylink="shared.debug.authentication.ExternalSecureInvasiveDebugEnabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ExternalSecureInvasiveDebugEnabled()
// ====================================
// The definition of this function is IMPLEMENTATION DEFINED.
// In the recommended interface, this function returns the state of the (DBGEN AND SPIDEN) signal.
// CoreSight allows asserting SPIDEN without also asserting DBGEN, but this is not recommended.

boolean <anchor link="impl-shared.ExternalSecureInvasiveDebugEnabled.0" hover="function: boolean ExternalSecureInvasiveDebugEnabled()">ExternalSecureInvasiveDebugEnabled</anchor>()
    if !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a link="impl-shared.SecureOnlyImplementation.0" file="shared_pseudocode.xml" hover="function: boolean SecureOnlyImplementation()">SecureOnlyImplementation</a>() then return FALSE;
    return <a link="impl-shared.ExternalInvasiveDebugEnabled.0" file="shared_pseudocode.xml" hover="function: boolean ExternalInvasiveDebugEnabled()">ExternalInvasiveDebugEnabled</a>() &amp;&amp; SPIDEN == HIGH;</pstext>
    </ps>
    <ps name="shared/debug/authentication/ExternalSecureNoninvasiveDebugEnabled" mylink="shared.debug.authentication.ExternalSecureNoninvasiveDebugEnabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ExternalSecureNoninvasiveDebugEnabled()
// =======================================
// This function returns the value of ExternalSecureInvasiveDebugEnabled() when FEAT_Debugv8p4
// is implemented. Otherwise, the definition of this function is IMPLEMENTATION DEFINED.
// In the recommended interface, this function returns the state of the (DBGEN OR NIDEN) AND
// (SPIDEN OR SPNIDEN) signal.

boolean <anchor link="impl-shared.ExternalSecureNoninvasiveDebugEnabled.0" hover="function: boolean ExternalSecureNoninvasiveDebugEnabled()">ExternalSecureNoninvasiveDebugEnabled</anchor>()
    if !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a link="impl-shared.SecureOnlyImplementation.0" file="shared_pseudocode.xml" hover="function: boolean SecureOnlyImplementation()">SecureOnlyImplementation</a>() then return FALSE;
    if <a link="impl-shared.HaveNoninvasiveDebugAuth.0" file="shared_pseudocode.xml" hover="function: boolean HaveNoninvasiveDebugAuth()">HaveNoninvasiveDebugAuth</a>() then
        return <a link="impl-shared.ExternalNoninvasiveDebugEnabled.0" file="shared_pseudocode.xml" hover="function: boolean ExternalNoninvasiveDebugEnabled()">ExternalNoninvasiveDebugEnabled</a>() &amp;&amp; (SPIDEN == HIGH || SPNIDEN == HIGH);
    else
        return <a link="impl-shared.ExternalSecureInvasiveDebugEnabled.0" file="shared_pseudocode.xml" hover="function: boolean ExternalSecureInvasiveDebugEnabled()">ExternalSecureInvasiveDebugEnabled</a>();</pstext>
    </ps>
    <ps name="shared/debug/authentication/IsAccessSecure" mylink="shared.debug.authentication.IsAccessSecure" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns TRUE when an access is Secure
boolean <anchor link="impl-shared.IsAccessSecure.0" hover="function: boolean IsAccessSecure()">IsAccessSecure</anchor>();</pstext>
    </ps>
    <ps name="shared/debug/authentication/IsCorePowered" mylink="shared.debug.authentication.IsCorePowered" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns TRUE if the Core power domain is powered on, FALSE otherwise.
boolean <anchor link="impl-shared.IsCorePowered.0" hover="function: boolean IsCorePowered()">IsCorePowered</anchor>();</pstext>
    </ps>
    <ps name="shared/debug/breakpoint/CheckValidStateMatch" mylink="shared.debug.breakpoint.CheckValidStateMatch" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CheckValidStateMatch()
// ======================
// Checks for an invalid state match that will generate Constrained
// Unpredictable behaviour, otherwise returns Constraint_NONE.

(Constraint, bits(2), bit, bits(2)) <anchor link="impl-shared.CheckValidStateMatch.4" hover="function: (Constraint, bits(2), bit, bits(2)) CheckValidStateMatch(bits(2) SSC_in, bit HMC_in, bits(2) PxC_in,&#13; boolean isbreakpnt)">CheckValidStateMatch</anchor>(bits(2) SSC_in, bit HMC_in, bits(2) PxC_in,
                                                         boolean isbreakpnt)
    boolean reserved = FALSE;
    bits(2) SSC = SSC_in;
    bit HMC = HMC_in;
    bits(2) PxC = PxC_in;

    // Values that are not allocated in any architecture version
    if (HMC:SSC:PxC) IN {'01110','100x0','10110','11x10'} then
        reserved = TRUE;

    // Match 'Usr/Sys/Svc' only valid for AArch32 breakpoints
    if (!isbreakpnt || !<a link="impl-shared.HaveAArch32EL.1" file="shared_pseudocode.xml" hover="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>)) &amp;&amp; HMC:PxC == '000' &amp;&amp; SSC != '11' then
        reserved = TRUE;

    // Both EL3 and EL2 are not implemented
    if !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; (HMC != '0' || SSC != '00') then
        reserved = TRUE;

    // EL3 is not implemented
    if !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SSC IN {'01','10'} &amp;&amp; HMC:SSC:PxC != '10100' then
        reserved = TRUE;

    // EL3 using AArch64 only
    if (!<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) || !<a link="impl-shared.HaveAArch64.0" file="shared_pseudocode.xml" hover="function: boolean HaveAArch64()">HaveAArch64</a>()) &amp;&amp; HMC:SSC:PxC == '11000' then
        reserved = TRUE;

    // EL2 is not implemented
    if !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HMC:SSC:PxC == '11100' then
        reserved = TRUE;

    // Secure EL2 is not implemented
    if !<a link="impl-shared.HaveSecureEL2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() &amp;&amp; (HMC:SSC:PxC)  IN {'01100','10100','x11x1'} then
        reserved = TRUE;

    if reserved then
        // If parameters are set to a reserved type, behaves as either disabled or a defined type
        <a link="Constraint" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint</a> c;
        (c, &lt;HMC,SSC,PxC&gt;) = <a link="impl-shared.ConstrainUnpredictableBits.1" file="shared_pseudocode.xml" hover="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a link="Unpredictable_RESBPWPCTRL" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESBPWPCTRL</a>);
        assert c IN {<a link="Constraint_DISABLED" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>, <a link="Constraint_UNKNOWN" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>};
        if c == <a link="Constraint_DISABLED" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a> then
            return (c, bits(2) UNKNOWN,  bit UNKNOWN, bits(2) UNKNOWN);
        // Otherwise the value returned by ConstrainUnpredictableBits must be a not-reserved value

    return (<a link="Constraint_NONE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>, SSC,  HMC, PxC);</pstext>
    </ps>
    <ps name="shared/debug/breakpoint/NumBreakpointsImplemented" mylink="shared.debug.breakpoint.NumBreakpointsImplemented" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// NumBreakpointsImplemented()
// ===========================
// Returns the number of breakpoints implemented. This is indicated to software by
// DBGDIDR.BRPs in AArch32 state, and ID_AA64DFR0_EL1.BRPs in AArch64 state.

integer <anchor link="impl-shared.NumBreakpointsImplemented.0" hover="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</anchor>()
    return integer IMPLEMENTATION_DEFINED "Number of breakpoints";</pstext>
    </ps>
    <ps name="shared/debug/breakpoint/NumContextAwareBreakpointsImplemented" mylink="shared.debug.breakpoint.NumContextAwareBreakpointsImplemented" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// NumContextAwareBreakpointsImplemented()
// =======================================
// Returns the number of context-aware breakpoints implemented. This is indicated to software by
// DBGDIDR.CTX_CMPs in AArch32 state, and ID_AA64DFR0_EL1.CTX_CMPs in AArch64 state.

integer <anchor link="impl-shared.NumContextAwareBreakpointsImplemented.0" hover="function: integer NumContextAwareBreakpointsImplemented()">NumContextAwareBreakpointsImplemented</anchor>()
    return integer IMPLEMENTATION_DEFINED "Number of context-aware breakpoints";</pstext>
    </ps>
    <ps name="shared/debug/breakpoint/NumWatchpointsImplemented" mylink="shared.debug.breakpoint.NumWatchpointsImplemented" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// NumWatchpointsImplemented()
// ===========================
// Returns the number of watchpoints implemented. This is indicated to software by
// DBGDIDR.WRPs in AArch32 state, and ID_AA64DFR0_EL1.WRPs in AArch64 state.

integer <anchor link="impl-shared.NumWatchpointsImplemented.0" hover="function: integer NumWatchpointsImplemented()">NumWatchpointsImplemented</anchor>()
    return integer IMPLEMENTATION_DEFINED "Number of watchpoints";</pstext>
    </ps>
    <ps name="shared/debug/cti/CTI_SetEventLevel" mylink="shared.debug.cti.CTI_SetEventLevel" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Set a Cross Trigger multi-cycle input event trigger to the specified level.
CTI_SetEventLevel(<a link="CrossTriggerIn" file="shared_pseudocode.xml" hover="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow,&#13; CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3,&#13; CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1,&#13; CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}">CrossTriggerIn</a> id, signal level);</pstext>
    </ps>
    <ps name="shared/debug/cti/CTI_SignalEvent" mylink="shared.debug.cti.CTI_SignalEvent" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Signal a discrete event on a Cross Trigger input event trigger.
<anchor link="impl-shared.CTI_SignalEvent.1" hover="function: CTI_SignalEvent(CrossTriggerIn id)">CTI_SignalEvent</anchor>(<a link="CrossTriggerIn" file="shared_pseudocode.xml" hover="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow,&#13; CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3,&#13; CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1,&#13; CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}">CrossTriggerIn</a> id);</pstext>
    </ps>
    <ps name="shared/debug/cti/CrossTrigger" mylink="shared.debug.cti.CrossTrigger" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="CrossTriggerOut" hover="enumeration CrossTriggerOut {CrossTriggerOut_DebugRequest, CrossTriggerOut_RestartRequest,&#13; CrossTriggerOut_IRQ,          CrossTriggerOut_RSVD3,&#13; CrossTriggerOut_TraceExtIn0,  CrossTriggerOut_TraceExtIn1,&#13; CrossTriggerOut_TraceExtIn2,  CrossTriggerOut_TraceExtIn3}">CrossTriggerOut</anchor> {<anchor link="CrossTriggerOut_DebugRequest" hover="enumeration CrossTriggerOut {CrossTriggerOut_DebugRequest, CrossTriggerOut_RestartRequest,&#13; CrossTriggerOut_IRQ,          CrossTriggerOut_RSVD3,&#13; CrossTriggerOut_TraceExtIn0,  CrossTriggerOut_TraceExtIn1,&#13; CrossTriggerOut_TraceExtIn2,  CrossTriggerOut_TraceExtIn3}">CrossTriggerOut_DebugRequest</anchor>, <anchor link="CrossTriggerOut_RestartRequest" hover="enumeration CrossTriggerOut {CrossTriggerOut_DebugRequest, CrossTriggerOut_RestartRequest,&#13; CrossTriggerOut_IRQ,          CrossTriggerOut_RSVD3,&#13; CrossTriggerOut_TraceExtIn0,  CrossTriggerOut_TraceExtIn1,&#13; CrossTriggerOut_TraceExtIn2,  CrossTriggerOut_TraceExtIn3}">CrossTriggerOut_RestartRequest</anchor>,
                             <anchor link="CrossTriggerOut_IRQ" hover="enumeration CrossTriggerOut {CrossTriggerOut_DebugRequest, CrossTriggerOut_RestartRequest,&#13; CrossTriggerOut_IRQ,          CrossTriggerOut_RSVD3,&#13; CrossTriggerOut_TraceExtIn0,  CrossTriggerOut_TraceExtIn1,&#13; CrossTriggerOut_TraceExtIn2,  CrossTriggerOut_TraceExtIn3}">CrossTriggerOut_IRQ</anchor>,          <anchor link="CrossTriggerOut_RSVD3" hover="enumeration CrossTriggerOut {CrossTriggerOut_DebugRequest, CrossTriggerOut_RestartRequest,&#13; CrossTriggerOut_IRQ,          CrossTriggerOut_RSVD3,&#13; CrossTriggerOut_TraceExtIn0,  CrossTriggerOut_TraceExtIn1,&#13; CrossTriggerOut_TraceExtIn2,  CrossTriggerOut_TraceExtIn3}">CrossTriggerOut_RSVD3</anchor>,
                             <anchor link="CrossTriggerOut_TraceExtIn0" hover="enumeration CrossTriggerOut {CrossTriggerOut_DebugRequest, CrossTriggerOut_RestartRequest,&#13; CrossTriggerOut_IRQ,          CrossTriggerOut_RSVD3,&#13; CrossTriggerOut_TraceExtIn0,  CrossTriggerOut_TraceExtIn1,&#13; CrossTriggerOut_TraceExtIn2,  CrossTriggerOut_TraceExtIn3}">CrossTriggerOut_TraceExtIn0</anchor>,  <anchor link="CrossTriggerOut_TraceExtIn1" hover="enumeration CrossTriggerOut {CrossTriggerOut_DebugRequest, CrossTriggerOut_RestartRequest,&#13; CrossTriggerOut_IRQ,          CrossTriggerOut_RSVD3,&#13; CrossTriggerOut_TraceExtIn0,  CrossTriggerOut_TraceExtIn1,&#13; CrossTriggerOut_TraceExtIn2,  CrossTriggerOut_TraceExtIn3}">CrossTriggerOut_TraceExtIn1</anchor>,
                             <anchor link="CrossTriggerOut_TraceExtIn2" hover="enumeration CrossTriggerOut {CrossTriggerOut_DebugRequest, CrossTriggerOut_RestartRequest,&#13; CrossTriggerOut_IRQ,          CrossTriggerOut_RSVD3,&#13; CrossTriggerOut_TraceExtIn0,  CrossTriggerOut_TraceExtIn1,&#13; CrossTriggerOut_TraceExtIn2,  CrossTriggerOut_TraceExtIn3}">CrossTriggerOut_TraceExtIn2</anchor>,  <anchor link="CrossTriggerOut_TraceExtIn3" hover="enumeration CrossTriggerOut {CrossTriggerOut_DebugRequest, CrossTriggerOut_RestartRequest,&#13; CrossTriggerOut_IRQ,          CrossTriggerOut_RSVD3,&#13; CrossTriggerOut_TraceExtIn0,  CrossTriggerOut_TraceExtIn1,&#13; CrossTriggerOut_TraceExtIn2,  CrossTriggerOut_TraceExtIn3}">CrossTriggerOut_TraceExtIn3</anchor>};

enumeration <anchor link="CrossTriggerIn" hover="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow,&#13; CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3,&#13; CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1,&#13; CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}">CrossTriggerIn</anchor>  {<anchor link="CrossTriggerIn_CrossHalt" hover="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow,&#13; CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3,&#13; CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1,&#13; CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}">CrossTriggerIn_CrossHalt</anchor>,     <anchor link="CrossTriggerIn_PMUOverflow" hover="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow,&#13; CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3,&#13; CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1,&#13; CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}">CrossTriggerIn_PMUOverflow</anchor>,
                             <anchor link="CrossTriggerIn_RSVD2" hover="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow,&#13; CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3,&#13; CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1,&#13; CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}">CrossTriggerIn_RSVD2</anchor>,         <anchor link="CrossTriggerIn_RSVD3" hover="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow,&#13; CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3,&#13; CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1,&#13; CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}">CrossTriggerIn_RSVD3</anchor>,
                             <anchor link="CrossTriggerIn_TraceExtOut0" hover="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow,&#13; CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3,&#13; CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1,&#13; CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}">CrossTriggerIn_TraceExtOut0</anchor>,  <anchor link="CrossTriggerIn_TraceExtOut1" hover="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow,&#13; CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3,&#13; CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1,&#13; CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}">CrossTriggerIn_TraceExtOut1</anchor>,
                             <anchor link="CrossTriggerIn_TraceExtOut2" hover="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow,&#13; CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3,&#13; CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1,&#13; CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}">CrossTriggerIn_TraceExtOut2</anchor>,  <anchor link="CrossTriggerIn_TraceExtOut3" hover="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow,&#13; CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3,&#13; CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1,&#13; CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}">CrossTriggerIn_TraceExtOut3</anchor>};</pstext>
    </ps>
    <ps name="shared/debug/dccanditr/CheckForDCCInterrupts" mylink="shared.debug.dccanditr.CheckForDCCInterrupts" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CheckForDCCInterrupts()
// =======================

<anchor link="impl-shared.CheckForDCCInterrupts.0" hover="function: CheckForDCCInterrupts()">CheckForDCCInterrupts</anchor>()
    commrx = (EDSCR.RXfull == '1');
    commtx = (EDSCR.TXfull == '0');

    // COMMRX and COMMTX support is optional and not recommended for new designs.
    // SetInterruptRequestLevel(InterruptID_COMMRX, if commrx then HIGH else LOW);
    // SetInterruptRequestLevel(InterruptID_COMMTX, if commtx then HIGH else LOW);

    // The value to be driven onto the common COMMIRQ signal.
    boolean commirq;
    if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then
        commirq = ((commrx &amp;&amp; DBGDCCINT.RX == '1') ||
                   (commtx &amp;&amp; DBGDCCINT.TX == '1'));
    else
        commirq = ((commrx &amp;&amp; MDCCINT_EL1.RX == '1') ||
                   (commtx &amp;&amp; MDCCINT_EL1.TX == '1'));
    SetInterruptRequestLevel(<a link="InterruptID_COMMIRQ" file="shared_pseudocode.xml" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_COMMIRQ</a>, if commirq then HIGH else LOW);

    return;</pstext>
    </ps>
    <ps name="shared/debug/dccanditr/DBGDTRRX_EL0" mylink="shared.debug.dccanditr.DBGDTRRX_EL0" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// DBGDTRRX_EL0[] (external write)
// ===============================
// Called on writes to debug register 0x08C.

<anchor link="impl-shared.DBGDTRRX_EL0.write.1" hover="accessor: DBGDTRRX_EL0[boolean memory_mapped] = bits(32) value">DBGDTRRX_EL0</anchor>[boolean memory_mapped] = bits(32) value

    if EDPRSR&lt;6:5,0&gt; != '001' then                      // Check DLK, OSLK and PU bits
        IMPLEMENTATION_DEFINED "generate error response";
        return;

    if EDSCR.ERR == '1' then return;                    // Error flag set: ignore write

    // The Software lock is OPTIONAL.
    if memory_mapped &amp;&amp; EDLSR.SLK == '1' then return;   // Software lock locked: ignore write

    if EDSCR.RXfull == '1' || (<a link="impl-shared.Halted.0" file="shared_pseudocode.xml" hover="function: boolean Halted()">Halted</a>() &amp;&amp; EDSCR.MA == '1' &amp;&amp; EDSCR.ITE == '0') then
        EDSCR.RXO = '1';  EDSCR.ERR = '1';              // Overrun condition: ignore write
        return;

    EDSCR.RXfull = '1';
    DTRRX = value;

    if <a link="impl-shared.Halted.0" file="shared_pseudocode.xml" hover="function: boolean Halted()">Halted</a>() &amp;&amp; EDSCR.MA == '1' then
        EDSCR.ITE = '0';                            // See comments in EDITR[] (external write)
        if !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
            <a link="impl-shared.ExecuteA64.1" file="shared_pseudocode.xml" hover="function: ExecuteA64(bits(32) instr)">ExecuteA64</a>(0xD5330501&lt;31:0&gt;);               // A64 "MRS X1,DBGDTRRX_EL0"
            <a link="impl-shared.ExecuteA64.1" file="shared_pseudocode.xml" hover="function: ExecuteA64(bits(32) instr)">ExecuteA64</a>(0xB8004401&lt;31:0&gt;);               // A64 "STR W1,[X0],#4"
            <a link="impl-aarch64.X.write.1" file="shared_pseudocode.xml" hover="accessor: X[integer n] = bits(width) value">X</a>[1] = bits(64) UNKNOWN;
        else
            <a link="impl-shared.ExecuteT32.2" file="shared_pseudocode.xml" hover="function: ExecuteT32(bits(16) hw1, bits(16) hw2)">ExecuteT32</a>(0xEE10&lt;15:0&gt; /*hw1*/, 0x1E15&lt;15:0&gt; /*hw2*/);  // T32 "MRS R1,DBGDTRRXint"
            <a link="impl-shared.ExecuteT32.2" file="shared_pseudocode.xml" hover="function: ExecuteT32(bits(16) hw1, bits(16) hw2)">ExecuteT32</a>(0xF840&lt;15:0&gt; /*hw1*/, 0x1B04&lt;15:0&gt; /*hw2*/);  // T32 "STR R1,[R0],#4"
            <a link="impl-aarch32.R.write.1" file="shared_pseudocode.xml" hover="accessor: R[integer n] = bits(32) value">R</a>[1] = bits(32) UNKNOWN;
        // If the store aborts, the Data Abort exception is taken and EDSCR.ERR is set to 1
        if EDSCR.ERR == '1' then
            EDSCR.RXfull = bit UNKNOWN;
            DBGDTRRX_EL0 = bits(64) UNKNOWN;
        else
            // "MRS X1,DBGDTRRX_EL0" calls DBGDTR_EL0[] (read) which clears RXfull.
            assert EDSCR.RXfull == '0';

        EDSCR.ITE = '1';                                // See comments in EDITR[] (external write)
    return;

// DBGDTRRX_EL0[] (external read)
// ==============================

bits(32) <anchor link="impl-shared.DBGDTRRX_EL0.read.1" hover="accessor: bits(32) DBGDTRRX_EL0[boolean memory_mapped]">DBGDTRRX_EL0</anchor>[boolean memory_mapped]
    return DTRRX;</pstext>
    </ps>
    <ps name="shared/debug/dccanditr/DBGDTRTX_EL0" mylink="shared.debug.dccanditr.DBGDTRTX_EL0" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// DBGDTRTX_EL0[] (external read)
// ==============================
// Called on reads of debug register 0x080.

bits(32) <anchor link="impl-shared.DBGDTRTX_EL0.read.1" hover="accessor: bits(32) DBGDTRTX_EL0[boolean memory_mapped]">DBGDTRTX_EL0</anchor>[boolean memory_mapped]

    if EDPRSR&lt;6:5,0&gt; != '001' then                      // Check DLK, OSLK and PU bits
        IMPLEMENTATION_DEFINED "generate error response";
        return bits(32) UNKNOWN;

    underrun = EDSCR.TXfull == '0' || (<a link="impl-shared.Halted.0" file="shared_pseudocode.xml" hover="function: boolean Halted()">Halted</a>() &amp;&amp; EDSCR.MA == '1' &amp;&amp; EDSCR.ITE == '0');
    value = if underrun then bits(32) UNKNOWN else DTRTX;

    if EDSCR.ERR == '1' then return value;              // Error flag set: no side-effects

    // The Software lock is OPTIONAL.
    if memory_mapped &amp;&amp; EDLSR.SLK == '1' then           // Software lock locked: no side-effects
        return value;

    if underrun then
        EDSCR.TXU = '1';  EDSCR.ERR = '1';              // Underrun condition: block side-effects
        return value;                                   // Return UNKNOWN

    EDSCR.TXfull = '0';
    if <a link="impl-shared.Halted.0" file="shared_pseudocode.xml" hover="function: boolean Halted()">Halted</a>() &amp;&amp; EDSCR.MA == '1' then
        EDSCR.ITE = '0';                                // See comments in EDITR[] (external write)

        if !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
            <a link="impl-shared.ExecuteA64.1" file="shared_pseudocode.xml" hover="function: ExecuteA64(bits(32) instr)">ExecuteA64</a>(0xB8404401&lt;31:0&gt;);               // A64 "LDR W1,[X0],#4"
        else
            <a link="impl-shared.ExecuteT32.2" file="shared_pseudocode.xml" hover="function: ExecuteT32(bits(16) hw1, bits(16) hw2)">ExecuteT32</a>(0xF850&lt;15:0&gt; /*hw1*/, 0x1B04&lt;15:0&gt; /*hw2*/);      // T32 "LDR R1,[R0],#4"
        // If the load aborts, the Data Abort exception is taken and EDSCR.ERR is set to 1
        if EDSCR.ERR == '1' then
            EDSCR.TXfull = bit UNKNOWN;
            DBGDTRTX_EL0 = bits(64) UNKNOWN;
        else
            if !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
                <a link="impl-shared.ExecuteA64.1" file="shared_pseudocode.xml" hover="function: ExecuteA64(bits(32) instr)">ExecuteA64</a>(0xD5130501&lt;31:0&gt;);           // A64 "MSR DBGDTRTX_EL0,X1"
            else
                <a link="impl-shared.ExecuteT32.2" file="shared_pseudocode.xml" hover="function: ExecuteT32(bits(16) hw1, bits(16) hw2)">ExecuteT32</a>(0xEE00&lt;15:0&gt; /*hw1*/, 0x1E15&lt;15:0&gt; /*hw2*/);  // T32 "MSR DBGDTRTXint,R1"
            // "MSR DBGDTRTX_EL0,X1" calls DBGDTR_EL0[] (write) which sets TXfull.
            assert EDSCR.TXfull == '1';
        if !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
            <a link="impl-aarch64.X.write.1" file="shared_pseudocode.xml" hover="accessor: X[integer n] = bits(width) value">X</a>[1] = bits(64) UNKNOWN;
        else
            <a link="impl-aarch32.R.write.1" file="shared_pseudocode.xml" hover="accessor: R[integer n] = bits(32) value">R</a>[1] = bits(32) UNKNOWN;
        EDSCR.ITE = '1';                                // See comments in EDITR[] (external write)

    return value;

// DBGDTRTX_EL0[] (external write)
// ===============================

<anchor link="impl-shared.DBGDTRTX_EL0.write.1" hover="accessor: DBGDTRTX_EL0[boolean memory_mapped] = bits(32) value">DBGDTRTX_EL0</anchor>[boolean memory_mapped] = bits(32) value
    // The Software lock is OPTIONAL.
    if memory_mapped &amp;&amp; EDLSR.SLK == '1' then return;   // Software lock locked: ignore write
    DTRTX = value;
    return;</pstext>
    </ps>
    <ps name="shared/debug/dccanditr/DBGDTR_EL0" mylink="shared.debug.dccanditr.DBGDTR_EL0" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// DBGDTR_EL0[] (write)
// ====================
// System register writes to DBGDTR_EL0, DBGDTRTX_EL0 (AArch64) and DBGDTRTXint (AArch32)

DBGDTR_EL0[] = bits(N) value_in
    bits(N) value = value_in;
    // For MSR DBGDTRTX_EL0,&lt;Rt&gt;  N=32, value=X[t]&lt;31:0&gt;, X[t]&lt;63:32&gt; is ignored
    // For MSR DBGDTR_EL0,&lt;Xt&gt;    N=64, value=X[t]&lt;63:0&gt;
    assert N IN {32,64};
    if EDSCR.TXfull == '1' then
        value = bits(N) UNKNOWN;
    // On a 64-bit write, implement a half-duplex channel
    if N == 64 then DTRRX = value&lt;63:32&gt;;
    DTRTX = value&lt;31:0&gt;;        // 32-bit or 64-bit write
    EDSCR.TXfull = '1';
    return;

// DBGDTR_EL0[] (read)
// ===================
// System register reads of DBGDTR_EL0, DBGDTRRX_EL0 (AArch64) and DBGDTRRXint (AArch32)

bits(N) <anchor link="impl-shared.DBGDTR_EL0.read.0" hover="accessor: bits(N) DBGDTR_EL0[]">DBGDTR_EL0</anchor>[]
    // For MRS &lt;Rt&gt;,DBGDTRTX_EL0  N=32, X[t]=Zeros(32):result
    // For MRS &lt;Xt&gt;,DBGDTR_EL0    N=64, X[t]=result
    assert N IN {32,64};
    bits(N) result;
    if EDSCR.RXfull == '0' then
        result = bits(N) UNKNOWN;
    else
        // On a 64-bit read, implement a half-duplex channel
        // NOTE: the word order is reversed on reads with regards to writes
        if N == 64 then result&lt;63:32&gt; = DTRTX;
        result&lt;31:0&gt; = DTRRX;
    EDSCR.RXfull = '0';
    return result;</pstext>
    </ps>
    <ps name="shared/debug/dccanditr/DTR" mylink="shared.debug.dccanditr.DTR" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">bits(32) DTRRX;
bits(32) DTRTX;</pstext>
    </ps>
    <ps name="shared/debug/dccanditr/EDITR" mylink="shared.debug.dccanditr.EDITR" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// EDITR[] (external write)
// ========================
// Called on writes to debug register 0x084.

<anchor link="impl-shared.EDITR.write.1" hover="accessor: EDITR[boolean memory_mapped] = bits(32) value">EDITR</anchor>[boolean memory_mapped] = bits(32) value
    if EDPRSR&lt;6:5,0&gt; != '001' then                      // Check DLK, OSLK and PU bits
        IMPLEMENTATION_DEFINED "generate error response";
        return;

    if EDSCR.ERR == '1' then return;                    // Error flag set: ignore write

    // The Software lock is OPTIONAL.
    if memory_mapped &amp;&amp; EDLSR.SLK == '1' then return;   // Software lock locked: ignore write

    if !<a link="impl-shared.Halted.0" file="shared_pseudocode.xml" hover="function: boolean Halted()">Halted</a>() then return;                           // Non-debug state: ignore write

    if EDSCR.ITE == '0' || EDSCR.MA == '1' then
        EDSCR.ITO = '1';  EDSCR.ERR = '1';              // Overrun condition: block write
        return;

    // ITE indicates whether the processor is ready to accept another instruction; the processor
    // may support multiple outstanding instructions. Unlike the "InstrCompl" flag in [v7A] there
    // is no indication that the pipeline is empty (all instructions have completed). In this
    // pseudocode, the assumption is that only one instruction can be executed at a time,
    // meaning ITE acts like "InstrCompl".
    EDSCR.ITE = '0';

    if !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
        <a link="impl-shared.ExecuteA64.1" file="shared_pseudocode.xml" hover="function: ExecuteA64(bits(32) instr)">ExecuteA64</a>(value);
    else
        <a link="impl-shared.ExecuteT32.2" file="shared_pseudocode.xml" hover="function: ExecuteT32(bits(16) hw1, bits(16) hw2)">ExecuteT32</a>(value&lt;15:0&gt;/*hw1*/, value&lt;31:16&gt; /*hw2*/);

    EDSCR.ITE = '1';

    return;</pstext>
    </ps>
    <ps name="shared/debug/halting/DCPSInstruction" mylink="shared.debug.halting.DCPSInstruction" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// DCPSInstruction()
// =================
// Operation of the DCPS instruction in Debug state

<anchor link="impl-shared.DCPSInstruction.1" hover="function: DCPSInstruction(bits(2) target_el)">DCPSInstruction</anchor>(bits(2) target_el)

    <a link="impl-shared.SynchronizeContext.0" file="shared_pseudocode.xml" hover="function: SynchronizeContext()">SynchronizeContext</a>();

    bits(2) handle_el;
    case target_el of
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>
            if PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> || (PSTATE.EL == <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>()) then handle_el = PSTATE.EL;
            elsif <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then UNDEFINED;
            else handle_el = <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;

        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>
            if !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then UNDEFINED;
            elsif PSTATE.EL == <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then handle_el = <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>;
            elsif !<a link="impl-shared.IsSecureEL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>() &amp;&amp; <a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>() then UNDEFINED;
            else handle_el = <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>
            if EDSCR.SDD == '1' || !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then UNDEFINED;
            handle_el = <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>;
        otherwise
            <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();

    from_secure = <a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>();
    if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(handle_el) then
        if PSTATE.M == <a link="M32_Monitor" file="shared_pseudocode.xml" hover="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then SCR.NS = '0';
        assert <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>();                  // Cannot move from AArch64 to AArch32
        case handle_el of
            when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>
                <a link="AArch32.WriteMode.1" file="shared_pseudocode.xml" hover="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a link="M32_Svc" file="shared_pseudocode.xml" hover="constant bits(5) M32_Svc = '10011'">M32_Svc</a>);
                if <a link="impl-shared.HavePANExt.0" file="shared_pseudocode.xml" hover="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; SCTLR.SPAN == '0' then
                    PSTATE.PAN = '1';
            when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>  <a link="AArch32.WriteMode.1" file="shared_pseudocode.xml" hover="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a link="M32_Hyp" file="shared_pseudocode.xml" hover="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>);
            when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>
                <a link="AArch32.WriteMode.1" file="shared_pseudocode.xml" hover="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a link="M32_Monitor" file="shared_pseudocode.xml" hover="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>);
                if <a link="impl-shared.HavePANExt.0" file="shared_pseudocode.xml" hover="function: boolean HavePANExt()">HavePANExt</a>() then
                    if !from_secure then
                        PSTATE.PAN = '0';
                    elsif SCTLR.SPAN == '0' then
                        PSTATE.PAN = '1';
        if handle_el == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then
            ELR_hyp = bits(32) UNKNOWN;  HSR = bits(32) UNKNOWN;
        else
            <a link="impl-aarch32.LR.write.none" file="shared_pseudocode.xml" hover="accessor: LR = bits(32) value">LR</a> = bits(32) UNKNOWN;
        <a link="impl-shared.SPSR.write.0" file="shared_pseudocode.xml" hover="accessor: SPSR[] = bits(N) value">SPSR</a>[] = bits(32) UNKNOWN;
        PSTATE.E = <a link="impl-aarch64.SCTLR.read.0" file="shared_pseudocode.xml" hover="accessor: SCTLRType SCTLR[]">SCTLR</a>[].EE;
        DLR = bits(32) UNKNOWN;  DSPSR = bits(32) UNKNOWN;

    else                                        // Targeting AArch64
        if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
            <a link="AArch64.MaybeZeroRegisterUppers.0" file="shared_pseudocode.xml" hover="function: AArch64.MaybeZeroRegisterUppers()">AArch64.MaybeZeroRegisterUppers</a>();
        PSTATE.nRW = '0';  PSTATE.SP = '1';  PSTATE.EL = handle_el;
        if <a link="impl-shared.HavePANExt.0" file="shared_pseudocode.xml" hover="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; ((handle_el == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; SCTLR_EL1.SPAN == '0') ||
                            (handle_el == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; HCR_EL2.E2H == '1' &amp;&amp;
                             HCR_EL2.TGE == '1' &amp;&amp; SCTLR_EL2.SPAN == '0')) then
            PSTATE.PAN = '1';
        <a link="impl-aarch64.ELR.write.0" file="shared_pseudocode.xml" hover="accessor: ELR[] = bits(64) value">ELR</a>[] = bits(64) UNKNOWN;  <a link="impl-shared.SPSR.write.0" file="shared_pseudocode.xml" hover="accessor: SPSR[] = bits(N) value">SPSR</a>[] = bits(64) UNKNOWN;  <a link="impl-aarch64.ESR.write.0" file="shared_pseudocode.xml" hover="accessor: ESR[] = ESRType value">ESR</a>[] = bits(64) UNKNOWN;
        DLR_EL0 = bits(64) UNKNOWN;  DSPSR_EL0 = bits(64) UNKNOWN;
        if <a link="impl-shared.HaveUAOExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveUAOExt()">HaveUAOExt</a>() then PSTATE.UAO = '0';
        if <a link="impl-shared.HaveMTEExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveMTEExt()">HaveMTEExt</a>() then PSTATE.TCO = '1';

    <a link="impl-shared.UpdateEDSCRFields.0" file="shared_pseudocode.xml" hover="function: UpdateEDSCRFields()">UpdateEDSCRFields</a>();                        // Update EDSCR PE state flags
    sync_errors = <a link="impl-shared.HaveIESB.0" file="shared_pseudocode.xml" hover="function: boolean HaveIESB()">HaveIESB</a>() &amp;&amp; <a link="impl-aarch64.SCTLR.read.0" file="shared_pseudocode.xml" hover="accessor: SCTLRType SCTLR[]">SCTLR</a>[].IESB == '1';
    if <a link="impl-shared.HaveDoubleFaultExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
        sync_errors = sync_errors || (SCR_EL3.EA == '1' &amp;&amp; SCR_EL3.NMEA == '1' &amp;&amp; PSTATE.EL == <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>);
    // SCTLR[].IESB might be ignored in Debug state.
    if !<a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_IESBinDebug" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_IESBinDebug</a>) then
        sync_errors = FALSE;
    if sync_errors then
        <a link="impl-shared.SynchronizeErrors.0" file="shared_pseudocode.xml" hover="function: SynchronizeErrors()">SynchronizeErrors</a>();
    return;</pstext>
    </ps>
    <ps name="shared/debug/halting/DRPSInstruction" mylink="shared.debug.halting.DRPSInstruction" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// DRPSInstruction()
// =================
// Operation of the A64 DRPS and T32 ERET instructions in Debug state

<anchor link="impl-shared.DRPSInstruction.0" hover="function: DRPSInstruction()">DRPSInstruction</anchor>()

    <a link="impl-shared.SynchronizeContext.0" file="shared_pseudocode.xml" hover="function: SynchronizeContext()">SynchronizeContext</a>();

    sync_errors = <a link="impl-shared.HaveIESB.0" file="shared_pseudocode.xml" hover="function: boolean HaveIESB()">HaveIESB</a>() &amp;&amp; <a link="impl-aarch64.SCTLR.read.0" file="shared_pseudocode.xml" hover="accessor: SCTLRType SCTLR[]">SCTLR</a>[].IESB == '1';
    if <a link="impl-shared.HaveDoubleFaultExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
        sync_errors = sync_errors || (SCR_EL3.EA == '1' &amp;&amp; SCR_EL3.NMEA == '1' &amp;&amp; PSTATE.EL == <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>);
    // SCTLR[].IESB might be ignored in Debug state.
    if !<a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_IESBinDebug" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_IESBinDebug</a>) then
        sync_errors = FALSE;
    if sync_errors then
        <a link="impl-shared.SynchronizeErrors.0" file="shared_pseudocode.xml" hover="function: SynchronizeErrors()">SynchronizeErrors</a>();

    <a link="impl-shared.DebugRestorePSR.0" file="shared_pseudocode.xml" hover="function: DebugRestorePSR()">DebugRestorePSR</a>();

    return;</pstext>
    </ps>
    <ps name="shared/debug/halting/DebugHalt" mylink="shared.debug.halting.DebugHalt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">constant bits(6) <anchor link="DebugHalt_Breakpoint" hover="constant bits(6) DebugHalt_Breakpoint = '000111'">DebugHalt_Breakpoint</anchor>      = '000111';
constant bits(6) <anchor link="DebugHalt_EDBGRQ" hover="constant bits(6) DebugHalt_EDBGRQ = '010011'">DebugHalt_EDBGRQ</anchor>          = '010011';
constant bits(6) <anchor link="DebugHalt_Step_Normal" hover="constant bits(6) DebugHalt_Step_Normal = '011011'">DebugHalt_Step_Normal</anchor>     = '011011';
constant bits(6) <anchor link="DebugHalt_Step_Exclusive" hover="constant bits(6) DebugHalt_Step_Exclusive = '011111'">DebugHalt_Step_Exclusive</anchor>  = '011111';
constant bits(6) <anchor link="DebugHalt_OSUnlockCatch" hover="constant bits(6) DebugHalt_OSUnlockCatch = '100011'">DebugHalt_OSUnlockCatch</anchor>   = '100011';
constant bits(6) <anchor link="DebugHalt_ResetCatch" hover="constant bits(6) DebugHalt_ResetCatch = '100111'">DebugHalt_ResetCatch</anchor>      = '100111';
constant bits(6) <anchor link="DebugHalt_Watchpoint" hover="constant bits(6) DebugHalt_Watchpoint = '101011'">DebugHalt_Watchpoint</anchor>      = '101011';
constant bits(6) <anchor link="DebugHalt_HaltInstruction" hover="constant bits(6) DebugHalt_HaltInstruction = '101111'">DebugHalt_HaltInstruction</anchor> = '101111';
constant bits(6) <anchor link="DebugHalt_SoftwareAccess" hover="constant bits(6) DebugHalt_SoftwareAccess = '110011'">DebugHalt_SoftwareAccess</anchor>  = '110011';
constant bits(6) <anchor link="DebugHalt_ExceptionCatch" hover="constant bits(6) DebugHalt_ExceptionCatch = '110111'">DebugHalt_ExceptionCatch</anchor>  = '110111';
constant bits(6) <anchor link="DebugHalt_Step_NoSyndrome" hover="constant bits(6) DebugHalt_Step_NoSyndrome = '111011'">DebugHalt_Step_NoSyndrome</anchor> = '111011';</pstext>
    </ps>
    <ps name="shared/debug/halting/DebugRestorePSR" mylink="shared.debug.halting.DebugRestorePSR" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// DebugRestorePSR()
// =================

<anchor link="impl-shared.DebugRestorePSR.0" hover="function: DebugRestorePSR()">DebugRestorePSR</anchor>()
    // PSTATE.{N,Z,C,V,Q,GE,SS,D,A,I,F} are not observable and ignored in Debug state, so
    // behave as if UNKNOWN.
    if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
        bits(32) spsr = <a link="impl-shared.SPSR.read.0" file="shared_pseudocode.xml" hover="accessor: bits(N) SPSR[]">SPSR</a>[];
        <a link="impl-shared.SetPSTATEFromPSR.1" file="shared_pseudocode.xml" hover="function: SetPSTATEFromPSR(bits(N) spsr)">SetPSTATEFromPSR</a>(spsr);
        PSTATE.&lt;N,Z,C,V,Q,GE,SS,A,I,F&gt; = bits(13) UNKNOWN;
        //  In AArch32, all instructions are T32 and unconditional.
        PSTATE.IT = '00000000';  PSTATE.T = '1';        // PSTATE.J is RES0
        DLR = bits(32) UNKNOWN;  DSPSR = bits(32) UNKNOWN;
    else
        bits(64) spsr = <a link="impl-shared.SPSR.read.0" file="shared_pseudocode.xml" hover="accessor: bits(N) SPSR[]">SPSR</a>[];
        <a link="impl-shared.SetPSTATEFromPSR.1" file="shared_pseudocode.xml" hover="function: SetPSTATEFromPSR(bits(N) spsr)">SetPSTATEFromPSR</a>(spsr);
        PSTATE.&lt;N,Z,C,V,SS,D,A,I,F&gt; = bits(9) UNKNOWN;
        DLR_EL0 = bits(64) UNKNOWN;  DSPSR_EL0 = bits(64) UNKNOWN;
    <a link="impl-shared.UpdateEDSCRFields.0" file="shared_pseudocode.xml" hover="function: UpdateEDSCRFields()">UpdateEDSCRFields</a>();                                // Update EDSCR PE state flags</pstext>
    </ps>
    <ps name="shared/debug/halting/DisableITRAndResumeInstructionPrefetch" mylink="shared.debug.halting.DisableITRAndResumeInstructionPrefetch" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions"><anchor link="impl-shared.DisableITRAndResumeInstructionPrefetch.0" hover="function: DisableITRAndResumeInstructionPrefetch()">DisableITRAndResumeInstructionPrefetch</anchor>();</pstext>
    </ps>
    <ps name="shared/debug/halting/ExecuteA64" mylink="shared.debug.halting.ExecuteA64" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Execute an A64 instruction in Debug state.
<anchor link="impl-shared.ExecuteA64.1" hover="function: ExecuteA64(bits(32) instr)">ExecuteA64</anchor>(bits(32) instr);</pstext>
    </ps>
    <ps name="shared/debug/halting/ExecuteT32" mylink="shared.debug.halting.ExecuteT32" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Execute a T32 instruction in Debug state.
<anchor link="impl-shared.ExecuteT32.2" hover="function: ExecuteT32(bits(16) hw1, bits(16) hw2)">ExecuteT32</anchor>(bits(16) hw1, bits(16) hw2);</pstext>
    </ps>
    <ps name="shared/debug/halting/ExitDebugState" mylink="shared.debug.halting.ExitDebugState" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ExitDebugState()
// ================

<anchor link="impl-shared.ExitDebugState.0" hover="function: ExitDebugState()">ExitDebugState</anchor>()
    assert <a link="impl-shared.Halted.0" file="shared_pseudocode.xml" hover="function: boolean Halted()">Halted</a>();
    <a link="impl-shared.SynchronizeContext.0" file="shared_pseudocode.xml" hover="function: SynchronizeContext()">SynchronizeContext</a>();

    // Although EDSCR.STATUS signals that the PE is restarting, debuggers must use EDPRSR.SDR to
    // detect that the PE has restarted.
    EDSCR.STATUS = '000001';                           // Signal restarting
    EDESR&lt;2:0&gt; = '000';                                // Clear any pending Halting debug events

    bits(64) new_pc;
    bits(64) spsr;

    if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
        new_pc = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(DLR);
        spsr = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(DSPSR);
    else
        new_pc = DLR_EL0;
        spsr = DSPSR_EL0;
    // If this is an illegal return, SetPSTATEFromPSR() will set PSTATE.IL.
    if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
        <a link="impl-shared.SetPSTATEFromPSR.1" file="shared_pseudocode.xml" hover="function: SetPSTATEFromPSR(bits(N) spsr)">SetPSTATEFromPSR</a>(spsr&lt;31:0&gt;);                  // Can update privileged bits, even at EL0
    else
        <a link="impl-shared.SetPSTATEFromPSR.1" file="shared_pseudocode.xml" hover="function: SetPSTATEFromPSR(bits(N) spsr)">SetPSTATEFromPSR</a>(spsr);                        // Can update privileged bits, even at EL0

    boolean branch_conditional = FALSE;
    if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
        if <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_RESTARTALIGNPC" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESTARTALIGNPC</a>) then new_pc&lt;0&gt; = '0';
        // AArch32 branch
        <a link="impl-shared.BranchTo.3" file="shared_pseudocode.xml" hover="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(new_pc&lt;31:0&gt;, <a link="BranchType_DBGEXIT" file="shared_pseudocode.xml" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType_DBGEXIT</a>, branch_conditional);
    else
        // If targeting AArch32 then possibly zero the 32 most significant bits of the target PC
        if spsr&lt;4&gt; == '1' &amp;&amp; <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_RESTARTZEROUPPERPC" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESTARTZEROUPPERPC</a>) then
            new_pc&lt;63:32&gt; = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();
        // A type of branch that is never predicted
        <a link="impl-shared.BranchTo.3" file="shared_pseudocode.xml" hover="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(new_pc, <a link="BranchType_DBGEXIT" file="shared_pseudocode.xml" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType_DBGEXIT</a>, branch_conditional);

    (EDSCR.STATUS,EDPRSR.SDR) = ('000010','1');        // Atomically signal restarted
    <a link="impl-shared.UpdateEDSCRFields.0" file="shared_pseudocode.xml" hover="function: UpdateEDSCRFields()">UpdateEDSCRFields</a>();                               // Stop signalling PE state
    <a link="impl-shared.DisableITRAndResumeInstructionPrefetch.0" file="shared_pseudocode.xml" hover="function: DisableITRAndResumeInstructionPrefetch()">DisableITRAndResumeInstructionPrefetch</a>();

    return;</pstext>
    </ps>
    <ps name="shared/debug/halting/Halt" mylink="shared.debug.halting.Halt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Halt()
// ======

<anchor link="impl-shared.Halt.1" hover="function: Halt(bits(6) reason)">Halt</anchor>(bits(6) reason)

    <a link="impl-shared.CTI_SignalEvent.1" file="shared_pseudocode.xml" hover="function: CTI_SignalEvent(CrossTriggerIn id)">CTI_SignalEvent</a>(<a link="CrossTriggerIn_CrossHalt" file="shared_pseudocode.xml" hover="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow,&#13; CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3,&#13; CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1,&#13; CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}">CrossTriggerIn_CrossHalt</a>);  // Trigger other cores to halt

    bits(64) preferred_restart_address = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    bits(32) spsr_32;
    bits(64) spsr_64;
    if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
        spsr_32 = <a link="impl-shared.GetPSRFromPSTATE.1" file="shared_pseudocode.xml" hover="function: bits(N) GetPSRFromPSTATE(ExceptionalOccurrenceTargetState targetELState)">GetPSRFromPSTATE</a>(<a link="DebugState" file="shared_pseudocode.xml" hover="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">DebugState</a>);
    else
        spsr_64 = <a link="impl-shared.GetPSRFromPSTATE.1" file="shared_pseudocode.xml" hover="function: bits(N) GetPSRFromPSTATE(ExceptionalOccurrenceTargetState targetELState)">GetPSRFromPSTATE</a>(<a link="DebugState" file="shared_pseudocode.xml" hover="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">DebugState</a>);

    if (<a link="impl-shared.HaveBTIExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveBTIExt()">HaveBTIExt</a>() &amp;&amp;
        !(reason IN {<a link="DebugHalt_Step_Normal" file="shared_pseudocode.xml" hover="constant bits(6) DebugHalt_Step_Normal = '011011'">DebugHalt_Step_Normal</a>, <a link="DebugHalt_Step_Exclusive" file="shared_pseudocode.xml" hover="constant bits(6) DebugHalt_Step_Exclusive = '011111'">DebugHalt_Step_Exclusive</a>, <a link="DebugHalt_Step_NoSyndrome" file="shared_pseudocode.xml" hover="constant bits(6) DebugHalt_Step_NoSyndrome = '111011'">DebugHalt_Step_NoSyndrome</a>,
                     <a link="DebugHalt_Breakpoint" file="shared_pseudocode.xml" hover="constant bits(6) DebugHalt_Breakpoint = '000111'">DebugHalt_Breakpoint</a>, <a link="DebugHalt_HaltInstruction" file="shared_pseudocode.xml" hover="constant bits(6) DebugHalt_HaltInstruction = '101111'">DebugHalt_HaltInstruction</a>}) &amp;&amp;
        <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_ZEROBTYPE" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_ZEROBTYPE</a>)) then
        if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
            spsr_32&lt;11:10&gt; = '00';
        else
            spsr_64&lt;11:10&gt; = '00';

    if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
        DLR = preferred_restart_address&lt;31:0&gt;;
        DSPSR = spsr_32;
    else
        DLR_EL0 = preferred_restart_address;
        DSPSR_EL0 = spsr_64;

    EDSCR.ITE = '1';
    EDSCR.ITO = '0';
    if <a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>() then
        EDSCR.SDD = '0';                        // If entered in Secure state, allow debug
    elsif <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
        EDSCR.SDD = if <a link="impl-shared.ExternalSecureInvasiveDebugEnabled.0" file="shared_pseudocode.xml" hover="function: boolean ExternalSecureInvasiveDebugEnabled()">ExternalSecureInvasiveDebugEnabled</a>() then '0' else '1';
    else
        assert EDSCR.SDD == '1';                // Otherwise EDSCR.SDD is RES1
    EDSCR.MA = '0';

    // In Debug state:
    // * PSTATE.{SS,SSBS,D,A,I,F} are not observable and ignored so behave-as-if UNKNOWN.
    // * PSTATE.{N,Z,C,V,Q,GE,E,M,nRW,EL,SP,DIT} are also not observable, but since these
    //     are not changed on exception entry, this function also leaves them unchanged.
    // * PSTATE.{IT,T} are ignored.
    // * PSTATE.IL is ignored and behave-as-if 0.
    // * PSTATE.BTYPE is ignored and behave-as-if 0.
    // * PSTATE.TCO is set 1.
    // * PSTATE.{UAO,PAN} are observable and not changed on entry into Debug state.
    if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
        PSTATE.&lt;IT,SS,SSBS,A,I,F,T&gt; = bits(14) UNKNOWN;
    else
        PSTATE.&lt;SS,SSBS,D,A,I,F&gt;    = bits(6)  UNKNOWN;
        PSTATE.TCO = '1';
        PSTATE.BTYPE = '00';
    PSTATE.IL = '0';

    <a link="impl-shared.StopInstructionPrefetchAndEnableITR.0" file="shared_pseudocode.xml" hover="function: StopInstructionPrefetchAndEnableITR()">StopInstructionPrefetchAndEnableITR</a>();
    EDSCR.STATUS = reason;                      // Signal entered Debug state
    <a link="impl-shared.UpdateEDSCRFields.0" file="shared_pseudocode.xml" hover="function: UpdateEDSCRFields()">UpdateEDSCRFields</a>();                        // Update EDSCR PE state flags.

    return;</pstext>
    </ps>
    <ps name="shared/debug/halting/HaltOnBreakpointOrWatchpoint" mylink="shared.debug.halting.HaltOnBreakpointOrWatchpoint" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaltOnBreakpointOrWatchpoint()
// ==============================
// Returns TRUE if the Breakpoint and Watchpoint debug events should be considered for Debug
// state entry, FALSE if they should be considered for a debug exception.

boolean <anchor link="impl-shared.HaltOnBreakpointOrWatchpoint.0" hover="function: boolean HaltOnBreakpointOrWatchpoint()">HaltOnBreakpointOrWatchpoint</anchor>()
    return <a link="impl-shared.HaltingAllowed.0" file="shared_pseudocode.xml" hover="function: boolean HaltingAllowed()">HaltingAllowed</a>() &amp;&amp; EDSCR.HDE == '1' &amp;&amp; OSLSR_EL1.OSLK == '0';</pstext>
    </ps>
    <ps name="shared/debug/halting/Halted" mylink="shared.debug.halting.Halted" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Halted()
// ========

boolean <anchor link="impl-shared.Halted.0" hover="function: boolean Halted()">Halted</anchor>()
    return !(EDSCR.STATUS IN {'000001', '000010'});                     // Halted</pstext>
    </ps>
    <ps name="shared/debug/halting/HaltingAllowed" mylink="shared.debug.halting.HaltingAllowed" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaltingAllowed()
// ================
// Returns TRUE if halting is currently allowed, FALSE if halting is prohibited.

boolean <anchor link="impl-shared.HaltingAllowed.0" hover="function: boolean HaltingAllowed()">HaltingAllowed</anchor>()
    if <a link="impl-shared.Halted.0" file="shared_pseudocode.xml" hover="function: boolean Halted()">Halted</a>() || <a link="impl-shared.DoubleLockStatus.0" file="shared_pseudocode.xml" hover="function: boolean DoubleLockStatus()">DoubleLockStatus</a>() then
        return FALSE;
    ss = <a link="impl-shared.SecurityStateAtEL.1" file="shared_pseudocode.xml" hover="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(PSTATE.EL);
    case ss of
        when <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a> return <a link="impl-shared.ExternalInvasiveDebugEnabled.0" file="shared_pseudocode.xml" hover="function: boolean ExternalInvasiveDebugEnabled()">ExternalInvasiveDebugEnabled</a>();
        when <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>    return <a link="impl-shared.ExternalSecureInvasiveDebugEnabled.0" file="shared_pseudocode.xml" hover="function: boolean ExternalSecureInvasiveDebugEnabled()">ExternalSecureInvasiveDebugEnabled</a>();</pstext>
    </ps>
    <ps name="shared/debug/halting/Restarting" mylink="shared.debug.halting.Restarting" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Restarting()
// ============

boolean <anchor link="impl-shared.Restarting.0" hover="function: boolean Restarting()">Restarting</anchor>()
    return EDSCR.STATUS == '000001';                                    // Restarting</pstext>
    </ps>
    <ps name="shared/debug/halting/StopInstructionPrefetchAndEnableITR" mylink="shared.debug.halting.StopInstructionPrefetchAndEnableITR" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions"><anchor link="impl-shared.StopInstructionPrefetchAndEnableITR.0" hover="function: StopInstructionPrefetchAndEnableITR()">StopInstructionPrefetchAndEnableITR</anchor>();</pstext>
    </ps>
    <ps name="shared/debug/halting/UpdateEDSCRFields" mylink="shared.debug.halting.UpdateEDSCRFields" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// UpdateEDSCRFields()
// ===================
// Update EDSCR PE state fields

<anchor link="impl-shared.UpdateEDSCRFields.0" hover="function: UpdateEDSCRFields()">UpdateEDSCRFields</anchor>()

    if !<a link="impl-shared.Halted.0" file="shared_pseudocode.xml" hover="function: boolean Halted()">Halted</a>() then
        EDSCR.EL = '00';
        EDSCR.NS = bit UNKNOWN;

        EDSCR.RW = '1111';
    else
        EDSCR.EL = PSTATE.EL;
        ss = <a link="impl-shared.SecurityStateAtEL.1" file="shared_pseudocode.xml" hover="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(PSTATE.EL);
        EDSCR.NS = if ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> then '0' else '1';

        bits(4) RW;
        RW&lt;1&gt; = if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then '0' else '1';
        if PSTATE.EL != <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then
            RW&lt;0&gt; = RW&lt;1&gt;;
        else
            RW&lt;0&gt; = if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then '0' else '1';
        if !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) || (<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a link="impl-shared.SCR_GEN.read.0" file="shared_pseudocode.xml" hover="accessor: SCRType SCR_GEN[]">SCR_GEN</a>[].NS == '0' &amp;&amp; !<a link="impl-shared.IsSecureEL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>()) then
            RW&lt;2&gt; = RW&lt;1&gt;;
        else
            RW&lt;2&gt; = if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then '0' else '1';
        if !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
            RW&lt;3&gt; = RW&lt;2&gt;;
        else
            RW&lt;3&gt; = if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then '0' else '1';

        // The least-significant bits of EDSCR.RW are UNKNOWN if any higher EL is using AArch32.
        if RW&lt;3&gt; == '0' then RW&lt;2:0&gt; = bits(3) UNKNOWN;
        elsif RW&lt;2&gt; == '0' then RW&lt;1:0&gt; = bits(2) UNKNOWN;
        elsif RW&lt;1&gt; == '0' then RW&lt;0&gt; = bit UNKNOWN;
        EDSCR.RW = RW;
    return;</pstext>
    </ps>
    <ps name="shared/debug/haltingevents/CheckExceptionCatch" mylink="shared.debug.haltingevents.CheckExceptionCatch" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CheckExceptionCatch()
// =====================
// Check whether an Exception Catch debug event is set on the current Exception level

<anchor link="impl-shared.CheckExceptionCatch.1" hover="function: CheckExceptionCatch(boolean exception_entry)">CheckExceptionCatch</anchor>(boolean exception_entry)
    // Called after an exception entry or exit, that is, such that the Security state
    // and PSTATE.EL are correct for the exception target. When FEAT_Debugv8p2
    // is not implemented, this function might also be called at any time.
    ss = <a link="impl-shared.SecurityStateAtEL.1" file="shared_pseudocode.xml" hover="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(PSTATE.EL);
    base = if ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> then 0 else 4;
    if <a link="impl-shared.HaltingAllowed.0" file="shared_pseudocode.xml" hover="function: boolean HaltingAllowed()">HaltingAllowed</a>() then
        boolean halt;
        if <a link="impl-shared.HaveExtendedECDebugEvents.0" file="shared_pseudocode.xml" hover="function: boolean HaveExtendedECDebugEvents()">HaveExtendedECDebugEvents</a>() then
            exception_exit = !exception_entry;
            increment = 8;
            ctrl = EDECCR&lt;<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) + base + increment&gt;:EDECCR&lt;<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) + base&gt;;
            case ctrl of
                when '00'  halt = FALSE;
                when '01'  halt = TRUE;
                when '10'  halt = (exception_exit == TRUE);
                when '11'  halt = (exception_entry == TRUE);
        else
            halt = (EDECCR&lt;<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) + base&gt; == '1');
        if halt then <a link="impl-shared.Halt.1" file="shared_pseudocode.xml" hover="function: Halt(bits(6) reason)">Halt</a>(<a link="DebugHalt_ExceptionCatch" file="shared_pseudocode.xml" hover="constant bits(6) DebugHalt_ExceptionCatch = '110111'">DebugHalt_ExceptionCatch</a>);</pstext>
    </ps>
    <ps name="shared/debug/haltingevents/CheckHaltingStep" mylink="shared.debug.haltingevents.CheckHaltingStep" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CheckHaltingStep()
// ==================
// Check whether EDESR.SS has been set by Halting Step

<anchor link="impl-shared.CheckHaltingStep.0" hover="function: CheckHaltingStep()">CheckHaltingStep</anchor>()
    if <a link="impl-shared.HaltingAllowed.0" file="shared_pseudocode.xml" hover="function: boolean HaltingAllowed()">HaltingAllowed</a>() &amp;&amp; EDESR.SS == '1' then
        // The STATUS code depends on how we arrived at the state where EDESR.SS == 1.
        if <a link="impl-shared.HaltingStep_DidNotStep.0" file="shared_pseudocode.xml" hover="function: boolean HaltingStep_DidNotStep()">HaltingStep_DidNotStep</a>() then
            <a link="impl-shared.Halt.1" file="shared_pseudocode.xml" hover="function: Halt(bits(6) reason)">Halt</a>(<a link="DebugHalt_Step_NoSyndrome" file="shared_pseudocode.xml" hover="constant bits(6) DebugHalt_Step_NoSyndrome = '111011'">DebugHalt_Step_NoSyndrome</a>);
        elsif <a link="impl-shared.HaltingStep_SteppedEX.0" file="shared_pseudocode.xml" hover="function: boolean HaltingStep_SteppedEX()">HaltingStep_SteppedEX</a>() then
            <a link="impl-shared.Halt.1" file="shared_pseudocode.xml" hover="function: Halt(bits(6) reason)">Halt</a>(<a link="DebugHalt_Step_Exclusive" file="shared_pseudocode.xml" hover="constant bits(6) DebugHalt_Step_Exclusive = '011111'">DebugHalt_Step_Exclusive</a>);
        else
            <a link="impl-shared.Halt.1" file="shared_pseudocode.xml" hover="function: Halt(bits(6) reason)">Halt</a>(<a link="DebugHalt_Step_Normal" file="shared_pseudocode.xml" hover="constant bits(6) DebugHalt_Step_Normal = '011011'">DebugHalt_Step_Normal</a>);</pstext>
    </ps>
    <ps name="shared/debug/haltingevents/CheckOSUnlockCatch" mylink="shared.debug.haltingevents.CheckOSUnlockCatch" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CheckOSUnlockCatch()
// ====================
// Called on unlocking the OS Lock to pend an OS Unlock Catch debug event

<anchor link="impl-shared.CheckOSUnlockCatch.0" hover="function: CheckOSUnlockCatch()">CheckOSUnlockCatch</anchor>()
    if ((<a link="impl-shared.HaveDoPD.0" file="shared_pseudocode.xml" hover="function: boolean HaveDoPD()">HaveDoPD</a>() &amp;&amp; CTIDEVCTL.OSUCE == '1') ||
        (!<a link="impl-shared.HaveDoPD.0" file="shared_pseudocode.xml" hover="function: boolean HaveDoPD()">HaveDoPD</a>() &amp;&amp; EDECR.OSUCE == '1')) then
        if !<a link="impl-shared.Halted.0" file="shared_pseudocode.xml" hover="function: boolean Halted()">Halted</a>() then EDESR.OSUC = '1';</pstext>
    </ps>
    <ps name="shared/debug/haltingevents/CheckPendingOSUnlockCatch" mylink="shared.debug.haltingevents.CheckPendingOSUnlockCatch" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CheckPendingOSUnlockCatch()
// ===========================
// Check whether EDESR.OSUC has been set by an OS Unlock Catch debug event

<anchor link="impl-shared.CheckPendingOSUnlockCatch.0" hover="function: CheckPendingOSUnlockCatch()">CheckPendingOSUnlockCatch</anchor>()
    if <a link="impl-shared.HaltingAllowed.0" file="shared_pseudocode.xml" hover="function: boolean HaltingAllowed()">HaltingAllowed</a>() &amp;&amp; EDESR.OSUC == '1' then
        <a link="impl-shared.Halt.1" file="shared_pseudocode.xml" hover="function: Halt(bits(6) reason)">Halt</a>(<a link="DebugHalt_OSUnlockCatch" file="shared_pseudocode.xml" hover="constant bits(6) DebugHalt_OSUnlockCatch = '100011'">DebugHalt_OSUnlockCatch</a>);</pstext>
    </ps>
    <ps name="shared/debug/haltingevents/CheckPendingResetCatch" mylink="shared.debug.haltingevents.CheckPendingResetCatch" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CheckPendingResetCatch()
// ========================
// Check whether EDESR.RC has been set by a Reset Catch debug event

<anchor link="impl-shared.CheckPendingResetCatch.0" hover="function: CheckPendingResetCatch()">CheckPendingResetCatch</anchor>()
    if <a link="impl-shared.HaltingAllowed.0" file="shared_pseudocode.xml" hover="function: boolean HaltingAllowed()">HaltingAllowed</a>() &amp;&amp; EDESR.RC == '1' then
        <a link="impl-shared.Halt.1" file="shared_pseudocode.xml" hover="function: Halt(bits(6) reason)">Halt</a>(<a link="DebugHalt_ResetCatch" file="shared_pseudocode.xml" hover="constant bits(6) DebugHalt_ResetCatch = '100111'">DebugHalt_ResetCatch</a>);</pstext>
    </ps>
    <ps name="shared/debug/haltingevents/CheckResetCatch" mylink="shared.debug.haltingevents.CheckResetCatch" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CheckResetCatch()
// =================
// Called after reset

<anchor link="impl-shared.CheckResetCatch.0" hover="function: CheckResetCatch()">CheckResetCatch</anchor>()
    if (<a link="impl-shared.HaveDoPD.0" file="shared_pseudocode.xml" hover="function: boolean HaveDoPD()">HaveDoPD</a>() &amp;&amp; CTIDEVCTL.RCE == '1') || (!<a link="impl-shared.HaveDoPD.0" file="shared_pseudocode.xml" hover="function: boolean HaveDoPD()">HaveDoPD</a>() &amp;&amp; EDECR.RCE == '1') then
        EDESR.RC = '1';
        // If halting is allowed then halt immediately
        if <a link="impl-shared.HaltingAllowed.0" file="shared_pseudocode.xml" hover="function: boolean HaltingAllowed()">HaltingAllowed</a>() then <a link="impl-shared.Halt.1" file="shared_pseudocode.xml" hover="function: Halt(bits(6) reason)">Halt</a>(<a link="DebugHalt_ResetCatch" file="shared_pseudocode.xml" hover="constant bits(6) DebugHalt_ResetCatch = '100111'">DebugHalt_ResetCatch</a>);</pstext>
    </ps>
    <ps name="shared/debug/haltingevents/CheckSoftwareAccessToDebugRegisters" mylink="shared.debug.haltingevents.CheckSoftwareAccessToDebugRegisters" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CheckSoftwareAccessToDebugRegisters()
// =====================================
// Check for access to Breakpoint and Watchpoint registers.

<anchor link="impl-shared.CheckSoftwareAccessToDebugRegisters.0" hover="function: CheckSoftwareAccessToDebugRegisters()">CheckSoftwareAccessToDebugRegisters</anchor>()
    os_lock = (if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then DBGOSLSR.OSLK else OSLSR_EL1.OSLK);
    if <a link="impl-shared.HaltingAllowed.0" file="shared_pseudocode.xml" hover="function: boolean HaltingAllowed()">HaltingAllowed</a>() &amp;&amp; EDSCR.TDA == '1' &amp;&amp; os_lock == '0' then
        <a link="impl-shared.Halt.1" file="shared_pseudocode.xml" hover="function: Halt(bits(6) reason)">Halt</a>(<a link="DebugHalt_SoftwareAccess" file="shared_pseudocode.xml" hover="constant bits(6) DebugHalt_SoftwareAccess = '110011'">DebugHalt_SoftwareAccess</a>);</pstext>
    </ps>
    <ps name="shared/debug/haltingevents/ExternalDebugRequest" mylink="shared.debug.haltingevents.ExternalDebugRequest" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ExternalDebugRequest()
// ======================

<anchor link="impl-shared.ExternalDebugRequest.0" hover="function: ExternalDebugRequest()">ExternalDebugRequest</anchor>()
    if <a link="impl-shared.HaltingAllowed.0" file="shared_pseudocode.xml" hover="function: boolean HaltingAllowed()">HaltingAllowed</a>() then
        <a link="impl-shared.Halt.1" file="shared_pseudocode.xml" hover="function: Halt(bits(6) reason)">Halt</a>(<a link="DebugHalt_EDBGRQ" file="shared_pseudocode.xml" hover="constant bits(6) DebugHalt_EDBGRQ = '010011'">DebugHalt_EDBGRQ</a>);
    // Otherwise the CTI continues to assert the debug request until it is taken.</pstext>
    </ps>
    <ps name="shared/debug/haltingevents/HaltingStep_DidNotStep" mylink="shared.debug.haltingevents.HaltingStep_DidNotStep" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns TRUE if the previously executed instruction was executed in the inactive state, that is,
// if it was not itself stepped.
boolean <anchor link="impl-shared.HaltingStep_DidNotStep.0" hover="function: boolean HaltingStep_DidNotStep()">HaltingStep_DidNotStep</anchor>();</pstext>
    </ps>
    <ps name="shared/debug/haltingevents/HaltingStep_SteppedEX" mylink="shared.debug.haltingevents.HaltingStep_SteppedEX" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns TRUE if the previously executed instruction was a Load-Exclusive class instruction
// executed in the active-not-pending state.
boolean <anchor link="impl-shared.HaltingStep_SteppedEX.0" hover="function: boolean HaltingStep_SteppedEX()">HaltingStep_SteppedEX</anchor>();</pstext>
    </ps>
    <ps name="shared/debug/haltingevents/RunHaltingStep" mylink="shared.debug.haltingevents.RunHaltingStep" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// RunHaltingStep()
// ================

<anchor link="impl-shared.RunHaltingStep.4" hover="function: RunHaltingStep(boolean exception_generated, bits(2) exception_target, boolean syscall,&#13; boolean reset)">RunHaltingStep</anchor>(boolean exception_generated, bits(2) exception_target, boolean syscall,
               boolean reset)
    // "exception_generated" is TRUE if the previous instruction generated a synchronous exception
    // or was cancelled by an asynchronous exception.
    //
    // if "exception_generated" is TRUE then "exception_target" is the target of the exception, and
    // "syscall" is TRUE if the exception is a synchronous exception where the preferred return
    // address is the instruction following that which generated the exception.
    //
    // "reset" is TRUE if exiting reset state into the highest EL.

    if reset then assert !<a link="impl-shared.Halted.0" file="shared_pseudocode.xml" hover="function: boolean Halted()">Halted</a>();             // Cannot come out of reset halted
    active = EDECR.SS == '1' &amp;&amp; !<a link="impl-shared.Halted.0" file="shared_pseudocode.xml" hover="function: boolean Halted()">Halted</a>();

    if active &amp;&amp; reset then                     // Coming out of reset with EDECR.SS set
        EDESR.SS = '1';
    elsif active &amp;&amp; <a link="impl-shared.HaltingAllowed.0" file="shared_pseudocode.xml" hover="function: boolean HaltingAllowed()">HaltingAllowed</a>() then
        boolean advance;
        if exception_generated &amp;&amp; exception_target == <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> then
            advance = syscall || <a link="impl-shared.ExternalSecureInvasiveDebugEnabled.0" file="shared_pseudocode.xml" hover="function: boolean ExternalSecureInvasiveDebugEnabled()">ExternalSecureInvasiveDebugEnabled</a>();
        else
            advance = TRUE;
        if advance then EDESR.SS = '1';

    return;</pstext>
    </ps>
    <ps name="shared/debug/interrupts/ExternalDebugInterruptsDisabled" mylink="shared.debug.interrupts.ExternalDebugInterruptsDisabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ExternalDebugInterruptsDisabled()
// =================================
// Determine whether EDSCR disables interrupts routed to 'target'.

boolean <anchor link="impl-shared.ExternalDebugInterruptsDisabled.1" hover="function: boolean ExternalDebugInterruptsDisabled(bits(2) target)">ExternalDebugInterruptsDisabled</anchor>(bits(2) target)
    boolean int_dis;
    <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss = <a link="impl-shared.SecurityStateAtEL.1" file="shared_pseudocode.xml" hover="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(target);
    if <a link="impl-shared.Havev8p4Debug.0" file="shared_pseudocode.xml" hover="function: boolean Havev8p4Debug()">Havev8p4Debug</a>() then
        if EDSCR.INTdis[0] == '1' then
            case ss of
                when <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a> int_dis = <a link="impl-shared.ExternalInvasiveDebugEnabled.0" file="shared_pseudocode.xml" hover="function: boolean ExternalInvasiveDebugEnabled()">ExternalInvasiveDebugEnabled</a>();
                when <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>    int_dis = <a link="impl-shared.ExternalSecureInvasiveDebugEnabled.0" file="shared_pseudocode.xml" hover="function: boolean ExternalSecureInvasiveDebugEnabled()">ExternalSecureInvasiveDebugEnabled</a>();
        else
            int_dis = FALSE;
    else
        case target of
            when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>
                int_dis = (EDSCR.INTdis == '11' &amp;&amp; <a link="impl-shared.ExternalSecureInvasiveDebugEnabled.0" file="shared_pseudocode.xml" hover="function: boolean ExternalSecureInvasiveDebugEnabled()">ExternalSecureInvasiveDebugEnabled</a>());
            when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>
                int_dis = (EDSCR.INTdis == '1x' &amp;&amp; <a link="impl-shared.ExternalInvasiveDebugEnabled.0" file="shared_pseudocode.xml" hover="function: boolean ExternalInvasiveDebugEnabled()">ExternalInvasiveDebugEnabled</a>());
            when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>
                if ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> then
                    int_dis = (EDSCR.INTdis == '1x' &amp;&amp; <a link="impl-shared.ExternalSecureInvasiveDebugEnabled.0" file="shared_pseudocode.xml" hover="function: boolean ExternalSecureInvasiveDebugEnabled()">ExternalSecureInvasiveDebugEnabled</a>());
                else
                    int_dis = (EDSCR.INTdis != '00' &amp;&amp; <a link="impl-shared.ExternalInvasiveDebugEnabled.0" file="shared_pseudocode.xml" hover="function: boolean ExternalInvasiveDebugEnabled()">ExternalInvasiveDebugEnabled</a>());
    return int_dis;</pstext>
    </ps>
    <ps name="shared/debug/pmu/GetNumEventCounters" mylink="shared.debug.pmu.GetNumEventCounters" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// GetNumEventCounters()
// =====================
// Returns the number of event counters implemented. This is indicated to software at the
// highest Exception level by PMCR.N in AArch32 state, and PMCR_EL0.N in AArch64 state.

integer <anchor link="impl-shared.GetNumEventCounters.0" hover="function: integer GetNumEventCounters()">GetNumEventCounters</anchor>()
    return integer IMPLEMENTATION_DEFINED "Number of event counters";</pstext>
    </ps>
    <ps name="shared/debug/pmu/HasElapsed64Cycles" mylink="shared.debug.pmu.HasElapsed64Cycles" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns TRUE if 64 cycles have elapsed between the last count, and FALSE otherwise.
boolean <anchor link="impl-shared.HasElapsed64Cycles.0" hover="function: boolean HasElapsed64Cycles()">HasElapsed64Cycles</anchor>();</pstext>
    </ps>
    <ps name="shared/debug/pmu/PMUCountValue" mylink="shared.debug.pmu.PMUCountValue" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// PMUCountValue()
// ===============
// Implements the PMU threshold function, if implemented.
// Returns the value to increment event counter 'n' by, if the event it is
// configured to count yields the value 'V' on this cycle.

integer <anchor link="impl-shared.PMUCountValue.2" hover="function: integer PMUCountValue(integer n, integer V)">PMUCountValue</anchor>(integer n, integer V)
    if !<a link="impl-shared.HavePMUv3TH.0" file="shared_pseudocode.xml" hover="function: boolean HavePMUv3TH()">HavePMUv3TH</a>() then
        return V;

    integer T = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PMEVTYPER_EL0[n].TH);

    case PMEVTYPER_EL0[n].TC of
        when '000' return (if V != T then V else 0);    // Disabled or not-equal
        when '001' return (if V != T then 1 else 0);    // Not-equal, count
        when '010' return (if V == T then V else 0);    // Equals
        when '011' return (if V == T then 1 else 0);    // Equals, count
        when '100' return (if V &gt;= T then V else 0);    // Greater-than-or-equal
        when '101' return (if V &gt;= T then 1 else 0);    // Greater-than-or-equal, count
        when '110' return (if V &lt;  T then V else 0);    // Less-than
        when '111' return (if V &lt;  T then 1 else 0);    // Less-than, count</pstext>
    </ps>
    <ps name="shared/debug/pmu/PMUCounterMask" mylink="shared.debug.pmu.PMUCounterMask" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">constant integer <anchor link="CYCLE_COUNTER_ID" hover="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</anchor> = 31;

// PMUCounterMask()
// ================
// Return bitmask of accessible PMU counters.

bits(32) <anchor link="impl-shared.PMUCounterMask.0" hover="function: bits(32) PMUCounterMask()">PMUCounterMask</anchor>()
    integer n;
    if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
        n = <a link="AArch32.GetNumEventCountersAccessible.0" file="shared_pseudocode.xml" hover="function: integer AArch32.GetNumEventCountersAccessible()">AArch32.GetNumEventCountersAccessible</a>();
    else
        n = <a link="AArch64.GetNumEventCountersAccessible.0" file="shared_pseudocode.xml" hover="function: integer AArch64.GetNumEventCountersAccessible()">AArch64.GetNumEventCountersAccessible</a>();
    return '1' : <a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(<a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(n), 31);</pstext>
    </ps>
    <ps name="shared/debug/pmu/PMUEvent" mylink="shared.debug.pmu.PMUEvent" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">constant bits(16) <anchor link="PMU_EVENT_SW_INCR" hover="constant bits(16) PMU_EVENT_SW_INCR = 0x0000&lt;15:0&gt;">PMU_EVENT_SW_INCR</anchor>                    = 0x0000&lt;15:0&gt;;
constant bits(16) <anchor link="PMU_EVENT_INST_RETIRED" hover="constant bits(16) PMU_EVENT_INST_RETIRED = 0x0008&lt;15:0&gt;">PMU_EVENT_INST_RETIRED</anchor>               = 0x0008&lt;15:0&gt;;
constant bits(16) <anchor link="PMU_EVENT_EXC_TAKEN" hover="constant bits(16) PMU_EVENT_EXC_TAKEN = 0x0009&lt;15:0&gt;">PMU_EVENT_EXC_TAKEN</anchor>                  = 0x0009&lt;15:0&gt;;
constant bits(16) <anchor link="PMU_EVENT_CPU_CYCLES" hover="constant bits(16) PMU_EVENT_CPU_CYCLES = 0x0011&lt;15:0&gt;">PMU_EVENT_CPU_CYCLES</anchor>                 = 0x0011&lt;15:0&gt;;
constant bits(16) <anchor link="PMU_EVENT_INST_SPEC" hover="constant bits(16) PMU_EVENT_INST_SPEC = 0x001B&lt;15:0&gt;">PMU_EVENT_INST_SPEC</anchor>                  = 0x001B&lt;15:0&gt;;
constant bits(16) <anchor link="PMU_EVENT_CHAIN" hover="constant bits(16) PMU_EVENT_CHAIN = 0x001E&lt;15:0&gt;">PMU_EVENT_CHAIN</anchor>                      = 0x001E&lt;15:0&gt;;

// PMUEvent()
// ==========
// Generate a PMU event. By default, increment by 1.

<anchor link="impl-shared.PMUEvent.1" hover="function: PMUEvent(bits(16) event)">PMUEvent</anchor>(bits(16) event)
    <a link="impl-shared.PMUEvent.2" file="shared_pseudocode.xml" hover="function: PMUEvent(bits(16) event, integer increment)">PMUEvent</a>(event, 1);

// PMUEvent()
// ==========
// Accumulate a PMU Event.

<anchor link="impl-shared.PMUEvent.2" hover="function: PMUEvent(bits(16) event, integer increment)">PMUEvent</anchor>(bits(16) event, integer increment)
    integer counters = <a link="impl-shared.GetNumEventCounters.0" file="shared_pseudocode.xml" hover="function: integer GetNumEventCounters()">GetNumEventCounters</a>();
    if counters != 0 then
        for idx = 0 to counters - 1
            <a link="impl-shared.PMUEvent.3" file="shared_pseudocode.xml" hover="function: PMUEvent(bits(16) event, integer increment, integer idx)">PMUEvent</a>(event, increment, idx);

// PMUEvent()
// ==========
// Accumulate a PMU Event for a specific event counter.

<anchor link="impl-shared.PMUEvent.3" hover="function: PMUEvent(bits(16) event, integer increment, integer idx)">PMUEvent</anchor>(bits(16) event, integer increment, integer idx)
    if !<a link="impl-shared.HavePMUv3.0" file="shared_pseudocode.xml" hover="function: boolean HavePMUv3()">HavePMUv3</a>() then
        return;

    if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
        if PMEVTYPER[idx].evtCount == event then
            PMUEventAccumulator[idx] = PMUEventAccumulator[idx] + increment;
    else
        if PMEVTYPER_EL0[idx].evtCount == event then
            PMUEventAccumulator[idx] = PMUEventAccumulator[idx] + increment;</pstext>
    </ps>
    <ps name="shared/debug/pmu/integer" mylink="shared.debug.pmu.integer" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">array integer PMUEventAccumulator[0..30];   // Accumulates PMU events for a cycle</pstext>
    </ps>
    <ps name="shared/debug/samplebasedprofiling/CreatePCSample" mylink="shared.debug.samplebasedprofiling.CreatePCSample" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CreatePCSample()
// ================

<anchor link="impl-shared.CreatePCSample.0" hover="function: CreatePCSample()">CreatePCSample</anchor>()
    // In a simple sequential execution of the program, CreatePCSample is executed each time the PE
    // executes an instruction that can be sampled. An implementation is not constrained such that
    // reads of EDPCSRlo return the current values of PC, etc.

    pc_sample.valid = <a link="impl-shared.ExternalNoninvasiveDebugAllowed.0" file="shared_pseudocode.xml" hover="function: boolean ExternalNoninvasiveDebugAllowed()">ExternalNoninvasiveDebugAllowed</a>() &amp;&amp; !<a link="impl-shared.Halted.0" file="shared_pseudocode.xml" hover="function: boolean Halted()">Halted</a>();
    pc_sample.pc = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    pc_sample.el = PSTATE.EL;
    pc_sample.rw = if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then '0' else '1';
    pc_sample.ns = if <a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>() then '0' else '1';
    pc_sample.contextidr = if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then CONTEXTIDR else CONTEXTIDR_EL1&lt;31:0&gt;;
    pc_sample.has_el2 = PSTATE.EL != <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>();

    if pc_sample.has_el2 then
        if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
            pc_sample.vmid = <a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(VTTBR.VMID, 16);
        elsif !<a link="impl-shared.Have16bitVMID.0" file="shared_pseudocode.xml" hover="function: boolean Have16bitVMID()">Have16bitVMID</a>() || VTCR_EL2.VS == '0' then
            pc_sample.vmid = <a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(VTTBR_EL2.VMID&lt;7:0&gt;, 16);
        else
            pc_sample.vmid = VTTBR_EL2.VMID;
        if (<a link="impl-shared.HaveVirtHostExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() || <a link="impl-shared.HaveV82Debug.0" file="shared_pseudocode.xml" hover="function: boolean HaveV82Debug()">HaveV82Debug</a>()) &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
            pc_sample.contextidr_el2 = CONTEXTIDR_EL2&lt;31:0&gt;;
        else
            pc_sample.contextidr_el2 = bits(32) UNKNOWN;
        pc_sample.el0h = PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a link="impl-shared.IsInHost.0" file="shared_pseudocode.xml" hover="function: boolean IsInHost()">IsInHost</a>();
    return;</pstext>
    </ps>
    <ps name="shared/debug/samplebasedprofiling/EDPCSRlo" mylink="shared.debug.samplebasedprofiling.EDPCSRlo" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// EDPCSRlo[] (read)
// =================

bits(32) <anchor link="impl-shared.EDPCSRlo.read.1" hover="accessor: bits(32) EDPCSRlo[boolean memory_mapped]">EDPCSRlo</anchor>[boolean memory_mapped]

    if EDPRSR&lt;6:5,0&gt; != '001' then                      // Check DLK, OSLK and PU bits
        IMPLEMENTATION_DEFINED "generate error response";
        return bits(32) UNKNOWN;

    // The Software lock is OPTIONAL.
    update = !memory_mapped || EDLSR.SLK == '0';        // Software locked: no side-effects

    bits(32) sample;
    if pc_sample.valid then
        sample = pc_sample.pc&lt;31:0&gt;;
        if update then
            if <a link="impl-shared.HaveVirtHostExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; EDSCR.SC2 == '1' then
                EDPCSRhi.PC = (if pc_sample.rw == '0' then <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(24) else pc_sample.pc&lt;55:32&gt;);
                EDPCSRhi.EL = pc_sample.el;
                EDPCSRhi.NS = pc_sample.ns;
            else
                EDPCSRhi = (if pc_sample.rw == '0' then <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(32) else pc_sample.pc&lt;63:32&gt;);
            EDCIDSR = pc_sample.contextidr;
            if (<a link="impl-shared.HaveVirtHostExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() || <a link="impl-shared.HaveV82Debug.0" file="shared_pseudocode.xml" hover="function: boolean HaveV82Debug()">HaveV82Debug</a>()) &amp;&amp; EDSCR.SC2 == '1' then
                EDVIDSR = (if pc_sample.has_el2 then pc_sample.contextidr_el2
                           else bits(32) UNKNOWN);
            else
                EDVIDSR.VMID = (if pc_sample.has_el2 &amp;&amp; pc_sample.el IN {<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>,<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>}
                                then pc_sample.vmid else <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>());
                EDVIDSR.NS = pc_sample.ns;
                EDVIDSR.E2 = (if pc_sample.el == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then '1' else '0');
                EDVIDSR.E3 = (if pc_sample.el == <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> then '1' else '0') AND pc_sample.rw;
                // The conditions for setting HV are not specified if PCSRhi is zero.
                // An example implementation may be "pc_sample.rw".
                EDVIDSR.HV = (if !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(EDPCSRhi) then '1' else bit IMPLEMENTATION_DEFINED "0 or 1");
    else
        sample = <a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(32);
        if update then
            EDPCSRhi = bits(32) UNKNOWN;
            EDCIDSR = bits(32) UNKNOWN;
            EDVIDSR = bits(32) UNKNOWN;

    return sample;</pstext>
    </ps>
    <ps name="shared/debug/samplebasedprofiling/PCSample" mylink="shared.debug.samplebasedprofiling.PCSample" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">type <anchor link="PCSample" hover="type PCSample is ( boolean valid, bits(64) pc, bits(2) el, bit rw, bit ns, boolean has_el2, bits(32) contextidr, bits(32) contextidr_el2, boolean el0h, bits(16) vmid )">PCSample</anchor> is (
    boolean valid,
    bits(64) pc,
    bits(2) el,
    bit rw,
    bit ns,
    boolean has_el2,
    bits(32) contextidr,
    bits(32) contextidr_el2,
    boolean el0h,
    bits(16) vmid
)

<a link="PCSample" file="shared_pseudocode.xml" hover="type PCSample is ( boolean valid, bits(64) pc, bits(2) el, bit rw, bit ns, boolean has_el2, bits(32) contextidr, bits(32) contextidr_el2, boolean el0h, bits(16) vmid )">PCSample</a> pc_sample;</pstext>
    </ps>
    <ps name="shared/debug/samplebasedprofiling/PMPCSR" mylink="shared.debug.samplebasedprofiling.PMPCSR" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// PMPCSR[] (read)
// ===============

bits(32) <anchor link="impl-shared.PMPCSR.read.1" hover="accessor: bits(32) PMPCSR[boolean memory_mapped]">PMPCSR</anchor>[boolean memory_mapped]

    if EDPRSR&lt;6:5,0&gt; != '001' then                      // Check DLK, OSLK and PU bits
        IMPLEMENTATION_DEFINED "generate error response";
        return bits(32) UNKNOWN;

    // The Software lock is OPTIONAL.
    update = !memory_mapped || PMLSR.SLK == '0';        // Software locked: no side-effects

    bits(32) sample;
    if pc_sample.valid then
        sample = pc_sample.pc&lt;31:0&gt;;
        if update then
            PMPCSR&lt;55:32&gt; = (if pc_sample.rw == '0' then <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(24) else pc_sample.pc&lt;55:32&gt;);
            PMPCSR.EL = pc_sample.el;
            PMPCSR.NS = pc_sample.ns;

            PMCID1SR = pc_sample.contextidr;
            PMCID2SR = if pc_sample.has_el2 then pc_sample.contextidr_el2 else bits(32) UNKNOWN;

            PMVIDSR.VMID = (if pc_sample.has_el2 &amp;&amp; pc_sample.el IN {<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>,<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>} &amp;&amp; !pc_sample.el0h
                            then pc_sample.vmid else bits(16) UNKNOWN);
    else
        sample = <a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(32);
        if update then
            PMPCSR&lt;55:32&gt;  = bits(24) UNKNOWN;
            PMPCSR.EL = bits(2) UNKNOWN;
            PMPCSR.NS = bit UNKNOWN;

            PMCID1SR = bits(32) UNKNOWN;
            PMCID2SR = bits(32) UNKNOWN;

            PMVIDSR.VMID = bits(16) UNKNOWN;

    return sample;</pstext>
    </ps>
    <ps name="shared/debug/softwarestep/CheckSoftwareStep" mylink="shared.debug.softwarestep.CheckSoftwareStep" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CheckSoftwareStep()
// ===================
// Take a Software Step exception if in the active-pending state

<anchor link="impl-shared.CheckSoftwareStep.0" hover="function: CheckSoftwareStep()">CheckSoftwareStep</anchor>()

    // Other self-hosted debug functions will call AArch32.GenerateDebugExceptions() if called from
    // AArch32 state. However, because Software Step is only active when the debug target Exception
    // level is using AArch64, CheckSoftwareStep only calls AArch64.GenerateDebugExceptions().
    step_enabled = !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="impl-shared.DebugTarget.0" file="shared_pseudocode.xml" hover="function: bits(2) DebugTarget()">DebugTarget</a>()) &amp;&amp; <a link="AArch64.GenerateDebugExceptions.0" file="shared_pseudocode.xml" hover="function: boolean AArch64.GenerateDebugExceptions()">AArch64.GenerateDebugExceptions</a>() &amp;&amp; MDSCR_EL1.SS == '1';
    if step_enabled &amp;&amp; PSTATE.SS == '0' then
        <a link="AArch64.SoftwareStepException.0" file="shared_pseudocode.xml" hover="function: AArch64.SoftwareStepException()">AArch64.SoftwareStepException</a>();</pstext>
    </ps>
    <ps name="shared/debug/softwarestep/DebugExceptionReturnSS" mylink="shared.debug.softwarestep.DebugExceptionReturnSS" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// DebugExceptionReturnSS()
// ========================
// Returns value to write to PSTATE.SS on an exception return or Debug state exit.

bit <anchor link="impl-shared.DebugExceptionReturnSS.1" hover="function: bit DebugExceptionReturnSS(bits(N) spsr)">DebugExceptionReturnSS</anchor>(bits(N) spsr)
    if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
        assert N == 32;
    else
        assert N == 64;

    assert <a link="impl-shared.Halted.0" file="shared_pseudocode.xml" hover="function: boolean Halted()">Halted</a>() || <a link="impl-shared.Restarting.0" file="shared_pseudocode.xml" hover="function: boolean Restarting()">Restarting</a>() ||  PSTATE.EL != <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>;

    boolean enabled_at_source;
    if <a link="impl-shared.Restarting.0" file="shared_pseudocode.xml" hover="function: boolean Restarting()">Restarting</a>() then
        enabled_at_source = FALSE;
    elsif <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
        enabled_at_source = <a link="AArch32.GenerateDebugExceptions.0" file="shared_pseudocode.xml" hover="function: boolean AArch32.GenerateDebugExceptions()">AArch32.GenerateDebugExceptions</a>();
    else
        enabled_at_source = <a link="AArch64.GenerateDebugExceptions.0" file="shared_pseudocode.xml" hover="function: boolean AArch64.GenerateDebugExceptions()">AArch64.GenerateDebugExceptions</a>();

    boolean valid;
    bits(2) dest;
    if <a link="impl-shared.IllegalExceptionReturn.1" file="shared_pseudocode.xml" hover="function: boolean IllegalExceptionReturn(bits(N) spsr)">IllegalExceptionReturn</a>(spsr) then
        dest = PSTATE.EL;
    else
        (valid, dest) = <a link="impl-shared.ELFromSPSR.1" file="shared_pseudocode.xml" hover="function: (boolean,bits(2)) ELFromSPSR(bits(N) spsr)">ELFromSPSR</a>(spsr);  assert valid;

    dest_is_secure = <a link="impl-shared.IsSecureBelowEL3.0" file="shared_pseudocode.xml" hover="function: boolean IsSecureBelowEL3()">IsSecureBelowEL3</a>() || dest == <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>;
    bit mask;
    boolean enabled_at_dest;
    dest_using_32 = (if dest == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then spsr&lt;4&gt; == '1' else <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(dest));
    if dest_using_32 then
        enabled_at_dest = <a link="AArch32.GenerateDebugExceptionsFrom.2" file="shared_pseudocode.xml" hover="function: boolean AArch32.GenerateDebugExceptionsFrom(bits(2) from, boolean secure)">AArch32.GenerateDebugExceptionsFrom</a>(dest, dest_is_secure);
    else
        mask = spsr&lt;9&gt;;
        enabled_at_dest = <a link="AArch64.GenerateDebugExceptionsFrom.3" file="shared_pseudocode.xml" hover="function: boolean AArch64.GenerateDebugExceptionsFrom(bits(2) from, boolean secure, bit mask)">AArch64.GenerateDebugExceptionsFrom</a>(dest, dest_is_secure, mask);

    ELd = <a link="impl-shared.DebugTargetFrom.1" file="shared_pseudocode.xml" hover="function: bits(2) DebugTargetFrom(boolean secure)">DebugTargetFrom</a>(dest_is_secure);
    bit SS_bit;
    if !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(ELd) &amp;&amp; MDSCR_EL1.SS == '1' &amp;&amp; !enabled_at_source &amp;&amp; enabled_at_dest then
        SS_bit = spsr&lt;21&gt;;
    else
        SS_bit = '0';

    return SS_bit;</pstext>
    </ps>
    <ps name="shared/debug/softwarestep/SSAdvance" mylink="shared.debug.softwarestep.SSAdvance" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SSAdvance()
// ===========
// Advance the Software Step state machine.

<anchor link="impl-shared.SSAdvance.0" hover="function: SSAdvance()">SSAdvance</anchor>()

    // A simpler implementation of this function just clears PSTATE.SS to zero regardless of the
    // current Software Step state machine. However, this check is made to illustrate that the
    // processor only needs to consider advancing the state machine from the active-not-pending
    // state.
    target = <a link="impl-shared.DebugTarget.0" file="shared_pseudocode.xml" hover="function: bits(2) DebugTarget()">DebugTarget</a>();
    step_enabled = !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(target) &amp;&amp; MDSCR_EL1.SS == '1';
    active_not_pending = step_enabled &amp;&amp; PSTATE.SS == '1';

    if active_not_pending then PSTATE.SS = '0';

    return;</pstext>
    </ps>
    <ps name="shared/debug/softwarestep/SoftwareStep_DidNotStep" mylink="shared.debug.softwarestep.SoftwareStep_DidNotStep" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns TRUE if the previously executed instruction was executed in the
// inactive state, that is, if it was not itself stepped.
// Might return TRUE or FALSE if the previously executed instruction was an ISB
// or ERET executed in the active-not-pending state, or if another exception
// was taken before the Software Step exception.  Returns FALSE otherwise,
// indicating that the previously executed instruction was executed in the
// active-not-pending state, that is, the instruction was stepped.
boolean <anchor link="impl-shared.SoftwareStep_DidNotStep.0" hover="function: boolean SoftwareStep_DidNotStep()">SoftwareStep_DidNotStep</anchor>();</pstext>
    </ps>
    <ps name="shared/debug/softwarestep/SoftwareStep_SteppedEX" mylink="shared.debug.softwarestep.SoftwareStep_SteppedEX" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns a value that describes the previously executed instruction. The
// result is valid only if SoftwareStep_DidNotStep() returns FALSE.
// Might return TRUE or FALSE if the instruction was an AArch32 LDREX or LDAEX
// that failed its condition code test.  Otherwise returns TRUE if the
// instruction was a Load-Exclusive class instruction, and FALSE if the
// instruction was not a Load-Exclusive class instruction.
boolean <anchor link="impl-shared.SoftwareStep_SteppedEX.0" hover="function: boolean SoftwareStep_SteppedEX()">SoftwareStep_SteppedEX</anchor>();</pstext>
    </ps>
    <ps name="shared/exceptions/exceptions/ConditionSyndrome" mylink="shared.exceptions.exceptions.ConditionSyndrome" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ConditionSyndrome()
// ===================
// Return CV and COND fields of instruction syndrome

bits(5) <anchor link="impl-shared.ConditionSyndrome.0" hover="function: bits(5) ConditionSyndrome()">ConditionSyndrome</anchor>()

    bits(5) syndrome;

    if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
        cond = <a link="AArch32.CurrentCond.0" file="shared_pseudocode.xml" hover="function: bits(4) AArch32.CurrentCond()">AArch32.CurrentCond</a>();
        if PSTATE.T == '0' then             // A32
            syndrome&lt;4&gt; = '1';
            // A conditional A32 instruction that is known to pass its condition code check
            // can be presented either with COND set to 0xE, the value for unconditional, or
            // the COND value held in the instruction.
            if <a link="impl-shared.ConditionHolds.1" file="shared_pseudocode.xml" hover="function: boolean ConditionHolds(bits(4) cond)">ConditionHolds</a>(cond) &amp;&amp; <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_ESRCONDPASS" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_ESRCONDPASS</a>) then
                syndrome&lt;3:0&gt; = '1110';
            else
                syndrome&lt;3:0&gt; = cond;
        else                                // T32
            // When a T32 instruction is trapped, it is IMPLEMENTATION DEFINED whether:
            //  * CV set to 0 and COND is set to an UNKNOWN value
            //  * CV set to 1 and COND is set to the condition code for the condition that
            //    applied to the instruction.
            if boolean IMPLEMENTATION_DEFINED "Condition valid for trapped T32" then
                syndrome&lt;4&gt; = '1';
                syndrome&lt;3:0&gt; = cond;
            else
                syndrome&lt;4&gt; = '0';
                syndrome&lt;3:0&gt; = bits(4) UNKNOWN;
    else
        syndrome&lt;4&gt; = '1';
        syndrome&lt;3:0&gt; = '1110';

    return syndrome;</pstext>
    </ps>
    <ps name="shared/exceptions/exceptions/Exception" mylink="shared.exceptions.exceptions.Exception" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="Exception" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception</anchor> {<anchor link="Exception_Uncategorized" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</anchor>,       // Uncategorized or unknown reason
                       <anchor link="Exception_WFxTrap" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_WFxTrap</anchor>,             // Trapped WFI or WFE instruction
                       <anchor link="Exception_CP15RTTrap" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RTTrap</anchor>,          // Trapped AArch32 MCR or MRC access, coproc=0b1111
                       <anchor link="Exception_CP15RRTTrap" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RRTTrap</anchor>,         // Trapped AArch32 MCRR or MRRC access, coproc=0b1111
                       <anchor link="Exception_CP14RTTrap" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RTTrap</anchor>,          // Trapped AArch32 MCR or MRC access, coproc=0b1110
                       <anchor link="Exception_CP14DTTrap" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14DTTrap</anchor>,          // Trapped AArch32 LDC or STC access, coproc=0b1110
                       <anchor link="Exception_CP14RRTTrap" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RRTTrap</anchor>,         // Trapped AArch32 MRRC access, coproc=0b1110
                       <anchor link="Exception_AdvSIMDFPAccessTrap" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</anchor>, // HCPTR-trapped access to SIMD or FP
                       <anchor link="Exception_FPIDTrap" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPIDTrap</anchor>,            // Trapped access to SIMD or FP ID register
                       <anchor link="Exception_LDST64BTrap" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_LDST64BTrap</anchor>,         // Trapped access to ST64BV, ST64BV0, ST64B and LD64B
                       // Trapped BXJ instruction not supported in Armv8
                       <anchor link="Exception_PACTrap" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PACTrap</anchor>,             // Trapped invalid PAC use
                       <anchor link="Exception_IllegalState" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IllegalState</anchor>,        // Illegal Execution state
                       <anchor link="Exception_SupervisorCall" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SupervisorCall</anchor>,      // Supervisor Call
                       <anchor link="Exception_HypervisorCall" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_HypervisorCall</anchor>,      // Hypervisor Call
                       <anchor link="Exception_MonitorCall" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_MonitorCall</anchor>,         // Monitor Call or Trapped SMC instruction
                       <anchor link="Exception_SystemRegisterTrap" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SystemRegisterTrap</anchor>,  // Trapped MRS or MSR system register access
                       <anchor link="Exception_ERetTrap" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_ERetTrap</anchor>,            // Trapped invalid ERET use
                       <anchor link="Exception_InstructionAbort" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_InstructionAbort</anchor>,    // Instruction Abort or Prefetch Abort
                       <anchor link="Exception_PCAlignment" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PCAlignment</anchor>,         // PC alignment fault
                       <anchor link="Exception_DataAbort" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</anchor>,           // Data Abort
                       <anchor link="Exception_NV2DataAbort" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2DataAbort</anchor>,        // Data abort at EL1 reported as being from EL2
                       <anchor link="Exception_PACFail" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PACFail</anchor>,             // PAC Authentication failure
                       <anchor link="Exception_SPAlignment" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SPAlignment</anchor>,         // SP alignment fault
                       <anchor link="Exception_FPTrappedException" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPTrappedException</anchor>,  // IEEE trapped FP exception
                       <anchor link="Exception_SError" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SError</anchor>,              // SError interrupt
                       <anchor link="Exception_Breakpoint" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Breakpoint</anchor>,          // (Hardware) Breakpoint
                       <anchor link="Exception_SoftwareStep" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareStep</anchor>,        // Software Step
                       <anchor link="Exception_Watchpoint" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Watchpoint</anchor>,          // Watchpoint
                       <anchor link="Exception_NV2Watchpoint" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2Watchpoint</anchor>,       // Watchpoint at EL1 reported as being from EL2
                       <anchor link="Exception_SoftwareBreakpoint" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareBreakpoint</anchor>,  // Software Breakpoint Instruction
                       <anchor link="Exception_VectorCatch" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_VectorCatch</anchor>,         // AArch32 Vector Catch
                       <anchor link="Exception_IRQ" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IRQ</anchor>,                 // IRQ interrupt
                       <anchor link="Exception_BranchTarget" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_BranchTarget</anchor>,        // Branch Target Identification
                       <anchor link="Exception_MemCpyMemSet" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_MemCpyMemSet</anchor>,        // Exception from a CPY* or SET* instruction
                       <anchor link="Exception_FIQ" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FIQ</anchor>};                // FIQ interrupt</pstext>
    </ps>
    <ps name="shared/exceptions/exceptions/ExceptionRecord" mylink="shared.exceptions.exceptions.ExceptionRecord" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">type <anchor link="ExceptionRecord" hover="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</anchor> is (
    <a link="Exception" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception</a>   exceptype,           // Exception class
    bits(25)    syndrome,            // Syndrome record
    bits(5)     syndrome2,           // ST64BV(0) return value register specifier
    bits(64)    vaddress,            // Virtual fault address
    boolean     ipavalid,            // Validity of Intermediate Physical fault address
    bit         NS,                  // Intermediate Physical fault address space
    bits(52)    ipaddress,           // Intermediate Physical fault address
    boolean     trappedsyscallinst)  // Trapped SVC or SMC instruction</pstext>
    </ps>
    <ps name="shared/exceptions/exceptions/ExceptionSyndrome" mylink="shared.exceptions.exceptions.ExceptionSyndrome" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ExceptionSyndrome()
// ===================
// Return a blank exception syndrome record for an exception of the given type.

ExceptionRecord <anchor link="impl-shared.ExceptionSyndrome.1" hover="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</anchor>(<a link="Exception" file="shared_pseudocode.xml" hover="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception</a> exceptype)

    <a link="ExceptionRecord" file="shared_pseudocode.xml" hover="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress, boolean trappedsyscallinst)">ExceptionRecord</a> r;

    r.exceptype = exceptype;

    // Initialize all other fields
    r.syndrome  = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();
    r.syndrome2 = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();
    r.vaddress  = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();
    r.ipavalid  = FALSE;
    r.NS        = '0';
    r.ipaddress = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();
    r.trappedsyscallinst = FALSE;
    return r;</pstext>
    </ps>
    <ps name="shared/functions/aborts/EncodeLDFSC" mylink="shared.functions.aborts.EncodeLDFSC" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// EncodeLDFSC()
// =============
// Function that gives the Long-descriptor FSC code for types of Fault

bits(6) <anchor link="impl-shared.EncodeLDFSC.2" hover="function: bits(6) EncodeLDFSC(Fault statuscode, integer level)">EncodeLDFSC</anchor>(<a link="Fault" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> statuscode, integer level)
    bits(6) result;

    if level == -1 then
        assert <a link="impl-shared.Have52BitIPAAndPASpaceExt.0" file="shared_pseudocode.xml" hover="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>();
        case statuscode of
            when <a link="Fault_AddressSize" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>          result = '101001';
            when <a link="Fault_Translation" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>          result = '101011';
            when <a link="Fault_SyncExternalOnWalk" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternalOnWalk</a>   result = '010011';
            when <a link="Fault_SyncParityOnWalk" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParityOnWalk</a>     result = '011011'; assert !<a link="impl-shared.HaveRASExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveRASExt()">HaveRASExt</a>();
            otherwise                       <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();

        return result;
    case statuscode of
        when <a link="Fault_AddressSize" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>         result = '0000':level&lt;1:0&gt;; assert level IN {0,1,2,3};
        when <a link="Fault_AccessFlag" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>          result = '0010':level&lt;1:0&gt;; assert level IN {0,1,2,3};
        when <a link="Fault_Permission" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>          result = '0011':level&lt;1:0&gt;; assert level IN {0,1,2,3};
        when <a link="Fault_Translation" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>         result = '0001':level&lt;1:0&gt;; assert level IN {0,1,2,3};
        when <a link="Fault_SyncExternal" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternal</a>        result = '010000';
        when <a link="Fault_SyncExternalOnWalk" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternalOnWalk</a>  result = '0101':level&lt;1:0&gt;; assert level IN {0,1,2,3};
        when <a link="Fault_SyncParity" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParity</a>          result = '011000';
        when <a link="Fault_SyncParityOnWalk" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParityOnWalk</a>    result = '0111':level&lt;1:0&gt;; assert level IN {0,1,2,3};
        when <a link="Fault_AsyncParity" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncParity</a>         result = '011001';
        when <a link="Fault_AsyncExternal" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>       result = '010001';
        when <a link="Fault_Alignment" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>           result = '100001';
        when <a link="Fault_Debug" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Debug</a>               result = '100010';
        when <a link="Fault_TLBConflict" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_TLBConflict</a>         result = '110000';
        when <a link="Fault_HWUpdateAccessFlag" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_HWUpdateAccessFlag</a>  result = '110001';
        when <a link="Fault_Lockdown" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Lockdown</a>            result = '110100';  // IMPLEMENTATION DEFINED
        when <a link="Fault_Exclusive" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Exclusive</a>           result = '110101';  // IMPLEMENTATION DEFINED
        otherwise                      <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();

    return result;</pstext>
    </ps>
    <ps name="shared/functions/aborts/IPAValid" mylink="shared.functions.aborts.IPAValid" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// IPAValid()
// ==========
// Return TRUE if the IPA is reported for the abort

boolean <anchor link="impl-shared.IPAValid.1" hover="function: boolean IPAValid(FaultRecord fault)">IPAValid</anchor>(<a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    assert fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    if fault.s2fs1walk then
        return fault.statuscode IN {
            <a link="Fault_AccessFlag" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>,
            <a link="Fault_Permission" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>,
            <a link="Fault_Translation" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>,
            <a link="Fault_AddressSize" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>
        };
    elsif fault.secondstage then
        return fault.statuscode IN {
            <a link="Fault_AccessFlag" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>,
            <a link="Fault_Translation" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>,
            <a link="Fault_AddressSize" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>
        };
    else
        return FALSE;</pstext>
    </ps>
    <ps name="shared/functions/aborts/IsAsyncAbort" mylink="shared.functions.aborts.IsAsyncAbort" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// IsAsyncAbort()
// ==============
// Returns TRUE if the abort currently being processed is an asynchronous abort, and FALSE
// otherwise.

boolean <anchor link="impl-shared.IsAsyncAbort.1" hover="function: boolean IsAsyncAbort(Fault statuscode)">IsAsyncAbort</anchor>(<a link="Fault" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> statuscode)
    assert statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    return (statuscode IN {<a link="Fault_AsyncExternal" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>, <a link="Fault_AsyncParity" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncParity</a>});

// IsAsyncAbort()
// ==============

boolean <a link="impl-shared.IsAsyncAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsAsyncAbort(Fault statuscode)">IsAsyncAbort</a>(<a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    return <a link="impl-shared.IsAsyncAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsAsyncAbort(Fault statuscode)">IsAsyncAbort</a>(fault.statuscode);</pstext>
    </ps>
    <ps name="shared/functions/aborts/IsDebugException" mylink="shared.functions.aborts.IsDebugException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// IsDebugException()
// ==================

boolean <anchor link="impl-shared.IsDebugException.1" hover="function: boolean IsDebugException(FaultRecord fault)">IsDebugException</anchor>(<a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    assert fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;
    return fault.statuscode == <a link="Fault_Debug" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Debug</a>;</pstext>
    </ps>
    <ps name="shared/functions/aborts/IsExternalAbort" mylink="shared.functions.aborts.IsExternalAbort" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// IsExternalAbort()
// =================
// Returns TRUE if the abort currently being processed is an External abort and FALSE otherwise.

boolean <anchor link="impl-shared.IsExternalAbort.1" hover="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</anchor>(<a link="Fault" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> statuscode)
    assert statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    return (statuscode IN {
        <a link="Fault_SyncExternal" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternal</a>,
        <a link="Fault_SyncParity" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParity</a>,
        <a link="Fault_SyncExternalOnWalk" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternalOnWalk</a>,
        <a link="Fault_SyncParityOnWalk" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParityOnWalk</a>,
        <a link="Fault_AsyncExternal" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>,
        <a link="Fault_AsyncParity" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncParity</a>
    });

// IsExternalAbort()
// =================

boolean <a link="impl-shared.IsExternalAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(<a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    return <a link="impl-shared.IsExternalAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault.statuscode);</pstext>
    </ps>
    <ps name="shared/functions/aborts/IsExternalSyncAbort" mylink="shared.functions.aborts.IsExternalSyncAbort" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// IsExternalSyncAbort()
// =====================
// Returns TRUE if the abort currently being processed is an external
// synchronous abort and FALSE otherwise.

boolean <anchor link="impl-shared.IsExternalSyncAbort.1" hover="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</anchor>(<a link="Fault" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> statuscode)
    assert statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    return (statuscode IN {
        <a link="Fault_SyncExternal" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternal</a>,
        <a link="Fault_SyncParity" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParity</a>,
        <a link="Fault_SyncExternalOnWalk" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternalOnWalk</a>,
        <a link="Fault_SyncParityOnWalk" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParityOnWalk</a>
    });

// IsExternalSyncAbort()
// =====================

boolean <a link="impl-shared.IsExternalSyncAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(<a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    return <a link="impl-shared.IsExternalSyncAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(fault.statuscode);</pstext>
    </ps>
    <ps name="shared/functions/aborts/IsFault" mylink="shared.functions.aborts.IsFault" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// IsFault()
// =========
// Return TRUE if a fault is associated with an address descriptor

boolean <anchor link="impl-shared.IsFault.1" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</anchor>(<a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> addrdesc)
    return addrdesc.fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

// IsFault()
// =========
// Return TRUE if a fault is associated with a memory access.

boolean <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(<a link="Fault" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> fault)
    return fault != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

// IsFault()
// =========
// Return TRUE if a fault is associated with status returned by memory.

boolean <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(<a link="PhysMemRetStatus" file="shared_pseudocode.xml" hover="type PhysMemRetStatus is (Fault statuscode, bit extflag, bits(2) errortype, bits(64) store64bstatus, AccType acctype)">PhysMemRetStatus</a> retstatus)
    return retstatus.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;</pstext>
    </ps>
    <ps name="shared/functions/aborts/IsSErrorInterrupt" mylink="shared.functions.aborts.IsSErrorInterrupt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// IsSErrorInterrupt()
// ===================
// Returns TRUE if the abort currently being processed is an SError interrupt, and FALSE
// otherwise.

boolean <anchor link="impl-shared.IsSErrorInterrupt.1" hover="function: boolean IsSErrorInterrupt(Fault statuscode)">IsSErrorInterrupt</anchor>(<a link="Fault" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> statuscode)
    assert statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    return (statuscode IN {<a link="Fault_AsyncExternal" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>, <a link="Fault_AsyncParity" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncParity</a>});

// IsSErrorInterrupt()
// ===================

boolean <a link="impl-shared.IsSErrorInterrupt.1" file="shared_pseudocode.xml" hover="function: boolean IsSErrorInterrupt(Fault statuscode)">IsSErrorInterrupt</a>(<a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    return <a link="impl-shared.IsSErrorInterrupt.1" file="shared_pseudocode.xml" hover="function: boolean IsSErrorInterrupt(Fault statuscode)">IsSErrorInterrupt</a>(fault.statuscode);</pstext>
    </ps>
    <ps name="shared/functions/aborts/IsSecondStage" mylink="shared.functions.aborts.IsSecondStage" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// IsSecondStage()
// ===============

boolean <anchor link="impl-shared.IsSecondStage.1" hover="function: boolean IsSecondStage(FaultRecord fault)">IsSecondStage</anchor>(<a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    assert fault.statuscode != <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    return fault.secondstage;</pstext>
    </ps>
    <ps name="shared/functions/aborts/LSInstructionSyndrome" mylink="shared.functions.aborts.LSInstructionSyndrome" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns the extended syndrome information for a second stage fault.
//  &lt;10&gt;  - Syndrome valid bit. The syndrome is only valid for certain types of access instruction.
//  &lt;9:8&gt; - Access size.
//  &lt;7&gt;   - Sign extended (for loads).
//  &lt;6:2&gt; - Transfer register.
//  &lt;1&gt;   - Transfer register is 64-bit.
//  &lt;0&gt;   - Instruction has acquire/release semantics.
bits(11) <anchor link="impl-shared.LSInstructionSyndrome.0" hover="function: bits(11) LSInstructionSyndrome()">LSInstructionSyndrome</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/cache/CACHE_OP" mylink="shared.functions.cache.CACHE_OP" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CACHE_OP()
// ==========
// Performs Cache maintenance operations as per CacheRecord.

<anchor link="impl-shared.CACHE_OP.1" hover="function: CACHE_OP(CacheRecord cache)">CACHE_OP</anchor>(<a link="CacheRecord" file="shared_pseudocode.xml" hover="type CacheRecord is ( AccType acctype, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, bits(64) regval, FullAddress paddress, bits(64) vaddress, integer set, integer way, integer level, Shareability shareability, boolean translated, boolean is_vmid_valid, bits(16) vmid, boolean is_asid_valid, bits(16) asid, SecurityState security, CachePASpace cpas )">CacheRecord</a> cache)
    IMPLEMENTATION_DEFINED;</pstext>
    </ps>
    <ps name="shared/functions/cache/CPASAtPAS" mylink="shared.functions.cache.CPASAtPAS" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CPASAtPAS()
// ===========
// Get cache PA space for given PA space.

CachePASpace <anchor link="impl-shared.CPASAtPAS.1" hover="function: CachePASpace CPASAtPAS(PASpace pas)">CPASAtPAS</anchor>(<a link="PASpace" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PASpace</a> pas)
    case pas of
        when <a link="PAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</a>
            return <a link="CPAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration CachePASpace {&#13; CPAS_NonSecure,&#13; CPAS_SecureNonSecure, CPAS_Secure&#13; }">CPAS_NonSecure</a>;
        when <a link="PAS_Secure" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_Secure</a>
            return <a link="CPAS_Secure" file="shared_pseudocode.xml" hover="enumeration CachePASpace {&#13; CPAS_NonSecure,&#13; CPAS_SecureNonSecure, CPAS_Secure&#13; }">CPAS_Secure</a>;</pstext>
    </ps>
    <ps name="shared/functions/cache/CPASAtSecurityState" mylink="shared.functions.cache.CPASAtSecurityState" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CPASAtSecurityState()
// =====================
// Get cache PA space for given security state.

CachePASpace <anchor link="impl-shared.CPASAtSecurityState.1" hover="function: CachePASpace CPASAtSecurityState(SecurityState ss)">CPASAtSecurityState</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss)
    case ss of
        when <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a>
            return <a link="CPAS_NonSecure" file="shared_pseudocode.xml" hover="enumeration CachePASpace {&#13; CPAS_NonSecure,&#13; CPAS_SecureNonSecure, CPAS_Secure&#13; }">CPAS_NonSecure</a>;
        when <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>
            return <a link="CPAS_SecureNonSecure" file="shared_pseudocode.xml" hover="enumeration CachePASpace {&#13; CPAS_NonSecure,&#13; CPAS_SecureNonSecure, CPAS_Secure&#13; }">CPAS_SecureNonSecure</a>;</pstext>
    </ps>
    <ps name="shared/functions/cache/CacheOp" mylink="shared.functions.cache.CacheOp" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="CacheOp" hover="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp</anchor> {
    <anchor link="CacheOp_Clean" hover="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Clean</anchor>,
    <anchor link="CacheOp_Invalidate" hover="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Invalidate</anchor>,
    <anchor link="CacheOp_CleanInvalidate" hover="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_CleanInvalidate</anchor>
};</pstext>
    </ps>
    <ps name="shared/functions/cache/CacheOpScope" mylink="shared.functions.cache.CacheOpScope" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="CacheOpScope" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</anchor> {
    <anchor link="CacheOpScope_SetWay" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_SetWay</anchor>,
    <anchor link="CacheOpScope_PoU" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoU</anchor>,
    <anchor link="CacheOpScope_PoC" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoC</anchor>,
    <anchor link="CacheOpScope_PoP" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoP</anchor>,
    <anchor link="CacheOpScope_PoDP" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoDP</anchor>,
    <anchor link="CacheOpScope_ALLU" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_ALLU</anchor>,
    <anchor link="CacheOpScope_ALLUIS" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_ALLUIS</anchor>
};</pstext>
    </ps>
    <ps name="shared/functions/cache/CachePASpace" mylink="shared.functions.cache.CachePASpace" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="CachePASpace" hover="enumeration CachePASpace {&#13; CPAS_NonSecure,&#13; CPAS_SecureNonSecure, CPAS_Secure&#13; }">CachePASpace</anchor> {
    <anchor link="CPAS_NonSecure" hover="enumeration CachePASpace {&#13; CPAS_NonSecure,&#13; CPAS_SecureNonSecure, CPAS_Secure&#13; }">CPAS_NonSecure</anchor>,
    <anchor link="CPAS_SecureNonSecure" hover="enumeration CachePASpace {&#13; CPAS_NonSecure,&#13; CPAS_SecureNonSecure, CPAS_Secure&#13; }">CPAS_SecureNonSecure</anchor>,   // match entries from Secure or Non-Secure PAS
    <anchor link="CPAS_Secure" hover="enumeration CachePASpace {&#13; CPAS_NonSecure,&#13; CPAS_SecureNonSecure, CPAS_Secure&#13; }">CPAS_Secure</anchor>
};</pstext>
    </ps>
    <ps name="shared/functions/cache/CacheRecord" mylink="shared.functions.cache.CacheRecord" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">type <anchor link="CacheRecord" hover="type CacheRecord is ( AccType acctype, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, bits(64) regval, FullAddress paddress, bits(64) vaddress, integer set, integer way, integer level, Shareability shareability, boolean translated, boolean is_vmid_valid, bits(16) vmid, boolean is_asid_valid, bits(16) asid, SecurityState security, CachePASpace cpas )">CacheRecord</anchor> is (
    <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a>          acctype,           // Access type
    <a link="CacheOp" file="shared_pseudocode.xml" hover="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp</a>          cacheop,           // Cache operation
    <a link="CacheOpScope" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a>     opscope,           // Cache operation type
    <a link="CacheType" file="shared_pseudocode.xml" hover="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType</a>        cachetype,         // Cache type
    bits(64)         regval,
    <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a>      paddress,
    bits(64)         vaddress,          // For VA operations
    integer          set,               // For SW operations
    integer          way,               // For SW operations
    integer          level,             // For SW operations
    <a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a>     shareability,
    boolean          translated,
    boolean          is_vmid_valid,     // is vmid valid for current context
    bits(16)         vmid,
    boolean          is_asid_valid,     // is asid valid for current context
    bits(16)         asid,
    <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a>    security,
    // For cache operations to full cache or by set/way
    // For operations by address, PA space in paddress
    <a link="CachePASpace" file="shared_pseudocode.xml" hover="enumeration CachePASpace {&#13; CPAS_NonSecure,&#13; CPAS_SecureNonSecure, CPAS_Secure&#13; }">CachePASpace</a>     cpas
)</pstext>
    </ps>
    <ps name="shared/functions/cache/CacheType" mylink="shared.functions.cache.CacheType" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="CacheType" hover="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType</anchor> {
    <anchor link="CacheType_Data" hover="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType_Data</anchor>,
    <anchor link="CacheType_Tag" hover="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType_Tag</anchor>,
    <anchor link="CacheType_Data_Tag" hover="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType_Data_Tag</anchor>,
    <anchor link="CacheType_Instruction" hover="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType_Instruction</anchor>
};</pstext>
    </ps>
    <ps name="shared/functions/cache/DCInstNeedsTranslation" mylink="shared.functions.cache.DCInstNeedsTranslation" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// DCInstNeedsTranslation()
// ========================
// Check whether Data Cache operation needs translation.

boolean <anchor link="impl-shared.DCInstNeedsTranslation.1" hover="function: boolean DCInstNeedsTranslation(CacheOpScope opscope)">DCInstNeedsTranslation</anchor>(<a link="CacheOpScope" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a> opscope)
    if CLIDR_EL1.LoC == '000' then
        return !boolean IMPLEMENTATION_DEFINED "No fault generated for DC operations if PoC is before any level of cache";

    if CLIDR_EL1.LoUU == '000' &amp;&amp; opscope == <a link="CacheOpScope_PoU" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoU</a> then
        return !boolean IMPLEMENTATION_DEFINED "No fault generated for DC operations if PoU is before any level of cache";

    return TRUE;</pstext>
    </ps>
    <ps name="shared/functions/cache/DecodeSW" mylink="shared.functions.cache.DecodeSW" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// DecodeSW()
// ==========
// Decode input value into set, way and level for SW instructions.

(integer, integer, integer) <anchor link="impl-shared.DecodeSW.2" hover="function: (integer, integer, integer) DecodeSW(bits(64) regval, CacheType cachetype)">DecodeSW</anchor>(bits(64) regval, <a link="CacheType" file="shared_pseudocode.xml" hover="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType</a> cachetype)
    level = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(regval[3:1]);
    (set, way, linesize) = <a link="impl-shared.GetCacheInfo.2" file="shared_pseudocode.xml" hover="function: (integer, integer, integer) GetCacheInfo(integer level, CacheType cachetype)">GetCacheInfo</a>(level, cachetype);
    return (set, way, level);</pstext>
    </ps>
    <ps name="shared/functions/cache/GetCacheInfo" mylink="shared.functions.cache.GetCacheInfo" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns numsets, assosciativity &amp; linesize.
(integer, integer, integer) <anchor link="impl-shared.GetCacheInfo.2" hover="function: (integer, integer, integer) GetCacheInfo(integer level, CacheType cachetype)">GetCacheInfo</anchor>(integer level, <a link="CacheType" file="shared_pseudocode.xml" hover="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType</a> cachetype);</pstext>
    </ps>
    <ps name="shared/functions/cache/ICInstNeedsTranslation" mylink="shared.functions.cache.ICInstNeedsTranslation" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ICInstNeedsTranslation()
// ========================
// Check whether Instruction Cache operation needs translation.

boolean <anchor link="impl-shared.ICInstNeedsTranslation.1" hover="function: boolean ICInstNeedsTranslation(CacheOpScope opscope)">ICInstNeedsTranslation</anchor>(<a link="CacheOpScope" file="shared_pseudocode.xml" hover="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a> opscope)
    return boolean IMPLEMENTATION_DEFINED "Instruction Cache needs translation";</pstext>
    </ps>
    <ps name="shared/functions/common/ASR" mylink="shared.functions.common.ASR" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ASR()
// =====

bits(N) <anchor link="impl-shared.ASR.2" hover="function: bits(N) ASR(bits(N) x, integer shift)">ASR</anchor>(bits(N) x, integer shift)
    assert shift &gt;= 0;
    bits(N) result;
    if shift == 0 then
        result = x;
    else
        (result, -) = <a link="impl-shared.ASR_C.2" file="shared_pseudocode.xml" hover="function: (bits(N), bit) ASR_C(bits(N) x, integer shift)">ASR_C</a>(x, shift);
    return result;</pstext>
    </ps>
    <ps name="shared/functions/common/ASR_C" mylink="shared.functions.common.ASR_C" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ASR_C()
// =======

(bits(N), bit) <anchor link="impl-shared.ASR_C.2" hover="function: (bits(N), bit) ASR_C(bits(N) x, integer shift)">ASR_C</anchor>(bits(N) x, integer shift)
    assert shift &gt; 0;
    extended_x = <a link="impl-shared.SignExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) SignExtend(bits(M) x, integer N)">SignExtend</a>(x, shift+N);
    result = extended_x&lt;shift+N-1:shift&gt;;
    carry_out = extended_x&lt;shift-1&gt;;
    return (result, carry_out);</pstext>
    </ps>
    <ps name="shared/functions/common/Abs" mylink="shared.functions.common.Abs" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Abs()
// =====

integer <anchor link="impl-shared.Abs.1" hover="function: integer Abs(integer x)">Abs</anchor>(integer x)
    return if x &gt;= 0 then x else -x;

// Abs()
// =====

real <a link="impl-shared.Abs.1" file="shared_pseudocode.xml" hover="function: integer Abs(integer x)">Abs</a>(real x)
    return if x &gt;= 0.0 then x else -x;</pstext>
    </ps>
    <ps name="shared/functions/common/Align" mylink="shared.functions.common.Align" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Align()
// =======

integer <anchor link="impl-shared.Align.2" hover="function: integer Align(integer x, integer y)">Align</anchor>(integer x, integer y)
    return y * (x DIV y);

// Align()
// =======

bits(N) <a link="impl-shared.Align.2" file="shared_pseudocode.xml" hover="function: integer Align(integer x, integer y)">Align</a>(bits(N) x, integer y)
    return <a link="impl-shared.Align.2" file="shared_pseudocode.xml" hover="function: integer Align(integer x, integer y)">Align</a>(<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(x), y)&lt;N-1:0&gt;;</pstext>
    </ps>
    <ps name="shared/functions/common/BitCount" mylink="shared.functions.common.BitCount" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// BitCount()
// ==========

integer <anchor link="impl-shared.BitCount.1" hover="function: integer BitCount(bits(N) x)">BitCount</anchor>(bits(N) x)
    integer result = 0;
    for i = 0 to N-1
        if x&lt;i&gt; == '1' then
            result = result + 1;
    return result;</pstext>
    </ps>
    <ps name="shared/functions/common/CountLeadingSignBits" mylink="shared.functions.common.CountLeadingSignBits" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CountLeadingSignBits()
// ======================

integer <anchor link="impl-shared.CountLeadingSignBits.1" hover="function: integer CountLeadingSignBits(bits(N) x)">CountLeadingSignBits</anchor>(bits(N) x)
    return <a link="impl-shared.CountLeadingZeroBits.1" file="shared_pseudocode.xml" hover="function: integer CountLeadingZeroBits(bits(N) x)">CountLeadingZeroBits</a>(x&lt;N-1:1&gt; EOR x&lt;N-2:0&gt;);</pstext>
    </ps>
    <ps name="shared/functions/common/CountLeadingZeroBits" mylink="shared.functions.common.CountLeadingZeroBits" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CountLeadingZeroBits()
// ======================

integer <anchor link="impl-shared.CountLeadingZeroBits.1" hover="function: integer CountLeadingZeroBits(bits(N) x)">CountLeadingZeroBits</anchor>(bits(N) x)
    return N - (<a link="impl-shared.HighestSetBit.1" file="shared_pseudocode.xml" hover="function: integer HighestSetBit(bits(N) x)">HighestSetBit</a>(x) + 1);</pstext>
    </ps>
    <ps name="shared/functions/common/Elem" mylink="shared.functions.common.Elem" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Elem[] - non-assignment form
// ============================

bits(size) <anchor link="impl-shared.Elem.read.3" hover="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</anchor>[bits(N) vector, integer e, integer size]
    assert e &gt;= 0 &amp;&amp; (e+1)*size &lt;= N;
    return vector&lt;e*size+size-1 : e*size&gt;;

// Elem[] - non-assignment form
// ============================

bits(size) <anchor link="impl-shared.Elem.read.2" hover="accessor: bits(size) Elem[bits(N) vector, integer e]">Elem</anchor>[bits(N) vector, integer e]
    return <a link="impl-shared.Elem.read.3" file="shared_pseudocode.xml" hover="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[vector, e, size];

// Elem[] - assignment form
// ========================

<anchor link="impl-shared.Elem.write.3" hover="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</anchor>[bits(N) &amp;vector, integer e, integer size] = bits(size) value
    assert e &gt;= 0 &amp;&amp; (e+1)*size &lt;= N;
    vector&lt;(e+1)*size-1:e*size&gt; = value;
    return;

// Elem[] - assignment form
// ========================

<anchor link="impl-shared.Elem.write.2" hover="accessor: Elem[bits(N) &amp;vector, integer e] = bits(size) value">Elem</anchor>[bits(N) &amp;vector, integer e] = bits(size) value
    <a link="impl-shared.Elem.write.3" file="shared_pseudocode.xml" hover="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[vector, e, size] = value;
    return;</pstext>
    </ps>
    <ps name="shared/functions/common/Extend" mylink="shared.functions.common.Extend" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Extend()
// ========

bits(N) <anchor link="impl-shared.Extend.3" hover="function: bits(N) Extend(bits(M) x, integer N, boolean unsigned)">Extend</anchor>(bits(M) x, integer N, boolean unsigned)
    return if unsigned then <a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(x, N) else <a link="impl-shared.SignExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) SignExtend(bits(M) x, integer N)">SignExtend</a>(x, N);

// Extend()
// ========

bits(N) <anchor link="impl-shared.Extend.2" hover="function: bits(N) Extend(bits(M) x, boolean unsigned)">Extend</anchor>(bits(M) x, boolean unsigned)
    return <a link="impl-shared.Extend.3" file="shared_pseudocode.xml" hover="function: bits(N) Extend(bits(M) x, integer N, boolean unsigned)">Extend</a>(x, N, unsigned);</pstext>
    </ps>
    <ps name="shared/functions/common/HighestSetBit" mylink="shared.functions.common.HighestSetBit" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HighestSetBit()
// ===============

integer <anchor link="impl-shared.HighestSetBit.1" hover="function: integer HighestSetBit(bits(N) x)">HighestSetBit</anchor>(bits(N) x)
    for i = N-1 downto 0
        if x&lt;i&gt; == '1' then return i;
    return -1;</pstext>
    </ps>
    <ps name="shared/functions/common/Int" mylink="shared.functions.common.Int" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Int()
// =====

integer <anchor link="impl-shared.Int.2" hover="function: integer Int(bits(N) x, boolean unsigned)">Int</anchor>(bits(N) x, boolean unsigned)
    result = if unsigned then <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(x) else <a link="impl-shared.SInt.1" file="shared_pseudocode.xml" hover="function: integer SInt(bits(N) x)">SInt</a>(x);
    return result;</pstext>
    </ps>
    <ps name="shared/functions/common/IsOnes" mylink="shared.functions.common.IsOnes" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// IsOnes()
// ========

boolean <anchor link="impl-shared.IsOnes.1" hover="function: boolean IsOnes(bits(N) x)">IsOnes</anchor>(bits(N) x)
    return x == <a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(N);</pstext>
    </ps>
    <ps name="shared/functions/common/IsZero" mylink="shared.functions.common.IsZero" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// IsZero()
// ========

boolean <anchor link="impl-shared.IsZero.1" hover="function: boolean IsZero(bits(N) x)">IsZero</anchor>(bits(N) x)
    return x == <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(N);</pstext>
    </ps>
    <ps name="shared/functions/common/IsZeroBit" mylink="shared.functions.common.IsZeroBit" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// IsZeroBit()
// ===========

bit <anchor link="impl-shared.IsZeroBit.1" hover="function: bit IsZeroBit(bits(N) x)">IsZeroBit</anchor>(bits(N) x)
    return if <a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(x) then '1' else '0';</pstext>
    </ps>
    <ps name="shared/functions/common/LSL" mylink="shared.functions.common.LSL" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// LSL()
// =====

bits(N) <anchor link="impl-shared.LSL.2" hover="function: bits(N) LSL(bits(N) x, integer shift)">LSL</anchor>(bits(N) x, integer shift)
    assert shift &gt;= 0;
    bits(N) result;
    if shift == 0 then
        result = x;
    else
        (result, -) = <a link="impl-shared.LSL_C.2" file="shared_pseudocode.xml" hover="function: (bits(N), bit) LSL_C(bits(N) x, integer shift)">LSL_C</a>(x, shift);
    return result;</pstext>
    </ps>
    <ps name="shared/functions/common/LSL_C" mylink="shared.functions.common.LSL_C" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// LSL_C()
// =======

(bits(N), bit) <anchor link="impl-shared.LSL_C.2" hover="function: (bits(N), bit) LSL_C(bits(N) x, integer shift)">LSL_C</anchor>(bits(N) x, integer shift)
    assert shift &gt; 0;
    extended_x = x : <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(shift);
    result = extended_x&lt;N-1:0&gt;;
    carry_out = extended_x&lt;N&gt;;
    return (result, carry_out);</pstext>
    </ps>
    <ps name="shared/functions/common/LSR" mylink="shared.functions.common.LSR" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// LSR()
// =====

bits(N) <anchor link="impl-shared.LSR.2" hover="function: bits(N) LSR(bits(N) x, integer shift)">LSR</anchor>(bits(N) x, integer shift)
    assert shift &gt;= 0;
    bits(N) result;
    if shift == 0 then
        result = x;
    else
        (result, -) = <a link="impl-shared.LSR_C.2" file="shared_pseudocode.xml" hover="function: (bits(N), bit) LSR_C(bits(N) x, integer shift)">LSR_C</a>(x, shift);
    return result;</pstext>
    </ps>
    <ps name="shared/functions/common/LSR_C" mylink="shared.functions.common.LSR_C" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// LSR_C()
// =======

(bits(N), bit) <anchor link="impl-shared.LSR_C.2" hover="function: (bits(N), bit) LSR_C(bits(N) x, integer shift)">LSR_C</anchor>(bits(N) x, integer shift)
    assert shift &gt; 0;
    extended_x = <a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(x, shift+N);
    result = extended_x&lt;shift+N-1:shift&gt;;
    carry_out = extended_x&lt;shift-1&gt;;
    return (result, carry_out);</pstext>
    </ps>
    <ps name="shared/functions/common/LowestSetBit" mylink="shared.functions.common.LowestSetBit" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// LowestSetBit()
// ==============

integer <anchor link="impl-shared.LowestSetBit.1" hover="function: integer LowestSetBit(bits(N) x)">LowestSetBit</anchor>(bits(N) x)
    for i = 0 to N-1
        if x&lt;i&gt; == '1' then return i;
    return N;</pstext>
    </ps>
    <ps name="shared/functions/common/Max" mylink="shared.functions.common.Max" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Max()
// =====

integer <anchor link="impl-shared.Max.2" hover="function: integer Max(integer a, integer b)">Max</anchor>(integer a, integer b)
    return if a &gt;= b then a else b;

// Max()
// =====

real <a link="impl-shared.Max.2" file="shared_pseudocode.xml" hover="function: integer Max(integer a, integer b)">Max</a>(real a, real b)
    return if a &gt;= b then a else b;</pstext>
    </ps>
    <ps name="shared/functions/common/Min" mylink="shared.functions.common.Min" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Min()
// =====

integer <anchor link="impl-shared.Min.2" hover="function: integer Min(integer a, integer b)">Min</anchor>(integer a, integer b)
    return if a &lt;= b then a else b;

// Min()
// =====

real <a link="impl-shared.Min.2" file="shared_pseudocode.xml" hover="function: integer Min(integer a, integer b)">Min</a>(real a, real b)
    return if a &lt;= b then a else b;</pstext>
    </ps>
    <ps name="shared/functions/common/Ones" mylink="shared.functions.common.Ones" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Ones()
// ======

bits(N) <anchor link="impl-shared.Ones.1" hover="function: bits(N) Ones(integer N)">Ones</anchor>(integer N)
    return <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>('1',N);

// Ones()
// ======

bits(N) <anchor link="impl-shared.Ones.0" hover="function: bits(N) Ones()">Ones</anchor>()
    return <a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(N);</pstext>
    </ps>
    <ps name="shared/functions/common/ROR" mylink="shared.functions.common.ROR" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ROR()
// =====

bits(N) <anchor link="impl-shared.ROR.2" hover="function: bits(N) ROR(bits(N) x, integer shift)">ROR</anchor>(bits(N) x, integer shift)
    assert shift &gt;= 0;
    bits(N) result;
    if shift == 0 then
        result = x;
    else
        (result, -) = <a link="impl-shared.ROR_C.2" file="shared_pseudocode.xml" hover="function: (bits(N), bit) ROR_C(bits(N) x, integer shift)">ROR_C</a>(x, shift);
    return result;</pstext>
    </ps>
    <ps name="shared/functions/common/ROR_C" mylink="shared.functions.common.ROR_C" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ROR_C()
// =======

(bits(N), bit) <anchor link="impl-shared.ROR_C.2" hover="function: (bits(N), bit) ROR_C(bits(N) x, integer shift)">ROR_C</anchor>(bits(N) x, integer shift)
    assert shift != 0;
    m = shift MOD N;
    result = <a link="impl-shared.LSR.2" file="shared_pseudocode.xml" hover="function: bits(N) LSR(bits(N) x, integer shift)">LSR</a>(x,m) OR <a link="impl-shared.LSL.2" file="shared_pseudocode.xml" hover="function: bits(N) LSL(bits(N) x, integer shift)">LSL</a>(x,N-m);
    carry_out = result&lt;N-1&gt;;
    return (result, carry_out);</pstext>
    </ps>
    <ps name="shared/functions/common/Replicate" mylink="shared.functions.common.Replicate" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Replicate()
// ===========

bits(N) <anchor link="impl-shared.Replicate.1" hover="function: bits(N) Replicate(bits(M) x)">Replicate</anchor>(bits(M) x)
    assert N MOD M == 0;
    return <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(x, N DIV M);

bits(M*N) <anchor link="impl-shared.Replicate.2" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</anchor>(bits(M) x, integer N);</pstext>
    </ps>
    <ps name="shared/functions/common/RoundDown" mylink="shared.functions.common.RoundDown" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">integer <anchor link="impl-shared.RoundDown.1" hover="function: integer RoundDown(real x)">RoundDown</anchor>(real x);</pstext>
    </ps>
    <ps name="shared/functions/common/RoundTowardsZero" mylink="shared.functions.common.RoundTowardsZero" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// RoundTowardsZero()
// ==================

integer <anchor link="impl-shared.RoundTowardsZero.1" hover="function: integer RoundTowardsZero(real x)">RoundTowardsZero</anchor>(real x)
    return if x == 0.0 then 0 else if x &gt;= 0.0 then <a link="impl-shared.RoundDown.1" file="shared_pseudocode.xml" hover="function: integer RoundDown(real x)">RoundDown</a>(x) else <a link="impl-shared.RoundUp.1" file="shared_pseudocode.xml" hover="function: integer RoundUp(real x)">RoundUp</a>(x);</pstext>
    </ps>
    <ps name="shared/functions/common/RoundUp" mylink="shared.functions.common.RoundUp" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">integer <anchor link="impl-shared.RoundUp.1" hover="function: integer RoundUp(real x)">RoundUp</anchor>(real x);</pstext>
    </ps>
    <ps name="shared/functions/common/SInt" mylink="shared.functions.common.SInt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SInt()
// ======

integer <anchor link="impl-shared.SInt.1" hover="function: integer SInt(bits(N) x)">SInt</anchor>(bits(N) x)
    result = 0;
    for i = 0 to N-1
        if x&lt;i&gt; == '1' then result = result + 2^i;
    if x&lt;N-1&gt; == '1' then result = result - 2^N;
    return result;</pstext>
    </ps>
    <ps name="shared/functions/common/SignExtend" mylink="shared.functions.common.SignExtend" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SignExtend()
// ============

bits(N) <anchor link="impl-shared.SignExtend.2" hover="function: bits(N) SignExtend(bits(M) x, integer N)">SignExtend</anchor>(bits(M) x, integer N)
    assert N &gt;= M;
    return <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(x&lt;M-1&gt;, N-M) : x;

// SignExtend()
// ============

bits(N) <anchor link="impl-shared.SignExtend.1" hover="function: bits(N) SignExtend(bits(M) x)">SignExtend</anchor>(bits(M) x)
    return <a link="impl-shared.SignExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) SignExtend(bits(M) x, integer N)">SignExtend</a>(x, N);</pstext>
    </ps>
    <ps name="shared/functions/common/Split64to32" mylink="shared.functions.common.Split64to32" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Split64to32()
// =============

(bits(32), bits(32)) <anchor link="impl-shared.Split64to32.1" hover="function: (bits(32), bits(32)) Split64to32(bits(64) value)">Split64to32</anchor>(bits(64) value)
    return (value&lt;63:32&gt;, value&lt;31:0&gt;);</pstext>
    </ps>
    <ps name="shared/functions/common/UInt" mylink="shared.functions.common.UInt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// UInt()
// ======

integer <anchor link="impl-shared.UInt.1" hover="function: integer UInt(bits(N) x)">UInt</anchor>(bits(N) x)
    result = 0;
    for i = 0 to N-1
        if x&lt;i&gt; == '1' then result = result + 2^i;
    return result;</pstext>
    </ps>
    <ps name="shared/functions/common/ZeroExtend" mylink="shared.functions.common.ZeroExtend" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ZeroExtend()
// ============

bits(N) <anchor link="impl-shared.ZeroExtend.2" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</anchor>(bits(M) x, integer N)
    assert N &gt;= M;
    return <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(N-M) : x;

// ZeroExtend()
// ============

bits(N) <anchor link="impl-shared.ZeroExtend.1" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</anchor>(bits(M) x)
    return <a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(x, N);</pstext>
    </ps>
    <ps name="shared/functions/common/Zeros" mylink="shared.functions.common.Zeros" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Zeros()
// =======

bits(N) <anchor link="impl-shared.Zeros.1" hover="function: bits(N) Zeros(integer N)">Zeros</anchor>(integer N)
    return <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>('0',N);

// Zeros()
// =======

bits(N) <anchor link="impl-shared.Zeros.0" hover="function: bits(N) Zeros()">Zeros</anchor>()
    return <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(N);</pstext>
    </ps>
    <ps name="shared/functions/counters/AArch32.CheckTimerConditions" mylink="shared.functions.counters.AArch32.CheckTimerConditions" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.CheckTimerConditions()
// ==============================
// Checking timer conditions for all A32 timer registers

<anchor link="AArch32.CheckTimerConditions.0" hover="function: AArch32.CheckTimerConditions()">AArch32.CheckTimerConditions</anchor>()
    boolean status;
    bits(64) offset;
    offset = <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(64);
    assert !<a link="impl-shared.HaveAArch64.0" file="shared_pseudocode.xml" hover="function: boolean HaveAArch64()">HaveAArch64</a>();

    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
        if CNTP_CTL_S.ENABLE == '1' then
            status = <a link="impl-shared.IsTimerConditionMet.4" file="shared_pseudocode.xml" hover="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(offset, CNTP_CVAL_S,
                                         CNTP_CTL_S.IMASK, <a link="InterruptID_CNTPS" file="shared_pseudocode.xml" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTPS</a>);
            CNTP_CTL_S.ISTATUS = if status then '1' else '0';

        if CNTP_CTL_NS.ENABLE == '1' then
            status = <a link="impl-shared.IsTimerConditionMet.4" file="shared_pseudocode.xml" hover="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(offset, CNTP_CVAL_NS,
                                         CNTP_CTL_NS.IMASK, <a link="InterruptID_CNTP" file="shared_pseudocode.xml" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTP</a>);
            CNTP_CTL_NS.ISTATUS = if status then '1' else '0';
    else
        if CNTP_CTL.ENABLE == '1' then
            status = <a link="impl-shared.IsTimerConditionMet.4" file="shared_pseudocode.xml" hover="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(offset, CNTP_CVAL,
                                         CNTP_CTL.IMASK, <a link="InterruptID_CNTP" file="shared_pseudocode.xml" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTP</a>);
            CNTP_CTL.ISTATUS = if status then '1' else '0';

    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; CNTHP_CTL.ENABLE == '1' then
        status = <a link="impl-shared.IsTimerConditionMet.4" file="shared_pseudocode.xml" hover="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(offset, CNTHP_CVAL,
                                     CNTHP_CTL.IMASK, <a link="InterruptID_CNTHP" file="shared_pseudocode.xml" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTHP</a>);
        CNTHP_CTL.ISTATUS = if status then '1' else '0';

    if CNTV_CTL_EL0.ENABLE == '1' then
        status = <a link="impl-shared.IsTimerConditionMet.4" file="shared_pseudocode.xml" hover="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(CNTVOFF_EL2, CNTV_CVAL_EL0,
                                     CNTV_CTL_EL0.IMASK, <a link="InterruptID_CNTV" file="shared_pseudocode.xml" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTV</a>);
        CNTV_CTL_EL0.ISTATUS = if status then '1' else '0';

    return;</pstext>
    </ps>
    <ps name="shared/functions/counters/AArch64.CheckTimerConditions" mylink="shared.functions.counters.AArch64.CheckTimerConditions" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.CheckTimerConditions()
// ==============================
// Checking timer conditions for all A64 timer registers

<anchor link="AArch64.CheckTimerConditions.0" hover="function: AArch64.CheckTimerConditions()">AArch64.CheckTimerConditions</anchor>()
    boolean status;
    bits(64) offset;
    boolean ecv = FALSE;
    if <a link="impl-shared.HaveECVExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveECVExt()">HaveECVExt</a>() then
        ecv = CNTHCTL_EL2.ECV == '1' &amp;&amp; SCR_EL3.ECVEn == '1' &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>();
    if ecv then
        offset = CNTPOFF_EL2;
    else
        offset = <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(64);

    if CNTP_CTL_EL0.ENABLE == '1' then
        status = <a link="impl-shared.IsTimerConditionMet.4" file="shared_pseudocode.xml" hover="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(offset, CNTP_CVAL_EL0,
                                     CNTP_CTL_EL0.IMASK, <a link="InterruptID_CNTP" file="shared_pseudocode.xml" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTP</a>);
        CNTP_CTL_EL0.ISTATUS = if status then '1' else '0';
    if ((<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) || (<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; !<a link="impl-shared.HaveSecureEL2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>())) &amp;&amp;
       CNTHP_CTL_EL2.ENABLE == '1') then
        status = <a link="impl-shared.IsTimerConditionMet.4" file="shared_pseudocode.xml" hover="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(64), CNTHP_CVAL_EL2,
                                     CNTHP_CTL_EL2.IMASK, <a link="InterruptID_CNTHP" file="shared_pseudocode.xml" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTHP</a>);
        CNTHP_CTL_EL2.ISTATUS = if status then '1' else '0';
    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; <a link="impl-shared.HaveSecureEL2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() &amp;&amp; CNTHPS_CTL_EL2.ENABLE == '1' then
        status = <a link="impl-shared.IsTimerConditionMet.4" file="shared_pseudocode.xml" hover="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(64), CNTHPS_CVAL_EL2,
                                     CNTHPS_CTL_EL2.IMASK, <a link="InterruptID_CNTHPS" file="shared_pseudocode.xml" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTHPS</a>);
        CNTHPS_CTL_EL2.ISTATUS = if status then '1' else '0';

    if CNTPS_CTL_EL1.ENABLE == '1' then
        status = <a link="impl-shared.IsTimerConditionMet.4" file="shared_pseudocode.xml" hover="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(offset, CNTPS_CVAL_EL1,
                                     CNTPS_CTL_EL1.IMASK, <a link="InterruptID_CNTPS" file="shared_pseudocode.xml" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTPS</a>);
        CNTPS_CTL_EL1.ISTATUS = if status then '1' else '0';

    if CNTV_CTL_EL0.ENABLE == '1' then
        status = <a link="impl-shared.IsTimerConditionMet.4" file="shared_pseudocode.xml" hover="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(CNTVOFF_EL2, CNTV_CVAL_EL0,
                                     CNTV_CTL_EL0.IMASK, <a link="InterruptID_CNTV" file="shared_pseudocode.xml" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTV</a>);
        CNTV_CTL_EL0.ISTATUS = if status then '1' else '0';

    if ((<a link="impl-shared.HaveVirtHostExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; (<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) || !<a link="impl-shared.HaveSecureEL2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>())) &amp;&amp;
        CNTHV_CTL_EL2.ENABLE == '1') then
        status = <a link="impl-shared.IsTimerConditionMet.4" file="shared_pseudocode.xml" hover="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(64), CNTHV_CVAL_EL2,
                                     CNTHV_CTL_EL2.IMASK, <a link="InterruptID_CNTHV" file="shared_pseudocode.xml" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTHV</a>);
        CNTHV_CTL_EL2.ISTATUS = if status then '1' else '0';

    if ((<a link="impl-shared.HaveSecureEL2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() &amp;&amp; <a link="impl-shared.HaveVirtHostExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>()) &amp;&amp;
        CNTHVS_CTL_EL2.ENABLE == '1') then
        status = <a link="impl-shared.IsTimerConditionMet.4" file="shared_pseudocode.xml" hover="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(64), CNTHVS_CVAL_EL2,
                                     CNTHVS_CTL_EL2.IMASK, <a link="InterruptID_CNTHVS" file="shared_pseudocode.xml" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTHVS</a>);
        CNTHVS_CTL_EL2.ISTATUS = if status then '1' else '0';
    return;</pstext>
    </ps>
    <ps name="shared/functions/counters/GenericCounterTick" mylink="shared.functions.counters.GenericCounterTick" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// GenericCounterTick()
// ====================
// Increments PhysicalCount value for every clock tick.

<anchor link="impl-shared.GenericCounterTick.0" hover="function: GenericCounterTick()">GenericCounterTick</anchor>()
    bits(64) prev_physical_count;
    if CNTCR.EN == '0' then
        if !<a link="impl-shared.HaveAArch64.0" file="shared_pseudocode.xml" hover="function: boolean HaveAArch64()">HaveAArch64</a>() then
            <a link="AArch32.CheckTimerConditions.0" file="shared_pseudocode.xml" hover="function: AArch32.CheckTimerConditions()">AArch32.CheckTimerConditions</a>();
        else
            <a link="AArch64.CheckTimerConditions.0" file="shared_pseudocode.xml" hover="function: AArch64.CheckTimerConditions()">AArch64.CheckTimerConditions</a>();
        return;
    prev_physical_count = <a link="impl-shared.PhysicalCountInt.0" file="shared_pseudocode.xml" hover="function: bits(64) PhysicalCountInt()">PhysicalCountInt</a>();
    if <a link="impl-shared.HaveCNTSCExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveCNTSCExt()">HaveCNTSCExt</a>() &amp;&amp; CNTCR.SCEN == '1' then
        PhysicalCount = PhysicalCount + <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(CNTSCR);
    else
        PhysicalCount&lt;87:24&gt; = PhysicalCount&lt;87:24&gt; + 1;
    if !<a link="impl-shared.HaveAArch64.0" file="shared_pseudocode.xml" hover="function: boolean HaveAArch64()">HaveAArch64</a>() then
        <a link="AArch32.CheckTimerConditions.0" file="shared_pseudocode.xml" hover="function: AArch32.CheckTimerConditions()">AArch32.CheckTimerConditions</a>();
    else
        <a link="AArch64.CheckTimerConditions.0" file="shared_pseudocode.xml" hover="function: AArch64.CheckTimerConditions()">AArch64.CheckTimerConditions</a>();
    <a link="impl-shared.TestEventCNTP.2" file="shared_pseudocode.xml" hover="function: TestEventCNTP(bits(64) prev_physical_count, bits(64) current_physical_count)">TestEventCNTP</a>(prev_physical_count, <a link="impl-shared.PhysicalCountInt.0" file="shared_pseudocode.xml" hover="function: bits(64) PhysicalCountInt()">PhysicalCountInt</a>());
    <a link="impl-shared.TestEventCNTV.2" file="shared_pseudocode.xml" hover="function: TestEventCNTV(bits(64) prev_physical_count, bits(64) current_physical_count)">TestEventCNTV</a>(prev_physical_count, <a link="impl-shared.PhysicalCountInt.0" file="shared_pseudocode.xml" hover="function: bits(64) PhysicalCountInt()">PhysicalCountInt</a>());
    return;</pstext>
    </ps>
    <ps name="shared/functions/counters/IsTimerConditionMet" mylink="shared.functions.counters.IsTimerConditionMet" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// IsTimerConditionMet()
// =====================

boolean <anchor link="impl-shared.IsTimerConditionMet.4" hover="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</anchor>(bits(64) offset, bits(64) compare_value,
                            bits(1) imask, <a link="InterruptID" file="shared_pseudocode.xml" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID</a> intid)
    boolean conditon_met;
    signal level;
    condition_met = (<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(<a link="impl-shared.PhysicalCountInt.0" file="shared_pseudocode.xml" hover="function: bits(64) PhysicalCountInt()">PhysicalCountInt</a>() - offset) -
                                        <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(compare_value)) &gt;= 0;
    level = if condition_met &amp;&amp; imask == '0' then HIGH else LOW;
    SetInterruptRequestLevel(intid, level);
    return condition_met;</pstext>
    </ps>
    <ps name="shared/functions/counters/PhysicalCount" mylink="shared.functions.counters.PhysicalCount" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">bits(88) PhysicalCount;</pstext>
    </ps>
    <ps name="shared/functions/counters/SetEventRegister" mylink="shared.functions.counters.SetEventRegister" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SetEventRegister()
// ==================
// Sets the Event Register of this PE

<anchor link="impl-shared.SetEventRegister.0" hover="function: SetEventRegister()">SetEventRegister</anchor>()
    EventRegister = '1';
    return;</pstext>
    </ps>
    <ps name="shared/functions/counters/TestEventCNTP" mylink="shared.functions.counters.TestEventCNTP" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// TestEventCNTP()
// ===============
// Generate Event stream from the physical counter

<anchor link="impl-shared.TestEventCNTP.2" hover="function: TestEventCNTP(bits(64) prev_physical_count, bits(64) current_physical_count)">TestEventCNTP</anchor>(bits(64) prev_physical_count, bits(64) current_physical_count)
    bits(64) offset;
    bits(1) samplebit, previousbit;
    if CNTHCTL_EL2.EVNTEN == '1' then
        n = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(CNTHCTL_EL2.EVNTI);
        if <a link="impl-shared.HaveECVExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveECVExt()">HaveECVExt</a>() &amp;&amp; CNTHCTL_EL2.EVNTIS == '1' then
            n = n + 8;
        boolean ecv = FALSE;
        if <a link="impl-shared.HaveECVExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveECVExt()">HaveECVExt</a>() then
            ecv = (<a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; CNTHCTL_EL2.ECV == '1' &amp;&amp;
                   SCR_EL3.ECVEn == '1');
            offset = if ecv then CNTPOFF_EL2 else <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(64);
        samplebit   = (current_physical_count - offset)&lt;n&gt;;
        previousbit = (prev_physical_count - offset)&lt;n&gt;;
        if CNTHCTL_EL2.EVNTDIR == '0' then
            if previousbit == '0' &amp;&amp; samplebit == '1' then <a link="impl-shared.SetEventRegister.0" file="shared_pseudocode.xml" hover="function: SetEventRegister()">SetEventRegister</a>();
        else
            if previousbit == '1' &amp;&amp; samplebit == '0' then <a link="impl-shared.SetEventRegister.0" file="shared_pseudocode.xml" hover="function: SetEventRegister()">SetEventRegister</a>();
    return;</pstext>
    </ps>
    <ps name="shared/functions/counters/TestEventCNTV" mylink="shared.functions.counters.TestEventCNTV" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// TestEventCNTV()
// ===============
// Generate Event stream from the virtual counter

<anchor link="impl-shared.TestEventCNTV.2" hover="function: TestEventCNTV(bits(64) prev_physical_count, bits(64) current_physical_count)">TestEventCNTV</anchor>(bits(64) prev_physical_count, bits(64) current_physical_count)
    bits(64) offset;
    bits(1) samplebit, previousbit;
    if (!(<a link="impl-shared.HaveVirtHostExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; == '11') &amp;&amp;
        CNTKCTL_EL1.EVNTEN == '1') then
        n = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(CNTKCTL_EL1.EVNTI);
        if <a link="impl-shared.HaveECVExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveECVExt()">HaveECVExt</a>() &amp;&amp; CNTKCTL_EL1.EVNTIS == '1' then
            n = n + 8;
        if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; (!<a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() || HCR_EL2.&lt;E2H,TGE&gt; != '11') then
            offset = CNTVOFF_EL2;
        else
            offset = <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(64);
        samplebit   = (current_physical_count - offset)&lt;n&gt;;
        previousbit = (prev_physical_count - offset)&lt;n&gt;;
        if CNTKCTL_EL1.EVNTDIR == '0' then
            if previousbit == '0' &amp;&amp; samplebit == '1' then <a link="impl-shared.SetEventRegister.0" file="shared_pseudocode.xml" hover="function: SetEventRegister()">SetEventRegister</a>();
        else
            if previousbit == '1' &amp;&amp; samplebit == '0' then <a link="impl-shared.SetEventRegister.0" file="shared_pseudocode.xml" hover="function: SetEventRegister()">SetEventRegister</a>();
    return;</pstext>
    </ps>
    <ps name="shared/functions/crc/BitReverse" mylink="shared.functions.crc.BitReverse" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// BitReverse()
// ============

bits(N) <anchor link="impl-shared.BitReverse.1" hover="function: bits(N) BitReverse(bits(N) data)">BitReverse</anchor>(bits(N) data)
    bits(N) result;
    for i = 0 to N-1
        result&lt;(N-i)-1&gt; = data&lt;i&gt;;
    return result;</pstext>
    </ps>
    <ps name="shared/functions/crc/HaveCRCExt" mylink="shared.functions.crc.HaveCRCExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveCRCExt()
// ============

boolean <anchor link="impl-shared.HaveCRCExt.0" hover="function: boolean HaveCRCExt()">HaveCRCExt</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p1" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p1</a>) || boolean IMPLEMENTATION_DEFINED "Have CRC extension";</pstext>
    </ps>
    <ps name="shared/functions/crc/Poly32Mod2" mylink="shared.functions.crc.Poly32Mod2" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Poly32Mod2()
// ============

// Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation

bits(32) <anchor link="impl-shared.Poly32Mod2.2" hover="function: bits(32) Poly32Mod2(bits(N) data_in, bits(32) poly)">Poly32Mod2</anchor>(bits(N) data_in, bits(32) poly)
    assert N &gt; 32;
    bits(N) data = data_in;
    for i = N-1 downto 32
        if data&lt;i&gt; == '1' then
            data&lt;i-1:0&gt; = data&lt;i-1:0&gt; EOR (poly:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(i-32));
    return data&lt;31:0&gt;;</pstext>
    </ps>
    <ps name="shared/functions/crypto/AESInvMixColumns" mylink="shared.functions.crypto.AESInvMixColumns" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AESInvMixColumns()
// ==================
// Transformation in the Inverse Cipher that is the inverse of AESMixColumns.

bits(128) <anchor link="impl-shared.AESInvMixColumns.1" hover="function: bits(128) AESInvMixColumns(bits (128) op)">AESInvMixColumns</anchor>(bits (128) op)
    bits(4*8) in0 = op&lt; 96+:8&gt; : op&lt; 64+:8&gt; : op&lt; 32+:8&gt; : op&lt;  0+:8&gt;;
    bits(4*8) in1 = op&lt;104+:8&gt; : op&lt; 72+:8&gt; : op&lt; 40+:8&gt; : op&lt;  8+:8&gt;;
    bits(4*8) in2 = op&lt;112+:8&gt; : op&lt; 80+:8&gt; : op&lt; 48+:8&gt; : op&lt; 16+:8&gt;;
    bits(4*8) in3 = op&lt;120+:8&gt; : op&lt; 88+:8&gt; : op&lt; 56+:8&gt; : op&lt; 24+:8&gt;;

    bits(4*8) out0;
    bits(4*8) out1;
    bits(4*8) out2;
    bits(4*8) out3;

    for c = 0 to 3
        out0&lt;c*8+:8&gt; =  <a link="impl-shared.FFmul0E.1" file="shared_pseudocode.xml" hover="function: bits(8) FFmul0E(bits(8) b)">FFmul0E</a>(in0&lt;c*8+:8&gt;) EOR <a link="impl-shared.FFmul0B.1" file="shared_pseudocode.xml" hover="function: bits(8) FFmul0B(bits(8) b)">FFmul0B</a>(in1&lt;c*8+:8&gt;) EOR <a link="impl-shared.FFmul0D.1" file="shared_pseudocode.xml" hover="function: bits(8) FFmul0D(bits(8) b)">FFmul0D</a>(in2&lt;c*8+:8&gt;) EOR <a link="impl-shared.FFmul09.1" file="shared_pseudocode.xml" hover="function: bits(8) FFmul09(bits(8) b)">FFmul09</a>(in3&lt;c*8+:8&gt;);
        out1&lt;c*8+:8&gt; =  <a link="impl-shared.FFmul09.1" file="shared_pseudocode.xml" hover="function: bits(8) FFmul09(bits(8) b)">FFmul09</a>(in0&lt;c*8+:8&gt;) EOR <a link="impl-shared.FFmul0E.1" file="shared_pseudocode.xml" hover="function: bits(8) FFmul0E(bits(8) b)">FFmul0E</a>(in1&lt;c*8+:8&gt;) EOR <a link="impl-shared.FFmul0B.1" file="shared_pseudocode.xml" hover="function: bits(8) FFmul0B(bits(8) b)">FFmul0B</a>(in2&lt;c*8+:8&gt;) EOR <a link="impl-shared.FFmul0D.1" file="shared_pseudocode.xml" hover="function: bits(8) FFmul0D(bits(8) b)">FFmul0D</a>(in3&lt;c*8+:8&gt;);
        out2&lt;c*8+:8&gt; =  <a link="impl-shared.FFmul0D.1" file="shared_pseudocode.xml" hover="function: bits(8) FFmul0D(bits(8) b)">FFmul0D</a>(in0&lt;c*8+:8&gt;) EOR <a link="impl-shared.FFmul09.1" file="shared_pseudocode.xml" hover="function: bits(8) FFmul09(bits(8) b)">FFmul09</a>(in1&lt;c*8+:8&gt;) EOR <a link="impl-shared.FFmul0E.1" file="shared_pseudocode.xml" hover="function: bits(8) FFmul0E(bits(8) b)">FFmul0E</a>(in2&lt;c*8+:8&gt;) EOR <a link="impl-shared.FFmul0B.1" file="shared_pseudocode.xml" hover="function: bits(8) FFmul0B(bits(8) b)">FFmul0B</a>(in3&lt;c*8+:8&gt;);
        out3&lt;c*8+:8&gt; =  <a link="impl-shared.FFmul0B.1" file="shared_pseudocode.xml" hover="function: bits(8) FFmul0B(bits(8) b)">FFmul0B</a>(in0&lt;c*8+:8&gt;) EOR <a link="impl-shared.FFmul0D.1" file="shared_pseudocode.xml" hover="function: bits(8) FFmul0D(bits(8) b)">FFmul0D</a>(in1&lt;c*8+:8&gt;) EOR <a link="impl-shared.FFmul09.1" file="shared_pseudocode.xml" hover="function: bits(8) FFmul09(bits(8) b)">FFmul09</a>(in2&lt;c*8+:8&gt;) EOR <a link="impl-shared.FFmul0E.1" file="shared_pseudocode.xml" hover="function: bits(8) FFmul0E(bits(8) b)">FFmul0E</a>(in3&lt;c*8+:8&gt;);

    return (
        out3&lt;3*8+:8&gt; : out2&lt;3*8+:8&gt; : out1&lt;3*8+:8&gt; : out0&lt;3*8+:8&gt; :
        out3&lt;2*8+:8&gt; : out2&lt;2*8+:8&gt; : out1&lt;2*8+:8&gt; : out0&lt;2*8+:8&gt; :
        out3&lt;1*8+:8&gt; : out2&lt;1*8+:8&gt; : out1&lt;1*8+:8&gt; : out0&lt;1*8+:8&gt; :
        out3&lt;0*8+:8&gt; : out2&lt;0*8+:8&gt; : out1&lt;0*8+:8&gt; : out0&lt;0*8+:8&gt;
    );</pstext>
    </ps>
    <ps name="shared/functions/crypto/AESInvShiftRows" mylink="shared.functions.crypto.AESInvShiftRows" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AESInvShiftRows()
// =================
// Transformation in the Inverse Cipher that is inverse of AESShiftRows.

bits(128) <anchor link="impl-shared.AESInvShiftRows.1" hover="function: bits(128) AESInvShiftRows(bits(128) op)">AESInvShiftRows</anchor>(bits(128) op)
    return (
        op&lt; 31: 24&gt; : op&lt; 55: 48&gt; : op&lt; 79: 72&gt; : op&lt;103: 96&gt; :
        op&lt;127:120&gt; : op&lt; 23: 16&gt; : op&lt; 47: 40&gt; : op&lt; 71: 64&gt; :
        op&lt; 95: 88&gt; : op&lt;119:112&gt; : op&lt; 15:  8&gt; : op&lt; 39: 32&gt; :
        op&lt; 63: 56&gt; : op&lt; 87: 80&gt; : op&lt;111:104&gt; : op&lt;  7:  0&gt;
    );</pstext>
    </ps>
    <ps name="shared/functions/crypto/AESInvSubBytes" mylink="shared.functions.crypto.AESInvSubBytes" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AESInvSubBytes()
// ================
// Transformation in the Inverse Cipher that is the inverse of AESSubBytes.

bits(128) <anchor link="impl-shared.AESInvSubBytes.1" hover="function: bits(128) AESInvSubBytes(bits(128) op)">AESInvSubBytes</anchor>(bits(128) op)
    // Inverse S-box values
    bits(16*16*8) GF2_inv = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0x7d0c2155631469e126d677ba7e042b17&lt;127:0&gt; :
        /*E*/ 0x619953833cbbebc8b0f52aae4d3be0a0&lt;127:0&gt; :
        /*D*/ 0xef9cc9939f7ae52d0d4ab519a97f5160&lt;127:0&gt; :
        /*C*/ 0x5fec8027591012b131c7078833a8dd1f&lt;127:0&gt; :
        /*B*/ 0xf45acd78fec0db9a2079d2c64b3e56fc&lt;127:0&gt; :
        /*A*/ 0x1bbe18aa0e62b76f89c5291d711af147&lt;127:0&gt; :
        /*9*/ 0x6edf751ce837f9e28535ade72274ac96&lt;127:0&gt; :
        /*8*/ 0x73e6b4f0cecff297eadc674f4111913a&lt;127:0&gt; :
        /*7*/ 0x6b8a130103bdafc1020f3fca8f1e2cd0&lt;127:0&gt; :
        /*6*/ 0x0645b3b80558e4f70ad3bc8c00abd890&lt;127:0&gt; :
        /*5*/ 0x849d8da75746155edab9edfd5048706c&lt;127:0&gt; :
        /*4*/ 0x92b6655dcc5ca4d41698688664f6f872&lt;127:0&gt; :
        /*3*/ 0x25d18b6d49a25b76b224d92866a12e08&lt;127:0&gt; :
        /*2*/ 0x4ec3fa420b954cee3d23c2a632947b54&lt;127:0&gt; :
        /*1*/ 0xcbe9dec444438e3487ff2f9b8239e37c&lt;127:0&gt; :
        /*0*/ 0xfbd7f3819ea340bf38a53630d56a0952&lt;127:0&gt;
    );
    bits(128) out;
    for i = 0 to 15
        out&lt;i*8+:8&gt; = GF2_inv&lt;<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(op&lt;i*8+:8&gt;)*8+:8&gt;;
    return out;</pstext>
    </ps>
    <ps name="shared/functions/crypto/AESMixColumns" mylink="shared.functions.crypto.AESMixColumns" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AESMixColumns()
// ===============
// Transformation in the Cipher that takes all of the columns of the
// State and mixes their data (independently of one another) to
// produce new columns.

bits(128) <anchor link="impl-shared.AESMixColumns.1" hover="function: bits(128) AESMixColumns(bits (128) op)">AESMixColumns</anchor>(bits (128) op)
    bits(4*8) in0 = op&lt; 96+:8&gt; : op&lt; 64+:8&gt; : op&lt; 32+:8&gt; : op&lt;  0+:8&gt;;
    bits(4*8) in1 = op&lt;104+:8&gt; : op&lt; 72+:8&gt; : op&lt; 40+:8&gt; : op&lt;  8+:8&gt;;
    bits(4*8) in2 = op&lt;112+:8&gt; : op&lt; 80+:8&gt; : op&lt; 48+:8&gt; : op&lt; 16+:8&gt;;
    bits(4*8) in3 = op&lt;120+:8&gt; : op&lt; 88+:8&gt; : op&lt; 56+:8&gt; : op&lt; 24+:8&gt;;

    bits(4*8) out0;
    bits(4*8) out1;
    bits(4*8) out2;
    bits(4*8) out3;

    for c = 0 to 3
        out0&lt;c*8+:8&gt; =  <a link="impl-shared.FFmul02.1" file="shared_pseudocode.xml" hover="function: bits(8) FFmul02(bits(8) b)">FFmul02</a>(in0&lt;c*8+:8&gt;) EOR <a link="impl-shared.FFmul03.1" file="shared_pseudocode.xml" hover="function: bits(8) FFmul03(bits(8) b)">FFmul03</a>(in1&lt;c*8+:8&gt;) EOR         in2&lt;c*8+:8&gt;  EOR         in3&lt;c*8+:8&gt;;
        out1&lt;c*8+:8&gt; =          in0&lt;c*8+:8&gt;  EOR <a link="impl-shared.FFmul02.1" file="shared_pseudocode.xml" hover="function: bits(8) FFmul02(bits(8) b)">FFmul02</a>(in1&lt;c*8+:8&gt;) EOR <a link="impl-shared.FFmul03.1" file="shared_pseudocode.xml" hover="function: bits(8) FFmul03(bits(8) b)">FFmul03</a>(in2&lt;c*8+:8&gt;) EOR         in3&lt;c*8+:8&gt;;
        out2&lt;c*8+:8&gt; =          in0&lt;c*8+:8&gt;  EOR         in1&lt;c*8+:8&gt;  EOR <a link="impl-shared.FFmul02.1" file="shared_pseudocode.xml" hover="function: bits(8) FFmul02(bits(8) b)">FFmul02</a>(in2&lt;c*8+:8&gt;) EOR <a link="impl-shared.FFmul03.1" file="shared_pseudocode.xml" hover="function: bits(8) FFmul03(bits(8) b)">FFmul03</a>(in3&lt;c*8+:8&gt;);
        out3&lt;c*8+:8&gt; =  <a link="impl-shared.FFmul03.1" file="shared_pseudocode.xml" hover="function: bits(8) FFmul03(bits(8) b)">FFmul03</a>(in0&lt;c*8+:8&gt;) EOR         in1&lt;c*8+:8&gt;  EOR         in2&lt;c*8+:8&gt;  EOR <a link="impl-shared.FFmul02.1" file="shared_pseudocode.xml" hover="function: bits(8) FFmul02(bits(8) b)">FFmul02</a>(in3&lt;c*8+:8&gt;);

    return (
        out3&lt;3*8+:8&gt; : out2&lt;3*8+:8&gt; : out1&lt;3*8+:8&gt; : out0&lt;3*8+:8&gt; :
        out3&lt;2*8+:8&gt; : out2&lt;2*8+:8&gt; : out1&lt;2*8+:8&gt; : out0&lt;2*8+:8&gt; :
        out3&lt;1*8+:8&gt; : out2&lt;1*8+:8&gt; : out1&lt;1*8+:8&gt; : out0&lt;1*8+:8&gt; :
        out3&lt;0*8+:8&gt; : out2&lt;0*8+:8&gt; : out1&lt;0*8+:8&gt; : out0&lt;0*8+:8&gt;
    );</pstext>
    </ps>
    <ps name="shared/functions/crypto/AESShiftRows" mylink="shared.functions.crypto.AESShiftRows" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AESShiftRows()
// ==============
// Transformation in the Cipher that processes the State by cyclically
// shifting the last three rows of the State by different offsets.

bits(128) <anchor link="impl-shared.AESShiftRows.1" hover="function: bits(128) AESShiftRows(bits(128) op)">AESShiftRows</anchor>(bits(128) op)
    return (
        op&lt; 95: 88&gt; : op&lt; 55: 48&gt; : op&lt; 15:  8&gt; : op&lt;103: 96&gt; :
        op&lt; 63: 56&gt; : op&lt; 23: 16&gt; : op&lt;111:104&gt; : op&lt; 71: 64&gt; :
        op&lt; 31: 24&gt; : op&lt;119:112&gt; : op&lt; 79: 72&gt; : op&lt; 39: 32&gt; :
        op&lt;127:120&gt; : op&lt; 87: 80&gt; : op&lt; 47: 40&gt; : op&lt;  7:  0&gt;
    );</pstext>
    </ps>
    <ps name="shared/functions/crypto/AESSubBytes" mylink="shared.functions.crypto.AESSubBytes" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AESSubBytes()
// =============
// Transformation in the Cipher that processes the State using a nonlinear
// byte substitution table (S-box) that operates on each of the State bytes
// independently.

bits(128) <anchor link="impl-shared.AESSubBytes.1" hover="function: bits(128) AESSubBytes(bits(128) op)">AESSubBytes</anchor>(bits(128) op)
    // S-box values
    bits(16*16*8) GF2 = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0x16bb54b00f2d99416842e6bf0d89a18c&lt;127:0&gt; :
        /*E*/ 0xdf2855cee9871e9b948ed9691198f8e1&lt;127:0&gt; :
        /*D*/ 0x9e1dc186b95735610ef6034866b53e70&lt;127:0&gt; :
        /*C*/ 0x8a8bbd4b1f74dde8c6b4a61c2e2578ba&lt;127:0&gt; :
        /*B*/ 0x08ae7a65eaf4566ca94ed58d6d37c8e7&lt;127:0&gt; :
        /*A*/ 0x79e4959162acd3c25c2406490a3a32e0&lt;127:0&gt; :
        /*9*/ 0xdb0b5ede14b8ee4688902a22dc4f8160&lt;127:0&gt; :
        /*8*/ 0x73195d643d7ea7c41744975fec130ccd&lt;127:0&gt; :
        /*7*/ 0xd2f3ff1021dab6bcf5389d928f40a351&lt;127:0&gt; :
        /*6*/ 0xa89f3c507f02f94585334d43fbaaefd0&lt;127:0&gt; :
        /*5*/ 0xcf584c4a39becb6a5bb1fc20ed00d153&lt;127:0&gt; :
        /*4*/ 0x842fe329b3d63b52a05a6e1b1a2c8309&lt;127:0&gt; :
        /*3*/ 0x75b227ebe28012079a059618c323c704&lt;127:0&gt; :
        /*2*/ 0x1531d871f1e5a534ccf73f362693fdb7&lt;127:0&gt; :
        /*1*/ 0xc072a49cafa2d4adf04759fa7dc982ca&lt;127:0&gt; :
        /*0*/ 0x76abd7fe2b670130c56f6bf27b777c63&lt;127:0&gt;
    );
    bits(128) out;
    for i = 0 to 15
        out&lt;i*8+:8&gt; = GF2&lt;<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(op&lt;i*8+:8&gt;)*8+:8&gt;;
    return out;</pstext>
    </ps>
    <ps name="shared/functions/crypto/FFmul02" mylink="shared.functions.crypto.FFmul02" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FFmul02()
// =========

bits(8) <anchor link="impl-shared.FFmul02.1" hover="function: bits(8) FFmul02(bits(8) b)">FFmul02</anchor>(bits(8) b)
    bits(256*8) FFmul_02 = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0xE5E7E1E3EDEFE9EBF5F7F1F3FDFFF9FB&lt;127:0&gt; :
        /*E*/ 0xC5C7C1C3CDCFC9CBD5D7D1D3DDDFD9DB&lt;127:0&gt; :
        /*D*/ 0xA5A7A1A3ADAFA9ABB5B7B1B3BDBFB9BB&lt;127:0&gt; :
        /*C*/ 0x858781838D8F898B959791939D9F999B&lt;127:0&gt; :
        /*B*/ 0x656761636D6F696B757771737D7F797B&lt;127:0&gt; :
        /*A*/ 0x454741434D4F494B555751535D5F595B&lt;127:0&gt; :
        /*9*/ 0x252721232D2F292B353731333D3F393B&lt;127:0&gt; :
        /*8*/ 0x050701030D0F090B151711131D1F191B&lt;127:0&gt; :
        /*7*/ 0xFEFCFAF8F6F4F2F0EEECEAE8E6E4E2E0&lt;127:0&gt; :
        /*6*/ 0xDEDCDAD8D6D4D2D0CECCCAC8C6C4C2C0&lt;127:0&gt; :
        /*5*/ 0xBEBCBAB8B6B4B2B0AEACAAA8A6A4A2A0&lt;127:0&gt; :
        /*4*/ 0x9E9C9A98969492908E8C8A8886848280&lt;127:0&gt; :
        /*3*/ 0x7E7C7A78767472706E6C6A6866646260&lt;127:0&gt; :
        /*2*/ 0x5E5C5A58565452504E4C4A4846444240&lt;127:0&gt; :
        /*1*/ 0x3E3C3A38363432302E2C2A2826242220&lt;127:0&gt; :
        /*0*/ 0x1E1C1A18161412100E0C0A0806040200&lt;127:0&gt;
    );
    return FFmul_02&lt;<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(b)*8+:8&gt;;</pstext>
    </ps>
    <ps name="shared/functions/crypto/FFmul03" mylink="shared.functions.crypto.FFmul03" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FFmul03()
// =========

bits(8) <anchor link="impl-shared.FFmul03.1" hover="function: bits(8) FFmul03(bits(8) b)">FFmul03</anchor>(bits(8) b)
    bits(256*8) FFmul_03 = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0x1A191C1F16151013020104070E0D080B&lt;127:0&gt; :
        /*E*/ 0x2A292C2F26252023323134373E3D383B&lt;127:0&gt; :
        /*D*/ 0x7A797C7F76757073626164676E6D686B&lt;127:0&gt; :
        /*C*/ 0x4A494C4F46454043525154575E5D585B&lt;127:0&gt; :
        /*B*/ 0xDAD9DCDFD6D5D0D3C2C1C4C7CECDC8CB&lt;127:0&gt; :
        /*A*/ 0xEAE9ECEFE6E5E0E3F2F1F4F7FEFDF8FB&lt;127:0&gt; :
        /*9*/ 0xBAB9BCBFB6B5B0B3A2A1A4A7AEADA8AB&lt;127:0&gt; :
        /*8*/ 0x8A898C8F86858083929194979E9D989B&lt;127:0&gt; :
        /*7*/ 0x818287848D8E8B88999A9F9C95969390&lt;127:0&gt; :
        /*6*/ 0xB1B2B7B4BDBEBBB8A9AAAFACA5A6A3A0&lt;127:0&gt; :
        /*5*/ 0xE1E2E7E4EDEEEBE8F9FAFFFCF5F6F3F0&lt;127:0&gt; :
        /*4*/ 0xD1D2D7D4DDDEDBD8C9CACFCCC5C6C3C0&lt;127:0&gt; :
        /*3*/ 0x414247444D4E4B48595A5F5C55565350&lt;127:0&gt; :
        /*2*/ 0x717277747D7E7B78696A6F6C65666360&lt;127:0&gt; :
        /*1*/ 0x212227242D2E2B28393A3F3C35363330&lt;127:0&gt; :
        /*0*/ 0x111217141D1E1B18090A0F0C05060300&lt;127:0&gt;
    );
    return FFmul_03&lt;<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(b)*8+:8&gt;;</pstext>
    </ps>
    <ps name="shared/functions/crypto/FFmul09" mylink="shared.functions.crypto.FFmul09" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FFmul09()
// =========

bits(8) <anchor link="impl-shared.FFmul09.1" hover="function: bits(8) FFmul09(bits(8) b)">FFmul09</anchor>(bits(8) b)
    bits(256*8) FFmul_09 = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0x464F545D626B70790E071C152A233831&lt;127:0&gt; :
        /*E*/ 0xD6DFC4CDF2FBE0E99E978C85BAB3A8A1&lt;127:0&gt; :
        /*D*/ 0x7D746F6659504B42353C272E1118030A&lt;127:0&gt; :
        /*C*/ 0xEDE4FFF6C9C0DBD2A5ACB7BE8188939A&lt;127:0&gt; :
        /*B*/ 0x3039222B141D060F78716A635C554E47&lt;127:0&gt; :
        /*A*/ 0xA0A9B2BB848D969FE8E1FAF3CCC5DED7&lt;127:0&gt; :
        /*9*/ 0x0B0219102F263D34434A5158676E757C&lt;127:0&gt; :
        /*8*/ 0x9B928980BFB6ADA4D3DAC1C8F7FEE5EC&lt;127:0&gt; :
        /*7*/ 0xAAA3B8B18E879C95E2EBF0F9C6CFD4DD&lt;127:0&gt; :
        /*6*/ 0x3A3328211E170C05727B6069565F444D&lt;127:0&gt; :
        /*5*/ 0x9198838AB5BCA7AED9D0CBC2FDF4EFE6&lt;127:0&gt; :
        /*4*/ 0x0108131A252C373E49405B526D647F76&lt;127:0&gt; :
        /*3*/ 0xDCD5CEC7F8F1EAE3949D868FB0B9A2AB&lt;127:0&gt; :
        /*2*/ 0x4C455E5768617A73040D161F2029323B&lt;127:0&gt; :
        /*1*/ 0xE7EEF5FCC3CAD1D8AFA6BDB48B829990&lt;127:0&gt; :
        /*0*/ 0x777E656C535A41483F362D241B120900&lt;127:0&gt;
    );
    return FFmul_09&lt;<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(b)*8+:8&gt;;</pstext>
    </ps>
    <ps name="shared/functions/crypto/FFmul0B" mylink="shared.functions.crypto.FFmul0B" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FFmul0B()
// =========

bits(8) <anchor link="impl-shared.FFmul0B.1" hover="function: bits(8) FFmul0B(bits(8) b)">FFmul0B</anchor>(bits(8) b)
    bits(256*8) FFmul_0B = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0xA3A8B5BE8F849992FBF0EDE6D7DCC1CA&lt;127:0&gt; :
        /*E*/ 0x1318050E3F3429224B405D56676C717A&lt;127:0&gt; :
        /*D*/ 0xD8D3CEC5F4FFE2E9808B969DACA7BAB1&lt;127:0&gt; :
        /*C*/ 0x68637E75444F5259303B262D1C170A01&lt;127:0&gt; :
        /*B*/ 0x555E434879726F640D061B10212A373C&lt;127:0&gt; :
        /*A*/ 0xE5EEF3F8C9C2DFD4BDB6ABA0919A878C&lt;127:0&gt; :
        /*9*/ 0x2E2538330209141F767D606B5A514C47&lt;127:0&gt; :
        /*8*/ 0x9E958883B2B9A4AFC6CDD0DBEAE1FCF7&lt;127:0&gt; :
        /*7*/ 0x545F424978736E650C071A11202B363D&lt;127:0&gt; :
        /*6*/ 0xE4EFF2F9C8C3DED5BCB7AAA1909B868D&lt;127:0&gt; :
        /*5*/ 0x2F2439320308151E777C616A5B504D46&lt;127:0&gt; :
        /*4*/ 0x9F948982B3B8A5AEC7CCD1DAEBE0FDF6&lt;127:0&gt; :
        /*3*/ 0xA2A9B4BF8E859893FAF1ECE7D6DDC0CB&lt;127:0&gt; :
        /*2*/ 0x1219040F3E3528234A415C57666D707B&lt;127:0&gt; :
        /*1*/ 0xD9D2CFC4F5FEE3E8818A979CADA6BBB0&lt;127:0&gt; :
        /*0*/ 0x69627F74454E5358313A272C1D160B00&lt;127:0&gt;
    );
    return FFmul_0B&lt;<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(b)*8+:8&gt;;</pstext>
    </ps>
    <ps name="shared/functions/crypto/FFmul0D" mylink="shared.functions.crypto.FFmul0D" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FFmul0D()
// =========

bits(8) <anchor link="impl-shared.FFmul0D.1" hover="function: bits(8) FFmul0D(bits(8) b)">FFmul0D</anchor>(bits(8) b)
    bits(256*8) FFmul_0D = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0x979A8D80A3AEB9B4FFF2E5E8CBC6D1DC&lt;127:0&gt; :
        /*E*/ 0x474A5D50737E69642F2235381B16010C&lt;127:0&gt; :
        /*D*/ 0x2C21363B1815020F44495E53707D6A67&lt;127:0&gt; :
        /*C*/ 0xFCF1E6EBC8C5D2DF94998E83A0ADBAB7&lt;127:0&gt; :
        /*B*/ 0xFAF7E0EDCEC3D4D9929F8885A6ABBCB1&lt;127:0&gt; :
        /*A*/ 0x2A27303D1E130409424F5855767B6C61&lt;127:0&gt; :
        /*9*/ 0x414C5B5675786F622924333E1D10070A&lt;127:0&gt; :
        /*8*/ 0x919C8B86A5A8BFB2F9F4E3EECDC0D7DA&lt;127:0&gt; :
        /*7*/ 0x4D40575A7974636E25283F32111C0B06&lt;127:0&gt; :
        /*6*/ 0x9D90878AA9A4B3BEF5F8EFE2C1CCDBD6&lt;127:0&gt; :
        /*5*/ 0xF6FBECE1C2CFD8D59E938489AAA7B0BD&lt;127:0&gt; :
        /*4*/ 0x262B3C31121F08054E4354597A77606D&lt;127:0&gt; :
        /*3*/ 0x202D3A3714190E034845525F7C71666B&lt;127:0&gt; :
        /*2*/ 0xF0FDEAE7C4C9DED39895828FACA1B6BB&lt;127:0&gt; :
        /*1*/ 0x9B96818CAFA2B5B8F3FEE9E4C7CADDD0&lt;127:0&gt; :
        /*0*/ 0x4B46515C7F726568232E3934171A0D00&lt;127:0&gt;
    );
    return FFmul_0D&lt;<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(b)*8+:8&gt;;</pstext>
    </ps>
    <ps name="shared/functions/crypto/FFmul0E" mylink="shared.functions.crypto.FFmul0E" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FFmul0E()
// =========

bits(8) <anchor link="impl-shared.FFmul0E.1" hover="function: bits(8) FFmul0E(bits(8) b)">FFmul0E</anchor>(bits(8) b)
    bits(256*8) FFmul_0E = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0x8D83919FB5BBA9A7FDF3E1EFC5CBD9D7&lt;127:0&gt; :
        /*E*/ 0x6D63717F555B49471D13010F252B3937&lt;127:0&gt; :
        /*D*/ 0x56584A446E60727C26283A341E10020C&lt;127:0&gt; :
        /*C*/ 0xB6B8AAA48E80929CC6C8DAD4FEF0E2EC&lt;127:0&gt; :
        /*B*/ 0x202E3C321816040A505E4C426866747A&lt;127:0&gt; :
        /*A*/ 0xC0CEDCD2F8F6E4EAB0BEACA28886949A&lt;127:0&gt; :
        /*9*/ 0xFBF5E7E9C3CDDFD18B859799B3BDAFA1&lt;127:0&gt; :
        /*8*/ 0x1B150709232D3F316B657779535D4F41&lt;127:0&gt; :
        /*7*/ 0xCCC2D0DEF4FAE8E6BCB2A0AE848A9896&lt;127:0&gt; :
        /*6*/ 0x2C22303E141A08065C52404E646A7876&lt;127:0&gt; :
        /*5*/ 0x17190B052F21333D67697B755F51434D&lt;127:0&gt; :
        /*4*/ 0xF7F9EBE5CFC1D3DD87899B95BFB1A3AD&lt;127:0&gt; :
        /*3*/ 0x616F7D735957454B111F0D032927353B&lt;127:0&gt; :
        /*2*/ 0x818F9D93B9B7A5ABF1FFEDE3C9C7D5DB&lt;127:0&gt; :
        /*1*/ 0xBAB4A6A8828C9E90CAC4D6D8F2FCEEE0&lt;127:0&gt; :
        /*0*/ 0x5A544648626C7E702A243638121C0E00&lt;127:0&gt;
    );
    return FFmul_0E&lt;<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(b)*8+:8&gt;;</pstext>
    </ps>
    <ps name="shared/functions/crypto/HaveAESExt" mylink="shared.functions.crypto.HaveAESExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveAESExt()
// ============
// TRUE if AES cryptographic instructions support is implemented,
// FALSE otherwise.

boolean <anchor link="impl-shared.HaveAESExt.0" hover="function: boolean HaveAESExt()">HaveAESExt</anchor>()
    return boolean IMPLEMENTATION_DEFINED "Has AES Crypto instructions";</pstext>
    </ps>
    <ps name="shared/functions/crypto/HaveBit128PMULLExt" mylink="shared.functions.crypto.HaveBit128PMULLExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveBit128PMULLExt()
// ====================
// TRUE if 128 bit form of PMULL instructions support is implemented,
// FALSE otherwise.

boolean <anchor link="impl-shared.HaveBit128PMULLExt.0" hover="function: boolean HaveBit128PMULLExt()">HaveBit128PMULLExt</anchor>()
    return boolean IMPLEMENTATION_DEFINED "Has 128-bit form of PMULL instructions";</pstext>
    </ps>
    <ps name="shared/functions/crypto/HaveSHA1Ext" mylink="shared.functions.crypto.HaveSHA1Ext" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveSHA1Ext()
// =============
// TRUE if SHA1 cryptographic instructions support is implemented,
// FALSE otherwise.

boolean <anchor link="impl-shared.HaveSHA1Ext.0" hover="function: boolean HaveSHA1Ext()">HaveSHA1Ext</anchor>()
    return boolean IMPLEMENTATION_DEFINED "Has SHA1 Crypto instructions";</pstext>
    </ps>
    <ps name="shared/functions/crypto/HaveSHA256Ext" mylink="shared.functions.crypto.HaveSHA256Ext" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveSHA256Ext()
// ===============
// TRUE if SHA256 cryptographic instructions support is implemented,
// FALSE otherwise.

boolean <anchor link="impl-shared.HaveSHA256Ext.0" hover="function: boolean HaveSHA256Ext()">HaveSHA256Ext</anchor>()
    return boolean IMPLEMENTATION_DEFINED "Has SHA256 Crypto instructions";</pstext>
    </ps>
    <ps name="shared/functions/crypto/HaveSHA3Ext" mylink="shared.functions.crypto.HaveSHA3Ext" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveSHA3Ext()
// =============
// TRUE if SHA3 cryptographic instructions support is implemented,
// and when SHA1 and SHA2 basic cryptographic instructions support is implemented,
// FALSE otherwise.

boolean <anchor link="impl-shared.HaveSHA3Ext.0" hover="function: boolean HaveSHA3Ext()">HaveSHA3Ext</anchor>()
    if !<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p2" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) || !(<a link="impl-shared.HaveSHA1Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveSHA1Ext()">HaveSHA1Ext</a>() &amp;&amp; <a link="impl-shared.HaveSHA256Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveSHA256Ext()">HaveSHA256Ext</a>()) then
        return FALSE;
    return boolean IMPLEMENTATION_DEFINED "Has SHA3 Crypto instructions";</pstext>
    </ps>
    <ps name="shared/functions/crypto/HaveSHA512Ext" mylink="shared.functions.crypto.HaveSHA512Ext" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveSHA512Ext()
// ===============
// TRUE if SHA512 cryptographic instructions support is implemented,
// and when SHA1 and SHA2 basic cryptographic instructions support is implemented,
// FALSE otherwise.

boolean <anchor link="impl-shared.HaveSHA512Ext.0" hover="function: boolean HaveSHA512Ext()">HaveSHA512Ext</anchor>()
    if !<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p2" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) || !(<a link="impl-shared.HaveSHA1Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveSHA1Ext()">HaveSHA1Ext</a>() &amp;&amp; <a link="impl-shared.HaveSHA256Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveSHA256Ext()">HaveSHA256Ext</a>()) then
        return FALSE;
    return boolean IMPLEMENTATION_DEFINED "Has SHA512 Crypto instructions";</pstext>
    </ps>
    <ps name="shared/functions/crypto/HaveSM3Ext" mylink="shared.functions.crypto.HaveSM3Ext" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveSM3Ext()
// ============
// TRUE if SM3 cryptographic instructions support is implemented,
// FALSE otherwise.

boolean <anchor link="impl-shared.HaveSM3Ext.0" hover="function: boolean HaveSM3Ext()">HaveSM3Ext</anchor>()
    if !<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p2" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) then
        return FALSE;
    return boolean IMPLEMENTATION_DEFINED "Has SM3 Crypto instructions";</pstext>
    </ps>
    <ps name="shared/functions/crypto/HaveSM4Ext" mylink="shared.functions.crypto.HaveSM4Ext" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveSM4Ext()
// ============
// TRUE if SM4 cryptographic instructions support is implemented,
// FALSE otherwise.

boolean <anchor link="impl-shared.HaveSM4Ext.0" hover="function: boolean HaveSM4Ext()">HaveSM4Ext</anchor>()
    if !<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p2" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) then
        return FALSE;
    return boolean IMPLEMENTATION_DEFINED "Has SM4 Crypto instructions";</pstext>
    </ps>
    <ps name="shared/functions/crypto/ROL" mylink="shared.functions.crypto.ROL" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ROL()
// =====

bits(N) <anchor link="impl-shared.ROL.2" hover="function: bits(N) ROL(bits(N) x, integer shift)">ROL</anchor>(bits(N) x, integer shift)
    assert shift &gt;= 0 &amp;&amp; shift &lt;= N;
    if (shift == 0) then
        return x;
    return <a link="impl-shared.ROR.2" file="shared_pseudocode.xml" hover="function: bits(N) ROR(bits(N) x, integer shift)">ROR</a>(x, N-shift);</pstext>
    </ps>
    <ps name="shared/functions/crypto/SHA256hash" mylink="shared.functions.crypto.SHA256hash" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SHA256hash()
// ============

bits(128) <anchor link="impl-shared.SHA256hash.4" hover="function: bits(128) SHA256hash(bits (128) x_in, bits(128) y_in, bits(128) w, boolean part1)">SHA256hash</anchor>(bits (128) x_in, bits(128) y_in, bits(128) w, boolean part1)
    bits(32) chs, maj, t;
    bits(128) x = x_in;
    bits(128) y = y_in;

    for e = 0 to 3
        chs = <a link="impl-shared.SHAchoose.3" file="shared_pseudocode.xml" hover="function: bits(32) SHAchoose(bits(32) x, bits(32) y, bits(32) z)">SHAchoose</a>(y&lt;31:0&gt;, y&lt;63:32&gt;, y&lt;95:64&gt;);
        maj = <a link="impl-shared.SHAmajority.3" file="shared_pseudocode.xml" hover="function: bits(32) SHAmajority(bits(32) x, bits(32) y, bits(32) z)">SHAmajority</a>(x&lt;31:0&gt;, x&lt;63:32&gt;, x&lt;95:64&gt;);
        t = y&lt;127:96&gt; + <a link="impl-shared.SHAhashSIGMA1.1" file="shared_pseudocode.xml" hover="function: bits(32) SHAhashSIGMA1(bits(32) x)">SHAhashSIGMA1</a>(y&lt;31:0&gt;) + chs + <a link="impl-shared.Elem.read.3" file="shared_pseudocode.xml" hover="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[w, e, 32];
        x&lt;127:96&gt; = t + x&lt;127:96&gt;;
        y&lt;127:96&gt; = t + <a link="impl-shared.SHAhashSIGMA0.1" file="shared_pseudocode.xml" hover="function: bits(32) SHAhashSIGMA0(bits(32) x)">SHAhashSIGMA0</a>(x&lt;31:0&gt;) + maj;
        &lt;y, x&gt; = <a link="impl-shared.ROL.2" file="shared_pseudocode.xml" hover="function: bits(N) ROL(bits(N) x, integer shift)">ROL</a>(y : x, 32);
    return (if part1 then x else y);</pstext>
    </ps>
    <ps name="shared/functions/crypto/SHAchoose" mylink="shared.functions.crypto.SHAchoose" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SHAchoose()
// ===========

bits(32) <anchor link="impl-shared.SHAchoose.3" hover="function: bits(32) SHAchoose(bits(32) x, bits(32) y, bits(32) z)">SHAchoose</anchor>(bits(32) x, bits(32) y, bits(32) z)
    return (((y EOR z) AND x) EOR z);</pstext>
    </ps>
    <ps name="shared/functions/crypto/SHAhashSIGMA0" mylink="shared.functions.crypto.SHAhashSIGMA0" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SHAhashSIGMA0()
// ===============

bits(32) <anchor link="impl-shared.SHAhashSIGMA0.1" hover="function: bits(32) SHAhashSIGMA0(bits(32) x)">SHAhashSIGMA0</anchor>(bits(32) x)
    return <a link="impl-shared.ROR.2" file="shared_pseudocode.xml" hover="function: bits(N) ROR(bits(N) x, integer shift)">ROR</a>(x, 2) EOR <a link="impl-shared.ROR.2" file="shared_pseudocode.xml" hover="function: bits(N) ROR(bits(N) x, integer shift)">ROR</a>(x, 13) EOR <a link="impl-shared.ROR.2" file="shared_pseudocode.xml" hover="function: bits(N) ROR(bits(N) x, integer shift)">ROR</a>(x, 22);</pstext>
    </ps>
    <ps name="shared/functions/crypto/SHAhashSIGMA1" mylink="shared.functions.crypto.SHAhashSIGMA1" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SHAhashSIGMA1()
// ===============

bits(32) <anchor link="impl-shared.SHAhashSIGMA1.1" hover="function: bits(32) SHAhashSIGMA1(bits(32) x)">SHAhashSIGMA1</anchor>(bits(32) x)
    return <a link="impl-shared.ROR.2" file="shared_pseudocode.xml" hover="function: bits(N) ROR(bits(N) x, integer shift)">ROR</a>(x, 6) EOR <a link="impl-shared.ROR.2" file="shared_pseudocode.xml" hover="function: bits(N) ROR(bits(N) x, integer shift)">ROR</a>(x, 11) EOR <a link="impl-shared.ROR.2" file="shared_pseudocode.xml" hover="function: bits(N) ROR(bits(N) x, integer shift)">ROR</a>(x, 25);</pstext>
    </ps>
    <ps name="shared/functions/crypto/SHAmajority" mylink="shared.functions.crypto.SHAmajority" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SHAmajority()
// =============

bits(32) <anchor link="impl-shared.SHAmajority.3" hover="function: bits(32) SHAmajority(bits(32) x, bits(32) y, bits(32) z)">SHAmajority</anchor>(bits(32) x, bits(32) y, bits(32) z)
    return ((x AND y) OR ((x OR y) AND z));</pstext>
    </ps>
    <ps name="shared/functions/crypto/SHAparity" mylink="shared.functions.crypto.SHAparity" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SHAparity()
// ===========

bits(32) <anchor link="impl-shared.SHAparity.3" hover="function: bits(32) SHAparity(bits(32) x, bits(32) y, bits(32) z)">SHAparity</anchor>(bits(32) x, bits(32) y, bits(32) z)
    return (x EOR y EOR z);</pstext>
    </ps>
    <ps name="shared/functions/crypto/Sbox" mylink="shared.functions.crypto.Sbox" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Sbox()
// ======
// Used in SM4E crypto instruction

bits(8) <anchor link="impl-shared.Sbox.1" hover="function: bits(8) Sbox(bits(8) sboxin)">Sbox</anchor>(bits(8) sboxin)
    bits(8) sboxout;
    bits(2048) sboxstring = 0xd690e9fecce13db716b614c228fb2c052b679a762abe04c3aa441326498606999c4250f491ef987a33540b43edcfac62e4b31ca9c908e89580df94fa758f3fa64707a7fcf37317ba83593c19e6854fa8686b81b27164da8bf8eb0f4b70569d351e240e5e6358d1a225227c3b01217887d40046579fd327524c3602e7a0c4c89eeabf8ad240c738b5a3f7f2cef96115a1e0ae5da49b341a55ad933230f58cb1e31df6e22e8266ca60c02923ab0d534e6fd5db3745defd8e2f03ff6a726d6c5b518d1baf92bbddbc7f11d95c411f105ad80ac13188a5cd7bbd2d74d012b8e5b4b08969974a0c96777e65b9f109c56ec68418f07dec3adc4d2079ee5f3ed7cb3948&lt;2047:0&gt;;

    sboxout = sboxstring&lt;(255-<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(sboxin))*8+7:(255-<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(sboxin))*8&gt;;
    return sboxout;</pstext>
    </ps>
    <ps name="shared/functions/exclusive/ClearExclusiveByAddress" mylink="shared.functions.exclusive.ClearExclusiveByAddress" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Clear the global Exclusives monitors for all PEs EXCEPT processorid if they
// record any part of the physical address region of size bytes starting at paddress.
// It is IMPLEMENTATION DEFINED whether the global Exclusives monitor for processorid
// is also cleared if it records any part of the address region.
<anchor link="impl-shared.ClearExclusiveByAddress.3" hover="function: ClearExclusiveByAddress(FullAddress paddress, integer processorid, integer size)">ClearExclusiveByAddress</anchor>(<a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> paddress, integer processorid, integer size);</pstext>
    </ps>
    <ps name="shared/functions/exclusive/ClearExclusiveLocal" mylink="shared.functions.exclusive.ClearExclusiveLocal" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Clear the local Exclusives monitor for the specified processorid.
<anchor link="impl-shared.ClearExclusiveLocal.1" hover="function: ClearExclusiveLocal(integer processorid)">ClearExclusiveLocal</anchor>(integer processorid);</pstext>
    </ps>
    <ps name="shared/functions/exclusive/ClearExclusiveMonitors" mylink="shared.functions.exclusive.ClearExclusiveMonitors" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ClearExclusiveMonitors()
// ========================
// Clear the local Exclusives monitor for the executing PE.

<anchor link="impl-shared.ClearExclusiveMonitors.0" hover="function: ClearExclusiveMonitors()">ClearExclusiveMonitors</anchor>()
    <a link="impl-shared.ClearExclusiveLocal.1" file="shared_pseudocode.xml" hover="function: ClearExclusiveLocal(integer processorid)">ClearExclusiveLocal</a>(<a link="impl-shared.ProcessorID.0" file="shared_pseudocode.xml" hover="function: integer ProcessorID()">ProcessorID</a>());</pstext>
    </ps>
    <ps name="shared/functions/exclusive/ExclusiveMonitorsStatus" mylink="shared.functions.exclusive.ExclusiveMonitorsStatus" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns '0' to indicate success if the last memory write by this PE was to
// the same physical address region endorsed by ExclusiveMonitorsPass().
// Returns '1' to indicate failure if address translation resulted in a different
// physical address.
bit <anchor link="impl-shared.ExclusiveMonitorsStatus.0" hover="function: bit ExclusiveMonitorsStatus()">ExclusiveMonitorsStatus</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/exclusive/IsExclusiveGlobal" mylink="shared.functions.exclusive.IsExclusiveGlobal" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Return TRUE if the global Exclusives monitor for processorid includes all of
// the physical address region of size bytes starting at paddress.
boolean <anchor link="impl-shared.IsExclusiveGlobal.3" hover="function: boolean IsExclusiveGlobal(FullAddress paddress, integer processorid, integer size)">IsExclusiveGlobal</anchor>(<a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> paddress, integer processorid, integer size);</pstext>
    </ps>
    <ps name="shared/functions/exclusive/IsExclusiveLocal" mylink="shared.functions.exclusive.IsExclusiveLocal" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Return TRUE if the local Exclusives monitor for processorid includes all of
// the physical address region of size bytes starting at paddress.
boolean <anchor link="impl-shared.IsExclusiveLocal.3" hover="function: boolean IsExclusiveLocal(FullAddress paddress, integer processorid, integer size)">IsExclusiveLocal</anchor>(<a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> paddress, integer processorid, integer size);</pstext>
    </ps>
    <ps name="shared/functions/exclusive/MarkExclusiveGlobal" mylink="shared.functions.exclusive.MarkExclusiveGlobal" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Record the physical address region of size bytes starting at paddress in
// the global Exclusives monitor for processorid.
<anchor link="impl-shared.MarkExclusiveGlobal.3" hover="function: MarkExclusiveGlobal(FullAddress paddress, integer processorid, integer size)">MarkExclusiveGlobal</anchor>(<a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> paddress, integer processorid, integer size);</pstext>
    </ps>
    <ps name="shared/functions/exclusive/MarkExclusiveLocal" mylink="shared.functions.exclusive.MarkExclusiveLocal" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Record the physical address region of size bytes starting at paddress in
// the local Exclusives monitor for processorid.
<anchor link="impl-shared.MarkExclusiveLocal.3" hover="function: MarkExclusiveLocal(FullAddress paddress, integer processorid, integer size)">MarkExclusiveLocal</anchor>(<a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> paddress, integer processorid, integer size);</pstext>
    </ps>
    <ps name="shared/functions/exclusive/ProcessorID" mylink="shared.functions.exclusive.ProcessorID" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Return the ID of the currently executing PE.
integer <anchor link="impl-shared.ProcessorID.0" hover="function: integer ProcessorID()">ProcessorID</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/extension/AArch32.HaveHPDExt" mylink="shared.functions.extension.AArch32.HaveHPDExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch32.HaveHPDExt()
// ====================

boolean <anchor link="AArch32.HaveHPDExt.0" hover="function: boolean AArch32.HaveHPDExt()">AArch32.HaveHPDExt</anchor>()
    return (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p2" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has AArch32 hierarchical permission disables");</pstext>
    </ps>
    <ps name="shared/functions/extension/AArch64.HaveHPDExt" mylink="shared.functions.extension.AArch64.HaveHPDExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.HaveHPDExt()
// ====================

boolean <anchor link="AArch64.HaveHPDExt.0" hover="function: boolean AArch64.HaveHPDExt()">AArch64.HaveHPDExt</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p1" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p1</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/Have16bitVMID" mylink="shared.functions.extension.Have16bitVMID" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Have16bitVMID()
// ===============
// Returns TRUE if EL2 and support for a 16-bit VMID are implemented.

boolean <anchor link="impl-shared.Have16bitVMID.0" hover="function: boolean Have16bitVMID()">Have16bitVMID</anchor>()
    return (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p1" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p1</a>) &amp;&amp; <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp;
        boolean IMPLEMENTATION_DEFINED "Has 16-bit VMID");</pstext>
    </ps>
    <ps name="shared/functions/extension/Have52BitIPAAndPASpaceExt" mylink="shared.functions.extension.Have52BitIPAAndPASpaceExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Have52BitIPAAndPASpaceExt()
// ===========================
// Returns TRUE if 52-bit IPA and PA extension support
// is implemented, and FALSE otherwise.

boolean <anchor link="impl-shared.Have52BitIPAAndPASpaceExt.0" hover="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</anchor>()
    return (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p7" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p7</a>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has 52-bit IPA and PA support" &amp;&amp;
            <a link="impl-shared.Have52BitVAExt.0" file="shared_pseudocode.xml" hover="function: boolean Have52BitVAExt()">Have52BitVAExt</a>() &amp;&amp; <a link="impl-shared.Have52BitPAExt.0" file="shared_pseudocode.xml" hover="function: boolean Have52BitPAExt()">Have52BitPAExt</a>());</pstext>
    </ps>
    <ps name="shared/functions/extension/Have52BitPAExt" mylink="shared.functions.extension.Have52BitPAExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Have52BitPAExt()
// ================
// Returns TRUE if Large Physical Address extension
// support is implemented and FALSE otherwise.

boolean <anchor link="impl-shared.Have52BitPAExt.0" hover="function: boolean Have52BitPAExt()">Have52BitPAExt</anchor>()
    return (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p2" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) &amp;&amp;
           boolean IMPLEMENTATION_DEFINED "Has large 52-bit PA/IPA support");</pstext>
    </ps>
    <ps name="shared/functions/extension/Have52BitVAExt" mylink="shared.functions.extension.Have52BitVAExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Have52BitVAExt()
// ================
// Returns TRUE if Large Virtual Address extension
// support is implemented and FALSE otherwise.

boolean <anchor link="impl-shared.Have52BitVAExt.0" hover="function: boolean Have52BitVAExt()">Have52BitVAExt</anchor>()
    return (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p2" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has large 52-bit VA support");</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveAArch32BF16Ext" mylink="shared.functions.extension.HaveAArch32BF16Ext" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveAArch32BF16Ext()
// ====================
// Returns TRUE if AArch32 BFloat16 instruction support is implemented, and FALSE otherwise.

boolean <anchor link="impl-shared.HaveAArch32BF16Ext.0" hover="function: boolean HaveAArch32BF16Ext()">HaveAArch32BF16Ext</anchor>()
    return (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p2" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has AArch32 BFloat16 extension");</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveAArch32Int8MatMulExt" mylink="shared.functions.extension.HaveAArch32Int8MatMulExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveAArch32Int8MatMulExt()
// ==========================
// Returns TRUE if AArch32 8-bit integer matrix multiply instruction support
// implemented, and FALSE otherwise.

boolean <anchor link="impl-shared.HaveAArch32Int8MatMulExt.0" hover="function: boolean HaveAArch32Int8MatMulExt()">HaveAArch32Int8MatMulExt</anchor>()
    return (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p2" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has AArch32 Int8 Mat Mul extension");</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveAltFP" mylink="shared.functions.extension.HaveAltFP" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveAltFP()
// ===========
// Returns TRUE if alternative Floating-point extension support
// is implemented, and FALSE otherwise.

boolean <anchor link="impl-shared.HaveAltFP.0" hover="function: boolean HaveAltFP()">HaveAltFP</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p7" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p7</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveAtomicExt" mylink="shared.functions.extension.HaveAtomicExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveAtomicExt()
// ===============

boolean <anchor link="impl-shared.HaveAtomicExt.0" hover="function: boolean HaveAtomicExt()">HaveAtomicExt</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p1" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p1</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveBF16Ext" mylink="shared.functions.extension.HaveBF16Ext" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveBF16Ext()
// =============
// Returns TRUE if AArch64 BFloat16 instruction support is implemented, and FALSE otherwise.

boolean <anchor link="impl-shared.HaveBF16Ext.0" hover="function: boolean HaveBF16Ext()">HaveBF16Ext</anchor>()
    return (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p6" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p6</a>) ||
            (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p2" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) &amp;&amp;
             boolean IMPLEMENTATION_DEFINED "Has AArch64 BFloat16 extension"));</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveBTIExt" mylink="shared.functions.extension.HaveBTIExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveBTIExt()
// ============
// Returns TRUE if support for Branch Target Indentification is implemented.

boolean <anchor link="impl-shared.HaveBTIExt.0" hover="function: boolean HaveBTIExt()">HaveBTIExt</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p5" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p5</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveBlockBBM" mylink="shared.functions.extension.HaveBlockBBM" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveBlockBBM()
// ==============
// Returns TRUE if support for changing block size without requiring
// break-before-make is implemented.

boolean <anchor link="impl-shared.HaveBlockBBM.0" hover="function: boolean HaveBlockBBM()">HaveBlockBBM</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p4" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveCNTSCExt" mylink="shared.functions.extension.HaveCNTSCExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveCNTSCExt()
// ==============
// Returns TRUE if the Generic Counter Scaling is implemented, and FALSE
// otherwise.

boolean <anchor link="impl-shared.HaveCNTSCExt.0" hover="function: boolean HaveCNTSCExt()">HaveCNTSCExt</anchor>()
    return (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p4" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has Generic Counter Scaling support");</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveCommonNotPrivateTransExt" mylink="shared.functions.extension.HaveCommonNotPrivateTransExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveCommonNotPrivateTransExt()
// ==============================

boolean <anchor link="impl-shared.HaveCommonNotPrivateTransExt.0" hover="function: boolean HaveCommonNotPrivateTransExt()">HaveCommonNotPrivateTransExt</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p2" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveDGHExt" mylink="shared.functions.extension.HaveDGHExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveDGHExt()
// ============
// Returns TRUE if Data Gathering Hint instruction support is implemented, and
// FALSE otherwise.

boolean <anchor link="impl-shared.HaveDGHExt.0" hover="function: boolean HaveDGHExt()">HaveDGHExt</anchor>()
    return boolean IMPLEMENTATION_DEFINED "Has AArch64 DGH extension";</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveDITExt" mylink="shared.functions.extension.HaveDITExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveDITExt()
// ============

boolean <anchor link="impl-shared.HaveDITExt.0" hover="function: boolean HaveDITExt()">HaveDITExt</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p4" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveDOTPExt" mylink="shared.functions.extension.HaveDOTPExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveDOTPExt()
// =============
// Returns TRUE if Dot Product feature support is implemented, and FALSE otherwise.

boolean <anchor link="impl-shared.HaveDOTPExt.0" hover="function: boolean HaveDOTPExt()">HaveDOTPExt</anchor>()
    return (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p4" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>) ||
            (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p2" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has Dot Product extension"));</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveDoPD" mylink="shared.functions.extension.HaveDoPD" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveDoPD()
// ==========
// Returns TRUE if Debug Over Power Down extension
// support is implemented and FALSE otherwise.

boolean <anchor link="impl-shared.HaveDoPD.0" hover="function: boolean HaveDoPD()">HaveDoPD</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p2" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) &amp;&amp; boolean IMPLEMENTATION_DEFINED "Has DoPD extension";</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveDoubleFaultExt" mylink="shared.functions.extension.HaveDoubleFaultExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveDoubleFaultExt()
// ====================

boolean <anchor link="impl-shared.HaveDoubleFaultExt.0" hover="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</anchor>()
    return (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p4" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>) &amp;&amp; <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a link="impl-shared.HaveIESB.0" file="shared_pseudocode.xml" hover="function: boolean HaveIESB()">HaveIESB</a>());</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveDoubleLock" mylink="shared.functions.extension.HaveDoubleLock" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveDoubleLock()
// ================
// Returns TRUE if support for the OS Double Lock is implemented.

boolean <anchor link="impl-shared.HaveDoubleLock.0" hover="function: boolean HaveDoubleLock()">HaveDoubleLock</anchor>()
    return (!<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p4" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>) ||
            boolean IMPLEMENTATION_DEFINED "OS Double Lock is implemented");</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveE0PDExt" mylink="shared.functions.extension.HaveE0PDExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveE0PDExt()
// =============
// Returns TRUE if support for constant fault times for unprivileged accesses
// to the memory map is implemented.

boolean <anchor link="impl-shared.HaveE0PDExt.0" hover="function: boolean HaveE0PDExt()">HaveE0PDExt</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p5" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p5</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveECVExt" mylink="shared.functions.extension.HaveECVExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveECVExt()
// ============
// Returns TRUE if Enhanced Counter Virtualization extension
// support is implemented, and FALSE otherwise.

boolean <anchor link="impl-shared.HaveECVExt.0" hover="function: boolean HaveECVExt()">HaveECVExt</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p6" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p6</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveEMPAMExt" mylink="shared.functions.extension.HaveEMPAMExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveEMPAMExt()
// ==============
// Returns TRUE if Enhanced MPAM is implemented, and FALSE otherwise.

boolean <anchor link="impl-shared.HaveEMPAMExt.0" hover="function: boolean HaveEMPAMExt()">HaveEMPAMExt</anchor>()
    return (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p6" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p6</a>) &amp;&amp;
            <a link="impl-shared.HaveMPAMExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveMPAMExt()">HaveMPAMExt</a>() &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has enhanced MPAM extension");</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveExtendedCacheSets" mylink="shared.functions.extension.HaveExtendedCacheSets" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveExtendedCacheSets()
// =======================

boolean <anchor link="impl-shared.HaveExtendedCacheSets.0" hover="function: boolean HaveExtendedCacheSets()">HaveExtendedCacheSets</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p3" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p3</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveExtendedECDebugEvents" mylink="shared.functions.extension.HaveExtendedECDebugEvents" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveExtendedECDebugEvents()
// ===========================

boolean <anchor link="impl-shared.HaveExtendedECDebugEvents.0" hover="function: boolean HaveExtendedECDebugEvents()">HaveExtendedECDebugEvents</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p2" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveExtendedExecuteNeverExt" mylink="shared.functions.extension.HaveExtendedExecuteNeverExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveExtendedExecuteNeverExt()
// =============================

boolean <anchor link="impl-shared.HaveExtendedExecuteNeverExt.0" hover="function: boolean HaveExtendedExecuteNeverExt()">HaveExtendedExecuteNeverExt</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p2" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveFCADDExt" mylink="shared.functions.extension.HaveFCADDExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveFCADDExt()
// ==============

boolean <anchor link="impl-shared.HaveFCADDExt.0" hover="function: boolean HaveFCADDExt()">HaveFCADDExt</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p3" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p3</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveFGTExt" mylink="shared.functions.extension.HaveFGTExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveFGTExt()
// ============
// Returns TRUE if Fine Grained Trap is implemented, and FALSE otherwise.

boolean <anchor link="impl-shared.HaveFGTExt.0" hover="function: boolean HaveFGTExt()">HaveFGTExt</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p6" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p6</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveFJCVTZSExt" mylink="shared.functions.extension.HaveFJCVTZSExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveFJCVTZSExt()
// ================

boolean <anchor link="impl-shared.HaveFJCVTZSExt.0" hover="function: boolean HaveFJCVTZSExt()">HaveFJCVTZSExt</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p3" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p3</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveFP16MulNoRoundingToFP32Ext" mylink="shared.functions.extension.HaveFP16MulNoRoundingToFP32Ext" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveFP16MulNoRoundingToFP32Ext()
// ================================
// Returns TRUE if has FP16 multiply with no intermediate rounding accumulate
// to FP32 instructions, and FALSE otherwise

boolean <anchor link="impl-shared.HaveFP16MulNoRoundingToFP32Ext.0" hover="function: boolean HaveFP16MulNoRoundingToFP32Ext()">HaveFP16MulNoRoundingToFP32Ext</anchor>()
    if !<a link="impl-shared.HaveFP16Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveFP16Ext()">HaveFP16Ext</a>() then return FALSE;
    if <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p4" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>) then return TRUE;
    return (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p2" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has accumulate FP16 product into FP32 extension");</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveFeatCMOW" mylink="shared.functions.extension.HaveFeatCMOW" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveFeatCMOW()
// ==============
// Returns TRUE if the SCTLR_EL1.CMOW bit is implemented and the SCTLR_EL2.CMOW and
// HCRX_EL2.CMOW bits are implemented if EL2 is implemented.

boolean <anchor link="impl-shared.HaveFeatCMOW.0" hover="function: boolean HaveFeatCMOW()">HaveFeatCMOW</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p8" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p8</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveFeatHBC" mylink="shared.functions.extension.HaveFeatHBC" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveFeatHBC()
// =============
// Returns TRUE if the BC instruction is implemented, and FALSE otherwise.

boolean <anchor link="impl-shared.HaveFeatHBC.0" hover="function: boolean HaveFeatHBC()">HaveFeatHBC</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p8" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p8</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveFeatHCX" mylink="shared.functions.extension.HaveFeatHCX" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveFeatHCX()
// =============
// Returns TRUE if HCRX_EL2 Trap Control register is implemented,
// and FALSE otherwise.

boolean <anchor link="impl-shared.HaveFeatHCX.0" hover="function: boolean HaveFeatHCX()">HaveFeatHCX</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p7" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p7</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveFeatHPMN0" mylink="shared.functions.extension.HaveFeatHPMN0" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveFeatHPMN0()
// ===============
// Returns TRUE if HDCR.HPMN or MDCR_EL2.HPMN is permitted to be 0 without
// generating UNPREDICTABLE behavior, and FALSE otherwise.

boolean <anchor link="impl-shared.HaveFeatHPMN0.0" hover="function: boolean HaveFeatHPMN0()">HaveFeatHPMN0</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p8" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p8</a>) &amp;&amp; <a link="impl-shared.HavePMUv3.0" file="shared_pseudocode.xml" hover="function: boolean HavePMUv3()">HavePMUv3</a>() &amp;&amp; <a link="impl-shared.HaveFGTExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveFGTExt()">HaveFGTExt</a>() &amp;&amp; <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveFeatLS64" mylink="shared.functions.extension.HaveFeatLS64" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveFeatLS64()
// ==============
// Returns TRUE if the LD64B, ST64B instructions are
// supported, and FALSE otherwise.

boolean <anchor link="impl-shared.HaveFeatLS64.0" hover="function: boolean HaveFeatLS64()">HaveFeatLS64</anchor>()
    return (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p7" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p7</a>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has Load Store 64-Byte instruction support");</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveFeatLS64_ACCDATA" mylink="shared.functions.extension.HaveFeatLS64_ACCDATA" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveFeatLS64_ACCDATA()
// ======================
// Returns TRUE if the ST64BV0 instruction is
// supported, and FALSE otherwise.

boolean <anchor link="impl-shared.HaveFeatLS64_ACCDATA.0" hover="function: boolean HaveFeatLS64_ACCDATA()">HaveFeatLS64_ACCDATA</anchor>()
    return (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p7" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p7</a>) &amp;&amp; <a link="impl-shared.HaveFeatLS64_V.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatLS64_V()">HaveFeatLS64_V</a>() &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has Store 64-Byte <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> with return instruction support");</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveFeatLS64_V" mylink="shared.functions.extension.HaveFeatLS64_V" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveFeatLS64_V()
// ================
// Returns TRUE if the ST64BV instruction is
// supported, and FALSE otherwise.

boolean <anchor link="impl-shared.HaveFeatLS64_V.0" hover="function: boolean HaveFeatLS64_V()">HaveFeatLS64_V</anchor>()
    return (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p7" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p7</a>) &amp;&amp; <a link="impl-shared.HaveFeatLS64.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatLS64()">HaveFeatLS64</a>() &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has Store 64-Byte with return instruction support");</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveFeatMOPS" mylink="shared.functions.extension.HaveFeatMOPS" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveFeatMOPS()
// ==============
// Returns TRUE if the CPY* and SET* instructions are supported, and FALSE otherwise.

boolean <anchor link="impl-shared.HaveFeatMOPS.0" hover="function: boolean HaveFeatMOPS()">HaveFeatMOPS</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p8" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p8</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveFeatNMI" mylink="shared.functions.extension.HaveFeatNMI" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveFeatNMI()
// =============
// Returns TRUE if the Non-Maskable Interrupt extension is
// implemented, and FALSE otherwise.

boolean <anchor link="impl-shared.HaveFeatNMI.0" hover="function: boolean HaveFeatNMI()">HaveFeatNMI</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p8" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p8</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveFeatRPRES" mylink="shared.functions.extension.HaveFeatRPRES" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveFeatRPRES()
// ===============
// Returns TRUE if reciprocal estimate implements 12-bit precision
// when FPCR.AH=1, and FALSE otherwise.

boolean <anchor link="impl-shared.HaveFeatRPRES.0" hover="function: boolean HaveFeatRPRES()">HaveFeatRPRES</anchor>()
    return (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p7" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p7</a>) &amp;&amp;
        (boolean IMPLEMENTATION_DEFINED "Has increased Reciprocal Estimate and Square Root Estimate precision support") &amp;&amp;
        <a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>());</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveFeatTIDCP1" mylink="shared.functions.extension.HaveFeatTIDCP1" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveFeatTIDCP1()
// ================
// Returns TRUE if the SCTLR_EL1.TIDCP bit is implemented and the SCTLR_EL2.TIDCP bit
// is implemented if EL2 is implemented.

boolean <anchor link="impl-shared.HaveFeatTIDCP1.0" hover="function: boolean HaveFeatTIDCP1()">HaveFeatTIDCP1</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p8" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p8</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveFeatWFxT" mylink="shared.functions.extension.HaveFeatWFxT" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveFeatWFxT()
// ==============
// Returns TRUE if WFET and WFIT instruction support is implemented,
// and FALSE otherwise.

boolean <anchor link="impl-shared.HaveFeatWFxT.0" hover="function: boolean HaveFeatWFxT()">HaveFeatWFxT</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p7" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p7</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveFeatWFxT2" mylink="shared.functions.extension.HaveFeatWFxT2" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveFeatWFxT2()
// ===============
// Returns TRUE if the register number is reported in the ESR_ELx
// on exceptions to WFIT and WFET.

boolean <anchor link="impl-shared.HaveFeatWFxT2.0" hover="function: boolean HaveFeatWFxT2()">HaveFeatWFxT2</anchor>()
    return <a link="impl-shared.HaveFeatWFxT.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatWFxT()">HaveFeatWFxT</a>() &amp;&amp; boolean IMPLEMENTATION_DEFINED "Has feature WFxT2";</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveFeatXS" mylink="shared.functions.extension.HaveFeatXS" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveFeatXS()
// ============
// Returns TRUE if XS attribute and the TLBI and DSB instructions with nXS qualifier
// are supported, and FALSE otherwise.

boolean <anchor link="impl-shared.HaveFeatXS.0" hover="function: boolean HaveFeatXS()">HaveFeatXS</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p7" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p7</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveFlagFormatExt" mylink="shared.functions.extension.HaveFlagFormatExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveFlagFormatExt()
// ===================
// Returns TRUE if flag format conversion instructions implemented.

boolean <anchor link="impl-shared.HaveFlagFormatExt.0" hover="function: boolean HaveFlagFormatExt()">HaveFlagFormatExt</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p5" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p5</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveFlagManipulateExt" mylink="shared.functions.extension.HaveFlagManipulateExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveFlagManipulateExt()
// =======================
// Returns TRUE if flag manipulate instructions are implemented.

boolean <anchor link="impl-shared.HaveFlagManipulateExt.0" hover="function: boolean HaveFlagManipulateExt()">HaveFlagManipulateExt</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p4" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveFrintExt" mylink="shared.functions.extension.HaveFrintExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveFrintExt()
// ==============
// Returns TRUE if FRINT instructions are implemented.

boolean <anchor link="impl-shared.HaveFrintExt.0" hover="function: boolean HaveFrintExt()">HaveFrintExt</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p5" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p5</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveHPMDExt" mylink="shared.functions.extension.HaveHPMDExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveHPMDExt()
// =============

boolean <anchor link="impl-shared.HaveHPMDExt.0" hover="function: boolean HaveHPMDExt()">HaveHPMDExt</anchor>()
    return <a link="impl-shared.HavePMUv3p1.0" file="shared_pseudocode.xml" hover="function: boolean HavePMUv3p1()">HavePMUv3p1</a>();</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveIDSExt" mylink="shared.functions.extension.HaveIDSExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveIDSExt()
// ============
// Returns TRUE if ID register handling feature is implemented.

boolean <anchor link="impl-shared.HaveIDSExt.0" hover="function: boolean HaveIDSExt()">HaveIDSExt</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p4" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveIESB" mylink="shared.functions.extension.HaveIESB" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveIESB()
// ==========

boolean <anchor link="impl-shared.HaveIESB.0" hover="function: boolean HaveIESB()">HaveIESB</anchor>()
    return (<a link="impl-shared.HaveRASExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has Implicit Error Synchronization Barrier");</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveInt8MatMulExt" mylink="shared.functions.extension.HaveInt8MatMulExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveInt8MatMulExt()
// ===================
// Returns TRUE if AArch64 8-bit integer matrix multiply instruction support
// implemented, and FALSE otherwise.

boolean <anchor link="impl-shared.HaveInt8MatMulExt.0" hover="function: boolean HaveInt8MatMulExt()">HaveInt8MatMulExt</anchor>()
    return (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p6" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p6</a>) ||
            (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p2" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) &amp;&amp;
             boolean IMPLEMENTATION_DEFINED "Has AArch64 Int8 Mat Mul extension"));</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveLSE2Ext" mylink="shared.functions.extension.HaveLSE2Ext" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveLSE2Ext()
// =============
// Returns TRUE if LSE2 is implemented, and FALSE otherwise.

boolean <anchor link="impl-shared.HaveLSE2Ext.0" hover="function: boolean HaveLSE2Ext()">HaveLSE2Ext</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p4" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveMPAMExt" mylink="shared.functions.extension.HaveMPAMExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveMPAMExt()
// =============
// Returns TRUE if MPAM is implemented, and FALSE otherwise.

boolean <anchor link="impl-shared.HaveMPAMExt.0" hover="function: boolean HaveMPAMExt()">HaveMPAMExt</anchor>()
    return (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p2" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has MPAM extension");</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveMTE2Ext" mylink="shared.functions.extension.HaveMTE2Ext" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveMTE2Ext()
// =============
// Returns TRUE if MTE support is beyond EL0, and FALSE otherwise.

boolean <anchor link="impl-shared.HaveMTE2Ext.0" hover="function: boolean HaveMTE2Ext()">HaveMTE2Ext</anchor>()
    if !<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p5" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p5</a>) then
        return FALSE;
    return boolean IMPLEMENTATION_DEFINED "Has MTE2 extension";</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveMTE3Ext" mylink="shared.functions.extension.HaveMTE3Ext" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveMTE3Ext()
// =============
// Returns TRUE if MTE Asymmetric Fault Handling support is
// implemented, and FALSE otherwise.

boolean <anchor link="impl-shared.HaveMTE3Ext.0" hover="function: boolean HaveMTE3Ext()">HaveMTE3Ext</anchor>()
    return ((<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p7" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p7</a>) &amp;&amp; <a link="impl-shared.HaveMTE2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>()) || (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p5" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p5</a>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has MTE3 extension"));</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveMTEExt" mylink="shared.functions.extension.HaveMTEExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveMTEExt()
// ============
// Returns TRUE if MTE implemented, and FALSE otherwise.

boolean <anchor link="impl-shared.HaveMTEExt.0" hover="function: boolean HaveMTEExt()">HaveMTEExt</anchor>()
    if !<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p5" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p5</a>) then
        return FALSE;
    if <a link="impl-shared.HaveMTE2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() then
        return TRUE;
    return boolean IMPLEMENTATION_DEFINED "Has MTE extension";</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveNV2Ext" mylink="shared.functions.extension.HaveNV2Ext" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveNV2Ext()
// ============
// Returns TRUE if Enhanced Nested Virtualization is implemented.

boolean <anchor link="impl-shared.HaveNV2Ext.0" hover="function: boolean HaveNV2Ext()">HaveNV2Ext</anchor>()
    return (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p4" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>) &amp;&amp; <a link="impl-shared.HaveNVExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveNVExt()">HaveNVExt</a>()
            &amp;&amp; boolean IMPLEMENTATION_DEFINED "Has support for Enhanced Nested Virtualization");</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveNVExt" mylink="shared.functions.extension.HaveNVExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveNVExt()
// ===========
// Returns TRUE if Nested Virtualization is implemented.

boolean <anchor link="impl-shared.HaveNVExt.0" hover="function: boolean HaveNVExt()">HaveNVExt</anchor>()
    return (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p3" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p3</a>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has Nested Virtualization");</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveNoSecurePMUDisableOverride" mylink="shared.functions.extension.HaveNoSecurePMUDisableOverride" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveNoSecurePMUDisableOverride()
// ================================

boolean <anchor link="impl-shared.HaveNoSecurePMUDisableOverride.0" hover="function: boolean HaveNoSecurePMUDisableOverride()">HaveNoSecurePMUDisableOverride</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p2" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveNoninvasiveDebugAuth" mylink="shared.functions.extension.HaveNoninvasiveDebugAuth" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveNoninvasiveDebugAuth()
// ==========================
// Returns TRUE if the Non-invasive debug controls are implemented.

boolean <anchor link="impl-shared.HaveNoninvasiveDebugAuth.0" hover="function: boolean HaveNoninvasiveDebugAuth()">HaveNoninvasiveDebugAuth</anchor>()
    return !<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p4" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HavePAN3Ext" mylink="shared.functions.extension.HavePAN3Ext" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HavePAN3Ext()
// =============
// Returns TRUE if SCTLR_EL1.EPAN and SCTLR_EL2.EPAN support is implemented,
// and FALSE otherwise.

boolean <anchor link="impl-shared.HavePAN3Ext.0" hover="function: boolean HavePAN3Ext()">HavePAN3Ext</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p7" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p7</a>) || (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p1" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p1</a>) &amp;&amp;
           boolean IMPLEMENTATION_DEFINED "Has PAN3 extension");</pstext>
    </ps>
    <ps name="shared/functions/extension/HavePANExt" mylink="shared.functions.extension.HavePANExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HavePANExt()
// ============

boolean <anchor link="impl-shared.HavePANExt.0" hover="function: boolean HavePANExt()">HavePANExt</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p1" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p1</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HavePMUv3" mylink="shared.functions.extension.HavePMUv3" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HavePMUv3()
// ===========
// Returns TRUE if the Performance Monitors extension is implemented, and FALSE otherwise.

boolean <anchor link="impl-shared.HavePMUv3.0" hover="function: boolean HavePMUv3()">HavePMUv3</anchor>()
    return boolean IMPLEMENTATION_DEFINED "Has Performance Monitors extension";</pstext>
    </ps>
    <ps name="shared/functions/extension/HavePMUv3TH" mylink="shared.functions.extension.HavePMUv3TH" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HavePMUv3TH()
// =============
// Returns TRUE if the PMUv3 threshold extension is implemented, and FALSE otherwise.

boolean <anchor link="impl-shared.HavePMUv3TH.0" hover="function: boolean HavePMUv3TH()">HavePMUv3TH</anchor>()
    return (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p8" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p8</a>) &amp;&amp; <a link="impl-shared.HavePMUv3.0" file="shared_pseudocode.xml" hover="function: boolean HavePMUv3()">HavePMUv3</a>() &amp;&amp;
        boolean IMPLEMENTATION_DEFINED "Has PMUv3 threshold extension");</pstext>
    </ps>
    <ps name="shared/functions/extension/HavePMUv3p1" mylink="shared.functions.extension.HavePMUv3p1" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HavePMUv3p1()
// =============
// Returns TRUE if the Performance Monitors extension is implemented, and FALSE otherwise.

boolean <anchor link="impl-shared.HavePMUv3p1.0" hover="function: boolean HavePMUv3p1()">HavePMUv3p1</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p1" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p1</a>) &amp;&amp; <a link="impl-shared.HavePMUv3.0" file="shared_pseudocode.xml" hover="function: boolean HavePMUv3()">HavePMUv3</a>();</pstext>
    </ps>
    <ps name="shared/functions/extension/HavePMUv3p4" mylink="shared.functions.extension.HavePMUv3p4" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HavePMUv3p4()
// =============
// Returns TRUE if the PMUv3.4 extension is implemented, and FALSE otherwise.

boolean <anchor link="impl-shared.HavePMUv3p4.0" hover="function: boolean HavePMUv3p4()">HavePMUv3p4</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p4" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>) &amp;&amp; <a link="impl-shared.HavePMUv3.0" file="shared_pseudocode.xml" hover="function: boolean HavePMUv3()">HavePMUv3</a>();</pstext>
    </ps>
    <ps name="shared/functions/extension/HavePMUv3p5" mylink="shared.functions.extension.HavePMUv3p5" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HavePMUv3p5()
// =============
// Returns TRUE if the PMUv3.5 extension is implemented, and FALSE otherwise.

boolean <anchor link="impl-shared.HavePMUv3p5.0" hover="function: boolean HavePMUv3p5()">HavePMUv3p5</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p5" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p5</a>) &amp;&amp; <a link="impl-shared.HavePMUv3.0" file="shared_pseudocode.xml" hover="function: boolean HavePMUv3()">HavePMUv3</a>();</pstext>
    </ps>
    <ps name="shared/functions/extension/HavePMUv3p7" mylink="shared.functions.extension.HavePMUv3p7" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HavePMUv3p7()
// =============
// Returns TRUE if the PMUv3.7 extension is implemented, and FALSE otherwise.

boolean <anchor link="impl-shared.HavePMUv3p7.0" hover="function: boolean HavePMUv3p7()">HavePMUv3p7</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p7" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p7</a>) &amp;&amp; <a link="impl-shared.HavePMUv3.0" file="shared_pseudocode.xml" hover="function: boolean HavePMUv3()">HavePMUv3</a>();</pstext>
    </ps>
    <ps name="shared/functions/extension/HavePageBasedHardwareAttributes" mylink="shared.functions.extension.HavePageBasedHardwareAttributes" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HavePageBasedHardwareAttributes()
// =================================

boolean <anchor link="impl-shared.HavePageBasedHardwareAttributes.0" hover="function: boolean HavePageBasedHardwareAttributes()">HavePageBasedHardwareAttributes</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p2" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HavePrivATExt" mylink="shared.functions.extension.HavePrivATExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HavePrivATExt()
// ===============

boolean <anchor link="impl-shared.HavePrivATExt.0" hover="function: boolean HavePrivATExt()">HavePrivATExt</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p2" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveQRDMLAHExt" mylink="shared.functions.extension.HaveQRDMLAHExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveQRDMLAHExt()
// ================

boolean <anchor link="impl-shared.HaveQRDMLAHExt.0" hover="function: boolean HaveQRDMLAHExt()">HaveQRDMLAHExt</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p1" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p1</a>);

boolean <anchor link="impl-shared.HaveAccessFlagUpdateExt.0" hover="function: boolean HaveAccessFlagUpdateExt()">HaveAccessFlagUpdateExt</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p1" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p1</a>);

boolean <anchor link="impl-shared.HaveDirtyBitModifierExt.0" hover="function: boolean HaveDirtyBitModifierExt()">HaveDirtyBitModifierExt</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p1" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p1</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveRASExt" mylink="shared.functions.extension.HaveRASExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveRASExt()
// ============

boolean <anchor link="impl-shared.HaveRASExt.0" hover="function: boolean HaveRASExt()">HaveRASExt</anchor>()
    return (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p2" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) ||
            boolean IMPLEMENTATION_DEFINED "Has RAS extension");</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveRNG" mylink="shared.functions.extension.HaveRNG" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveRNG()
// =========
// Returns TRUE if Random Number Generator extension
// support is implemented and FALSE otherwise.

boolean <anchor link="impl-shared.HaveRNG.0" hover="function: boolean HaveRNG()">HaveRNG</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p5" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p5</a>) &amp;&amp; boolean IMPLEMENTATION_DEFINED "Has RNG extension";</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveSBExt" mylink="shared.functions.extension.HaveSBExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveSBExt()
// ===========
// Returns TRUE if support for SB is implemented, and FALSE otherwise.

boolean <anchor link="impl-shared.HaveSBExt.0" hover="function: boolean HaveSBExt()">HaveSBExt</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p5" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p5</a>) || boolean IMPLEMENTATION_DEFINED "Has SB extension";</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveSSBSExt" mylink="shared.functions.extension.HaveSSBSExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveSSBSExt()
// =============
// Returns TRUE if support for SSBS is implemented, and FALSE otherwise.

boolean <anchor link="impl-shared.HaveSSBSExt.0" hover="function: boolean HaveSSBSExt()">HaveSSBSExt</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p5" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p5</a>) || boolean IMPLEMENTATION_DEFINED "Has SSBS extension";</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveSecureEL2Ext" mylink="shared.functions.extension.HaveSecureEL2Ext" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveSecureEL2Ext()
// ==================
// Returns TRUE if Secure EL2 is implemented.

boolean <anchor link="impl-shared.HaveSecureEL2Ext.0" hover="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p4" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveSecureExtDebugView" mylink="shared.functions.extension.HaveSecureExtDebugView" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveSecureExtDebugView()
// ========================
// Returns TRUE if support for Secure and Non-secure views of debug peripherals
// is implemented.

boolean <anchor link="impl-shared.HaveSecureExtDebugView.0" hover="function: boolean HaveSecureExtDebugView()">HaveSecureExtDebugView</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p4" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveSelfHostedTrace" mylink="shared.functions.extension.HaveSelfHostedTrace" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveSelfHostedTrace()
// =====================

boolean <anchor link="impl-shared.HaveSelfHostedTrace.0" hover="function: boolean HaveSelfHostedTrace()">HaveSelfHostedTrace</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p4" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveSmallTranslationTblExt" mylink="shared.functions.extension.HaveSmallTranslationTblExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveSmallTranslationTblExt()
// ============================
// Returns TRUE if Small Translation Table Support is implemented.

boolean <anchor link="impl-shared.HaveSmallTranslationTableExt.0" hover="function: boolean HaveSmallTranslationTableExt()">HaveSmallTranslationTableExt</anchor>()
    return (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p4" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has Small Translation Table extension");</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveSoftwareLock" mylink="shared.functions.extension.HaveSoftwareLock" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveSoftwareLock()
// ==================
// Returns TRUE if Software Lock is implemented.

boolean <anchor link="impl-shared.HaveSoftwareLock.1" hover="function: boolean HaveSoftwareLock(Component component)">HaveSoftwareLock</anchor>(<a link="Component" file="shared_pseudocode.xml" hover="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component</a> component)
    if <a link="impl-shared.Havev8p4Debug.0" file="shared_pseudocode.xml" hover="function: boolean Havev8p4Debug()">Havev8p4Debug</a>() then
        return FALSE;
    if <a link="impl-shared.HaveDoPD.0" file="shared_pseudocode.xml" hover="function: boolean HaveDoPD()">HaveDoPD</a>() &amp;&amp; component != <a link="Component_CTI" file="shared_pseudocode.xml" hover="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component_CTI</a> then
        return FALSE;
    case component of
        when <a link="Component_Debug" file="shared_pseudocode.xml" hover="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component_Debug</a>
            return boolean IMPLEMENTATION_DEFINED "Debug has Software Lock";
        when <a link="Component_PMU" file="shared_pseudocode.xml" hover="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component_PMU</a>
            return boolean IMPLEMENTATION_DEFINED "PMU has Software Lock";
        when <a link="Component_CTI" file="shared_pseudocode.xml" hover="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component_CTI</a>
            return boolean IMPLEMENTATION_DEFINED "CTI has Software Lock";
        otherwise
            <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveStage2MemAttrControl" mylink="shared.functions.extension.HaveStage2MemAttrControl" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveStage2MemAttrControl()
// ==========================
// Returns TRUE if support for Stage2 control of memory types and cacheability
// attributes is implemented.

boolean <anchor link="impl-shared.HaveStage2MemAttrControl.0" hover="function: boolean HaveStage2MemAttrControl()">HaveStage2MemAttrControl</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p4" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveStatisticalProfiling" mylink="shared.functions.extension.HaveStatisticalProfiling" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveStatisticalProfiling()
// ==========================
// Returns TRUE if Statistical Profiling Extension is implemented,
// and FALSE otherwise.

boolean <anchor link="impl-shared.HaveStatisticalProfiling.0" hover="function: boolean HaveStatisticalProfiling()">HaveStatisticalProfiling</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p2" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveStatisticalProfilingv1p1" mylink="shared.functions.extension.HaveStatisticalProfilingv1p1" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveStatisticalProfilingv1p1()
// ==============================
// Returns TRUE if the SPEv1p1 extension is implemented, and FALSE otherwise.

boolean <anchor link="impl-shared.HaveStatisticalProfilingv1p1.0" hover="function: boolean HaveStatisticalProfilingv1p1()">HaveStatisticalProfilingv1p1</anchor>()
    return (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p3" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p3</a>) &amp;&amp;
        boolean IMPLEMENTATION_DEFINED "Has SPEv1p1 extension");</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveStatisticalProfilingv1p2" mylink="shared.functions.extension.HaveStatisticalProfilingv1p2" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveStatisticalProfilingv1p2()
// ==============================
// Returns TRUE if the SPEv1p2 extension is implemented, and FALSE otherwise.

boolean <anchor link="impl-shared.HaveStatisticalProfilingv1p2.0" hover="function: boolean HaveStatisticalProfilingv1p2()">HaveStatisticalProfilingv1p2</anchor>()
    return (<a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p7" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p7</a>) &amp;&amp; <a link="impl-shared.HaveStatisticalProfiling.0" file="shared_pseudocode.xml" hover="function: boolean HaveStatisticalProfiling()">HaveStatisticalProfiling</a>() &amp;&amp;
        boolean IMPLEMENTATION_DEFINED "Has SPEv1p2 extension");</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveTWEDExt" mylink="shared.functions.extension.HaveTWEDExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveTWEDExt()
// =============
// Returns TRUE if Delayed Trapping of WFE instruction support is implemented,
// and FALSE otherwise.

boolean <anchor link="impl-shared.HaveTWEDExt.0" hover="function: boolean HaveTWEDExt()">HaveTWEDExt</anchor>()
    return boolean IMPLEMENTATION_DEFINED "Has TWED extension";</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveTraceExt" mylink="shared.functions.extension.HaveTraceExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveTraceExt()
// ==============
// Returns TRUE if Trace functionality as described by the Trace Architecture
// is implemented.

boolean <anchor link="impl-shared.HaveTraceExt.0" hover="function: boolean HaveTraceExt()">HaveTraceExt</anchor>()
    return boolean IMPLEMENTATION_DEFINED "Has Trace Architecture functionality";</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveTrapLoadStoreMultipleDeviceExt" mylink="shared.functions.extension.HaveTrapLoadStoreMultipleDeviceExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveTrapLoadStoreMultipleDeviceExt()
// ====================================

boolean <anchor link="impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0" hover="function: boolean HaveTrapLoadStoreMultipleDeviceExt()">HaveTrapLoadStoreMultipleDeviceExt</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p2" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveUAOExt" mylink="shared.functions.extension.HaveUAOExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveUAOExt()
// ============

boolean <anchor link="impl-shared.HaveUAOExt.0" hover="function: boolean HaveUAOExt()">HaveUAOExt</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p2" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveV82Debug" mylink="shared.functions.extension.HaveV82Debug" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveV82Debug()
// ==============

boolean <anchor link="impl-shared.HaveV82Debug.0" hover="function: boolean HaveV82Debug()">HaveV82Debug</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p2" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/HaveVirtHostExt" mylink="shared.functions.extension.HaveVirtHostExt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveVirtHostExt()
// =================

boolean <anchor link="impl-shared.HaveVirtHostExt.0" hover="function: boolean HaveVirtHostExt()">HaveVirtHostExt</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p1" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p1</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/Havev8p4Debug" mylink="shared.functions.extension.Havev8p4Debug" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Havev8p4Debug()
// ===============
// Returns TRUE if support for the Debugv8p4 feature is implemented and FALSE otherwise.

boolean <anchor link="impl-shared.Havev8p4Debug.0" hover="function: boolean Havev8p4Debug()">Havev8p4Debug</anchor>()
    return <a link="impl-shared.HasArchVersion.1" file="shared_pseudocode.xml" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a link="ARMv8p4" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>);</pstext>
    </ps>
    <ps name="shared/functions/extension/InsertIESBBeforeException" mylink="shared.functions.extension.InsertIESBBeforeException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// If SCTLR_ELx.IESB is 1 when an exception is generated to ELx, any pending Unrecoverable
// SError interrupt must be taken before executing any instructions in the exception handler.
// However, this can be before the branch to the exception handler is made.
boolean <anchor link="impl-shared.InsertIESBBeforeException.1" hover="function: boolean InsertIESBBeforeException(bits(2) el)">InsertIESBBeforeException</anchor>(bits(2) el);</pstext>
    </ps>
    <ps name="shared/functions/externalaborts/HandleExternalAbort" mylink="shared.functions.externalaborts.HandleExternalAbort" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HandleExternalAbort()
// =====================
// Takes a Synchronous/Asynchronous abort based on fault.

<anchor link="impl-shared.HandleExternalAbort.5" hover="function: HandleExternalAbort(PhysMemRetStatus memretstatus, boolean iswrite,&#13; AddressDescriptor memaddrdesc, integer size,&#13; AccessDescriptor accdesc)">HandleExternalAbort</anchor>(<a link="PhysMemRetStatus" file="shared_pseudocode.xml" hover="type PhysMemRetStatus is (Fault statuscode, bit extflag, bits(2) errortype, bits(64) store64bstatus, AccType acctype)">PhysMemRetStatus</a> memretstatus, boolean iswrite,
                    <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc, integer size,
                    <a link="AccessDescriptor" file="shared_pseudocode.xml" hover="type AccessDescriptor is ( MPAMinfo mpam, AccType acctype)">AccessDescriptor</a> accdesc)
    assert (memretstatus.statuscode IN {<a link="Fault_SyncExternal" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternal</a>, <a link="Fault_AsyncExternal" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>} ||
           (!<a link="impl-shared.HaveRASExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; memretstatus.statuscode IN {<a link="Fault_SyncParity" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParity</a>,
                                                         <a link="Fault_AsyncParity" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncParity</a>}));

    fault = <a link="impl-shared.NoFault.0" file="shared_pseudocode.xml" hover="function: FaultRecord NoFault()">NoFault</a>();
    fault.statuscode = memretstatus.statuscode;
    fault.write = iswrite;
    fault.extflag = memretstatus.extflag;
    fault.acctype = memretstatus.acctype;
    // It is implementation specific whether external aborts signaled
    // in-band synchronously are taken synchronously or asynchronously
    if (<a link="impl-shared.IsExternalSyncAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(fault) &amp;&amp;
            !<a link="impl-shared.IsExternalAbortTakenSynchronously.5" file="shared_pseudocode.xml" hover="function: boolean IsExternalAbortTakenSynchronously(PhysMemRetStatus memstatus,&#13; boolean iswrite,&#13; AddressDescriptor desc,&#13; integer size,&#13; AccessDescriptor accdesc)">IsExternalAbortTakenSynchronously</a>(memretstatus, iswrite, memaddrdesc,
                                               size, accdesc)) then
        if fault.statuscode == <a link="Fault_SyncParity" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParity</a> then
            fault.statuscode = <a link="Fault_AsyncParity" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncParity</a>;
        else
            fault.statuscode = <a link="Fault_AsyncExternal" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>;

    if <a link="impl-shared.HaveRASExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveRASExt()">HaveRASExt</a>() then
        fault.errortype = <a link="impl-shared.PEErrorState.1" file="shared_pseudocode.xml" hover="function: bits(2) PEErrorState(PhysMemRetStatus memstatus)">PEErrorState</a>(memretstatus);
    else
        fault.errortype = bits(2) UNKNOWN;

    if <a link="impl-shared.IsExternalSyncAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(fault) then
        if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
            <a link="AArch32.Abort.2" file="shared_pseudocode.xml" hover="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(memaddrdesc.vaddress&lt;31:0&gt;, fault);
        else
            <a link="AArch64.Abort.2" file="shared_pseudocode.xml" hover="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(memaddrdesc.vaddress, fault);

    else
        <a link="impl-shared.PendSErrorInterrupt.1" file="shared_pseudocode.xml" hover="function: PendSErrorInterrupt(FaultRecord fault)">PendSErrorInterrupt</a>(fault);</pstext>
    </ps>
    <ps name="shared/functions/externalaborts/HandleExternalReadAbort" mylink="shared.functions.externalaborts.HandleExternalReadAbort" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HandleExternalReadAbort()
// =========================
// Wrapper function for HandleExternalAbort function in case of an External
// Abort on memory read.

<anchor link="impl-shared.HandleExternalReadAbort.4" hover="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</anchor>(<a link="PhysMemRetStatus" file="shared_pseudocode.xml" hover="type PhysMemRetStatus is (Fault statuscode, bit extflag, bits(2) errortype, bits(64) store64bstatus, AccType acctype)">PhysMemRetStatus</a> memstatus, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc,
                        integer size, <a link="AccessDescriptor" file="shared_pseudocode.xml" hover="type AccessDescriptor is ( MPAMinfo mpam, AccType acctype)">AccessDescriptor</a> accdesc)
    iswrite = FALSE;
    <a link="impl-shared.HandleExternalAbort.5" file="shared_pseudocode.xml" hover="function: HandleExternalAbort(PhysMemRetStatus memretstatus, boolean iswrite,&#13; AddressDescriptor memaddrdesc, integer size,&#13; AccessDescriptor accdesc)">HandleExternalAbort</a>(memstatus, iswrite, memaddrdesc, size, accdesc);</pstext>
    </ps>
    <ps name="shared/functions/externalaborts/HandleExternalTTWAbort" mylink="shared.functions.externalaborts.HandleExternalTTWAbort" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HandleExternalTTWAbort()
// ========================
// Take Asynchronous abort or update FaultRecord for Translation Table Walk
// based on PhysMemRetStatus.

FaultRecord <anchor link="impl-shared.HandleExternalTTWAbort.6" hover="function: FaultRecord HandleExternalTTWAbort(PhysMemRetStatus memretstatus, boolean iswrite,&#13; AddressDescriptor memaddrdesc,&#13; AccessDescriptor accdesc, integer size,&#13; FaultRecord input_fault)">HandleExternalTTWAbort</anchor>(<a link="PhysMemRetStatus" file="shared_pseudocode.xml" hover="type PhysMemRetStatus is (Fault statuscode, bit extflag, bits(2) errortype, bits(64) store64bstatus, AccType acctype)">PhysMemRetStatus</a> memretstatus, boolean iswrite,
                                   <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc,
                                   <a link="AccessDescriptor" file="shared_pseudocode.xml" hover="type AccessDescriptor is ( MPAMinfo mpam, AccType acctype)">AccessDescriptor</a> accdesc, integer size,
                                   <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> input_fault)
    output_fault = input_fault;
    output_fault.extflag = memretstatus.extflag;
    output_fault.statuscode = memretstatus.statuscode;
    if (<a link="impl-shared.IsExternalSyncAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(output_fault) &amp;&amp;
            !<a link="impl-shared.IsExternalAbortTakenSynchronously.5" file="shared_pseudocode.xml" hover="function: boolean IsExternalAbortTakenSynchronously(PhysMemRetStatus memstatus,&#13; boolean iswrite,&#13; AddressDescriptor desc,&#13; integer size,&#13; AccessDescriptor accdesc)">IsExternalAbortTakenSynchronously</a>(memretstatus, iswrite,
                                               memaddrdesc,
                                               size, accdesc)) then
        if output_fault.statuscode == <a link="Fault_SyncParity" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParity</a> then
            output_fault.statuscode = <a link="Fault_AsyncParity" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncParity</a>;
        else
            output_fault.statuscode = <a link="Fault_AsyncExternal" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>;

    // If a synchronous fault is on a translation table walk, then update
    // the fault type
    if <a link="impl-shared.IsExternalSyncAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(output_fault) then
        if output_fault.statuscode == <a link="Fault_SyncParity" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParity</a> then
            output_fault.statuscode = <a link="Fault_SyncParityOnWalk" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParityOnWalk</a>;
        else
            output_fault.statuscode = <a link="Fault_SyncExternalOnWalk" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternalOnWalk</a>;
    if <a link="impl-shared.HaveRASExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveRASExt()">HaveRASExt</a>() then
        output_fault.errortype = <a link="impl-shared.PEErrorState.1" file="shared_pseudocode.xml" hover="function: bits(2) PEErrorState(PhysMemRetStatus memstatus)">PEErrorState</a>(memretstatus);
    else
        output_fault.errortype = bits(2) UNKNOWN;
    if !<a link="impl-shared.IsExternalSyncAbort.1" file="shared_pseudocode.xml" hover="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(output_fault) then
        <a link="impl-shared.PendSErrorInterrupt.1" file="shared_pseudocode.xml" hover="function: PendSErrorInterrupt(FaultRecord fault)">PendSErrorInterrupt</a>(output_fault);
        output_fault.statuscode = <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;
    return output_fault;</pstext>
    </ps>
    <ps name="shared/functions/externalaborts/HandleExternalWriteAbort" mylink="shared.functions.externalaborts.HandleExternalWriteAbort" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HandleExternalWriteAbort()
// ==========================
// Wrapper function for HandleExternalAbort function in case of an External
// Abort on memory write.

<anchor link="impl-shared.HandleExternalWriteAbort.4" hover="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</anchor>(<a link="PhysMemRetStatus" file="shared_pseudocode.xml" hover="type PhysMemRetStatus is (Fault statuscode, bit extflag, bits(2) errortype, bits(64) store64bstatus, AccType acctype)">PhysMemRetStatus</a> memstatus, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc,
                         integer size, <a link="AccessDescriptor" file="shared_pseudocode.xml" hover="type AccessDescriptor is ( MPAMinfo mpam, AccType acctype)">AccessDescriptor</a> accdesc)
    iswrite = TRUE;
    <a link="impl-shared.HandleExternalAbort.5" file="shared_pseudocode.xml" hover="function: HandleExternalAbort(PhysMemRetStatus memretstatus, boolean iswrite,&#13; AddressDescriptor memaddrdesc, integer size,&#13; AccessDescriptor accdesc)">HandleExternalAbort</a>(memstatus, iswrite, memaddrdesc, size, accdesc);</pstext>
    </ps>
    <ps name="shared/functions/externalaborts/IsExternalAbortTakenSynchronously" mylink="shared.functions.externalaborts.IsExternalAbortTakenSynchronously" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Return an implementation specific value:
// TRUE if the fault returned for the access can be taken synchronously,
// FALSE otherwise.
//
// This might vary between accesses, for example depending on the error type
// or memory type being accessed.
// External aborts on data accesses and translation table walks on data accesses
// can be either synchronous or asynchronous.
//
// When FEAT_DoubleFault is not implemented, External aborts on instruction
// fetches and translation table walks on instruction fetches can be either
// synchronous or asynchronous.
// When FEAT_DoubleFault is implemented, all External abort exceptions on
// instruction fetches and translation table walks on instruction fetches
// must be synchronous.
boolean <anchor link="impl-shared.IsExternalAbortTakenSynchronously.5" hover="function: boolean IsExternalAbortTakenSynchronously(PhysMemRetStatus memstatus,&#13; boolean iswrite,&#13; AddressDescriptor desc,&#13; integer size,&#13; AccessDescriptor accdesc)">IsExternalAbortTakenSynchronously</anchor>(<a link="PhysMemRetStatus" file="shared_pseudocode.xml" hover="type PhysMemRetStatus is (Fault statuscode, bit extflag, bits(2) errortype, bits(64) store64bstatus, AccType acctype)">PhysMemRetStatus</a> memstatus,
                                          boolean iswrite,
                                          <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> desc,
                                          integer size,
                                          <a link="AccessDescriptor" file="shared_pseudocode.xml" hover="type AccessDescriptor is ( MPAMinfo mpam, AccType acctype)">AccessDescriptor</a> accdesc);</pstext>
    </ps>
    <ps name="shared/functions/externalaborts/PEErrorState" mylink="shared.functions.externalaborts.PEErrorState" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">constant bits(2) <anchor link="Sync_UC" hover="constant bits(2) Sync_UC = '10'">Sync_UC</anchor>   = '10'; // Synchronous Uncontainable
constant bits(2) <anchor link="Sync_UER" hover="constant bits(2) Sync_UER = '00'">Sync_UER</anchor>  = '00'; // Synchronous Recoverable
constant bits(2) <anchor link="Sync_UEO" hover="constant bits(2) Sync_UEO = '11'">Sync_UEO</anchor>  = '11'; // Synchronous Restartable
constant bits(2) <anchor link="ASync_UC" hover="constant bits(2) ASync_UC = '00'">ASync_UC</anchor>  = '00'; // ASynchronous Uncontainable
constant bits(2) <anchor link="ASync_UEU" hover="constant bits(2) ASync_UEU = '01'">ASync_UEU</anchor> = '01'; // ASynchronous Unrecoverable
constant bits(2) <anchor link="ASync_UER" hover="constant bits(2) ASync_UER = '11'">ASync_UER</anchor> = '11'; // ASynchronous Recoverable
constant bits(2) <anchor link="ASync_UEO" hover="constant bits(2) ASync_UEO = '10'">ASync_UEO</anchor> = '10'; // ASynchronous Restartable

bits(2) <anchor link="impl-shared.PEErrorState.1" hover="function: bits(2) PEErrorState(PhysMemRetStatus memstatus)">PEErrorState</anchor>(<a link="PhysMemRetStatus" file="shared_pseudocode.xml" hover="type PhysMemRetStatus is (Fault statuscode, bit extflag, bits(2) errortype, bits(64) store64bstatus, AccType acctype)">PhysMemRetStatus</a> memstatus);</pstext>
    </ps>
    <ps name="shared/functions/externalaborts/PendSErrorInterrupt" mylink="shared.functions.externalaborts.PendSErrorInterrupt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Pend the SError.
<anchor link="impl-shared.PendSErrorInterrupt.1" hover="function: PendSErrorInterrupt(FaultRecord fault)">PendSErrorInterrupt</anchor>(<a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault);</pstext>
    </ps>
    <ps name="shared/functions/float/bfloat/BFAdd" mylink="shared.functions.float.bfloat.BFAdd" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// BFAdd()
// =======
// Single-precision add following BFloat16 computation behaviors.

bits(32) <anchor link="impl-shared.BFAdd.2" hover="function: bits(32) BFAdd(bits(32) op1, bits(32) op2)">BFAdd</anchor>(bits(32) op1, bits(32) op2)

    bits(32) result;

    <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr = FPCR[];
    (type1,sign1,value1) = <a link="impl-shared.BFUnpack.1" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) BFUnpack(bits(N) fpval)">BFUnpack</a>(op1);
    (type2,sign2,value2) = <a link="impl-shared.BFUnpack.1" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) BFUnpack(bits(N) fpval)">BFUnpack</a>(op2);
    if type1 == <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> || type2 == <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        result = <a link="impl-shared.FPDefaultNaN.1" file="shared_pseudocode.xml" hover="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
    else
        inf1 = (type1 == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        inf2 = (type2 == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        zero2 = (type2 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        if inf1 &amp;&amp; inf2 &amp;&amp; sign1 == NOT(sign2) then
            result = <a link="impl-shared.FPDefaultNaN.1" file="shared_pseudocode.xml" hover="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
        elsif (inf1 &amp;&amp; sign1 == '0') || (inf2 &amp;&amp; sign2 == '0') then
            result = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('0');
        elsif (inf1 &amp;&amp; sign1 == '1') || (inf2 &amp;&amp; sign2 == '1') then
            result = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('1');
        elsif zero1 &amp;&amp; zero2 &amp;&amp; sign1 == sign2 then
            result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(sign1);
        else
            result_value = value1 + value2;
            if result_value == 0.0 then
                result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>('0');    // Positive sign when Round to Odd
            else
                result = <a link="impl-shared.BFRound.1" file="shared_pseudocode.xml" hover="function: bits(32) BFRound(real op)">BFRound</a>(result_value);

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/bfloat/BFDotAdd" mylink="shared.functions.float.bfloat.BFDotAdd" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// BFDotAdd()
// ==========
// BFloat16 2-way dot-product and add to single-precision
// result = addend + op1_a*op2_a + op1_b*op2_b

bits(32) <anchor link="impl-shared.BFDotAdd.6" hover="function: bits(32) BFDotAdd(bits(32) addend, bits(16) op1_a, bits(16) op1_b,&#13; bits(16) op2_a, bits(16) op2_b, FPCRType fpcr_in)">BFDotAdd</anchor>(bits(32) addend, bits(16) op1_a, bits(16) op1_b,
                  bits(16) op2_a, bits(16) op2_b, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr_in)
    <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr = fpcr_in;

    bits(32) prod;

    prod = <a link="impl-shared.BFAdd.2" file="shared_pseudocode.xml" hover="function: bits(32) BFAdd(bits(32) op1, bits(32) op2)">BFAdd</a>(<a link="impl-shared.BFMul.2" file="shared_pseudocode.xml" hover="function: bits(32) BFMul(bits(16) op1, bits(16) op2)">BFMul</a>(op1_a, op2_a), <a link="impl-shared.BFMul.2" file="shared_pseudocode.xml" hover="function: bits(32) BFMul(bits(16) op1, bits(16) op2)">BFMul</a>(op1_b, op2_b));
    result = <a link="impl-shared.BFAdd.2" file="shared_pseudocode.xml" hover="function: bits(32) BFAdd(bits(32) op1, bits(32) op2)">BFAdd</a>(addend, prod);

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/bfloat/BFMatMulAdd" mylink="shared.functions.float.bfloat.BFMatMulAdd" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// BFMatMulAdd()
// =============
// BFloat16 matrix multiply and add to single-precision matrix
// result[2, 2] = addend[2, 2] + (op1[2, 4] * op2[4, 2])

bits(N) <anchor link="impl-shared.BFMatMulAdd.3" hover="function: bits(N) BFMatMulAdd(bits(N) addend, bits(N) op1, bits(N) op2)">BFMatMulAdd</anchor>(bits(N) addend, bits(N) op1, bits(N) op2)

    assert N == 128;

    bits(N) result;
    bits(32) sum;

    for i = 0 to 1
        for j = 0 to 1
            sum = <a link="impl-shared.Elem.read.3" file="shared_pseudocode.xml" hover="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[addend, 2*i + j, 32];
            for k = 0 to 1
                bits(16) elt1_a = <a link="impl-shared.Elem.read.3" file="shared_pseudocode.xml" hover="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[op1, 4*i + 2*k + 0, 16];
                bits(16) elt1_b = <a link="impl-shared.Elem.read.3" file="shared_pseudocode.xml" hover="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[op1, 4*i + 2*k + 1, 16];
                bits(16) elt2_a = <a link="impl-shared.Elem.read.3" file="shared_pseudocode.xml" hover="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[op2, 4*j + 2*k + 0, 16];
                bits(16) elt2_b = <a link="impl-shared.Elem.read.3" file="shared_pseudocode.xml" hover="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[op2, 4*j + 2*k + 1, 16];
                sum = <a link="impl-shared.BFDotAdd.6" file="shared_pseudocode.xml" hover="function: bits(32) BFDotAdd(bits(32) addend, bits(16) op1_a, bits(16) op1_b,&#13; bits(16) op2_a, bits(16) op2_b, FPCRType fpcr_in)">BFDotAdd</a>(sum, elt1_a, elt1_b, elt2_a, elt2_b, FPCR[]);
            <a link="impl-shared.Elem.write.3" file="shared_pseudocode.xml" hover="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[result, 2*i + j, 32] = sum;

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/bfloat/BFMul" mylink="shared.functions.float.bfloat.BFMul" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// BFMul()
// =======
// BFloat16 widening multiply to single-precision following BFloat16
// computation behaviors.

bits(32) <anchor link="impl-shared.BFMul.2" hover="function: bits(32) BFMul(bits(16) op1, bits(16) op2)">BFMul</anchor>(bits(16) op1, bits(16) op2)

    bits(32) result;

    <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr = FPCR[];
    (type1,sign1,value1) = <a link="impl-shared.BFUnpack.1" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) BFUnpack(bits(N) fpval)">BFUnpack</a>(op1);
    (type2,sign2,value2) = <a link="impl-shared.BFUnpack.1" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) BFUnpack(bits(N) fpval)">BFUnpack</a>(op2);
    if type1 == <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> || type2 == <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        result = <a link="impl-shared.FPDefaultNaN.1" file="shared_pseudocode.xml" hover="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
    else
        inf1 = (type1 == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        inf2 = (type2 == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        zero2 = (type2 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result = <a link="impl-shared.FPDefaultNaN.1" file="shared_pseudocode.xml" hover="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
        elsif inf1 || inf2 then
            result = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign1 EOR sign2);
        elsif zero1 || zero2 then
            result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(sign1 EOR sign2);
        else
            result = <a link="impl-shared.BFRound.1" file="shared_pseudocode.xml" hover="function: bits(32) BFRound(real op)">BFRound</a>(value1*value2);

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/bfloat/BFMulAdd" mylink="shared.functions.float.bfloat.BFMulAdd" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// BFMulAdd()
// ==========
// Used by BFMLALB and BFMLALT instructions.

bits(N) <anchor link="impl-shared.BFMulAdd.4" hover="function: bits(N) BFMulAdd(bits(N) addend, bits(N) op1, bits(N) op2, FPCRType fpcr_in)">BFMulAdd</anchor>(bits(N) addend, bits(N) op1, bits(N) op2, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr_in)
    <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    boolean altfp = <a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; fpcr.AH == '1';  // When TRUE:
    boolean fpexc = !altfp;                         //     Do not generate floating point exceptions
    if altfp then fpcr.&lt;FIZ,FZ&gt; = '11';             //     Flush denormal input and output to zero
    if altfp then fpcr.RMode    = '00';             //     Use RNE rounding mode
    return <a link="impl-shared.FPMulAdd.5" file="shared_pseudocode.xml" hover="function: bits(N) FPMulAdd(bits(N) addend, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean fpexc)">FPMulAdd</a>(addend, op1, op2, fpcr, fpexc);</pstext>
    </ps>
    <ps name="shared/functions/float/bfloat/BFNeg" mylink="shared.functions.float.bfloat.BFNeg" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// BFNeg()
// =======

bits(16) <anchor link="impl-shared.BFNeg.1" hover="function: bits(16) BFNeg(bits(16) op)">BFNeg</anchor>(bits(16) op)
    return NOT(op&lt;15&gt;) : op&lt;14:0&gt;;</pstext>
    </ps>
    <ps name="shared/functions/float/bfloat/BFRound" mylink="shared.functions.float.bfloat.BFRound" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// BFRound()
// =========
// Converts a real number OP into a single-precision value using the
// Round to Odd rounding mode and following BFloat16 computation behaviors.

bits(32) <anchor link="impl-shared.BFRound.1" hover="function: bits(32) BFRound(real op)">BFRound</anchor>(real op)

    assert op != 0.0;
    bits(32) result;

    // Format parameters - minimum exponent, numbers of exponent and fraction bits.
    minimum_exp = -126;  E = 8;  F = 23;

    // Split value into sign, unrounded mantissa and exponent.
    bit sign;
    real mantissa;
    if op &lt; 0.0 then
        sign = '1';  mantissa = -op;
    else
        sign = '0';  mantissa = op;
    exponent = 0;
    while mantissa &lt; 1.0 do
        mantissa = mantissa * 2.0;  exponent = exponent - 1;
    while mantissa &gt;= 2.0 do
        mantissa = mantissa / 2.0;  exponent = exponent + 1;

    // Fixed Flush-to-zero.
    if exponent &lt; minimum_exp then
        return <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);

    // Start creating the exponent value for the result. Start by biasing the actual exponent
    // so that the minimum exponent becomes 1, lower values 0 (indicating possible underflow).
    biased_exp = <a link="impl-shared.Max.2" file="shared_pseudocode.xml" hover="function: integer Max(integer a, integer b)">Max</a>((exponent - minimum_exp) + 1, 0);
    if biased_exp == 0 then mantissa = mantissa / 2.0^(minimum_exp - exponent);

    // Get the unrounded mantissa as an integer, and the "units in last place" rounding error.
    int_mant = <a link="impl-shared.RoundDown.1" file="shared_pseudocode.xml" hover="function: integer RoundDown(real x)">RoundDown</a>(mantissa * 2.0^F);  // &lt; 2.0^F if biased_exp == 0, &gt;= 2.0^F if not
    error = mantissa * 2.0^F - Real(int_mant);

    // Round to Odd
    if error != 0.0 then
        int_mant&lt;0&gt; = '1';

    // Deal with overflow and generate result.
    if biased_exp &gt;= 2^E - 1 then
        result = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign);      // Overflows generate appropriately-signed Infinity
    else
        result = sign : biased_exp&lt;30-F:0&gt; : int_mant&lt;F-1:0&gt;;

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/bfloat/BFUnpack" mylink="shared.functions.float.bfloat.BFUnpack" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// BFUnpack()
// ==========
// Unpacks a BFloat16 or single-precision value into its type,
// sign bit and real number that it represents.
// The real number result has the correct sign for numbers and infinities,
// is very large in magnitude for infinities, and is 0.0 for NaNs.
// (These values are chosen to simplify the description of
// comparisons and conversions.)

(FPType, bit, real) <anchor link="impl-shared.BFUnpack.1" hover="function: (FPType, bit, real) BFUnpack(bits(N) fpval)">BFUnpack</anchor>(bits(N) fpval)

    assert N IN {16,32};

    bit sign;
    bits(8) exp;
    bits(23) frac;
    if N == 16 then
        sign   = fpval&lt;15&gt;;
        exp    = fpval&lt;14:7&gt;;
        frac   = fpval&lt;6:0&gt; : <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(16);
    else  // N == 32
        sign   = fpval&lt;31&gt;;
        exp    = fpval&lt;30:23&gt;;
        frac   = fpval&lt;22:0&gt;;

    <a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> fptype;
    real value;
    if <a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(exp) then
        fptype = <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>;  value = 0.0;    // Fixed Flush to Zero
    elsif <a link="impl-shared.IsOnes.1" file="shared_pseudocode.xml" hover="function: boolean IsOnes(bits(N) x)">IsOnes</a>(exp) then
        if <a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(frac) then
            fptype = <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>;  value = 2.0^1000000;
        else    // no SNaN for BF16 arithmetic
            fptype = <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>; value = 0.0;
    else
        fptype = <a link="FPType_Nonzero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Nonzero</a>;
        value = 2.0^(<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(exp)-127) * (1.0 + Real(<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(frac)) * 2.0^-23);

    if sign == '1' then value = -value;

    return (fptype, sign, value);</pstext>
    </ps>
    <ps name="shared/functions/float/bfloat/FPConvertBF" mylink="shared.functions.float.bfloat.FPConvertBF" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPConvertBF()
// =============
// Converts a single-precision OP to BFloat16 value with using rounding mode of
// Round to Nearest Even when executed from AArch64 state and
// FPCR.AH == '1', otherwise rounding is controlled by FPCR/FPSCR.

bits(16) <anchor link="impl-shared.FPConvertBF.3" hover="function: bits(16) FPConvertBF(bits(32) op, FPCRType fpcr_in, FPRounding rounding_in)">FPConvertBF</anchor>(bits(32) op, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr_in, <a link="FPRounding" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding_in)

    <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    <a link="FPRounding" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding = rounding_in;
    bits(32) result;                                // BF16 value in top 16 bits
    boolean altfp = <a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    boolean fpexc = !altfp;                         // Generate no floating-point exceptions
    if altfp then fpcr.&lt;FIZ,FZ&gt; = '11';             // Flush denormal input and output to zero
    if altfp then rounding = <a link="FPRounding_TIEEVEN" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEEVEN</a>;    // Use RNE rounding mode

    // Unpack floating-point operand, with always flush-to-zero if fpcr.AH == '1'.
    (fptype,sign,value) = <a link="impl-shared.FPUnpack.3" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op, fpcr, fpexc);

    if fptype == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        if fpcr.DN == '1' then
            result = <a link="impl-shared.FPDefaultNaN.1" file="shared_pseudocode.xml" hover="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
        else
            result = <a link="impl-shared.FPConvertNaN.1" file="shared_pseudocode.xml" hover="function: bits(M) FPConvertNaN(bits(N) op)">FPConvertNaN</a>(op);
        if fptype == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
            if fpexc then <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InvalidOp" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    elsif fptype == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then
        result = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign);
    elsif fptype == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
        result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
    else
        result = <a link="impl-shared.FPRoundCVBF.4" file="shared_pseudocode.xml" hover="function: bits(32) FPRoundCVBF(real op, FPCRType fpcr, FPRounding rounding, boolean fpexc)">FPRoundCVBF</a>(value, fpcr, rounding, fpexc);

    // Returns correctly rounded BF16 value from top 16 bits
    return result&lt;31:16&gt;;

// FPConvertBF()
// =============
// Converts a single-precision operand to BFloat16 value.

bits(16) <anchor link="impl-shared.FPConvertBF.2" hover="function: bits(16) FPConvertBF(bits(32) op, FPCRType fpcr)">FPConvertBF</anchor>(bits(32) op, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)
    return <a link="impl-shared.FPConvertBF.3" file="shared_pseudocode.xml" hover="function: bits(16) FPConvertBF(bits(32) op, FPCRType fpcr_in, FPRounding rounding_in)">FPConvertBF</a>(op, fpcr, <a link="impl-shared.FPRoundingMode.1" file="shared_pseudocode.xml" hover="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr));</pstext>
    </ps>
    <ps name="shared/functions/float/bfloat/FPRoundCVBF" mylink="shared.functions.float.bfloat.FPRoundCVBF" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPRoundCVBF()
// =============
// Converts a real number OP into a BFloat16 value using the supplied
// rounding mode RMODE. The 'fpexc' argument controls the generation of
// floating-point exceptions.

bits(32) <anchor link="impl-shared.FPRoundCVBF.4" hover="function: bits(32) FPRoundCVBF(real op, FPCRType fpcr, FPRounding rounding, boolean fpexc)">FPRoundCVBF</anchor>(real op, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr, <a link="FPRounding" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding, boolean fpexc)
    boolean isbfloat16 = TRUE;
    return <a link="impl-shared.FPRoundBase.5" file="shared_pseudocode.xml" hover="function: bits(N) FPRoundBase(real op, FPCRType fpcr, FPRounding rounding,&#13; boolean isbfloat16, boolean fpexc)">FPRoundBase</a>(op, fpcr, rounding, isbfloat16, fpexc);</pstext>
    </ps>
    <ps name="shared/functions/float/fixedtofp/FixedToFP" mylink="shared.functions.float.fixedtofp.FixedToFP" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FixedToFP()
// ===========

// Convert M-bit fixed point OP with FBITS fractional bits to
// N-bit precision floating point, controlled by UNSIGNED and ROUNDING.

bits(N) <anchor link="impl-shared.FixedToFP.5" hover="function: bits(N) FixedToFP(bits(M) op, integer fbits, boolean unsigned, FPCRType fpcr, FPRounding rounding)">FixedToFP</anchor>(bits(M) op, integer fbits, boolean unsigned, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr, <a link="FPRounding" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding)

    assert N IN {16,32,64};
    assert M IN {16,32,64};
    bits(N) result;
    assert fbits &gt;= 0;
    assert rounding != <a link="FPRounding_ODD" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ODD</a>;

    // Correct signed-ness
    int_operand = <a link="impl-shared.Int.2" file="shared_pseudocode.xml" hover="function: integer Int(bits(N) x, boolean unsigned)">Int</a>(op, unsigned);

    // Scale by fractional bits and generate a real value
    real_operand = Real(int_operand) / 2.0^fbits;

    if real_operand == 0.0 then
        result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>('0');
    else
        result = <a link="impl-shared.FPRound.3" file="shared_pseudocode.xml" hover="function: bits(N) FPRound(real op, FPCRType fpcr_in, FPRounding rounding)">FPRound</a>(real_operand, fpcr, rounding);

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fpabs/FPAbs" mylink="shared.functions.float.fpabs.FPAbs" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPAbs()
// =======

bits(N) <anchor link="impl-shared.FPAbs.1" hover="function: bits(N) FPAbs(bits(N) op)">FPAbs</anchor>(bits(N) op)

    assert N IN {16,32,64};
    if !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; <a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() then
        <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr = FPCR[];
        if fpcr.AH == '1' then
            (fptype, -, -) = <a link="impl-shared.FPUnpack.3" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op, fpcr, FALSE);
            if fptype IN {<a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} then
                return op;        // When fpcr.AH=1, sign of NaN has no consequence

    return '0' : op&lt;N-2:0&gt;;</pstext>
    </ps>
    <ps name="shared/functions/float/fpadd/FPAdd" mylink="shared.functions.float.fpadd.FPAdd" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPAdd()
// =======

bits(N) <anchor link="impl-shared.FPAdd.3" hover="function: bits(N) FPAdd(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPAdd</anchor>(bits(N) op1, bits(N) op2, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)
    boolean fpexc = TRUE;       // Generate floating-point exceptions
    return <a link="impl-shared.FPAdd.4" file="shared_pseudocode.xml" hover="function: bits(N) FPAdd(bits(N) op1, bits(N) op2, FPCRType fpcr, boolean fpexc)">FPAdd</a>(op1, op2, fpcr, fpexc);

// FPAdd()
// =======

bits(N) <anchor link="impl-shared.FPAdd.4" hover="function: bits(N) FPAdd(bits(N) op1, bits(N) op2, FPCRType fpcr, boolean fpexc)">FPAdd</anchor>(bits(N) op1, bits(N) op2, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr, boolean fpexc)

    assert N IN {16,32,64};
    rounding = <a link="impl-shared.FPRoundingMode.1" file="shared_pseudocode.xml" hover="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);

    (type1,sign1,value1) = <a link="impl-shared.FPUnpack.3" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op1, fpcr, fpexc);
    (type2,sign2,value2) = <a link="impl-shared.FPUnpack.3" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op2, fpcr, fpexc);

    boolean altfmaxfmin = FALSE;    // Do not use altfp mode for FMIN, FMAX and variants
    (done,result) = <a link="impl-shared.FPProcessNaNs.7" file="shared_pseudocode.xml" hover="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean altfmaxfmin, boolean fpexc)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr, altfmaxfmin, fpexc);
    if !done then
        inf1  = (type1 == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);  inf2  = (type2 == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);      zero2 = (type2 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        if inf1 &amp;&amp; inf2 &amp;&amp; sign1 == NOT(sign2) then
            result = <a link="impl-shared.FPDefaultNaN.1" file="shared_pseudocode.xml" hover="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
            if fpexc then <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InvalidOp" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        elsif (inf1 &amp;&amp; sign1 == '0') || (inf2 &amp;&amp; sign2 == '0') then
            result = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('0');
        elsif (inf1 &amp;&amp; sign1 == '1') || (inf2 &amp;&amp; sign2 == '1') then
            result = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('1');
        elsif zero1 &amp;&amp; zero2 &amp;&amp; sign1 == sign2 then
            result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(sign1);
        else
            result_value = value1 + value2;
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                result_sign = if rounding == <a link="FPRounding_NEGINF" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a> then '1' else '0';
                result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(result_sign);
            else
                result = <a link="impl-shared.FPRound.4" file="shared_pseudocode.xml" hover="function: bits(N) FPRound(real op, FPCRType fpcr_in, FPRounding rounding, boolean fpexc)">FPRound</a>(result_value, fpcr, rounding, fpexc);

        if fpexc then <a link="impl-shared.FPProcessDenorms.4" file="shared_pseudocode.xml" hover="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fpcompare/FPCompare" mylink="shared.functions.float.fpcompare.FPCompare" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPCompare()
// ===========

bits(4) <anchor link="impl-shared.FPCompare.4" hover="function: bits(4) FPCompare(bits(N) op1, bits(N) op2, boolean signal_nans, FPCRType fpcr)">FPCompare</anchor>(bits(N) op1, bits(N) op2, boolean signal_nans, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    (type1,sign1,value1) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);

    bits(4) result;
    if type1 IN {<a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} || type2 IN {<a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} then
        result = '0011';
        if type1 == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || type2 == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || signal_nans then
            <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InvalidOp" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    else
        // All non-NaN cases can be evaluated on the values produced by FPUnpack()
        if value1 == value2 then
            result = '0110';
        elsif value1 &lt; value2 then
            result = '1000';
        else  // value1 &gt; value2
            result = '0010';

        <a link="impl-shared.FPProcessDenorms.4" file="shared_pseudocode.xml" hover="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fpcompareeq/FPCompareEQ" mylink="shared.functions.float.fpcompareeq.FPCompareEQ" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPCompareEQ()
// =============

boolean <anchor link="impl-shared.FPCompareEQ.3" hover="function: boolean FPCompareEQ(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPCompareEQ</anchor>(bits(N) op1, bits(N) op2, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    (type1,sign1,value1) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);

    boolean result;
    if type1 IN {<a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} || type2 IN {<a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} then
        result = FALSE;
        if type1 == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || type2 == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
            <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InvalidOp" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    else
        // All non-NaN cases can be evaluated on the values produced by FPUnpack()
        result = (value1 == value2);

        <a link="impl-shared.FPProcessDenorms.4" file="shared_pseudocode.xml" hover="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fpcomparege/FPCompareGE" mylink="shared.functions.float.fpcomparege.FPCompareGE" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPCompareGE()
// =============

boolean <anchor link="impl-shared.FPCompareGE.3" hover="function: boolean FPCompareGE(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPCompareGE</anchor>(bits(N) op1, bits(N) op2, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    (type1,sign1,value1) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);

    boolean result;
    if type1 IN {<a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} || type2 IN {<a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} then
        result = FALSE;
        <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InvalidOp" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    else
        // All non-NaN cases can be evaluated on the values produced by FPUnpack()
        result = (value1 &gt;= value2);
        <a link="impl-shared.FPProcessDenorms.4" file="shared_pseudocode.xml" hover="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fpcomparegt/FPCompareGT" mylink="shared.functions.float.fpcomparegt.FPCompareGT" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPCompareGT()
// =============

boolean <anchor link="impl-shared.FPCompareGT.3" hover="function: boolean FPCompareGT(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPCompareGT</anchor>(bits(N) op1, bits(N) op2, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    (type1,sign1,value1) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);

    boolean result;
    if type1 IN {<a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} || type2 IN {<a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} then
        result = FALSE;
        <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InvalidOp" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    else
        // All non-NaN cases can be evaluated on the values produced by FPUnpack()
        result = (value1 &gt; value2);

        <a link="impl-shared.FPProcessDenorms.4" file="shared_pseudocode.xml" hover="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fpconvert/FPConvert" mylink="shared.functions.float.fpconvert.FPConvert" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPConvert()
// ===========

// Convert floating point OP with N-bit precision to M-bit precision,
// with rounding controlled by ROUNDING.
// This is used by the FP-to-FP conversion instructions and so for
// half-precision data ignores FZ16, but observes AHP.

bits(M) <anchor link="impl-shared.FPConvert.3" hover="function: bits(M) FPConvert(bits(N) op, FPCRType fpcr, FPRounding rounding)">FPConvert</anchor>(bits(N) op, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr, <a link="FPRounding" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding)

    assert M IN {16,32,64};
    assert N IN {16,32,64};
    bits(M) result;

    // Unpack floating-point operand optionally with flush-to-zero.
    (fptype,sign,value) = <a link="impl-shared.FPUnpackCV.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpackCV(bits(N) fpval, FPCRType fpcr_in)">FPUnpackCV</a>(op, fpcr);

    alt_hp = (M == 16) &amp;&amp; (fpcr.AHP == '1');

    if fptype == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        if alt_hp then
            result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
        elsif fpcr.DN == '1' then
            result = <a link="impl-shared.FPDefaultNaN.1" file="shared_pseudocode.xml" hover="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
        else
            result = <a link="impl-shared.FPConvertNaN.1" file="shared_pseudocode.xml" hover="function: bits(M) FPConvertNaN(bits(N) op)">FPConvertNaN</a>(op);
        if fptype == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || alt_hp then
            <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InvalidOp" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>,fpcr);
    elsif fptype == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then
        if alt_hp then
            result = sign:<a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(M-1);
            <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InvalidOp" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        else
            result = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign);
    elsif fptype == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
        result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
    else
        result = <a link="impl-shared.FPRoundCV.3" file="shared_pseudocode.xml" hover="function: bits(N) FPRoundCV(real op, FPCRType fpcr_in, FPRounding rounding)">FPRoundCV</a>(value, fpcr, rounding);

        <a link="impl-shared.FPProcessDenorm.3" file="shared_pseudocode.xml" hover="function: FPProcessDenorm(FPType fptype, integer N, FPCRType fpcr)">FPProcessDenorm</a>(fptype, N, fpcr);

    return result;

// FPConvert()
// ===========

bits(M) <anchor link="impl-shared.FPConvert.2" hover="function: bits(M) FPConvert(bits(N) op, FPCRType fpcr)">FPConvert</anchor>(bits(N) op, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)
    return <a link="impl-shared.FPConvert.3" file="shared_pseudocode.xml" hover="function: bits(M) FPConvert(bits(N) op, FPCRType fpcr, FPRounding rounding)">FPConvert</a>(op, fpcr, <a link="impl-shared.FPRoundingMode.1" file="shared_pseudocode.xml" hover="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr));</pstext>
    </ps>
    <ps name="shared/functions/float/fpconvertnan/FPConvertNaN" mylink="shared.functions.float.fpconvertnan.FPConvertNaN" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPConvertNaN()
// ==============
// Converts a NaN of one floating-point type to another

bits(M) <anchor link="impl-shared.FPConvertNaN.1" hover="function: bits(M) FPConvertNaN(bits(N) op)">FPConvertNaN</anchor>(bits(N) op)

    assert N IN {16,32,64};
    assert M IN {16,32,64};
    bits(M) result;
    bits(51) frac;

    sign = op&lt;N-1&gt;;

    // Unpack payload from input NaN
    case N of
        when 64 frac = op&lt;50:0&gt;;
        when 32 frac = op&lt;21:0&gt;:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(29);
        when 16 frac = op&lt;8:0&gt;:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(42);

    // Repack payload into output NaN, while
    // converting an SNaN to a QNaN.
    case M of
        when 64 result = sign:<a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(M-52):frac;
        when 32 result = sign:<a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(M-23):frac&lt;50:29&gt;;
        when 16 result = sign:<a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(M-10):frac&lt;50:42&gt;;

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fpcrtype/FPCRType" mylink="shared.functions.float.fpcrtype.FPCRType" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">type <anchor link="FPCRType" hover="type FPCRType">FPCRType</anchor>;</pstext>
    </ps>
    <ps name="shared/functions/float/fpdecoderm/FPDecodeRM" mylink="shared.functions.float.fpdecoderm.FPDecodeRM" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPDecodeRM()
// ============

// Decode most common AArch32 floating-point rounding encoding.

FPRounding <anchor link="impl-shared.FPDecodeRM.1" hover="function: FPRounding FPDecodeRM(bits(2) rm)">FPDecodeRM</anchor>(bits(2) rm)

    <a link="FPRounding" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> result;
    case rm of
        when '00' result = <a link="FPRounding_TIEAWAY" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEAWAY</a>; // A
        when '01' result = <a link="FPRounding_TIEEVEN" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEEVEN</a>; // N
        when '10' result = <a link="FPRounding_POSINF" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_POSINF</a>;  // P
        when '11' result = <a link="FPRounding_NEGINF" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a>;  // M

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fpdecoderounding/FPDecodeRounding" mylink="shared.functions.float.fpdecoderounding.FPDecodeRounding" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPDecodeRounding()
// ==================

// Decode floating-point rounding mode and common AArch64 encoding.

FPRounding <anchor link="impl-shared.FPDecodeRounding.1" hover="function: FPRounding FPDecodeRounding(bits(2) rmode)">FPDecodeRounding</anchor>(bits(2) rmode)
    case rmode of
        when '00' return <a link="FPRounding_TIEEVEN" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEEVEN</a>; // N
        when '01' return <a link="FPRounding_POSINF" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_POSINF</a>;  // P
        when '10' return <a link="FPRounding_NEGINF" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a>;  // M
        when '11' return <a link="FPRounding_ZERO" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ZERO</a>;    // Z</pstext>
    </ps>
    <ps name="shared/functions/float/fpdefaultnan/FPDefaultNaN" mylink="shared.functions.float.fpdefaultnan.FPDefaultNaN" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPDefaultNaN()
// ==============

bits(N) <anchor link="impl-shared.FPDefaultNaN.0" hover="function: bits(N) FPDefaultNaN()">FPDefaultNaN</anchor>()
    <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr = FPCR[];
    return <a link="impl-shared.FPDefaultNaN.1" file="shared_pseudocode.xml" hover="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);

bits(N) <anchor link="impl-shared.FPDefaultNaN.1" hover="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</anchor>(<a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    bit sign = if <a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then fpcr.AH else '0';

    bits(E) exp  = <a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(E);
    bits(F) frac = '1':<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(F-1);

    return sign : exp : frac;</pstext>
    </ps>
    <ps name="shared/functions/float/fpdiv/FPDiv" mylink="shared.functions.float.fpdiv.FPDiv" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPDiv()
// =======

bits(N) <anchor link="impl-shared.FPDiv.3" hover="function: bits(N) FPDiv(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPDiv</anchor>(bits(N) op1, bits(N) op2, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    (type1,sign1,value1) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);
    (done,result) = <a link="impl-shared.FPProcessNaNs.5" file="shared_pseudocode.xml" hover="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1,&#13; bits(N) op2, FPCRType fpcr)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr);

    if !done then
        inf1  = type1 == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>;
        inf2  = type2 == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>;
        zero1 = type1 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>;
        zero2 = type2 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>;

        if (inf1 &amp;&amp; inf2) || (zero1 &amp;&amp; zero2) then
            result = <a link="impl-shared.FPDefaultNaN.1" file="shared_pseudocode.xml" hover="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
            <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InvalidOp" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        elsif inf1 || zero2 then
            result = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign1 EOR sign2);
            if !inf1 then <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_DivideByZero" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_DivideByZero</a>, fpcr);
        elsif zero1 || inf2 then
            result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(sign1 EOR sign2);
        else
            result = <a link="impl-shared.FPRound.2" file="shared_pseudocode.xml" hover="function: bits(N) FPRound(real op, FPCRType fpcr)">FPRound</a>(value1/value2, fpcr);

        if !zero2 then
            <a link="impl-shared.FPProcessDenorms.4" file="shared_pseudocode.xml" hover="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fpexc/FPExc" mylink="shared.functions.float.fpexc.FPExc" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="FPExc" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc</anchor>       {<anchor link="FPExc_InvalidOp" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</anchor>, <anchor link="FPExc_DivideByZero" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_DivideByZero</anchor>, <anchor link="FPExc_Overflow" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Overflow</anchor>,
                         <anchor link="FPExc_Underflow" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Underflow</anchor>, <anchor link="FPExc_Inexact" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Inexact</anchor>, <anchor link="FPExc_InputDenorm" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InputDenorm</anchor>};</pstext>
    </ps>
    <ps name="shared/functions/float/fpinfinity/FPInfinity" mylink="shared.functions.float.fpinfinity.FPInfinity" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPInfinity()
// ============

bits(N) <anchor link="impl-shared.FPInfinity.1" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</anchor>(bit sign)

    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    bits(E) exp  = <a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(E);
    bits(F) frac = <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(F);

    return sign : exp : frac;</pstext>
    </ps>
    <ps name="shared/functions/float/fpmax/FPMax" mylink="shared.functions.float.fpmax.FPMax" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPMax()
// =======

bits(N) <anchor link="impl-shared.FPMax.3" hover="function: bits(N) FPMax(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPMax</anchor>(bits(N) op1, bits(N) op2, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)
    boolean altfp = <a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    return <a link="impl-shared.FPMax.4" file="shared_pseudocode.xml" hover="function: bits(N) FPMax(bits(N) op1, bits(N) op2, FPCRType fpcr_in, boolean altfp)">FPMax</a>(op1, op2, fpcr, altfp);

// FPMax()
// =======
// Compare two inputs and return the larger value after rounding. The
// 'fpcr' argument supplies the FPCR control bits and 'altfp' determines
// if the function should use alternative floating-point behaviour.

bits(N) <anchor link="impl-shared.FPMax.4" hover="function: bits(N) FPMax(bits(N) op1, bits(N) op2, FPCRType fpcr_in, boolean altfp)">FPMax</anchor>(bits(N) op1, bits(N) op2, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr_in, boolean altfp)

    assert N IN {16,32,64};
    <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    (type1,sign1,value1) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);

    if (altfp &amp;&amp; type1 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> &amp;&amp; type2 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> &amp;&amp;
        ((sign1 == '0' &amp;&amp; sign2 == '1') || (sign1 == '1' &amp;&amp; sign2 == '0'))) then
        return <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(sign2);

    (done,result) = <a link="impl-shared.FPProcessNaNs.7" file="shared_pseudocode.xml" hover="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean altfmaxfmin, boolean fpexc)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr, altfp, TRUE);

    if !done then
        <a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> fptype;
        bit sign;
        real value;
        if value1 &gt; value2 then
            (fptype,sign,value) = (type1,sign1,value1);
        else
            (fptype,sign,value) = (type2,sign2,value2);
        if fptype == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then
            result = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign);
        elsif fptype == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
            sign = sign1 AND sign2;         // Use most positive sign
            result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
        else
            // The use of FPRound() covers the case where there is a trapped underflow exception
            // for a denormalized number even though the result is exact.
            rounding = <a link="impl-shared.FPRoundingMode.1" file="shared_pseudocode.xml" hover="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);
            if altfp then    // Denormal output is not flushed to zero
                fpcr.FZ = '0';
                fpcr.FZ16 = '0';

            result = <a link="impl-shared.FPRound.4" file="shared_pseudocode.xml" hover="function: bits(N) FPRound(real op, FPCRType fpcr_in, FPRounding rounding, boolean fpexc)">FPRound</a>(value, fpcr, rounding, TRUE);

        <a link="impl-shared.FPProcessDenorms.4" file="shared_pseudocode.xml" hover="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fpmaxnormal/FPMaxNormal" mylink="shared.functions.float.fpmaxnormal.FPMaxNormal" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPMaxNormal()
// =============

bits(N) <anchor link="impl-shared.FPMaxNormal.1" hover="function: bits(N) FPMaxNormal(bit sign)">FPMaxNormal</anchor>(bit sign)

    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp  = <a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(E-1):'0';
    frac = <a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(F);

    return sign : exp : frac;</pstext>
    </ps>
    <ps name="shared/functions/float/fpmaxnum/FPMaxNum" mylink="shared.functions.float.fpmaxnum.FPMaxNum" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPMaxNum()
// ==========

bits(N) <anchor link="impl-shared.FPMaxNum.3" hover="function: bits(N) FPMaxNum(bits(N) op1_in, bits(N) op2_in, FPCRType fpcr)">FPMaxNum</anchor>(bits(N) op1_in, bits(N) op2_in, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    bits(N) op1 = op1_in;
    bits(N) op2 = op2_in;
    (type1,-,-) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,-,-) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);

    boolean type1_nan = type1 IN {<a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>, <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>};
    boolean type2_nan = type2 IN {<a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>, <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>};
    boolean altfp = <a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';

    if !(altfp &amp;&amp; type1_nan &amp;&amp; type2_nan) then
        // Treat a single quiet-NaN as -Infinity.
        if type1 == <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> &amp;&amp; type2 != <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
            op1 = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('1');
        elsif type1 != <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> &amp;&amp; type2 == <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
            op2 = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('1');

    altfmaxfmin = FALSE;    // Restrict use of FMAX/FMIN NaN propagation rules
    result = <a link="impl-shared.FPMax.4" file="shared_pseudocode.xml" hover="function: bits(N) FPMax(bits(N) op1, bits(N) op2, FPCRType fpcr_in, boolean altfp)">FPMax</a>(op1, op2, fpcr, altfmaxfmin);

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fpmerge/IsMerging" mylink="shared.functions.float.fpmerge.IsMerging" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// IsMerging()
// ===========
// Returns TRUE if the output elements other than the lowest are taken from
// the destination register.

boolean <anchor link="impl-shared.IsMerging.1" hover="function: boolean IsMerging(FPCRType fpcr)">IsMerging</anchor>(<a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)
    boolean merge = <a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.NEP == '1';
    return merge;</pstext>
    </ps>
    <ps name="shared/functions/float/fpmin/FPMin" mylink="shared.functions.float.fpmin.FPMin" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPMin()
// =======

bits(N) <anchor link="impl-shared.FPMin.3" hover="function: bits(N) FPMin(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPMin</anchor>(bits(N) op1, bits(N) op2, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)
    boolean altfp = <a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    return <a link="impl-shared.FPMin.4" file="shared_pseudocode.xml" hover="function: bits(N) FPMin(bits(N) op1, bits(N) op2, FPCRType fpcr_in, boolean altfp)">FPMin</a>(op1, op2, fpcr, altfp);

// FPMin()
// =======
// Compare two operands and return the smaller operand after rounding. The
// 'fpcr' argument supplies the FPCR control bits and 'altfp' determines
// if the function should use alternative behaviour.

bits(N) <anchor link="impl-shared.FPMin.4" hover="function: bits(N) FPMin(bits(N) op1, bits(N) op2, FPCRType fpcr_in, boolean altfp)">FPMin</anchor>(bits(N) op1, bits(N) op2, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr_in, boolean altfp)

    assert N IN {16,32,64};
    <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    (type1,sign1,value1) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);

    if (altfp &amp;&amp; type1 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> &amp;&amp; type2 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> &amp;&amp;
        ((sign1 == '0' &amp;&amp; sign2 == '1') || (sign1 == '1' &amp;&amp; sign2 == '0'))) then
        return <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(sign2);

    (done,result) = <a link="impl-shared.FPProcessNaNs.7" file="shared_pseudocode.xml" hover="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean altfmaxfmin, boolean fpexc)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr, altfp, TRUE);

    if !done then
        <a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> fptype;
        bit sign;
        real value;
        <a link="FPRounding" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding;
        if value1 &lt; value2 then
            (fptype,sign,value) = (type1,sign1,value1);
        else
            (fptype,sign,value) = (type2,sign2,value2);
        if fptype == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then
            result = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign);
        elsif fptype == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
            sign = sign1 OR sign2;              // Use most negative sign
            result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
        else
            // The use of FPRound() covers the case where there is a trapped underflow exception
            // for a denormalized number even though the result is exact.
            rounding = <a link="impl-shared.FPRoundingMode.1" file="shared_pseudocode.xml" hover="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);
            if altfp then    // Denormal output is not flushed to zero
                fpcr.FZ = '0';
                fpcr.FZ16 = '0';

            result = <a link="impl-shared.FPRound.4" file="shared_pseudocode.xml" hover="function: bits(N) FPRound(real op, FPCRType fpcr_in, FPRounding rounding, boolean fpexc)">FPRound</a>(value, fpcr, rounding, TRUE);

        <a link="impl-shared.FPProcessDenorms.4" file="shared_pseudocode.xml" hover="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fpminnum/FPMinNum" mylink="shared.functions.float.fpminnum.FPMinNum" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPMinNum()
// ==========

bits(N) <anchor link="impl-shared.FPMinNum.3" hover="function: bits(N) FPMinNum(bits(N) op1_in, bits(N) op2_in, FPCRType fpcr)">FPMinNum</anchor>(bits(N) op1_in, bits(N) op2_in, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    bits(N) op1 = op1_in;
    bits(N) op2 = op2_in;
    (type1,-,-) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,-,-) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);

    boolean type1_nan = type1 IN {<a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>, <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>};
    boolean type2_nan = type2 IN {<a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>, <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>};
    boolean altfp = <a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';

    if !(altfp &amp;&amp; type1_nan &amp;&amp; type2_nan) then
        // Treat a single quiet-NaN as +Infinity.
        if type1 == <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> &amp;&amp; type2 != <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
            op1 = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('0');
        elsif type1 != <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> &amp;&amp; type2 == <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
            op2 = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('0');

    altfmaxfmin = FALSE;    // Restrict use of FMAX/FMIN NaN propagation rules
    result = <a link="impl-shared.FPMin.4" file="shared_pseudocode.xml" hover="function: bits(N) FPMin(bits(N) op1, bits(N) op2, FPCRType fpcr_in, boolean altfp)">FPMin</a>(op1, op2, fpcr, altfmaxfmin);

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fpmul/FPMul" mylink="shared.functions.float.fpmul.FPMul" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPMul()
// =======

bits(N) <anchor link="impl-shared.FPMul.3" hover="function: bits(N) FPMul(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPMul</anchor>(bits(N) op1, bits(N) op2, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    (type1,sign1,value1) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);
    (done,result) = <a link="impl-shared.FPProcessNaNs.5" file="shared_pseudocode.xml" hover="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1,&#13; bits(N) op2, FPCRType fpcr)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        inf2 = (type2 == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        zero2 = (type2 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result = <a link="impl-shared.FPDefaultNaN.1" file="shared_pseudocode.xml" hover="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
            <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InvalidOp" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        elsif inf1 || inf2 then
            result = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign1 EOR sign2);
        elsif zero1 || zero2 then
            result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(sign1 EOR sign2);
        else
            result = <a link="impl-shared.FPRound.2" file="shared_pseudocode.xml" hover="function: bits(N) FPRound(real op, FPCRType fpcr)">FPRound</a>(value1*value2, fpcr);

        <a link="impl-shared.FPProcessDenorms.4" file="shared_pseudocode.xml" hover="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fpmuladd/FPMulAdd" mylink="shared.functions.float.fpmuladd.FPMulAdd" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPMulAdd()
// ==========

bits(N) <anchor link="impl-shared.FPMulAdd.4" hover="function: bits(N) FPMulAdd(bits(N) addend, bits(N) op1, bits(N) op2, FPCRType fpcr)">FPMulAdd</anchor>(bits(N) addend, bits(N) op1, bits(N) op2, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)
    boolean fpexc = TRUE;       // Generate floating-point exceptions
    return <a link="impl-shared.FPMulAdd.5" file="shared_pseudocode.xml" hover="function: bits(N) FPMulAdd(bits(N) addend, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean fpexc)">FPMulAdd</a>(addend, op1, op2, fpcr, fpexc);

// FPMulAdd()
// ==========
//
// Calculates addend + op1*op2 with a single rounding. The 'fpcr' argument
// supplies the FPCR control bits, and 'fpexc' controls the generation of
// floating-point exceptions.

bits(N) <anchor link="impl-shared.FPMulAdd.5" hover="function: bits(N) FPMulAdd(bits(N) addend, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean fpexc)">FPMulAdd</anchor>(bits(N) addend, bits(N) op1, bits(N) op2,
                 <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr, boolean fpexc)

    assert N IN {16,32,64};

    (typeA,signA,valueA) = <a link="impl-shared.FPUnpack.3" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(addend, fpcr, fpexc);
    (type1,sign1,value1) = <a link="impl-shared.FPUnpack.3" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op1, fpcr, fpexc);
    (type2,sign2,value2) = <a link="impl-shared.FPUnpack.3" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op2, fpcr, fpexc);
    rounding = <a link="impl-shared.FPRoundingMode.1" file="shared_pseudocode.xml" hover="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);
    inf1 = (type1 == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>); zero1 = (type1 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
    inf2 = (type2 == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>); zero2 = (type2 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

    (done,result) = <a link="impl-shared.FPProcessNaNs3.8" file="shared_pseudocode.xml" hover="function: (boolean, bits(N)) FPProcessNaNs3(FPType type1, FPType type2, FPType type3,&#13; bits(N) op1, bits(N) op2, bits(N) op3,&#13; FPCRType fpcr, boolean fpexc)">FPProcessNaNs3</a>(typeA, type1, type2, addend, op1, op2, fpcr, fpexc);

    if !(<a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1') then
        if typeA == <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> &amp;&amp; ((inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2)) then
            result = <a link="impl-shared.FPDefaultNaN.1" file="shared_pseudocode.xml" hover="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
            if fpexc then <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InvalidOp" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);

    if !done then
        infA = (typeA == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>); zeroA = (typeA == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

        // Determine sign and type product will have if it does not cause an
        // Invalid Operation.
        signP = sign1 EOR sign2;
        infP  = inf1 || inf2;
        zeroP = zero1 || zero2;

        // Non SNaN-generated Invalid Operation cases are multiplies of zero
        // by infinity and additions of opposite-signed infinities.
        invalidop = (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) || (infA &amp;&amp; infP &amp;&amp; signA != signP);

        if invalidop then
            result = <a link="impl-shared.FPDefaultNaN.1" file="shared_pseudocode.xml" hover="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
            if fpexc then <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InvalidOp" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        // Other cases involving infinities produce an infinity of the same sign.
        elsif (infA &amp;&amp; signA == '0') || (infP &amp;&amp; signP == '0') then
            result = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('0');
        elsif (infA &amp;&amp; signA == '1') || (infP &amp;&amp; signP == '1') then
            result = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('1');

        // Cases where the result is exactly zero and its sign is not determined by the
        // rounding mode are additions of same-signed zeros.
        elsif zeroA &amp;&amp; zeroP &amp;&amp; signA == signP then
            result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(signA);

        // Otherwise calculate numerical result and round it.
        else
            result_value = valueA + (value1 * value2);
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                result_sign = if rounding == <a link="FPRounding_NEGINF" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a> then '1' else '0';
                result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(result_sign);
            else
                result = <a link="impl-shared.FPRound.4" file="shared_pseudocode.xml" hover="function: bits(N) FPRound(real op, FPCRType fpcr_in, FPRounding rounding, boolean fpexc)">FPRound</a>(result_value, fpcr, rounding, fpexc);

        if !invalidop &amp;&amp; fpexc then
            <a link="impl-shared.FPProcessDenorms3.5" file="shared_pseudocode.xml" hover="function: FPProcessDenorms3(FPType type1, FPType type2, FPType type3, integer N, FPCRType fpcr)">FPProcessDenorms3</a>(typeA, type1, type2, N, fpcr);

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fpmuladdh/FPMulAddH" mylink="shared.functions.float.fpmuladdh.FPMulAddH" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPMulAddH()
// ===========
// Calculates addend + op1*op2.

bits(N) <anchor link="impl-shared.FPMulAddH.4" hover="function: bits(N) FPMulAddH(bits(N) addend, bits(N DIV 2) op1, bits(N DIV 2) op2, FPCRType fpcr)">FPMulAddH</anchor>(bits(N) addend, bits(N DIV 2) op1, bits(N DIV 2) op2, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)
    boolean fpexc = TRUE;       // Generate floating-point exceptions
    return <a link="impl-shared.FPMulAddH.5" file="shared_pseudocode.xml" hover="function: bits(N) FPMulAddH(bits(N) addend, bits(N DIV 2) op1, bits(N DIV 2) op2,&#13; FPCRType fpcr, boolean fpexc)">FPMulAddH</a>(addend, op1, op2, fpcr, fpexc);

// FPMulAddH()
// ===========
// Calculates addend + op1*op2.

bits(N) <anchor link="impl-shared.FPMulAddH.5" hover="function: bits(N) FPMulAddH(bits(N) addend, bits(N DIV 2) op1, bits(N DIV 2) op2,&#13; FPCRType fpcr, boolean fpexc)">FPMulAddH</anchor>(bits(N) addend, bits(N DIV 2) op1, bits(N DIV 2) op2,
                  <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr, boolean fpexc)

    assert N == 32;
    rounding = <a link="impl-shared.FPRoundingMode.1" file="shared_pseudocode.xml" hover="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);
    (typeA,signA,valueA) = <a link="impl-shared.FPUnpack.3" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(addend, fpcr, fpexc);
    (type1,sign1,value1) = <a link="impl-shared.FPUnpack.3" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op1, fpcr, fpexc);
    (type2,sign2,value2) = <a link="impl-shared.FPUnpack.3" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op2, fpcr, fpexc);
    inf1 = (type1 == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>); zero1 = (type1 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
    inf2 = (type2 == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>); zero2 = (type2 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

    (done,result) = <a link="impl-shared.FPProcessNaNs3H.8" file="shared_pseudocode.xml" hover="function: (boolean, bits(N)) FPProcessNaNs3H(FPType type1, FPType type2, FPType type3,&#13; bits(N) op1, bits(N DIV 2) op2, bits(N DIV 2) op3,&#13; FPCRType fpcr, boolean fpexc)">FPProcessNaNs3H</a>(typeA, type1, type2, addend, op1, op2, fpcr, fpexc);

    if !(<a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1') then
        if typeA == <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> &amp;&amp; ((inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2)) then
            result = <a link="impl-shared.FPDefaultNaN.1" file="shared_pseudocode.xml" hover="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
            if fpexc then <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InvalidOp" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);

    if !done then
        infA = (typeA == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>); zeroA = (typeA == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

        // Determine sign and type product will have if it does not cause an
        // Invalid Operation.
        signP = sign1 EOR sign2;
        infP = inf1 || inf2;
        zeroP = zero1 || zero2;

        // Non SNaN-generated Invalid Operation cases are multiplies of zero by infinity and
        // additions of opposite-signed infinities.
        invalidop = (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) || (infA &amp;&amp; infP &amp;&amp; signA != signP);

        if invalidop then
            result = <a link="impl-shared.FPDefaultNaN.1" file="shared_pseudocode.xml" hover="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
            if fpexc then <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InvalidOp" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);

        // Other cases involving infinities produce an infinity of the same sign.
        elsif (infA &amp;&amp; signA == '0') || (infP &amp;&amp; signP == '0') then
            result = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('0');
        elsif (infA &amp;&amp; signA == '1') || (infP &amp;&amp; signP == '1') then
            result = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('1');

        // Cases where the result is exactly zero and its sign is not determined by the
        // rounding mode are additions of same-signed zeros.
        elsif zeroA &amp;&amp; zeroP &amp;&amp; signA == signP then
            result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(signA);

        // Otherwise calculate numerical result and round it.
        else
            result_value = valueA + (value1 * value2);
            if result_value == 0.0 then // Sign of exact zero result depends on rounding mode
                result_sign = if rounding == <a link="FPRounding_NEGINF" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a> then '1' else '0';
                result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(result_sign);
            else
                result = <a link="impl-shared.FPRound.4" file="shared_pseudocode.xml" hover="function: bits(N) FPRound(real op, FPCRType fpcr_in, FPRounding rounding, boolean fpexc)">FPRound</a>(result_value, fpcr, rounding, fpexc);

        if !invalidop &amp;&amp; fpexc then
            <a link="impl-shared.FPProcessDenorm.3" file="shared_pseudocode.xml" hover="function: FPProcessDenorm(FPType fptype, integer N, FPCRType fpcr)">FPProcessDenorm</a>(typeA, N, fpcr);

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fpmuladdh/FPProcessNaNs3H" mylink="shared.functions.float.fpmuladdh.FPProcessNaNs3H" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPProcessNaNs3H()
// =================

(boolean, bits(N)) <anchor link="impl-shared.FPProcessNaNs3H.8" hover="function: (boolean, bits(N)) FPProcessNaNs3H(FPType type1, FPType type2, FPType type3,&#13; bits(N) op1, bits(N DIV 2) op2, bits(N DIV 2) op3,&#13; FPCRType fpcr, boolean fpexc)">FPProcessNaNs3H</anchor>(<a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type1, <a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type2, <a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type3,
                                   bits(N) op1, bits(N DIV 2) op2, bits(N DIV 2) op3,
                                   <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr, boolean fpexc)

    assert N IN {32,64};

    bits(N) result;
    <a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type_nan;
    // When TRUE, use alternative NaN propagation rules.
    boolean altfp   = <a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    boolean op1_nan = type1 IN {<a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};
    boolean op2_nan = type2 IN {<a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};
    boolean op3_nan = type3 IN {<a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};
    if altfp then
        if (type1 == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || type2 == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || type3 == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>) then
            type_nan = <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>;
        else
            type_nan = <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>;

    boolean done;
    if altfp &amp;&amp; op1_nan &amp;&amp; op2_nan &amp;&amp; op3_nan then          // &lt;n&gt; register NaN selected
        done = TRUE;  result = <a link="impl-shared.FPConvertNaN.1" file="shared_pseudocode.xml" hover="function: bits(M) FPConvertNaN(bits(N) op)">FPConvertNaN</a>(<a link="impl-shared.FPProcessNaN.4" file="shared_pseudocode.xml" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type_nan, op2, fpcr, fpexc));
    elsif altfp &amp;&amp; op2_nan &amp;&amp; (op1_nan || op3_nan) then     // &lt;n&gt; register NaN selected
        done = TRUE;  result = <a link="impl-shared.FPConvertNaN.1" file="shared_pseudocode.xml" hover="function: bits(M) FPConvertNaN(bits(N) op)">FPConvertNaN</a>(<a link="impl-shared.FPProcessNaN.4" file="shared_pseudocode.xml" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type_nan, op2, fpcr, fpexc));
    elsif altfp &amp;&amp; op3_nan &amp;&amp; op1_nan then                  // &lt;m&gt; register NaN selected
        done = TRUE;  result = <a link="impl-shared.FPConvertNaN.1" file="shared_pseudocode.xml" hover="function: bits(M) FPConvertNaN(bits(N) op)">FPConvertNaN</a>(<a link="impl-shared.FPProcessNaN.4" file="shared_pseudocode.xml" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type_nan, op3, fpcr, fpexc));
    elsif type1 == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE; result = <a link="impl-shared.FPProcessNaN.4" file="shared_pseudocode.xml" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type1, op1, fpcr, fpexc);
    elsif type2 == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE; result = <a link="impl-shared.FPConvertNaN.1" file="shared_pseudocode.xml" hover="function: bits(M) FPConvertNaN(bits(N) op)">FPConvertNaN</a>(<a link="impl-shared.FPProcessNaN.4" file="shared_pseudocode.xml" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type2, op2, fpcr, fpexc));
    elsif type3 == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE; result = <a link="impl-shared.FPConvertNaN.1" file="shared_pseudocode.xml" hover="function: bits(M) FPConvertNaN(bits(N) op)">FPConvertNaN</a>(<a link="impl-shared.FPProcessNaN.4" file="shared_pseudocode.xml" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type3, op3, fpcr, fpexc));
    elsif type1 == <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE; result = <a link="impl-shared.FPProcessNaN.4" file="shared_pseudocode.xml" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type1, op1, fpcr, fpexc);
    elsif type2 == <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE; result = <a link="impl-shared.FPConvertNaN.1" file="shared_pseudocode.xml" hover="function: bits(M) FPConvertNaN(bits(N) op)">FPConvertNaN</a>(<a link="impl-shared.FPProcessNaN.4" file="shared_pseudocode.xml" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type2, op2, fpcr, fpexc));
    elsif type3 == <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE; result = <a link="impl-shared.FPConvertNaN.1" file="shared_pseudocode.xml" hover="function: bits(M) FPConvertNaN(bits(N) op)">FPConvertNaN</a>(<a link="impl-shared.FPProcessNaN.4" file="shared_pseudocode.xml" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type3, op3, fpcr, fpexc));
    else
        done = FALSE; result = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>(); // 'Don't care' result
    return (done, result);</pstext>
    </ps>
    <ps name="shared/functions/float/fpmulx/FPMulX" mylink="shared.functions.float.fpmulx.FPMulX" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPMulX()
// ========

bits(N) <anchor link="impl-shared.FPMulX.3" hover="function: bits(N) FPMulX(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPMulX</anchor>(bits(N) op1, bits(N) op2, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    bits(N) result;
    boolean done;
    (type1,sign1,value1) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);

    (done,result) = <a link="impl-shared.FPProcessNaNs.5" file="shared_pseudocode.xml" hover="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1,&#13; bits(N) op2, FPCRType fpcr)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        inf2 = (type2 == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        zero2 = (type2 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result = <a link="impl-shared.FPTwo.1" file="shared_pseudocode.xml" hover="function: bits(N) FPTwo(bit sign)">FPTwo</a>(sign1 EOR sign2);
        elsif inf1 || inf2 then
            result = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign1 EOR sign2);
        elsif zero1 || zero2 then
            result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(sign1 EOR sign2);
        else
            result = <a link="impl-shared.FPRound.2" file="shared_pseudocode.xml" hover="function: bits(N) FPRound(real op, FPCRType fpcr)">FPRound</a>(value1*value2, fpcr);

        <a link="impl-shared.FPProcessDenorms.4" file="shared_pseudocode.xml" hover="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fpneg/FPNeg" mylink="shared.functions.float.fpneg.FPNeg" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPNeg()
// =======

bits(N) <anchor link="impl-shared.FPNeg.1" hover="function: bits(N) FPNeg(bits(N) op)">FPNeg</anchor>(bits(N) op)

    assert N IN {16,32,64};
    if !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; <a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() then
        <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr = FPCR[];
        if fpcr.AH == '1' then
            (fptype, -, -) = <a link="impl-shared.FPUnpack.3" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op, fpcr, FALSE);
            if fptype IN {<a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} then

                return op;        // When fpcr.AH=1, sign of NaN has no consequence

    return NOT(op&lt;N-1&gt;) : op&lt;N-2:0&gt;;</pstext>
    </ps>
    <ps name="shared/functions/float/fponepointfive/FPOnePointFive" mylink="shared.functions.float.fponepointfive.FPOnePointFive" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPOnePointFive()
// ================

bits(N) <anchor link="impl-shared.FPOnePointFive.1" hover="function: bits(N) FPOnePointFive(bit sign)">FPOnePointFive</anchor>(bit sign)

    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp  = '0':<a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(E-1);
    frac = '1':<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(F-1);
    result = sign : exp : frac;

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fpprocessdenorms/FPProcessDenorm" mylink="shared.functions.float.fpprocessdenorms.FPProcessDenorm" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPProcessDenorm()
// =================
// Handles denormal input in case of single-precision or double-precision
// when using alternative floating-point mode.

<anchor link="impl-shared.FPProcessDenorm.3" hover="function: FPProcessDenorm(FPType fptype, integer N, FPCRType fpcr)">FPProcessDenorm</anchor>(<a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> fptype, integer N, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)
    boolean altfp = <a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    if altfp &amp;&amp; N != 16 &amp;&amp; fptype == <a link="FPType_Denormal" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a> then
        <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InputDenorm" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InputDenorm</a>, fpcr);</pstext>
    </ps>
    <ps name="shared/functions/float/fpprocessdenorms/FPProcessDenorms" mylink="shared.functions.float.fpprocessdenorms.FPProcessDenorms" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPProcessDenorms()
// ==================
// Handles denormal input in case of single-precision or double-precision
// when using alternative floating-point mode.

<anchor link="impl-shared.FPProcessDenorms.4" hover="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</anchor>(<a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type1, <a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type2, integer N, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)
    boolean altfp = <a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    if altfp &amp;&amp; N != 16 &amp;&amp; (type1 == <a link="FPType_Denormal" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a> || type2 == <a link="FPType_Denormal" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a>) then
        <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InputDenorm" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InputDenorm</a>, fpcr);</pstext>
    </ps>
    <ps name="shared/functions/float/fpprocessdenorms/FPProcessDenorms3" mylink="shared.functions.float.fpprocessdenorms.FPProcessDenorms3" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPProcessDenorms3()
// ===================
// Handles denormal input in case of single-precision or double-precision
// when using alternative floating-point mode.

<anchor link="impl-shared.FPProcessDenorms3.5" hover="function: FPProcessDenorms3(FPType type1, FPType type2, FPType type3, integer N, FPCRType fpcr)">FPProcessDenorms3</anchor>(<a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type1, <a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type2, <a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type3, integer N, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)
    boolean altfp = <a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    if altfp &amp;&amp; N != 16 &amp;&amp; (type1 == <a link="FPType_Denormal" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a> || type2 == <a link="FPType_Denormal" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a> ||
        type3 == <a link="FPType_Denormal" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a>) then
        <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InputDenorm" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InputDenorm</a>, fpcr);</pstext>
    </ps>
    <ps name="shared/functions/float/fpprocessdenorms/FPProcessDenorms4" mylink="shared.functions.float.fpprocessdenorms.FPProcessDenorms4" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPProcessDenorms4()
// ===================
// Handles denormal input in case of single-precision or double-precision
// when using alternative floating-point mode.

<anchor link="impl-shared.FPProcessDenorms4.6" hover="function: FPProcessDenorms4(FPType type1, FPType type2, FPType type3, FPType type4, integer N, FPCRType fpcr)">FPProcessDenorms4</anchor>(<a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type1, <a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type2, <a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type3, <a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type4, integer N, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)
    boolean altfp = <a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    if altfp &amp;&amp; N != 16 &amp;&amp; (type1 == <a link="FPType_Denormal" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a> || type2 == <a link="FPType_Denormal" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a> ||
        type3 == <a link="FPType_Denormal" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a> || type4 == <a link="FPType_Denormal" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a>) then
        <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InputDenorm" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InputDenorm</a>, fpcr);</pstext>
    </ps>
    <ps name="shared/functions/float/fpprocessexception/FPProcessException" mylink="shared.functions.float.fpprocessexception.FPProcessException" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPProcessException()
// ====================
//
// The 'fpcr' argument supplies FPCR control bits. Status information is
// updated directly in the FPSR where appropriate.

<anchor link="impl-shared.FPProcessException.2" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</anchor>(<a link="FPExc" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc</a> exception, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)

    integer cumul;
    // Determine the cumulative exception bit number
    case exception of
        when <a link="FPExc_InvalidOp" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>     cumul = 0;
        when <a link="FPExc_DivideByZero" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_DivideByZero</a>  cumul = 1;
        when <a link="FPExc_Overflow" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Overflow</a>      cumul = 2;
        when <a link="FPExc_Underflow" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Underflow</a>     cumul = 3;
        when <a link="FPExc_Inexact" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Inexact</a>       cumul = 4;
        when <a link="FPExc_InputDenorm" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InputDenorm</a>   cumul = 7;
    enable = cumul + 8;
    if fpcr&lt;enable&gt; == '1' then
        // Trapping of the exception enabled.
        // It is IMPLEMENTATION DEFINED whether the enable bit may be set at all,
        // and if so then how exceptions and in what order that they may be
        // accumulated before calling FPTrappedException().
        bits(8) accumulated_exceptions = <a link="impl-shared.GetAccumulatedFPExceptions.0" file="shared_pseudocode.xml" hover="function: bits(8) GetAccumulatedFPExceptions()">GetAccumulatedFPExceptions</a>();
        accumulated_exceptions&lt;cumul&gt; = '1';
        if boolean IMPLEMENTATION_DEFINED "Process floating-point exception" then
            if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
                <a link="AArch32.FPTrappedException.1" file="shared_pseudocode.xml" hover="function: AArch32.FPTrappedException(bits(8) accumulated_exceptions)">AArch32.FPTrappedException</a>(accumulated_exceptions);
            else
                is_ase = <a link="impl-shared.IsASEInstruction.0" file="shared_pseudocode.xml" hover="function: boolean IsASEInstruction()">IsASEInstruction</a>();
                <a link="AArch64.FPTrappedException.2" file="shared_pseudocode.xml" hover="function: AArch64.FPTrappedException(boolean is_ase, bits(8) accumulated_exceptions)">AArch64.FPTrappedException</a>(is_ase, accumulated_exceptions);
        else
            // The exceptions generated by this instruction are accumulated by the PE and
            // FPTrappedException is called later during its execution, before the next
            // instruction is executed. This field is cleared at the start of each FP instruction.
            <a link="impl-shared.SetAccumulatedFPExceptions.1" file="shared_pseudocode.xml" hover="function: SetAccumulatedFPExceptions(bits(8) accumulated_exceptions)">SetAccumulatedFPExceptions</a>(accumulated_exceptions);
    elsif <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
        // Set the cumulative exception bit
        FPSCR&lt;cumul&gt; = '1';
    else
        // Set the cumulative exception bit
        FPSR&lt;cumul&gt; = '1';

    return;</pstext>
    </ps>
    <ps name="shared/functions/float/fpprocessnan/FPProcessNaN" mylink="shared.functions.float.fpprocessnan.FPProcessNaN" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPProcessNaN()
// ==============

bits(N) <anchor link="impl-shared.FPProcessNaN.3" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr)">FPProcessNaN</anchor>(<a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> fptype, bits(N) op, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)
    boolean fpexc = TRUE;   // Generate floating-point exceptions
    return <a link="impl-shared.FPProcessNaN.4" file="shared_pseudocode.xml" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(fptype, op, fpcr, fpexc);

// FPProcessNaN()
// ==============
// Handle NaN input operands, returning the operand or default NaN value
// if fpcr.DN is selected. The 'fpcr' argument supplies the FPCR control bits.
// The 'fpexc' argument controls the generation of exceptions, regardless of
// whether 'fptype' is a signalling NaN or a quiet NaN.

bits(N) <anchor link="impl-shared.FPProcessNaN.4" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</anchor>(<a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> fptype, bits(N) op, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr, boolean fpexc)

    assert N IN {16,32,64};
    assert fptype IN {<a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>, <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>};
    integer topfrac;

    case N of
        when 16 topfrac =  9;
        when 32 topfrac = 22;
        when 64 topfrac = 51;

    result = op;
    if fptype == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        result&lt;topfrac&gt; = '1';
        if fpexc then <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InvalidOp" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    if fpcr.DN == '1' then  // DefaultNaN requested
        result = <a link="impl-shared.FPDefaultNaN.1" file="shared_pseudocode.xml" hover="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fpprocessnans/FPProcessNaNs" mylink="shared.functions.float.fpprocessnans.FPProcessNaNs" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPProcessNaNs()
// ===============

(boolean, bits(N)) <anchor link="impl-shared.FPProcessNaNs.5" hover="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1,&#13; bits(N) op2, FPCRType fpcr)">FPProcessNaNs</anchor>(<a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type1, <a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type2, bits(N) op1,
                                 bits(N) op2, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)
    boolean altfmaxfmin = FALSE;    // Do not use alfp mode for FMIN, FMAX and variants
    boolean fpexc       = TRUE;     // Generate floating-point exceptions
    return <a link="impl-shared.FPProcessNaNs.7" file="shared_pseudocode.xml" hover="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean altfmaxfmin, boolean fpexc)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr, altfmaxfmin, fpexc);

// FPProcessNaNs()
// ===============
//
// The boolean part of the return value says whether a NaN has been found and
// processed. The bits(N) part is only relevant if it has and supplies the
// result of the operation.
//
// The 'fpcr' argument supplies FPCR control bits and 'altfmaxfmin' controls
// alternative floating-point behaviour for FMAX, FMIN and variants. 'fpexc'
// controls the generation of floating-point exceptions. Status information
// is updated directly in the FPSR where appropriate.

(boolean, bits(N)) <anchor link="impl-shared.FPProcessNaNs.7" hover="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean altfmaxfmin, boolean fpexc)">FPProcessNaNs</anchor>(<a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type1, <a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type2, bits(N) op1, bits(N) op2,
                                 <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr, boolean altfmaxfmin, boolean fpexc)

    assert N IN {16,32,64};
    bit sign2;
    boolean done;
    bits(N) result;
    boolean altfp    = <a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    boolean op1_nan  = type1 IN {<a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};
    boolean op2_nan  = type2 IN {<a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};
    boolean any_snan = type1 == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || type2 == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>;
    <a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a>  type_nan = if any_snan then <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> else <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>;

    if altfmaxfmin &amp;&amp; (op1_nan || op2_nan) then
        <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InvalidOp" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        done = TRUE; sign2 = op2&lt;N-1&gt;;
        result = if type2 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(sign2) else op2;
    elsif altfp &amp;&amp; op1_nan &amp;&amp; op2_nan then
        // &lt;n&gt; register NaN selected
        done = TRUE;  result = <a link="impl-shared.FPProcessNaN.4" file="shared_pseudocode.xml" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type_nan, op1, fpcr, fpexc);
    elsif type1 == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE;  result = <a link="impl-shared.FPProcessNaN.4" file="shared_pseudocode.xml" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type1, op1, fpcr, fpexc);
    elsif type2 == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE;  result = <a link="impl-shared.FPProcessNaN.4" file="shared_pseudocode.xml" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type2, op2, fpcr, fpexc);
    elsif type1 == <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE;  result = <a link="impl-shared.FPProcessNaN.4" file="shared_pseudocode.xml" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type1, op1, fpcr, fpexc);
    elsif type2 == <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE;  result = <a link="impl-shared.FPProcessNaN.4" file="shared_pseudocode.xml" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type2, op2, fpcr, fpexc);
    else
        done = FALSE;  result = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();  // 'Don't care' result

    return (done, result);</pstext>
    </ps>
    <ps name="shared/functions/float/fpprocessnans3/FPProcessNaNs3" mylink="shared.functions.float.fpprocessnans3.FPProcessNaNs3" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPProcessNaNs3()
// ================

(boolean, bits(N)) <anchor link="impl-shared.FPProcessNaNs3.7" hover="function: (boolean, bits(N)) FPProcessNaNs3(FPType type1, FPType type2, FPType type3,&#13; bits(N) op1, bits(N) op2, bits(N) op3,&#13; FPCRType fpcr)">FPProcessNaNs3</anchor>(<a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type1, <a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type2, <a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type3,
                                  bits(N) op1, bits(N) op2, bits(N) op3,
                                  <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)
    boolean fpexc = TRUE;   // Generate floating-point exceptions
    return <a link="impl-shared.FPProcessNaNs3.8" file="shared_pseudocode.xml" hover="function: (boolean, bits(N)) FPProcessNaNs3(FPType type1, FPType type2, FPType type3,&#13; bits(N) op1, bits(N) op2, bits(N) op3,&#13; FPCRType fpcr, boolean fpexc)">FPProcessNaNs3</a>(type1, type2, type3, op1, op2, op3, fpcr, fpexc);

// FPProcessNaNs3()
// ================
// The boolean part of the return value says whether a NaN has been found and
// processed. The bits(N) part is only relevant if it has and supplies the
// result of the operation.
//
// The 'fpcr' argument supplies FPCR control bits and 'fpexc' controls the
// generation of floating-point exceptions. Status information is updated
// directly in the FPSR where appropriate.

(boolean, bits(N)) <anchor link="impl-shared.FPProcessNaNs3.8" hover="function: (boolean, bits(N)) FPProcessNaNs3(FPType type1, FPType type2, FPType type3,&#13; bits(N) op1, bits(N) op2, bits(N) op3,&#13; FPCRType fpcr, boolean fpexc)">FPProcessNaNs3</anchor>(<a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type1, <a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type2, <a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type3,
                                  bits(N) op1, bits(N) op2, bits(N) op3,
                                  <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr, boolean fpexc)

    assert N IN {16,32,64};
    bits(N) result;
    boolean op1_nan = type1 IN {<a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};
    boolean op2_nan = type2 IN {<a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};
    boolean op3_nan = type3 IN {<a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};

    boolean altfp = <a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    <a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type_nan;
    if altfp then
        if type1 == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || type2 == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || type3 == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
            type_nan = <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>;
        else
            type_nan = <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>;

    boolean done;
    if altfp &amp;&amp; op1_nan &amp;&amp; op2_nan &amp;&amp; op3_nan then
        // &lt;n&gt; register NaN selected
        done = TRUE;  result = <a link="impl-shared.FPProcessNaN.4" file="shared_pseudocode.xml" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type_nan, op2, fpcr, fpexc);
    elsif altfp &amp;&amp; op2_nan &amp;&amp; (op1_nan || op3_nan) then
        // &lt;n&gt; register NaN selected
        done = TRUE;  result = <a link="impl-shared.FPProcessNaN.4" file="shared_pseudocode.xml" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type_nan, op2, fpcr, fpexc);
    elsif altfp &amp;&amp; op3_nan &amp;&amp; op1_nan then
        // &lt;m&gt; register NaN selected
        done = TRUE;  result = <a link="impl-shared.FPProcessNaN.4" file="shared_pseudocode.xml" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type_nan, op3, fpcr, fpexc);
    elsif type1 == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE;  result = <a link="impl-shared.FPProcessNaN.4" file="shared_pseudocode.xml" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type1, op1, fpcr, fpexc);
    elsif type2 == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE;  result = <a link="impl-shared.FPProcessNaN.4" file="shared_pseudocode.xml" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type2, op2, fpcr, fpexc);
    elsif type3 == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE;  result = <a link="impl-shared.FPProcessNaN.4" file="shared_pseudocode.xml" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type3, op3, fpcr, fpexc);
    elsif type1 == <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE;  result = <a link="impl-shared.FPProcessNaN.4" file="shared_pseudocode.xml" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type1, op1, fpcr, fpexc);
    elsif type2 == <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE;  result = <a link="impl-shared.FPProcessNaN.4" file="shared_pseudocode.xml" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type2, op2, fpcr, fpexc);
    elsif type3 == <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE;  result = <a link="impl-shared.FPProcessNaN.4" file="shared_pseudocode.xml" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type3, op3, fpcr, fpexc);
    else
        done = FALSE;  result = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();  // 'Don't care' result

    return (done, result);</pstext>
    </ps>
    <ps name="shared/functions/float/fprecipestimate/FPRecipEstimate" mylink="shared.functions.float.fprecipestimate.FPRecipEstimate" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPRecipEstimate()
// =================

bits(N) <anchor link="impl-shared.FPRecipEstimate.2" hover="function: bits(N) FPRecipEstimate(bits(N) operand, FPCRType fpcr_in)">FPRecipEstimate</anchor>(bits(N) operand, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr_in)

    assert N IN {16,32,64};
    <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    bits(N) result;
    boolean overflow_to_inf;
    // When using alternative floating-point behaviour, do not generate
    // floating-point exceptions, flush denormal input and output to zero,
    // and use RNE rounding mode.
    boolean altfp = <a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    boolean fpexc = !altfp;
    if altfp then fpcr.&lt;FIZ,FZ&gt; = '11';
    if altfp then fpcr.RMode    = '00';

    (fptype,sign,value) = <a link="impl-shared.FPUnpack.3" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(operand, fpcr, fpexc);

    <a link="FPRounding" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding = <a link="impl-shared.FPRoundingMode.1" file="shared_pseudocode.xml" hover="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);
    if fptype == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        result = <a link="impl-shared.FPProcessNaN.4" file="shared_pseudocode.xml" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(fptype, operand, fpcr, fpexc);
    elsif fptype == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then
        result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
    elsif fptype == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
        result = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign);
        if fpexc then <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_DivideByZero" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_DivideByZero</a>, fpcr);
    elsif (
            (N == 16 &amp;&amp; <a link="impl-shared.Abs.1" file="shared_pseudocode.xml" hover="function: integer Abs(integer x)">Abs</a>(value) &lt; 2.0^-16) ||
            (N == 32 &amp;&amp; <a link="impl-shared.Abs.1" file="shared_pseudocode.xml" hover="function: integer Abs(integer x)">Abs</a>(value) &lt; 2.0^-128) ||
            (N == 64 &amp;&amp; <a link="impl-shared.Abs.1" file="shared_pseudocode.xml" hover="function: integer Abs(integer x)">Abs</a>(value) &lt; 2.0^-1024)
          ) then
        case rounding of
            when <a link="FPRounding_TIEEVEN" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEEVEN</a>
                overflow_to_inf = TRUE;
            when <a link="FPRounding_POSINF" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_POSINF</a>
                overflow_to_inf = (sign == '0');
            when <a link="FPRounding_NEGINF" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a>
                overflow_to_inf = (sign == '1');
            when <a link="FPRounding_ZERO" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ZERO</a>
                overflow_to_inf = FALSE;
        result = if overflow_to_inf then <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign) else <a link="impl-shared.FPMaxNormal.1" file="shared_pseudocode.xml" hover="function: bits(N) FPMaxNormal(bit sign)">FPMaxNormal</a>(sign);
        if fpexc then
            <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_Overflow" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Overflow</a>, fpcr);
            <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_Inexact" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Inexact</a>, fpcr);
    elsif ((fpcr.FZ == '1' &amp;&amp; N != 16) || (fpcr.FZ16 == '1' &amp;&amp; N == 16))
          &amp;&amp; (
               (N == 16 &amp;&amp; <a link="impl-shared.Abs.1" file="shared_pseudocode.xml" hover="function: integer Abs(integer x)">Abs</a>(value) &gt;= 2.0^14) ||
               (N == 32 &amp;&amp; <a link="impl-shared.Abs.1" file="shared_pseudocode.xml" hover="function: integer Abs(integer x)">Abs</a>(value) &gt;= 2.0^126) ||
               (N == 64 &amp;&amp; <a link="impl-shared.Abs.1" file="shared_pseudocode.xml" hover="function: integer Abs(integer x)">Abs</a>(value) &gt;= 2.0^1022)
             ) then
        // Result flushed to zero of correct sign
        result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);

        // Flush-to-zero never generates a trapped exception.
        if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
            FPSCR.UFC = '1';
        else
            if fpexc then FPSR.UFC = '1';
    else
        // Scale to a fixed point value in the range 0.5 &lt;= x &lt; 1.0 in steps of 1/512, and
        // calculate result exponent. Scaled value has copied sign bit,
        // exponent = 1022 = double-precision biased version of -1,
        // fraction = original fraction
        bits(52) fraction;
        integer exp;
        case N of
            when 16
                fraction = operand&lt;9:0&gt; : <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(42);
                exp = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(operand&lt;14:10&gt;);
            when 32
                fraction = operand&lt;22:0&gt; : <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(29);
                exp = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(operand&lt;30:23&gt;);
            when 64
                fraction = operand&lt;51:0&gt;;
                exp = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(operand&lt;62:52&gt;);

        if exp == 0 then
            if fraction&lt;51&gt; == '0' then
                exp = -1;
                fraction = fraction&lt;49:0&gt;:'00';
            else
                fraction = fraction&lt;50:0&gt;:'0';

        integer scaled;
        boolean increasedprecision = N==32 &amp;&amp; <a link="impl-shared.HaveFeatRPRES.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatRPRES()">HaveFeatRPRES</a>() &amp;&amp; altfp;

        if !increasedprecision then
            scaled = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>('1':fraction&lt;51:44&gt;);
        else
            scaled = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>('1':fraction&lt;51:41&gt;);

        integer result_exp;
        case N of
            when 16 result_exp =   29 - exp; // In range 29-30 = -1 to 29+1 = 30
            when 32 result_exp =  253 - exp; // In range 253-254 = -1 to 253+1 = 254
            when 64 result_exp = 2045 - exp; // In range 2045-2046 = -1 to 2045+1 = 2046

        // Scaled is in range 256 .. 511 or 2048 .. 4095 range representing a
        // fixed-point number in range [0.5 .. 1.0].
        estimate = <a link="impl-shared.RecipEstimate.2" file="shared_pseudocode.xml" hover="function: integer RecipEstimate(integer a_in, boolean increasedprecision)">RecipEstimate</a>(scaled, increasedprecision);

        // Estimate is in the range 256 .. 511 or 4096 .. 8191 representing a
        // fixed-point result in the range [1.0 .. 2.0].
        // Convert to scaled floating point result with copied sign bit,
        // high-order bits from estimate, and exponent calculated above.
        if !increasedprecision then
            fraction = estimate&lt;7:0&gt; : <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(44);
        else
            fraction = estimate&lt;11:0&gt; : <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(40);

        if result_exp == 0 then
            fraction = '1' : fraction&lt;51:1&gt;;
        elsif result_exp == -1 then
            fraction = '01' : fraction&lt;51:2&gt;;
            result_exp = 0;

        case N of
            when 16 result = sign : result_exp&lt;N-12:0&gt; : fraction&lt;51:42&gt;;
            when 32 result = sign : result_exp&lt;N-25:0&gt; : fraction&lt;51:29&gt;;
            when 64 result = sign : result_exp&lt;N-54:0&gt; : fraction&lt;51:0&gt;;

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fprecipestimate/RecipEstimate" mylink="shared.functions.float.fprecipestimate.RecipEstimate" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// RecipEstimate()
// ===============
// Compute estimate of reciprocal of 9-bit fixed-point number.
//
// a is in range 256 .. 511 or 2048 .. 4096 representing a number in
// the range 0.5 &lt;= x &lt; 1.0.
// increasedprecision determines if the mantissa is 8-bit or 12-bit.
// result is in the range 256 .. 511 or 4096 .. 8191 representing a
// number in the range 1.0 to 511/256 or 1.00 to 8191/4096.

integer <anchor link="impl-shared.RecipEstimate.2" hover="function: integer RecipEstimate(integer a_in, boolean increasedprecision)">RecipEstimate</anchor>(integer a_in, boolean increasedprecision)

    integer a = a_in;
    integer r;
    if !increasedprecision then
        assert 256 &lt;= a &amp;&amp; a &lt; 512;
        a = a*2+1;                       // Round to nearest
        integer b = (2 ^ 19) DIV a;
        r = (b+1) DIV 2;                 // Round to nearest
        assert 256 &lt;= r &amp;&amp; r &lt; 512;
    else
        assert 2048 &lt;= a &amp;&amp; a &lt; 4096;
        a = a*2+1;                       // Round to nearest
        real real_val = Real(2^25)/Real(a);
        r = <a link="impl-shared.RoundDown.1" file="shared_pseudocode.xml" hover="function: integer RoundDown(real x)">RoundDown</a>(real_val);
        real error = real_val - Real(r);
        boolean round_up = error &gt; 0.5;  // Error cannot be exactly 0.5 so do not need tie case
        if round_up then r = r+1;
        assert 4096 &lt;= r &amp;&amp; r &lt; 8192;

    return r;</pstext>
    </ps>
    <ps name="shared/functions/float/fprecpx/FPRecpX" mylink="shared.functions.float.fprecpx.FPRecpX" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPRecpX()
// =========

bits(N) <anchor link="impl-shared.FPRecpX.2" hover="function: bits(N) FPRecpX(bits(N) op, FPCRType fpcr_in)">FPRecpX</anchor>(bits(N) op, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr_in)

    assert N IN {16,32,64};
    <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    integer esize;
    case N of
        when 16 esize =  5;
        when 32 esize =  8;
        when 64 esize = 11;

    bits(N)           result;
    bits(esize)       exp;
    bits(esize)       max_exp;
    bits(N-(esize+1)) frac = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();

    boolean altfp = <a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; fpcr.AH == '1';
    boolean fpexc = !altfp;                 // Generate no floating-point exceptions
    if altfp then fpcr.&lt;FIZ,FZ&gt; = '11';     // Flush denormal input and output to zero
    (fptype,sign,value) = <a link="impl-shared.FPUnpack.3" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op, fpcr, fpexc);

    case N of
        when 16 exp = op&lt;10+esize-1:10&gt;;
        when 32 exp = op&lt;23+esize-1:23&gt;;
        when 64 exp = op&lt;52+esize-1:52&gt;;

    max_exp = <a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(esize) - 1;

    if fptype == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        result = <a link="impl-shared.FPProcessNaN.4" file="shared_pseudocode.xml" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(fptype, op, fpcr, fpexc);
    else
        if <a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(exp) then                 // Zero and denormals
            result = sign:max_exp:frac;
        else                                // Infinities and normals
            result = sign:NOT(exp):frac;

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fpround/FPRound" mylink="shared.functions.float.fpround.FPRound" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPRound()
// =========
// Used by data processing and int/fixed &lt;-&gt; FP conversion instructions.
// For half-precision data it ignores AHP, and observes FZ16.

bits(N) <anchor link="impl-shared.FPRound.3" hover="function: bits(N) FPRound(real op, FPCRType fpcr_in, FPRounding rounding)">FPRound</anchor>(real op, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr_in, <a link="FPRounding" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding)
    <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    fpcr.AHP = '0';
    boolean fpexc = TRUE;    // Generate floating-point exceptions
    boolean isbfloat16  = FALSE;
    return <a link="impl-shared.FPRoundBase.5" file="shared_pseudocode.xml" hover="function: bits(N) FPRoundBase(real op, FPCRType fpcr, FPRounding rounding,&#13; boolean isbfloat16, boolean fpexc)">FPRoundBase</a>(op, fpcr, rounding, isbfloat16, fpexc);

// FPRound()
// =========
// Used by data processing and int/fixed &lt;-&gt; FP conversion instructions.
// For half-precision data it ignores AHP, and observes FZ16.
//
// The 'fpcr' argument supplies FPCR control bits and 'fpexc' controls the
// generation of floating-point exceptions. Status information is updated
// directly in the FPSR where appropriate.

bits(N) <anchor link="impl-shared.FPRound.4" hover="function: bits(N) FPRound(real op, FPCRType fpcr_in, FPRounding rounding, boolean fpexc)">FPRound</anchor>(real op, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr_in, <a link="FPRounding" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding, boolean fpexc)
    <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    fpcr.AHP = '0';
    boolean isbfloat16 = FALSE;
    return <a link="impl-shared.FPRoundBase.5" file="shared_pseudocode.xml" hover="function: bits(N) FPRoundBase(real op, FPCRType fpcr, FPRounding rounding,&#13; boolean isbfloat16, boolean fpexc)">FPRoundBase</a>(op, fpcr, rounding, isbfloat16, fpexc);

// FPRound()
// =========

bits(N) <anchor link="impl-shared.FPRound.2" hover="function: bits(N) FPRound(real op, FPCRType fpcr)">FPRound</anchor>(real op, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)
    return <a link="impl-shared.FPRound.3" file="shared_pseudocode.xml" hover="function: bits(N) FPRound(real op, FPCRType fpcr_in, FPRounding rounding)">FPRound</a>(op, fpcr, <a link="impl-shared.FPRoundingMode.1" file="shared_pseudocode.xml" hover="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr));</pstext>
    </ps>
    <ps name="shared/functions/float/fpround/FPRoundBase" mylink="shared.functions.float.fpround.FPRoundBase" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPRoundBase()
// =============

bits(N) <anchor link="impl-shared.FPRoundBase.4" hover="function: bits(N) FPRoundBase(real op, FPCRType fpcr, FPRounding rounding, boolean isbfloat16)">FPRoundBase</anchor>(real op, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr, <a link="FPRounding" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding, boolean isbfloat16)
    boolean fpexc = TRUE;    // Generate floating-point exceptions
    return <a link="impl-shared.FPRoundBase.5" file="shared_pseudocode.xml" hover="function: bits(N) FPRoundBase(real op, FPCRType fpcr, FPRounding rounding,&#13; boolean isbfloat16, boolean fpexc)">FPRoundBase</a>(op, fpcr, rounding, isbfloat16, fpexc);

// FPRoundBase()
// =============
// Convert a real number OP into an N-bit floating-point value using the
// supplied rounding mode RMODE.
//
// The 'fpcr' argument supplies FPCR control bits and 'fpexc' controls the
// generation of floating-point exceptions. Status information is updated
// directly in the FPSR where appropriate.

bits(N) <anchor link="impl-shared.FPRoundBase.5" hover="function: bits(N) FPRoundBase(real op, FPCRType fpcr, FPRounding rounding,&#13; boolean isbfloat16, boolean fpexc)">FPRoundBase</anchor>(real op, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr, <a link="FPRounding" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding,
                    boolean isbfloat16, boolean fpexc)

    assert N IN {16,32,64};
    assert op != 0.0;
    assert rounding != <a link="FPRounding_TIEAWAY" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEAWAY</a>;
    bits(N) result;

    // Obtain format parameters - minimum exponent, numbers of exponent and fraction bits.
    integer minimum_exp;
    integer F;
    integer E;
    if N == 16 then
        minimum_exp = -14;  E = 5;  F = 10;
    elsif N == 32 &amp;&amp; isbfloat16 then
        minimum_exp = -126;  E = 8;  F = 7;
    elsif N == 32 then
        minimum_exp = -126;  E = 8;  F = 23;
    else  // N == 64
        minimum_exp = -1022;  E = 11;  F = 52;

    // Split value into sign, unrounded mantissa and exponent.
    bit sign;
    real mantissa;
    if op &lt; 0.0 then
        sign = '1';  mantissa = -op;
    else
        sign = '0';  mantissa = op;
    exponent = 0;
    while mantissa &lt; 1.0 do
        mantissa = mantissa * 2.0;  exponent = exponent - 1;
    while mantissa &gt;= 2.0 do
        mantissa = mantissa / 2.0;  exponent = exponent + 1;

    // When TRUE, detection of underflow occurs after rounding and the test for a
    // denormalized number for single and double precision values occurs after rounding.
    altfp = <a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';

    // Deal with flush-to-zero before rounding if FPCR.AH != '1'.
    if (!altfp &amp;&amp; ((fpcr.FZ == '1' &amp;&amp; N != 16) || (fpcr.FZ16 == '1' &amp;&amp; N == 16)) &amp;&amp;
        exponent &lt; minimum_exp) then
        // Flush-to-zero never generates a trapped exception.
        if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
            FPSCR.UFC = '1';
        else
            if fpexc then FPSR.UFC = '1';
        return <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);

    biased_exp_unconstrained = (exponent - minimum_exp) + 1;
    int_mant_unconstrained = <a link="impl-shared.RoundDown.1" file="shared_pseudocode.xml" hover="function: integer RoundDown(real x)">RoundDown</a>(mantissa * 2.0^F);
    error_unconstrained = mantissa * 2.0^F - Real(int_mant_unconstrained);

    // Start creating the exponent value for the result. Start by biasing the actual exponent
    // so that the minimum exponent becomes 1, lower values 0 (indicating possible underflow).
    biased_exp = <a link="impl-shared.Max.2" file="shared_pseudocode.xml" hover="function: integer Max(integer a, integer b)">Max</a>((exponent - minimum_exp) + 1, 0);
    if biased_exp == 0 then mantissa = mantissa / 2.0^(minimum_exp - exponent);

    // Get the unrounded mantissa as an integer, and the "units in last place" rounding error.
    int_mant = <a link="impl-shared.RoundDown.1" file="shared_pseudocode.xml" hover="function: integer RoundDown(real x)">RoundDown</a>(mantissa * 2.0^F);  // &lt; 2.0^F if biased_exp == 0, &gt;= 2.0^F if not
    error = mantissa * 2.0^F - Real(int_mant);

    // Underflow occurs if exponent is too small before rounding, and result is inexact or
    // the Underflow exception is trapped. This applies before rounding if FPCR.AH != '1'.
    if !altfp &amp;&amp; biased_exp == 0 &amp;&amp; (error != 0.0 || fpcr.UFE == '1') then
        if fpexc then <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_Underflow" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Underflow</a>, fpcr);

    // Round result according to rounding mode.
    boolean round_up_unconstrained;
    boolean round_up;
    boolean overflow_to_inf;
    if altfp then

        case rounding of
            when <a link="FPRounding_TIEEVEN" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEEVEN</a>
                round_up_unconstrained = (error_unconstrained &gt; 0.5 ||
                   (error_unconstrained == 0.5 &amp;&amp; int_mant_unconstrained&lt;0&gt; == '1'));
                round_up = (error &gt; 0.5 || (error == 0.5 &amp;&amp; int_mant&lt;0&gt; == '1'));
                overflow_to_inf = TRUE;
            when <a link="FPRounding_POSINF" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_POSINF</a>
                round_up_unconstrained = (error_unconstrained != 0.0 &amp;&amp; sign == '0');
                round_up = (error != 0.0 &amp;&amp; sign == '0');
                overflow_to_inf = (sign == '0');
            when <a link="FPRounding_NEGINF" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a>
                round_up_unconstrained = (error_unconstrained != 0.0 &amp;&amp; sign == '1');
                round_up = (error != 0.0 &amp;&amp; sign == '1');
                overflow_to_inf = (sign == '1');
            when <a link="FPRounding_ZERO" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ZERO</a>, <a link="FPRounding_ODD" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ODD</a>
                round_up_unconstrained = FALSE;
                round_up = FALSE;
                overflow_to_inf = FALSE;

        if round_up_unconstrained then
            int_mant_unconstrained = int_mant_unconstrained + 1;
            if int_mant_unconstrained == 2^(F+1) then    // Rounded up to next exponent
                biased_exp_unconstrained = biased_exp_unconstrained + 1;
                int_mant_unconstrained   = int_mant_unconstrained DIV 2;

        // Deal with flush-to-zero and underflow after rounding if FPCR.AH == '1'.
        if biased_exp_unconstrained &lt; 1 &amp;&amp; int_mant_unconstrained != 0 then
            // the result of unconstrained rounding is less than the minimum normalized number
            if (fpcr.FZ == '1' &amp;&amp; N != 16) || (fpcr.FZ16 == '1' &amp;&amp; N == 16) then   // Flush-to-zero
                if fpexc then
                    FPSR.UFC = '1';
                    <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_Inexact" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Inexact</a>, fpcr);
                return <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
            elsif error != 0.0 || fpcr.UFE == '1' then
                if fpexc then <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_Underflow" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Underflow</a>, fpcr);
    else    // altfp == FALSE
        case rounding of
            when <a link="FPRounding_TIEEVEN" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEEVEN</a>
                round_up = (error &gt; 0.5 || (error == 0.5 &amp;&amp; int_mant&lt;0&gt; == '1'));
                overflow_to_inf = TRUE;
            when <a link="FPRounding_POSINF" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_POSINF</a>
                round_up = (error != 0.0 &amp;&amp; sign == '0');
                overflow_to_inf = (sign == '0');
            when <a link="FPRounding_NEGINF" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a>
                round_up = (error != 0.0 &amp;&amp; sign == '1');
                overflow_to_inf = (sign == '1');
            when <a link="FPRounding_ZERO" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ZERO</a>, <a link="FPRounding_ODD" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ODD</a>
                round_up = FALSE;
                overflow_to_inf = FALSE;

    if round_up then
        int_mant = int_mant + 1;
        if int_mant == 2^F then      // Rounded up from denormalized to normalized
            biased_exp = 1;
        if int_mant == 2^(F+1) then  // Rounded up to next exponent
            biased_exp = biased_exp + 1;
            int_mant = int_mant DIV 2;

    // Handle rounding to odd
    if error != 0.0 &amp;&amp; rounding == <a link="FPRounding_ODD" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ODD</a> then
        int_mant&lt;0&gt; = '1';

    // Deal with overflow and generate result.
    if N != 16 || fpcr.AHP == '0' then  // Single, double or IEEE half precision
        if biased_exp &gt;= 2^E - 1 then
            result = if overflow_to_inf then <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign) else <a link="impl-shared.FPMaxNormal.1" file="shared_pseudocode.xml" hover="function: bits(N) FPMaxNormal(bit sign)">FPMaxNormal</a>(sign);
            if fpexc then <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_Overflow" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Overflow</a>, fpcr);
            error = 1.0;  // Ensure that an Inexact exception occurs
        else
            result = sign : biased_exp&lt;E-1:0&gt; : int_mant&lt;F-1:0&gt; : <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(N-(E+F+1));
    else                                     // Alternative half precision
        if biased_exp &gt;= 2^E then
            result = sign : <a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(N-1);
            if fpexc then <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InvalidOp" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
            error = 0.0;  // Ensure that an Inexact exception does not occur
        else
            result = sign : biased_exp&lt;E-1:0&gt; : int_mant&lt;F-1:0&gt; : <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(N-(E+F+1));

    // Deal with Inexact exception.
    if error != 0.0 then
        if fpexc then <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_Inexact" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Inexact</a>, fpcr);

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fpround/FPRoundCV" mylink="shared.functions.float.fpround.FPRoundCV" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPRoundCV()
// ===========
// Used for FP &lt;-&gt; FP conversion instructions.
// For half-precision data ignores FZ16 and observes AHP.

bits(N) <anchor link="impl-shared.FPRoundCV.3" hover="function: bits(N) FPRoundCV(real op, FPCRType fpcr_in, FPRounding rounding)">FPRoundCV</anchor>(real op, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr_in, <a link="FPRounding" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding)
    <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    fpcr.FZ16 = '0';
    boolean fpexc = TRUE;    // Generate floating-point exceptions
    boolean isbfloat16 = FALSE;
    return <a link="impl-shared.FPRoundBase.5" file="shared_pseudocode.xml" hover="function: bits(N) FPRoundBase(real op, FPCRType fpcr, FPRounding rounding,&#13; boolean isbfloat16, boolean fpexc)">FPRoundBase</a>(op, fpcr, rounding, isbfloat16, fpexc);</pstext>
    </ps>
    <ps name="shared/functions/float/fprounding/FPRounding" mylink="shared.functions.float.fprounding.FPRounding" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="FPRounding" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</anchor>  {<anchor link="FPRounding_TIEEVEN" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEEVEN</anchor>, <anchor link="FPRounding_POSINF" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_POSINF</anchor>,
                         <anchor link="FPRounding_NEGINF" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</anchor>,  <anchor link="FPRounding_ZERO" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ZERO</anchor>,
                         <anchor link="FPRounding_TIEAWAY" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEAWAY</anchor>, <anchor link="FPRounding_ODD" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ODD</anchor>};</pstext>
    </ps>
    <ps name="shared/functions/float/fproundingmode/FPRoundingMode" mylink="shared.functions.float.fproundingmode.FPRoundingMode" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPRoundingMode()
// ================
// Return the current floating-point rounding mode.

FPRounding <anchor link="impl-shared.FPRoundingMode.1" hover="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</anchor>(<a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)
    return <a link="impl-shared.FPDecodeRounding.1" file="shared_pseudocode.xml" hover="function: FPRounding FPDecodeRounding(bits(2) rmode)">FPDecodeRounding</a>(fpcr.RMode);</pstext>
    </ps>
    <ps name="shared/functions/float/fproundint/FPRoundInt" mylink="shared.functions.float.fproundint.FPRoundInt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPRoundInt()
// ============

// Round op to nearest integral floating point value using rounding mode in FPCR/FPSCR.
// If EXACT is TRUE, set FPSR.IXC if result is not numerically equal to op.

bits(N) <anchor link="impl-shared.FPRoundInt.4" hover="function: bits(N) FPRoundInt(bits(N) op, FPCRType fpcr, FPRounding rounding, boolean exact)">FPRoundInt</anchor>(bits(N) op, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr, <a link="FPRounding" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding, boolean exact)

    assert rounding != <a link="FPRounding_ODD" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ODD</a>;
    assert N IN {16,32,64};

    // When alternative floating-point support is TRUE, do not generate
    // Input Denormal floating-point exceptions.
    altfp = <a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    fpexc = !altfp;

    // Unpack using FPCR to determine if subnormals are flushed-to-zero.
    (fptype,sign,value) = <a link="impl-shared.FPUnpack.3" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op, fpcr, fpexc);

    bits(N) result;
    if fptype == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        result = <a link="impl-shared.FPProcessNaN.3" file="shared_pseudocode.xml" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr)">FPProcessNaN</a>(fptype, op, fpcr);
    elsif fptype == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then
        result = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign);
    elsif fptype == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
        result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
    else
        // Extract integer component.
        int_result = <a link="impl-shared.RoundDown.1" file="shared_pseudocode.xml" hover="function: integer RoundDown(real x)">RoundDown</a>(value);
        error = value - Real(int_result);

        // Determine whether supplied rounding mode requires an increment.
        boolean round_up;
        case rounding of
            when <a link="FPRounding_TIEEVEN" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEEVEN</a>
                round_up = (error &gt; 0.5 || (error == 0.5 &amp;&amp; int_result&lt;0&gt; == '1'));
            when <a link="FPRounding_POSINF" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_POSINF</a>
                round_up = (error != 0.0);
            when <a link="FPRounding_NEGINF" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a>
                round_up = FALSE;
            when <a link="FPRounding_ZERO" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ZERO</a>
                round_up = (error != 0.0 &amp;&amp; int_result &lt; 0);
            when <a link="FPRounding_TIEAWAY" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEAWAY</a>
                round_up = (error &gt; 0.5 || (error == 0.5 &amp;&amp; int_result &gt;= 0));

        if round_up then int_result = int_result + 1;

        // Convert integer value into an equivalent real value.
        real_result = Real(int_result);

        // Re-encode as a floating-point value, result is always exact.
        if real_result == 0.0 then
            result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
        else
            result = <a link="impl-shared.FPRound.3" file="shared_pseudocode.xml" hover="function: bits(N) FPRound(real op, FPCRType fpcr_in, FPRounding rounding)">FPRound</a>(real_result, fpcr, <a link="FPRounding_ZERO" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ZERO</a>);

        // Generate inexact exceptions.
        if error != 0.0 &amp;&amp; exact then
            <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_Inexact" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Inexact</a>, fpcr);

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fproundintn/FPRoundIntN" mylink="shared.functions.float.fproundintn.FPRoundIntN" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPRoundIntN()
// =============

bits(N) <anchor link="impl-shared.FPRoundIntN.4" hover="function: bits(N) FPRoundIntN(bits(N) op, FPCRType fpcr, FPRounding rounding, integer intsize)">FPRoundIntN</anchor>(bits(N) op, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr, <a link="FPRounding" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding, integer intsize)
    assert rounding != <a link="FPRounding_ODD" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ODD</a>;
    assert N IN {32,64};
    assert intsize IN {32, 64};
    integer exp;
    bits(N) result;
    boolean round_up;
    constant integer E = (if N == 32 then 8 else 11);
    constant integer F = N - (E + 1);

    // When alternative floating-point support is TRUE, do not generate
    // Input Denormal floating-point exceptions.
    altfp = <a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    fpexc = !altfp;

    // Unpack using FPCR to determine if subnormals are flushed-to-zero.
    (fptype,sign,value) = <a link="impl-shared.FPUnpack.3" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op, fpcr, fpexc);

    if fptype IN {<a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>, <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>} then
        if N == 32 then
            exp = 126 + intsize;
            result = '1':exp&lt;(E-1):0&gt;:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(F);
        else
            exp = 1022+intsize;
            result = '1':exp&lt;(E-1):0&gt;:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(F);
        <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InvalidOp" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    elsif fptype == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
        result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
    else
        // Extract integer component.
        int_result = <a link="impl-shared.RoundDown.1" file="shared_pseudocode.xml" hover="function: integer RoundDown(real x)">RoundDown</a>(value);
        error = value - Real(int_result);

        // Determine whether supplied rounding mode requires an increment.
        case rounding of
            when <a link="FPRounding_TIEEVEN" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEEVEN</a>
                round_up = error &gt; 0.5 || (error == 0.5 &amp;&amp; int_result&lt;0&gt; == '1');
            when <a link="FPRounding_POSINF" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_POSINF</a>
                round_up = error != 0.0;
            when <a link="FPRounding_NEGINF" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a>
                round_up = FALSE;
            when <a link="FPRounding_ZERO" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ZERO</a>
                round_up = error != 0.0 &amp;&amp; int_result &lt; 0;
            when <a link="FPRounding_TIEAWAY" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEAWAY</a>
                round_up = error &gt; 0.5 || (error == 0.5 &amp;&amp; int_result &gt;= 0);

        if round_up then int_result = int_result + 1;
        overflow = int_result &gt; 2^(intsize-1)-1 || int_result &lt; -1*2^(intsize-1);

        if overflow then
            if N == 32 then
                exp = 126 + intsize;
                result = '1':exp&lt;(E-1):0&gt;:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(F);
            else
                exp = 1022 + intsize;
                result = '1':exp&lt;(E-1):0&gt;:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(F);
            <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InvalidOp" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
            // This case shouldn't set Inexact.
            error = 0.0;

        else
            // Convert integer value into an equivalent real value.
            real_result = Real(int_result);

            // Re-encode as a floating-point value, result is always exact.
            if real_result == 0.0 then
                result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
            else
                result = <a link="impl-shared.FPRound.3" file="shared_pseudocode.xml" hover="function: bits(N) FPRound(real op, FPCRType fpcr_in, FPRounding rounding)">FPRound</a>(real_result, fpcr, <a link="FPRounding_ZERO" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ZERO</a>);

        // Generate inexact exceptions.
        if error != 0.0 then
            <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_Inexact" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Inexact</a>, fpcr);

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fprsqrtestimate/FPRSqrtEstimate" mylink="shared.functions.float.fprsqrtestimate.FPRSqrtEstimate" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPRSqrtEstimate()
// =================

bits(N) <anchor link="impl-shared.FPRSqrtEstimate.2" hover="function: bits(N) FPRSqrtEstimate(bits(N) operand, FPCRType fpcr_in)">FPRSqrtEstimate</anchor>(bits(N) operand, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr_in)

    assert N IN {16,32,64};
    <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr = fpcr_in;

    // When using alternative floating-point behaviour, do not generate
    // floating-point exceptions and flush denormal input to zero.
    boolean altfp = <a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    boolean fpexc = !altfp;
    if altfp then fpcr.&lt;FIZ,FZ&gt; = '11';

    (fptype,sign,value) = <a link="impl-shared.FPUnpack.3" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(operand, fpcr, fpexc);

    bits(N) result;
    if fptype == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        result = <a link="impl-shared.FPProcessNaN.4" file="shared_pseudocode.xml" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(fptype, operand, fpcr, fpexc);
    elsif fptype == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
        result = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign);
        if fpexc then <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_DivideByZero" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_DivideByZero</a>, fpcr);
    elsif sign == '1' then
        result = <a link="impl-shared.FPDefaultNaN.1" file="shared_pseudocode.xml" hover="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
        if fpexc then <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InvalidOp" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    elsif fptype == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then
        result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>('0');
    else
        // Scale to a fixed-point value in the range 0.25 &lt;= x &lt; 1.0 in steps of 512, with the
        // evenness or oddness of the exponent unchanged, and calculate result exponent.
        // Scaled value has copied sign bit, exponent = 1022 or 1021 = double-precision
        // biased version of -1 or -2, fraction = original fraction extended with zeros.

        bits(52) fraction;
        integer exp;
        case N of
            when 16
                fraction = operand&lt;9:0&gt; : <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(42);
                exp = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(operand&lt;14:10&gt;);
            when 32
                fraction = operand&lt;22:0&gt; : <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(29);
                exp = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(operand&lt;30:23&gt;);
            when 64
                fraction = operand&lt;51:0&gt;;
                exp = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(operand&lt;62:52&gt;);

        if exp == 0 then
            while fraction&lt;51&gt; == '0' do
                fraction = fraction&lt;50:0&gt; : '0';
                exp = exp - 1;
            fraction = fraction&lt;50:0&gt; : '0';

        integer scaled;
        boolean increasedprecision = N==32 &amp;&amp; <a link="impl-shared.HaveFeatRPRES.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatRPRES()">HaveFeatRPRES</a>() &amp;&amp; altfp;

        if !increasedprecision then
            if exp&lt;0&gt; == '0' then
                scaled = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>('1':fraction&lt;51:44&gt;);
            else
                scaled = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>('01':fraction&lt;51:45&gt;);
        else
            if exp&lt;0&gt; == '0' then
                scaled = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>('1':fraction&lt;51:41&gt;);
            else
                scaled = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>('01':fraction&lt;51:42&gt;);

        integer result_exp;
        case N of
            when 16 result_exp = (  44 - exp) DIV 2;
            when 32 result_exp = ( 380 - exp) DIV 2;
            when 64 result_exp = (3068 - exp) DIV 2;

        estimate = <a link="impl-shared.RecipSqrtEstimate.2" file="shared_pseudocode.xml" hover="function: integer RecipSqrtEstimate(integer a_in, boolean increasedprecision)">RecipSqrtEstimate</a>(scaled, increasedprecision);

        // Estimate is in the range 256 .. 511 or 4096 .. 8191 representing a
        // fixed-point result in the range [1.0 .. 2.0].
        // Convert to scaled floating point result with copied sign bit and high-order
        // fraction bits, and exponent calculated above.
        case N of
            when 16 result = '0' : result_exp&lt;N-12:0&gt; : estimate&lt;7:0&gt;:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(2);
            when 32
                if !increasedprecision then
                    result = '0' : result_exp&lt;N-25:0&gt; : estimate&lt;7:0&gt;:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(15);
                else
                    result = '0' : result_exp&lt;N-25:0&gt; : estimate&lt;11:0&gt;:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(11);
            when 64 result = '0' : result_exp&lt;N-54:0&gt; : estimate&lt;7:0&gt;:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(44);

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fprsqrtestimate/RecipSqrtEstimate" mylink="shared.functions.float.fprsqrtestimate.RecipSqrtEstimate" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// RecipSqrtEstimate()
// ===================
// Compute estimate of reciprocal square root of 9-bit fixed-point number.
//
// a_in is in range 128 .. 511 or 1024 .. 4095, with increased precision,
// representing a number in the range 0.25 &lt;= x &lt; 1.0.
// increasedprecision determines if the mantissa is 8-bit or 12-bit.
// result is in the range 256 .. 511 or 4096 .. 8191, with increased precision,
// representing a number in the range 1.0 to 511/256 or 8191/4096.

integer <anchor link="impl-shared.RecipSqrtEstimate.2" hover="function: integer RecipSqrtEstimate(integer a_in, boolean increasedprecision)">RecipSqrtEstimate</anchor>(integer a_in, boolean increasedprecision)

    integer a = a_in;
    integer r;
    if !increasedprecision then
        assert 128 &lt;= a &amp;&amp; a &lt; 512;
        if a &lt; 256 then                      // 0.25 .. 0.5
            a = a*2+1;                       // a in units of 1/512 rounded to nearest
        else                                 // 0.5 .. 1.0
            a = (a &gt;&gt; 1) &lt;&lt; 1;               // Discard bottom bit
            a = (a+1)*2;                     // a in units of 1/256 rounded to nearest
        integer b = 512;
        while a*(b+1)*(b+1) &lt; 2^28 do
            b = b+1;
        // b = largest b such that b &lt; 2^14 / sqrt(a)
        r = (b+1) DIV 2;                     // Round to nearest
        assert 256 &lt;= r &amp;&amp; r &lt; 512;
    else
        assert 1024 &lt;= a &amp;&amp; a &lt; 4096;
        real real_val;
        real error;
        integer int_val;

        if a &lt; 2048 then                     // 0.25... 0.5
            a = a*2 + 1;                     // Take 10 bits of fraction and force a 1 at the bottom
            real_val = Real(a)/2.0;
        else                                 // 0.5..1.0
            a = (a &gt;&gt; 1) &lt;&lt; 1;               // Discard bottom bit
            a = a+1;                         // Take 10 bits of fraction and force a 1 at the bottom
            real_val = Real(a);

        real_val = Sqrt(real_val);           // This number will lie in the range of 32 to 64
                                             // Round to nearest even for a DP float number
        real_val = real_val * Real(2^47);    // The integer is the size of the whole DP mantissa
        int_val  = <a link="impl-shared.RoundDown.1" file="shared_pseudocode.xml" hover="function: integer RoundDown(real x)">RoundDown</a>(real_val);      // Calculate rounding value
        error    = real_val - Real(int_val);
        round_up = error &gt; 0.5;              // Error cannot be exactly 0.5 so do not need tie case
        if round_up then int_val = int_val+1;

        real_val = Real(2^65)/Real(int_val); // Lies in the range 4096 &lt;= real_val &lt; 8192
        int_val  = <a link="impl-shared.RoundDown.1" file="shared_pseudocode.xml" hover="function: integer RoundDown(real x)">RoundDown</a>(real_val);      // Round that (to nearest even) to give integer
        error    = real_val - Real(int_val);
        round_up = (error &gt; 0.5 || (error == 0.5 &amp;&amp; int_val&lt;0&gt; == '1'));
        if round_up then int_val = int_val+1;

        r = int_val;
        assert 4096 &lt;= r &amp;&amp; r &lt; 8192;

    return r;</pstext>
    </ps>
    <ps name="shared/functions/float/fpsqrt/FPSqrt" mylink="shared.functions.float.fpsqrt.FPSqrt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPSqrt()
// ========

bits(N) <anchor link="impl-shared.FPSqrt.2" hover="function: bits(N) FPSqrt(bits(N) op, FPCRType fpcr)">FPSqrt</anchor>(bits(N) op, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    (fptype,sign,value) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op, fpcr);

    bits(N) result;
    if fptype == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        result = <a link="impl-shared.FPProcessNaN.3" file="shared_pseudocode.xml" hover="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr)">FPProcessNaN</a>(fptype, op, fpcr);
    elsif fptype == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
        result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
    elsif fptype == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> &amp;&amp; sign == '0' then
        result = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign);
    elsif sign == '1' then
        result = <a link="impl-shared.FPDefaultNaN.1" file="shared_pseudocode.xml" hover="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
        <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InvalidOp" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    else
        result = <a link="impl-shared.FPRound.2" file="shared_pseudocode.xml" hover="function: bits(N) FPRound(real op, FPCRType fpcr)">FPRound</a>(Sqrt(value), fpcr);

        <a link="impl-shared.FPProcessDenorm.3" file="shared_pseudocode.xml" hover="function: FPProcessDenorm(FPType fptype, integer N, FPCRType fpcr)">FPProcessDenorm</a>(fptype, N, fpcr);

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fpsub/FPSub" mylink="shared.functions.float.fpsub.FPSub" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPSub()
// =======

bits(N) <anchor link="impl-shared.FPSub.3" hover="function: bits(N) FPSub(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPSub</anchor>(bits(N) op1, bits(N) op2, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    rounding = <a link="impl-shared.FPRoundingMode.1" file="shared_pseudocode.xml" hover="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);

    (type1,sign1,value1) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a link="impl-shared.FPUnpack.2" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</a>(op2, fpcr);

    (done,result) = <a link="impl-shared.FPProcessNaNs.5" file="shared_pseudocode.xml" hover="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1,&#13; bits(N) op2, FPCRType fpcr)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        inf2 = (type2 == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        zero2 = (type2 == <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

        if inf1 &amp;&amp; inf2 &amp;&amp; sign1 == sign2 then
            result = <a link="impl-shared.FPDefaultNaN.1" file="shared_pseudocode.xml" hover="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
            <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InvalidOp" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        elsif (inf1 &amp;&amp; sign1 == '0') || (inf2 &amp;&amp; sign2 == '1') then
            result = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('0');
        elsif (inf1 &amp;&amp; sign1 == '1') || (inf2 &amp;&amp; sign2 == '0') then
            result = <a link="impl-shared.FPInfinity.1" file="shared_pseudocode.xml" hover="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('1');
        elsif zero1 &amp;&amp; zero2 &amp;&amp; sign1 == NOT(sign2) then
            result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(sign1);
        else
            result_value = value1 - value2;
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                result_sign = if rounding == <a link="FPRounding_NEGINF" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a> then '1' else '0';
                result = <a link="impl-shared.FPZero.1" file="shared_pseudocode.xml" hover="function: bits(N) FPZero(bit sign)">FPZero</a>(result_sign);
            else
                result = <a link="impl-shared.FPRound.3" file="shared_pseudocode.xml" hover="function: bits(N) FPRound(real op, FPCRType fpcr_in, FPRounding rounding)">FPRound</a>(result_value, fpcr, rounding);

        <a link="impl-shared.FPProcessDenorms.4" file="shared_pseudocode.xml" hover="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fpthree/FPThree" mylink="shared.functions.float.fpthree.FPThree" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPThree()
// =========

bits(N) <anchor link="impl-shared.FPThree.1" hover="function: bits(N) FPThree(bit sign)">FPThree</anchor>(bit sign)

    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp  = '1':<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(E-1);
    frac = '1':<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(F-1);
    result = sign : exp : frac;

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fptofixed/FPToFixed" mylink="shared.functions.float.fptofixed.FPToFixed" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPToFixed()
// ===========

// Convert N-bit precision floating point OP to M-bit fixed point with
// FBITS fractional bits, controlled by UNSIGNED and ROUNDING.

bits(M) <anchor link="impl-shared.FPToFixed.5" hover="function: bits(M) FPToFixed(bits(N) op, integer fbits, boolean unsigned, FPCRType fpcr, FPRounding rounding)">FPToFixed</anchor>(bits(N) op, integer fbits, boolean unsigned, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr, <a link="FPRounding" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding)

    assert N IN {16,32,64};
    assert M IN {16,32,64};
    assert fbits &gt;= 0;
    assert rounding != <a link="FPRounding_ODD" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ODD</a>;

    // When alternative floating-point support is TRUE, do not generate
    // Input Denormal floating-point exceptions.
    altfp = <a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    fpexc = !altfp;

    // Unpack using fpcr to determine if subnormals are flushed-to-zero.
    (fptype,sign,value) = <a link="impl-shared.FPUnpack.3" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op, fpcr, fpexc);

    // If NaN, set cumulative flag or take exception.
    if fptype == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InvalidOp" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);

    // Scale by fractional bits and produce integer rounded towards minus-infinity.
    value = value * 2.0^fbits;
    int_result = <a link="impl-shared.RoundDown.1" file="shared_pseudocode.xml" hover="function: integer RoundDown(real x)">RoundDown</a>(value);
    error = value - Real(int_result);

    // Determine whether supplied rounding mode requires an increment.
    boolean round_up;
    case rounding of
        when <a link="FPRounding_TIEEVEN" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEEVEN</a>
            round_up = (error &gt; 0.5 || (error == 0.5 &amp;&amp; int_result&lt;0&gt; == '1'));
        when <a link="FPRounding_POSINF" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_POSINF</a>
            round_up = (error != 0.0);
        when <a link="FPRounding_NEGINF" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a>
            round_up = FALSE;
        when <a link="FPRounding_ZERO" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ZERO</a>
            round_up = (error != 0.0 &amp;&amp; int_result &lt; 0);
        when <a link="FPRounding_TIEAWAY" file="shared_pseudocode.xml" hover="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEAWAY</a>
            round_up = (error &gt; 0.5 || (error == 0.5 &amp;&amp; int_result &gt;= 0));

    if round_up then int_result = int_result + 1;

    // Generate saturated result and exceptions.
    (result, overflow) = <a link="impl-shared.SatQ.3" file="shared_pseudocode.xml" hover="function: (bits(N), boolean) SatQ(integer i, integer N, boolean unsigned)">SatQ</a>(int_result, M, unsigned);
    if overflow then
        <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InvalidOp" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    elsif error != 0.0 then
        <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_Inexact" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Inexact</a>, fpcr);

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fptofixedjs/FPToFixedJS" mylink="shared.functions.float.fptofixedjs.FPToFixedJS" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPToFixedJS()
// =============

// Converts a double precision floating point input value
// to a signed integer, with rounding to zero.

(bits(N), bit) <anchor link="impl-shared.FPToFixedJS.3" hover="function: (bits(N), bit) FPToFixedJS(bits(M) op, FPCRType fpcr, boolean Is64)">FPToFixedJS</anchor>(bits(M) op, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr, boolean Is64)

    assert M == 64 &amp;&amp; N == 32;

    // If FALSE, never generate Input Denormal floating-point exceptions.
    fpexc_idenorm = !(<a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1');

    // Unpack using fpcr to determine if subnormals are flushed-to-zero.
    (fptype,sign,value) = <a link="impl-shared.FPUnpack.3" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</a>(op, fpcr, fpexc_idenorm);

    Z = '1';
    // If NaN, set cumulative flag or take exception.
    if fptype == <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InvalidOp" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        Z = '0';

    int_result = <a link="impl-shared.RoundDown.1" file="shared_pseudocode.xml" hover="function: integer RoundDown(real x)">RoundDown</a>(value);
    error = value - Real(int_result);

    // Determine whether supplied rounding mode requires an increment.

    round_it_up = (error != 0.0 &amp;&amp; int_result &lt; 0);
    if round_it_up then int_result = int_result + 1;

    integer result;
    if int_result &lt; 0 then
        result = int_result - 2^32*<a link="impl-shared.RoundUp.1" file="shared_pseudocode.xml" hover="function: integer RoundUp(real x)">RoundUp</a>(Real(int_result)/Real(2^32));
    else
        result = int_result - 2^32*<a link="impl-shared.RoundDown.1" file="shared_pseudocode.xml" hover="function: integer RoundDown(real x)">RoundDown</a>(Real(int_result)/Real(2^32));

    // Generate exceptions.
    if int_result &lt; -(2^31) || int_result &gt; (2^31)-1 then
        <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InvalidOp" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        Z = '0';
    elsif error != 0.0 then
        <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_Inexact" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Inexact</a>, fpcr);
        Z = '0';
    elsif sign == '1' &amp;&amp; value == 0.0 then
        Z = '0';
    elsif sign == '0' &amp;&amp; value == 0.0 &amp;&amp; !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(op&lt;51:0&gt;) then
        Z = '0';

    if fptype == <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then result = 0;

    return (result&lt;N-1:0&gt;, Z);</pstext>
    </ps>
    <ps name="shared/functions/float/fptwo/FPTwo" mylink="shared.functions.float.fptwo.FPTwo" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPTwo()
// =======

bits(N) <anchor link="impl-shared.FPTwo.1" hover="function: bits(N) FPTwo(bit sign)">FPTwo</anchor>(bit sign)

    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp  = '1':<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(E-1);
    frac = <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(F);
    result = sign : exp : frac;

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/fptype/FPType" mylink="shared.functions.float.fptype.FPType" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="FPType" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</anchor> {<anchor link="FPType_Zero" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</anchor>,
                    <anchor link="FPType_Denormal" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</anchor>,
                    <anchor link="FPType_Nonzero" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Nonzero</anchor>,
                    <anchor link="FPType_Infinity" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</anchor>,
                    <anchor link="FPType_QNaN" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</anchor>,
                    <anchor link="FPType_SNaN" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</anchor>};</pstext>
    </ps>
    <ps name="shared/functions/float/fpunpack/FPUnpack" mylink="shared.functions.float.fpunpack.FPUnpack" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPUnpack()
// ==========

(FPType, bit, real) <anchor link="impl-shared.FPUnpack.2" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in)">FPUnpack</anchor>(bits(N) fpval, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr_in)
    <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    fpcr.AHP = '0';
    boolean fpexc = TRUE;   // Generate floating-point exceptions
    (fp_type, sign, value) = <a link="impl-shared.FPUnpackBase.3" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpackBase</a>(fpval, fpcr, fpexc);
    return (fp_type, sign, value);

// FPUnpack()
// ==========
//
// Used by data processing and int/fixed &lt;-&gt; FP conversion instructions.
// For half-precision data it ignores AHP, and observes FZ16.

(FPType, bit, real) <anchor link="impl-shared.FPUnpack.3" hover="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpack</anchor>(bits(N) fpval, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr_in, boolean fpexc)
    <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    fpcr.AHP = '0';
    (fp_type, sign, value) = <a link="impl-shared.FPUnpackBase.3" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpackBase</a>(fpval, fpcr, fpexc);
    return (fp_type, sign, value);</pstext>
    </ps>
    <ps name="shared/functions/float/fpunpack/FPUnpackBase" mylink="shared.functions.float.fpunpack.FPUnpackBase" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPUnpackBase()
// ==============

(FPType, bit, real) <anchor link="impl-shared.FPUnpackBase.2" hover="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr)">FPUnpackBase</anchor>(bits(N) fpval, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr)
    boolean fpexc = TRUE;   // Generate floating-point exceptions
    (fp_type, sign, value) = <a link="impl-shared.FPUnpackBase.3" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpackBase</a>(fpval, fpcr, fpexc);
    return (fp_type, sign, value);

// FPUnpackBase()
// ==============
//
// Unpack a floating-point number into its type, sign bit and the real number
// that it represents. The real number result has the correct sign for numbers
// and infinities, is very large in magnitude for infinities, and is 0.0 for
// NaNs. (These values are chosen to simplify the description of comparisons
// and conversions.)
//
// The 'fpcr_in' argument supplies FPCR control bits and 'fpexc' controls the
// generation of floating-point exceptions. Status information is updated
// directly in the FPSR where appropriate.

(FPType, bit, real) <anchor link="impl-shared.FPUnpackBase.3" hover="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpackBase</anchor>(bits(N) fpval, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr_in, boolean fpexc)

    assert N IN {16,32,64};

    <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr = fpcr_in;

    boolean altfp = <a link="impl-shared.HaveAltFP.0" file="shared_pseudocode.xml" hover="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>();
    boolean fiz   = altfp &amp;&amp; fpcr.FIZ == '1';
    boolean fz    = fpcr.FZ == '1' &amp;&amp; !(altfp &amp;&amp; fpcr.AH == '1');
    real value;
    bit sign;
    <a link="FPType" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> fptype;

    if N == 16 then
        sign   = fpval&lt;15&gt;;
        exp16  = fpval&lt;14:10&gt;;
        frac16 = fpval&lt;9:0&gt;;
        if <a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(exp16) then
            if <a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(frac16) || fpcr.FZ16 == '1' then
                fptype = <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>;  value = 0.0;
            else
                fptype = <a link="FPType_Denormal" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a>;  value = 2.0^-14 * (Real(<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(frac16)) * 2.0^-10);
        elsif <a link="impl-shared.IsOnes.1" file="shared_pseudocode.xml" hover="function: boolean IsOnes(bits(N) x)">IsOnes</a>(exp16) &amp;&amp; fpcr.AHP == '0' then  // Infinity or NaN in IEEE format
            if <a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(frac16) then
                fptype = <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>;  value = 2.0^1000000;
            else
                fptype = if frac16&lt;9&gt; == '1' then <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> else <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>;
                value = 0.0;
        else
            fptype = <a link="FPType_Nonzero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Nonzero</a>;
            value = 2.0^(<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(exp16)-15) * (1.0 + Real(<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(frac16)) * 2.0^-10);

    elsif N == 32 then
        sign   = fpval&lt;31&gt;;
        exp32  = fpval&lt;30:23&gt;;
        frac32 = fpval&lt;22:0&gt;;

        if <a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(exp32) then
            if <a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(frac32) then
                // Produce zero if value is zero.
                fptype = <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>;  value = 0.0;
            elsif fz || fiz then        // Flush-to-zero if FIZ==1 or AH,FZ==01
                fptype = <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>;  value = 0.0;
                // Check whether to raise Input Denormal floating-point exception.
                // fpcr.FIZ==1 does not raise Input Denormal exception.
                if fz then
                    // Denormalized input flushed to zero
                    if fpexc then <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InputDenorm" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InputDenorm</a>, fpcr);
            else
                fptype = <a link="FPType_Denormal" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a>;  value = 2.0^-126 * (Real(<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(frac32)) * 2.0^-23);
        elsif <a link="impl-shared.IsOnes.1" file="shared_pseudocode.xml" hover="function: boolean IsOnes(bits(N) x)">IsOnes</a>(exp32) then
            if <a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(frac32) then
                fptype = <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>;  value = 2.0^1000000;
            else
                fptype = if frac32&lt;22&gt; == '1' then <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> else <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>;
                value = 0.0;
        else
            fptype = <a link="FPType_Nonzero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Nonzero</a>;
            value = 2.0^(<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(exp32)-127) * (1.0 + Real(<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(frac32)) * 2.0^-23);

    else // N == 64
        sign   = fpval&lt;63&gt;;
        exp64  = fpval&lt;62:52&gt;;
        frac64 = fpval&lt;51:0&gt;;

        if <a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(exp64) then
            if <a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(frac64) then
                // Produce zero if value is zero.
                fptype = <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>;  value = 0.0;
            elsif fz || fiz then        // Flush-to-zero if FIZ==1 or AH,FZ==01
                fptype = <a link="FPType_Zero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>;  value = 0.0;
                // Check whether to raise Input Denormal floating-point exception.
                // fpcr.FIZ==1 does not raise Input Denormal exception.
                if fz then
                    // Denormalized input flushed to zero
                    if fpexc then <a link="impl-shared.FPProcessException.2" file="shared_pseudocode.xml" hover="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a link="FPExc_InputDenorm" file="shared_pseudocode.xml" hover="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InputDenorm</a>, fpcr);
            else
                fptype = <a link="FPType_Denormal" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a>;  value = 2.0^-1022 * (Real(<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(frac64)) * 2.0^-52);
        elsif <a link="impl-shared.IsOnes.1" file="shared_pseudocode.xml" hover="function: boolean IsOnes(bits(N) x)">IsOnes</a>(exp64) then
            if <a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(frac64) then
                fptype = <a link="FPType_Infinity" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>;  value = 2.0^1000000;
            else
                fptype = if frac64&lt;51&gt; == '1' then <a link="FPType_QNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> else <a link="FPType_SNaN" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>;
                value = 0.0;
        else
            fptype = <a link="FPType_Nonzero" file="shared_pseudocode.xml" hover="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Nonzero</a>;
            value = 2.0^(<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(exp64)-1023) * (1.0 + Real(<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(frac64)) * 2.0^-52);

    if sign == '1' then value = -value;

    return (fptype, sign, value);</pstext>
    </ps>
    <ps name="shared/functions/float/fpunpack/FPUnpackCV" mylink="shared.functions.float.fpunpack.FPUnpackCV" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPUnpackCV()
// ============
//
// Used for FP &lt;-&gt; FP conversion instructions.
// For half-precision data ignores FZ16 and observes AHP.

(FPType, bit, real) <anchor link="impl-shared.FPUnpackCV.2" hover="function: (FPType, bit, real) FPUnpackCV(bits(N) fpval, FPCRType fpcr_in)">FPUnpackCV</anchor>(bits(N) fpval, <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr_in)
    <a link="FPCRType" file="shared_pseudocode.xml" hover="type FPCRType">FPCRType</a> fpcr = fpcr_in;
    fpcr.FZ16 = '0';
    boolean fpexc = TRUE;   // Generate floating-point exceptions
    (fp_type, sign, value) = <a link="impl-shared.FPUnpackBase.3" file="shared_pseudocode.xml" hover="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr_in, boolean fpexc)">FPUnpackBase</a>(fpval, fpcr, fpexc);
    return (fp_type, sign, value);</pstext>
    </ps>
    <ps name="shared/functions/float/fpzero/FPZero" mylink="shared.functions.float.fpzero.FPZero" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FPZero()
// ========

bits(N) <anchor link="impl-shared.FPZero.1" hover="function: bits(N) FPZero(bit sign)">FPZero</anchor>(bit sign)

    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp  = <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(E);
    frac = <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(F);
    result = sign : exp : frac;

    return result;</pstext>
    </ps>
    <ps name="shared/functions/float/vfpexpandimm/VFPExpandImm" mylink="shared.functions.float.vfpexpandimm.VFPExpandImm" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// VFPExpandImm()
// ==============

bits(N) <anchor link="impl-shared.VFPExpandImm.1" hover="function: bits(N) VFPExpandImm(bits(8) imm8)">VFPExpandImm</anchor>(bits(8) imm8)

    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = (N - E) - 1;
    sign = imm8&lt;7&gt;;
    exp  = NOT(imm8&lt;6&gt;):<a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;6&gt;,E-3):imm8&lt;5:4&gt;;
    frac = imm8&lt;3:0&gt;:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(F-4);
    result = sign : exp : frac;

    return result;</pstext>
    </ps>
    <ps name="shared/functions/integer/AddWithCarry" mylink="shared.functions.integer.AddWithCarry" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AddWithCarry()
// ==============
// Integer addition with carry input, returning result and NZCV flags

(bits(N), bits(4)) <anchor link="impl-shared.AddWithCarry.3" hover="function: (bits(N), bits(4)) AddWithCarry(bits(N) x, bits(N) y, bit carry_in)">AddWithCarry</anchor>(bits(N) x, bits(N) y, bit carry_in)
    integer unsigned_sum = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(x) + <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(y) + <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(carry_in);
    integer signed_sum = <a link="impl-shared.SInt.1" file="shared_pseudocode.xml" hover="function: integer SInt(bits(N) x)">SInt</a>(x) + <a link="impl-shared.SInt.1" file="shared_pseudocode.xml" hover="function: integer SInt(bits(N) x)">SInt</a>(y) + <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(carry_in);
    bits(N) result = unsigned_sum&lt;N-1:0&gt;; // same value as signed_sum&lt;N-1:0&gt;
    bit n = result&lt;N-1&gt;;
    bit z = if <a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(result) then '1' else '0';
    bit c = if <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(result) == unsigned_sum then '0' else '1';
    bit v = if <a link="impl-shared.SInt.1" file="shared_pseudocode.xml" hover="function: integer SInt(bits(N) x)">SInt</a>(result) == signed_sum then '0' else '1';
    return (result, n:z:c:v);</pstext>
    </ps>
    <ps name="shared/functions/interrupts/InterruptID" mylink="shared.functions.interrupts.InterruptID" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="InterruptID" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID</anchor> {
    <anchor link="InterruptID_PMUIRQ" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_PMUIRQ</anchor>,
    <anchor link="InterruptID_COMMIRQ" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_COMMIRQ</anchor>,
    <anchor link="InterruptID_CTIIRQ" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CTIIRQ</anchor>,
    <anchor link="InterruptID_COMMRX" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_COMMRX</anchor>,
    <anchor link="InterruptID_COMMTX" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_COMMTX</anchor>,
    <anchor link="InterruptID_CNTP" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTP</anchor>,
    <anchor link="InterruptID_CNTHP" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTHP</anchor>,
    <anchor link="InterruptID_CNTHPS" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTHPS</anchor>,
    <anchor link="InterruptID_CNTPS" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTPS</anchor>,
    <anchor link="InterruptID_CNTV" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTV</anchor>,
    <anchor link="InterruptID_CNTHV" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTHV</anchor>,
    <anchor link="InterruptID_CNTHVS" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID_CNTHVS</anchor>,
};</pstext>
    </ps>
    <ps name="shared/functions/interrupts/SetInterruptRequestLevel" mylink="shared.functions.interrupts.SetInterruptRequestLevel" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Set a level-sensitive interrupt to the specified level.
SetInterruptRequestLevel(<a link="InterruptID" file="shared_pseudocode.xml" hover="enumeration InterruptID {&#13; InterruptID_PMUIRQ,&#13; InterruptID_COMMIRQ,&#13; InterruptID_CTIIRQ,&#13; InterruptID_COMMRX,&#13; InterruptID_COMMTX,&#13; InterruptID_CNTP,&#13; InterruptID_CNTHP,&#13; InterruptID_CNTHPS,&#13; InterruptID_CNTPS,&#13; InterruptID_CNTV,&#13; InterruptID_CNTHV,&#13; InterruptID_CNTHVS,&#13; }">InterruptID</a> id, signal level);</pstext>
    </ps>
    <ps name="shared/functions/memory/AArch64.BranchAddr" mylink="shared.functions.memory.AArch64.BranchAddr" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AArch64.BranchAddr()
// ====================
// Return the virtual address with tag bits removed for storing to the program counter.

bits(64) <anchor link="AArch64.BranchAddr.1" hover="function: bits(64) AArch64.BranchAddr(bits(64) vaddress)">AArch64.BranchAddr</anchor>(bits(64) vaddress)
    assert !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>();
    msbit = <a link="impl-shared.AddrTop.3" file="shared_pseudocode.xml" hover="function: integer AddrTop(bits(64) address, boolean IsInstr, bits(2) el)">AddrTop</a>(vaddress, TRUE, PSTATE.EL);
    if msbit == 63 then
        return vaddress;
    elsif (PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} || <a link="impl-shared.IsInHost.0" file="shared_pseudocode.xml" hover="function: boolean IsInHost()">IsInHost</a>()) &amp;&amp; vaddress&lt;msbit&gt; == '1' then
        return <a link="impl-shared.SignExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) SignExtend(bits(M) x)">SignExtend</a>(vaddress&lt;msbit:0&gt;);
    else
        return <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(vaddress&lt;msbit:0&gt;);</pstext>
    </ps>
    <ps name="shared/functions/memory/AccType" mylink="shared.functions.memory.AccType" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="AccType" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</anchor> {<anchor link="AccType_NORMAL" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NORMAL</anchor>,            // Normal loads and stores
                     <anchor link="AccType_STREAM" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_STREAM</anchor>,            // Streaming loads and stores
                     <anchor link="AccType_VEC" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VEC</anchor>,               // Vector loads and stores
                     <anchor link="AccType_VECSTREAM" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VECSTREAM</anchor>,         // Streaming vector loads and stores
                     <anchor link="AccType_UNPRIVSTREAM" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_UNPRIVSTREAM</anchor>,      // Streaming unprivileged loads and stores
                     <anchor link="AccType_A32LSMD" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_A32LSMD</anchor>,           // Load and store multiple
                     <anchor link="AccType_ATOMIC" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMIC</anchor>,            // Atomic loads and stores
                     <anchor link="AccType_ATOMICRW" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</anchor>,
                     <anchor link="AccType_ORDERED" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDERED</anchor>,           // Load-Acquire and Store-Release
                     <anchor link="AccType_ORDEREDRW" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDRW</anchor>,
                     <anchor link="AccType_ORDEREDATOMIC" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMIC</anchor>,     // Load-Acquire and Store-Release with atomic access
                     <anchor link="AccType_ORDEREDATOMICRW" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMICRW</anchor>,
                     <anchor link="AccType_ATOMICLS64" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICLS64</anchor>,        // Atomic 64-byte loads and stores
                     <anchor link="AccType_LIMITEDORDERED" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_LIMITEDORDERED</anchor>,    // Load-LOAcquire and Store-LORelease
                     <anchor link="AccType_UNPRIV" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_UNPRIV</anchor>,            // Load and store unprivileged
                     <anchor link="AccType_IFETCH" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</anchor>,            // Instruction fetch
                     <anchor link="AccType_TTW" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_TTW</anchor>,               // Translation table walk
                     <anchor link="AccType_NV2REGISTER" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NV2REGISTER</anchor>,       // MRS/MSR instruction used at EL1 and which is
                                                // converted to a memory access that uses the
                                                // EL2 translation regime
                     // Other operations
                     <anchor link="AccType_DC" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</anchor>,                // Data cache maintenance
                     <anchor link="AccType_IC" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</anchor>,                // Instruction cache maintenance
                     <anchor link="AccType_DCZVA" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DCZVA</anchor>,             // DC ZVA instructions
                     <anchor link="AccType_ATPAN" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATPAN</anchor>,             // Address translation with PAN permission checks
                     <anchor link="AccType_AT" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</anchor>};               // Address translation</pstext>
    </ps>
    <ps name="shared/functions/memory/AccessDescriptor" mylink="shared.functions.memory.AccessDescriptor" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">type <anchor link="AccessDescriptor" hover="type AccessDescriptor is ( MPAMinfo mpam, AccType acctype)">AccessDescriptor</anchor> is (
    <a link="MPAMinfo" file="shared_pseudocode.xml" hover="type MPAMinfo is ( PARTIDspaceType mpam_ns, PARTIDtype partid, PMGtype pmg )">MPAMinfo</a> mpam,
    <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype)</pstext>
    </ps>
    <ps name="shared/functions/memory/AddrTop" mylink="shared.functions.memory.AddrTop" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AddrTop()
// =========
// Return the MSB number of a virtual address in the stage 1 translation regime for "el".
// If EL1 is using AArch64 then addresses from EL0 using AArch32 are zero-extended to 64 bits.

integer <anchor link="impl-shared.AddrTop.3" hover="function: integer AddrTop(bits(64) address, boolean IsInstr, bits(2) el)">AddrTop</anchor>(bits(64) address, boolean IsInstr, bits(2) el)
    assert <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(el);
    regime = <a link="impl-shared.S1TranslationRegime.1" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime(bits(2) el)">S1TranslationRegime</a>(el);
    if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(regime) then
        // AArch32 translation regime.
        return 31;
    else
        if <a link="impl-shared.EffectiveTBI.3" file="shared_pseudocode.xml" hover="function: bit EffectiveTBI(bits(64) address, boolean IsInstr, bits(2) el)">EffectiveTBI</a>(address, IsInstr, el) == '1' then
            return 55;
        else
            return 63;</pstext>
    </ps>
    <ps name="shared/functions/memory/Allocation" mylink="shared.functions.memory.Allocation" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">constant bits(2) <anchor link="MemHint_No" hover="constant bits(2) MemHint_No = '00'">MemHint_No</anchor> = '00';     // No Read-Allocate, No Write-Allocate
constant bits(2) <anchor link="MemHint_WA" hover="constant bits(2) MemHint_WA = '01'">MemHint_WA</anchor> = '01';     // No Read-Allocate, Write-Allocate
constant bits(2) <anchor link="MemHint_RA" hover="constant bits(2) MemHint_RA = '10'">MemHint_RA</anchor> = '10';     // Read-Allocate, No Write-Allocate
constant bits(2) <anchor link="MemHint_RWA" hover="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</anchor> = '11';    // Read-Allocate, Write-Allocate</pstext>
    </ps>
    <ps name="shared/functions/memory/BigEndian" mylink="shared.functions.memory.BigEndian" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// BigEndian()
// ===========

boolean <anchor link="impl-shared.BigEndian.1" hover="function: boolean BigEndian(AccType acctype)">BigEndian</anchor>(<a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype)
    boolean bigend;
    if <a link="impl-shared.HaveNV2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveNV2Ext()">HaveNV2Ext</a>() &amp;&amp; acctype == <a link="AccType_NV2REGISTER" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NV2REGISTER</a> then
        return SCTLR_EL2.EE == '1';

    if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
        bigend = (PSTATE.E != '0');
    elsif PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then
        bigend = (<a link="impl-aarch64.SCTLR.read.0" file="shared_pseudocode.xml" hover="accessor: SCTLRType SCTLR[]">SCTLR</a>[].E0E != '0');
    else
        bigend = (<a link="impl-aarch64.SCTLR.read.0" file="shared_pseudocode.xml" hover="accessor: SCTLRType SCTLR[]">SCTLR</a>[].EE != '0');
    return bigend;</pstext>
    </ps>
    <ps name="shared/functions/memory/BigEndianReverse" mylink="shared.functions.memory.BigEndianReverse" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// BigEndianReverse()
// ==================

bits(width) <anchor link="impl-shared.BigEndianReverse.1" hover="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</anchor> (bits(width) value)
    assert width IN {8, 16, 32, 64, 128};
    integer half = width DIV 2;
    if width == 8 then return value;
    return <a link="impl-shared.BigEndianReverse.1" file="shared_pseudocode.xml" hover="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(value&lt;half-1:0&gt;) : <a link="impl-shared.BigEndianReverse.1" file="shared_pseudocode.xml" hover="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(value&lt;width-1:half&gt;);</pstext>
    </ps>
    <ps name="shared/functions/memory/Cacheability" mylink="shared.functions.memory.Cacheability" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">constant bits(2) <anchor link="MemAttr_NC" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</anchor> = '00';     // Non-cacheable
constant bits(2) <anchor link="MemAttr_WT" hover="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</anchor> = '10';     // Write-through
constant bits(2) <anchor link="MemAttr_WB" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</anchor> = '11';     // Write-back</pstext>
    </ps>
    <ps name="shared/functions/memory/CreateAccessDescriptor" mylink="shared.functions.memory.CreateAccessDescriptor" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CreateAccessDescriptor()
// ========================

AccessDescriptor <anchor link="impl-shared.CreateAccessDescriptor.1" hover="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</anchor>(<a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype)
    <a link="AccessDescriptor" file="shared_pseudocode.xml" hover="type AccessDescriptor is ( MPAMinfo mpam, AccType acctype)">AccessDescriptor</a> accdesc;
    accdesc.acctype = acctype;
    accdesc.mpam = <a link="impl-shared.GenMPAMcurEL.1" file="shared_pseudocode.xml" hover="function: MPAMinfo GenMPAMcurEL(AccType acctype)">GenMPAMcurEL</a>(acctype);
    return accdesc;</pstext>
    </ps>
    <ps name="shared/functions/memory/DataMemoryBarrier" mylink="shared.functions.memory.DataMemoryBarrier" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions"><anchor link="impl-shared.DataMemoryBarrier.2" hover="function: DataMemoryBarrier(MBReqDomain domain, MBReqTypes types)">DataMemoryBarrier</anchor>(<a link="MBReqDomain" file="shared_pseudocode.xml" hover="enumeration MBReqDomain    {MBReqDomain_Nonshareable, MBReqDomain_InnerShareable,&#13; MBReqDomain_OuterShareable, MBReqDomain_FullSystem}">MBReqDomain</a> domain, <a link="MBReqTypes" file="shared_pseudocode.xml" hover="enumeration MBReqTypes     {MBReqTypes_Reads, MBReqTypes_Writes, MBReqTypes_All}">MBReqTypes</a> types);</pstext>
    </ps>
    <ps name="shared/functions/memory/DataSynchronizationBarrier" mylink="shared.functions.memory.DataSynchronizationBarrier" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions"><anchor link="impl-shared.DataSynchronizationBarrier.3" hover="function: DataSynchronizationBarrier(MBReqDomain domain, MBReqTypes types, boolean nXS)">DataSynchronizationBarrier</anchor>(<a link="MBReqDomain" file="shared_pseudocode.xml" hover="enumeration MBReqDomain    {MBReqDomain_Nonshareable, MBReqDomain_InnerShareable,&#13; MBReqDomain_OuterShareable, MBReqDomain_FullSystem}">MBReqDomain</a> domain, <a link="MBReqTypes" file="shared_pseudocode.xml" hover="enumeration MBReqTypes     {MBReqTypes_Reads, MBReqTypes_Writes, MBReqTypes_All}">MBReqTypes</a> types, boolean nXS);</pstext>
    </ps>
    <ps name="shared/functions/memory/DeviceType" mylink="shared.functions.memory.DeviceType" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="DeviceType" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType</anchor> {<anchor link="DeviceType_GRE" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_GRE</anchor>, <anchor link="DeviceType_nGRE" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGRE</anchor>, <anchor link="DeviceType_nGnRE" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRE</anchor>, <anchor link="DeviceType_nGnRnE" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</anchor>};</pstext>
    </ps>
    <ps name="shared/functions/memory/EffectiveTBI" mylink="shared.functions.memory.EffectiveTBI" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// EffectiveTBI()
// ==============
// Returns the effective TBI in the AArch64 stage 1 translation regime for "el".

bit <anchor link="impl-shared.EffectiveTBI.3" hover="function: bit EffectiveTBI(bits(64) address, boolean IsInstr, bits(2) el)">EffectiveTBI</anchor>(bits(64) address, boolean IsInstr, bits(2) el)
    bit tbi;
    bit tbid;
    assert <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(el);
    regime = <a link="impl-shared.S1TranslationRegime.1" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime(bits(2) el)">S1TranslationRegime</a>(el);
    assert(!<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(regime));

    case regime of
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>
            tbi = if address&lt;55&gt; == '1' then TCR_EL1.TBI1 else TCR_EL1.TBI0;
            if <a link="impl-aarch64.HavePACExt.0" file="shared_pseudocode.xml" hover="function: boolean HavePACExt()">HavePACExt</a>() then
                tbid = if address&lt;55&gt; == '1' then TCR_EL1.TBID1 else TCR_EL1.TBID0;
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>
            if <a link="impl-shared.HaveVirtHostExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; <a link="impl-shared.ELIsInHost.1" file="shared_pseudocode.xml" hover="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(el) then
                tbi = if address&lt;55&gt; == '1' then TCR_EL2.TBI1 else TCR_EL2.TBI0;
                if <a link="impl-aarch64.HavePACExt.0" file="shared_pseudocode.xml" hover="function: boolean HavePACExt()">HavePACExt</a>() then
                    tbid = if address&lt;55&gt; == '1' then TCR_EL2.TBID1 else TCR_EL2.TBID0;
            else
                tbi = TCR_EL2.TBI;
                if <a link="impl-aarch64.HavePACExt.0" file="shared_pseudocode.xml" hover="function: boolean HavePACExt()">HavePACExt</a>() then tbid = TCR_EL2.TBID;
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>
            tbi = TCR_EL3.TBI;
            if <a link="impl-aarch64.HavePACExt.0" file="shared_pseudocode.xml" hover="function: boolean HavePACExt()">HavePACExt</a>() then tbid = TCR_EL3.TBID;

    return (if tbi == '1' &amp;&amp; (!<a link="impl-aarch64.HavePACExt.0" file="shared_pseudocode.xml" hover="function: boolean HavePACExt()">HavePACExt</a>() || tbid == '0' || !IsInstr) then '1' else '0');</pstext>
    </ps>
    <ps name="shared/functions/memory/EffectiveTCMA" mylink="shared.functions.memory.EffectiveTCMA" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// EffectiveTCMA()
// ===============
// Returns the effective TCMA of a virtual address in the stage 1 translation regime for "el".

bit <anchor link="impl-shared.EffectiveTCMA.2" hover="function: bit EffectiveTCMA(bits(64) address, bits(2) el)">EffectiveTCMA</anchor>(bits(64) address, bits(2) el)
    bit tcma;
    assert <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(el);
    regime = <a link="impl-shared.S1TranslationRegime.1" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime(bits(2) el)">S1TranslationRegime</a>(el);
    assert(!<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(regime));

    case regime of
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>
            tcma = if address&lt;55&gt; == '1' then TCR_EL1.TCMA1 else TCR_EL1.TCMA0;
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>
            if <a link="impl-shared.HaveVirtHostExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; <a link="impl-shared.ELIsInHost.1" file="shared_pseudocode.xml" hover="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(el) then
                tcma = if address&lt;55&gt; == '1' then TCR_EL2.TCMA1 else TCR_EL2.TCMA0;
            else
                tcma = TCR_EL2.TCMA;
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>
            tcma = TCR_EL3.TCMA;

    return tcma;</pstext>
    </ps>
    <ps name="shared/functions/memory/Fault" mylink="shared.functions.memory.Fault" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="Fault" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</anchor> {<anchor link="Fault_None" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</anchor>,
                   <anchor link="Fault_AccessFlag" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</anchor>,
                   <anchor link="Fault_Alignment" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</anchor>,
                   <anchor link="Fault_Background" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Background</anchor>,
                   <anchor link="Fault_Domain" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Domain</anchor>,
                   <anchor link="Fault_Permission" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</anchor>,
                   <anchor link="Fault_Translation" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</anchor>,
                   <anchor link="Fault_AddressSize" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</anchor>,
                   <anchor link="Fault_SyncExternal" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternal</anchor>,
                   <anchor link="Fault_SyncExternalOnWalk" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternalOnWalk</anchor>,
                   <anchor link="Fault_SyncParity" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParity</anchor>,
                   <anchor link="Fault_SyncParityOnWalk" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParityOnWalk</anchor>,
                   <anchor link="Fault_AsyncParity" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncParity</anchor>,
                   <anchor link="Fault_AsyncExternal" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</anchor>,
                   <anchor link="Fault_Debug" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Debug</anchor>,
                   <anchor link="Fault_TLBConflict" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_TLBConflict</anchor>,
                   <anchor link="Fault_BranchTarget" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_BranchTarget</anchor>,
                   <anchor link="Fault_HWUpdateAccessFlag" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_HWUpdateAccessFlag</anchor>,
                   <anchor link="Fault_Lockdown" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Lockdown</anchor>,
                   <anchor link="Fault_Exclusive" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Exclusive</anchor>,
                   <anchor link="Fault_ICacheMaint" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_ICacheMaint</anchor>};</pstext>
    </ps>
    <ps name="shared/functions/memory/FaultRecord" mylink="shared.functions.memory.FaultRecord" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">type <anchor link="FaultRecord" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</anchor> is (<a link="Fault" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a>    statuscode,  // Fault Status
                     <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a>  acctype,      // Type of access that faulted
                     <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> ipaddress, // Intermediate physical address
                     boolean  s2fs1walk,    // Is on a Stage 1 translation table walk
                     boolean  write,        // TRUE for a write, FALSE for a read
                     integer  level,        // For translation, access flag and permission faults
                     bit      extflag,      // IMPLEMENTATION DEFINED syndrome for External aborts
                     boolean  secondstage,  // Is a Stage 2 abort
                     bits(4)  domain,       // Domain number, AArch32 only
                     bits(2)  errortype,    // [Armv8.2 RAS] AArch32 AET or AArch64 SET
                     bits(4)  debugmoe)     // Debug method of entry, from AArch32 only</pstext>
    </ps>
    <ps name="shared/functions/memory/FullAddress" mylink="shared.functions.memory.FullAddress" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">type <anchor link="FullAddress" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</anchor> is (
    <a link="PASpace" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PASpace</a>  paspace,
    bits(52) address
)</pstext>
    </ps>
    <ps name="shared/functions/memory/Hint_Prefetch" mylink="shared.functions.memory.Hint_Prefetch" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Signals the memory system that memory accesses of type HINT to or from the specified address are
// likely in the near future. The memory system may take some action to speed up the memory
// accesses when they do occur, such as pre-loading the the specified address into one or more
// caches as indicated by the innermost cache level target (0=L1, 1=L2, etc) and non-temporal hint
// stream. Any or all prefetch hints may be treated as a NOP. A prefetch hint must not cause a
// synchronous abort due to Alignment or Translation faults and the like. Its only effect on
// software-visible state should be on caches and TLBs associated with address, which must be
// accessible by reads, writes or execution, as defined in the translation regime of the current
// Exception level. It is guaranteed not to access Device memory.
// A Prefetch_EXEC hint must not result in an access that could not be performed by a speculative
// instruction fetch, therefore if all associated MMUs are disabled, then it cannot access any
// memory location that cannot be accessed by instruction fetches.
<anchor link="impl-shared.Hint_Prefetch.4" hover="function: Hint_Prefetch(bits(64) address, PrefetchHint hint, integer target, boolean stream)">Hint_Prefetch</anchor>(bits(64) address, <a link="PrefetchHint" file="shared_pseudocode.xml" hover="enumeration PrefetchHint {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}">PrefetchHint</a> hint, integer target, boolean stream);</pstext>
    </ps>
    <ps name="shared/functions/memory/MBReqDomain" mylink="shared.functions.memory.MBReqDomain" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="MBReqDomain" hover="enumeration MBReqDomain    {MBReqDomain_Nonshareable, MBReqDomain_InnerShareable,&#13; MBReqDomain_OuterShareable, MBReqDomain_FullSystem}">MBReqDomain</anchor>    {<anchor link="MBReqDomain_Nonshareable" hover="enumeration MBReqDomain    {MBReqDomain_Nonshareable, MBReqDomain_InnerShareable,&#13; MBReqDomain_OuterShareable, MBReqDomain_FullSystem}">MBReqDomain_Nonshareable</anchor>, <anchor link="MBReqDomain_InnerShareable" hover="enumeration MBReqDomain    {MBReqDomain_Nonshareable, MBReqDomain_InnerShareable,&#13; MBReqDomain_OuterShareable, MBReqDomain_FullSystem}">MBReqDomain_InnerShareable</anchor>,
                            <anchor link="MBReqDomain_OuterShareable" hover="enumeration MBReqDomain    {MBReqDomain_Nonshareable, MBReqDomain_InnerShareable,&#13; MBReqDomain_OuterShareable, MBReqDomain_FullSystem}">MBReqDomain_OuterShareable</anchor>, <anchor link="MBReqDomain_FullSystem" hover="enumeration MBReqDomain    {MBReqDomain_Nonshareable, MBReqDomain_InnerShareable,&#13; MBReqDomain_OuterShareable, MBReqDomain_FullSystem}">MBReqDomain_FullSystem</anchor>};</pstext>
    </ps>
    <ps name="shared/functions/memory/MBReqTypes" mylink="shared.functions.memory.MBReqTypes" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="MBReqTypes" hover="enumeration MBReqTypes     {MBReqTypes_Reads, MBReqTypes_Writes, MBReqTypes_All}">MBReqTypes</anchor>     {<anchor link="MBReqTypes_Reads" hover="enumeration MBReqTypes     {MBReqTypes_Reads, MBReqTypes_Writes, MBReqTypes_All}">MBReqTypes_Reads</anchor>, <anchor link="MBReqTypes_Writes" hover="enumeration MBReqTypes     {MBReqTypes_Reads, MBReqTypes_Writes, MBReqTypes_All}">MBReqTypes_Writes</anchor>, <anchor link="MBReqTypes_All" hover="enumeration MBReqTypes     {MBReqTypes_Reads, MBReqTypes_Writes, MBReqTypes_All}">MBReqTypes_All</anchor>};</pstext>
    </ps>
    <ps name="shared/functions/memory/MPAM" mylink="shared.functions.memory.MPAM" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">type <anchor link="PARTIDtype" hover="type PARTIDtype">PARTIDtype</anchor> = bits(16);
type <anchor link="PMGtype" hover="type PMGtype">PMGtype</anchor> = bits(8);
type <anchor link="PARTIDspaceType" hover="type PARTIDspaceType">PARTIDspaceType</anchor> = bit;
constant PARTIDspaceType <anchor link="PIdSpace_Secure" hover="constant PARTIDspaceType PIdSpace_Secure = '0'">PIdSpace_Secure</anchor>    = '0';
constant PARTIDspaceType <anchor link="PIdSpace_NonSecure" hover="constant PARTIDspaceType PIdSpace_NonSecure = '1'">PIdSpace_NonSecure</anchor> = '1';

type <anchor link="MPAMinfo" hover="type MPAMinfo is ( PARTIDspaceType mpam_ns, PARTIDtype partid, PMGtype pmg )">MPAMinfo</anchor> is (
     <a link="PARTIDspaceType" file="shared_pseudocode.xml" hover="type PARTIDspaceType">PARTIDspaceType</a> mpam_ns,
     <a link="PARTIDtype" file="shared_pseudocode.xml" hover="type PARTIDtype">PARTIDtype</a> partid,
     <a link="PMGtype" file="shared_pseudocode.xml" hover="type PMGtype">PMGtype</a> pmg
)</pstext>
    </ps>
    <ps name="shared/functions/memory/MemAttrHints" mylink="shared.functions.memory.MemAttrHints" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">type <anchor link="MemAttrHints" hover="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</anchor> is (
    bits(2) attrs,  // See MemAttr_*, Cacheability attributes
    bits(2) hints,  // See MemHint_*, Allocation hints
    boolean transient
)</pstext>
    </ps>
    <ps name="shared/functions/memory/MemType" mylink="shared.functions.memory.MemType" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="MemType" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType</anchor> {<anchor link="MemType_Normal" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</anchor>, <anchor link="MemType_Device" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</anchor>};</pstext>
    </ps>
    <ps name="shared/functions/memory/MemoryAttributes" mylink="shared.functions.memory.MemoryAttributes" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">type <anchor link="MemoryAttributes" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</anchor> is (
    <a link="MemType" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType</a>      memtype,
    <a link="DeviceType" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType</a>   device,       // For Device memory types
    <a link="MemAttrHints" file="shared_pseudocode.xml" hover="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> inner,        // Inner hints and attributes
    <a link="MemAttrHints" file="shared_pseudocode.xml" hover="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> outer,        // Outer hints and attributes
    <a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, // Shareability attribute
    boolean      tagged,       // Tagged access
    bit          xs            // XS attribute
)</pstext>
    </ps>
    <ps name="shared/functions/memory/PASpace" mylink="shared.functions.memory.PASpace" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="PASpace" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PASpace</anchor> {
    <anchor link="PAS_NonSecure" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_NonSecure</anchor>,
    <anchor link="PAS_Secure" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PAS_Secure</anchor>,
};</pstext>
    </ps>
    <ps name="shared/functions/memory/Permissions" mylink="shared.functions.memory.Permissions" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">type <anchor link="Permissions" hover="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(2) s2ap, bit s2xnx, bit s2xn )">Permissions</anchor> is (
    bits(2) ap_table,   // Stage 1 hierarchical access permissions
    bit     xn_table,   // Stage 1 hierarchical execute-never for single EL regimes
    bit     pxn_table,  // Stage 1 hierarchical privileged execute-never
    bit     uxn_table,  // Stage 1 hierarchical unprivileged execute-never
    bits(3) ap,         // Stage 1 access permissions
    bit     xn,         // Stage 1 execute-never for single EL regimes
    bit     uxn,        // Stage 1 unprivileged execute-never
    bit     pxn,        // Stage 1 privileged execute-never
    bits(2) s2ap,       // Stage 2 access permissions
    bit     s2xnx,      // Stage 2 extended execute-never
    bit     s2xn        // Stage 2 execute-never
)</pstext>
    </ps>
    <ps name="shared/functions/memory/PhysMemRead" mylink="shared.functions.memory.PhysMemRead" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns the value read from memory, and a status.
// Returned value is UNKNOWN if an external abort occurred while reading the
// memory.
// Otherwise the PhysMemRetStatus statuscode is Fault_None.
(PhysMemRetStatus, bits(8*size)) <anchor link="impl-shared.PhysMemRead.3" hover="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</anchor>(<a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> desc, integer size,
                                             <a link="AccessDescriptor" file="shared_pseudocode.xml" hover="type AccessDescriptor is ( MPAMinfo mpam, AccType acctype)">AccessDescriptor</a> accdesc);</pstext>
    </ps>
    <ps name="shared/functions/memory/PhysMemRetStatus" mylink="shared.functions.memory.PhysMemRetStatus" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">type <anchor link="PhysMemRetStatus" hover="type PhysMemRetStatus is (Fault statuscode, bit extflag, bits(2) errortype, bits(64) store64bstatus, AccType acctype)">PhysMemRetStatus</anchor> is (<a link="Fault" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a>    statuscode,     // Fault Status
                          bit      extflag,        // IMPLEMENTATION DEFINED
                                                   // syndrome for External aborts
                          bits(2)  errortype,      // optional error state
                                                   // returned on a physical
                                                   // memory access
                          bits(64) store64bstatus, // status of 64B store
                          <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a>  acctype)        // Type of access that faulted</pstext>
    </ps>
    <ps name="shared/functions/memory/PhysMemWrite" mylink="shared.functions.memory.PhysMemWrite" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Writes the value to memory, and returns the status of the write.
// If there is an external abort on the write, the PhysMemRetStatus indicates this.
// Otherwise the statuscode of PhysMemRetStatus is Fault_None.
PhysMemRetStatus <anchor link="impl-shared.PhysMemWrite.4" hover="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</anchor>(<a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> desc, integer size, <a link="AccessDescriptor" file="shared_pseudocode.xml" hover="type AccessDescriptor is ( MPAMinfo mpam, AccType acctype)">AccessDescriptor</a> accdesc,
                              bits(8*size) value);</pstext>
    </ps>
    <ps name="shared/functions/memory/PrefetchHint" mylink="shared.functions.memory.PrefetchHint" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="PrefetchHint" hover="enumeration PrefetchHint {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}">PrefetchHint</anchor> {<anchor link="Prefetch_READ" hover="enumeration PrefetchHint {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}">Prefetch_READ</anchor>, <anchor link="Prefetch_WRITE" hover="enumeration PrefetchHint {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}">Prefetch_WRITE</anchor>, <anchor link="Prefetch_EXEC" hover="enumeration PrefetchHint {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}">Prefetch_EXEC</anchor>};</pstext>
    </ps>
    <ps name="shared/functions/memory/Shareability" mylink="shared.functions.memory.Shareability" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="Shareability" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</anchor> {
    <anchor link="Shareability_NSH" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</anchor>,
    <anchor link="Shareability_ISH" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_ISH</anchor>,
    <anchor link="Shareability_OSH" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</anchor>
};</pstext>
    </ps>
    <ps name="shared/functions/memory/SpeculativeStoreBypassBarrierToPA" mylink="shared.functions.memory.SpeculativeStoreBypassBarrierToPA" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions"><anchor link="impl-shared.SpeculativeStoreBypassBarrierToPA.0" hover="function: SpeculativeStoreBypassBarrierToPA()">SpeculativeStoreBypassBarrierToPA</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/memory/SpeculativeStoreBypassBarrierToVA" mylink="shared.functions.memory.SpeculativeStoreBypassBarrierToVA" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions"><anchor link="impl-shared.SpeculativeStoreBypassBarrierToVA.0" hover="function: SpeculativeStoreBypassBarrierToVA()">SpeculativeStoreBypassBarrierToVA</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/memory/Tag" mylink="shared.functions.memory.Tag" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">constant integer <anchor link="LOG2_TAG_GRANULE" hover="constant integer LOG2_TAG_GRANULE = 4">LOG2_TAG_GRANULE</anchor> = 4;

constant integer <anchor link="TAG_GRANULE" hover="constant integer TAG_GRANULE = 1 &lt;&lt; LOG2_TAG_GRANULE">TAG_GRANULE</anchor> = 1 &lt;&lt; <a link="LOG2_TAG_GRANULE" file="shared_pseudocode.xml" hover="constant integer LOG2_TAG_GRANULE = 4">LOG2_TAG_GRANULE</a>;</pstext>
    </ps>
    <ps name="shared/functions/mpam/DefaultMPAMinfo" mylink="shared.functions.mpam.DefaultMPAMinfo" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// DefaultMPAMinfo()
// =================
// Returns default MPAM info.  The partidspace argument sets
// the PARTID space of the default MPAM information returned.

MPAMinfo <anchor link="impl-shared.DefaultMPAMinfo.1" hover="function: MPAMinfo DefaultMPAMinfo(PARTIDspaceType partidspace)">DefaultMPAMinfo</anchor>(<a link="PARTIDspaceType" file="shared_pseudocode.xml" hover="type PARTIDspaceType">PARTIDspaceType</a> partidspace)
    <a link="MPAMinfo" file="shared_pseudocode.xml" hover="type MPAMinfo is ( PARTIDspaceType mpam_ns, PARTIDtype partid, PMGtype pmg )">MPAMinfo</a> DefaultInfo;
    DefaultInfo.mpam_ns = partidspace;
    DefaultInfo.partid  = <a link="DefaultPARTID" file="shared_pseudocode.xml" hover="constant PARTIDtype DefaultPARTID = 0&lt;15:0&gt;">DefaultPARTID</a>;
    DefaultInfo.pmg     = <a link="DefaultPMG" file="shared_pseudocode.xml" hover="constant PMGtype DefaultPMG = 0&lt;7:0&gt;">DefaultPMG</a>;
    return DefaultInfo;</pstext>
    </ps>
    <ps name="shared/functions/mpam/DefaultPARTID" mylink="shared.functions.mpam.DefaultPARTID" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">constant PARTIDtype <anchor link="DefaultPARTID" hover="constant PARTIDtype DefaultPARTID = 0&lt;15:0&gt;">DefaultPARTID</anchor> = 0&lt;15:0&gt;;</pstext>
    </ps>
    <ps name="shared/functions/mpam/DefaultPMG" mylink="shared.functions.mpam.DefaultPMG" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">constant PMGtype    <anchor link="DefaultPMG" hover="constant PMGtype DefaultPMG = 0&lt;7:0&gt;">DefaultPMG</anchor> = 0&lt;7:0&gt;;</pstext>
    </ps>
    <ps name="shared/functions/mpam/GenMPAMcurEL" mylink="shared.functions.mpam.GenMPAMcurEL" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// GenMPAMcurEL()
// ==============
// Returns MPAMinfo for the current EL and security state.
// May be called if MPAM is not implemented (but in an version that supports
// MPAM), MPAM is disabled, or in AArch32.  In AArch32, convert the mode to
// EL if can and use that to drive MPAM information generation.  If mode
// cannot be converted, MPAM is not implemented, or MPAM is disabled return
// default MPAM information for the current security state.

MPAMinfo <anchor link="impl-shared.GenMPAMcurEL.1" hover="function: MPAMinfo GenMPAMcurEL(AccType acctype)">GenMPAMcurEL</anchor>(<a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype)
    bits(2) mpamEL;
    boolean validEL = FALSE;
    <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> security = if <a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>() then <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> else <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a>;
    boolean InD = FALSE;
    <a link="PARTIDspaceType" file="shared_pseudocode.xml" hover="type PARTIDspaceType">PARTIDspaceType</a> pspace = <a link="impl-shared.PARTIDspaceFromSS.1" file="shared_pseudocode.xml" hover="function: PARTIDspaceType PARTIDspaceFromSS(SecurityState security)">PARTIDspaceFromSS</a>(security);
    if pspace == <a link="PIdSpace_NonSecure" file="shared_pseudocode.xml" hover="constant PARTIDspaceType PIdSpace_NonSecure = '1'">PIdSpace_NonSecure</a> &amp;&amp; !<a link="impl-shared.MPAMisEnabled.0" file="shared_pseudocode.xml" hover="function: boolean MPAMisEnabled()">MPAMisEnabled</a>() then
        return <a link="impl-shared.DefaultMPAMinfo.1" file="shared_pseudocode.xml" hover="function: MPAMinfo DefaultMPAMinfo(PARTIDspaceType partidspace)">DefaultMPAMinfo</a>(pspace);
    if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
        (validEL, mpamEL) = <a link="impl-shared.ELFromM32.1" file="shared_pseudocode.xml" hover="function: (boolean,bits(2)) ELFromM32(bits(5) mode)">ELFromM32</a>(PSTATE.M);
    else
        mpamEL = if acctype == <a link="AccType_NV2REGISTER" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NV2REGISTER</a> then <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> else PSTATE.EL;
        validEL = TRUE;
    case acctype of
        when <a link="AccType_IFETCH" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a>, <a link="AccType_IC" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>
            InD = TRUE;
        otherwise
            // Other access types are DATA accesses
            InD = FALSE;
    if !validEL then
        return <a link="impl-shared.DefaultMPAMinfo.1" file="shared_pseudocode.xml" hover="function: MPAMinfo DefaultMPAMinfo(PARTIDspaceType partidspace)">DefaultMPAMinfo</a>(pspace);
    if <a link="impl-shared.HaveEMPAMExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveEMPAMExt()">HaveEMPAMExt</a>() &amp;&amp; security == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> then
        if MPAM3_EL3.FORCE_NS == '1' then
            pspace = <a link="PIdSpace_NonSecure" file="shared_pseudocode.xml" hover="constant PARTIDspaceType PIdSpace_NonSecure = '1'">PIdSpace_NonSecure</a>;
        if MPAM3_EL3.SDEFLT == '1' then
            return <a link="impl-shared.DefaultMPAMinfo.1" file="shared_pseudocode.xml" hover="function: MPAMinfo DefaultMPAMinfo(PARTIDspaceType partidspace)">DefaultMPAMinfo</a>(pspace);
    if !<a link="impl-shared.MPAMisEnabled.0" file="shared_pseudocode.xml" hover="function: boolean MPAMisEnabled()">MPAMisEnabled</a>() then
        return <a link="impl-shared.DefaultMPAMinfo.1" file="shared_pseudocode.xml" hover="function: MPAMinfo DefaultMPAMinfo(PARTIDspaceType partidspace)">DefaultMPAMinfo</a>(pspace);
    else
        return <a link="impl-shared.genMPAM.3" file="shared_pseudocode.xml" hover="function: MPAMinfo genMPAM(bits(2) el, boolean InD, PARTIDspaceType pspace)">genMPAM</a>(mpamEL, InD, pspace);</pstext>
    </ps>
    <ps name="shared/functions/mpam/MAP_vPARTID" mylink="shared.functions.mpam.MAP_vPARTID" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// MAP_vPARTID()
// =============
// Performs conversion of virtual PARTID into physical PARTID
// Contains all of the error checking and implementation
// choices for the conversion.

(PARTIDtype, boolean) <anchor link="impl-shared.MAP_vPARTID.1" hover="function: (PARTIDtype, boolean) MAP_vPARTID(PARTIDtype vpartid)">MAP_vPARTID</anchor>(<a link="PARTIDtype" file="shared_pseudocode.xml" hover="type PARTIDtype">PARTIDtype</a> vpartid)
    // should not ever be called if EL2 is not implemented
    // or is implemented but not enabled in the current
    // security state.
    <a link="PARTIDtype" file="shared_pseudocode.xml" hover="type PARTIDtype">PARTIDtype</a> ret;
    boolean err;
    integer virt    = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(vpartid);
    integer vpmrmax = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(MPAMIDR_EL1.VPMR_MAX);

    // vpartid_max is largest vpartid supported
    integer vpartid_max = (vpmrmax &lt;&lt; 2) + 3;

    // One of many ways to reduce vpartid to value less than vpartid_max.
    if <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(vpartid) &gt; vpartid_max then
        virt = virt MOD (vpartid_max+1);

    // Check for valid mapping entry.
    if MPAMVPMV_EL2&lt;virt&gt; == '1' then
        // vpartid has a valid mapping so access the map.
        ret = <a link="impl-shared.mapvpmw.1" file="shared_pseudocode.xml" hover="function: PARTIDtype mapvpmw(integer vpartid)">mapvpmw</a>(virt);
        err = FALSE;

    // Is the default virtual PARTID valid?
    elsif MPAMVPMV_EL2&lt;0&gt; == '1' then
        // Yes, so use default mapping for vpartid == 0.
        ret = MPAMVPM0_EL2&lt;0 +: 16&gt;;
        err = FALSE;

    // Neither is valid so use default physical PARTID.
    else
        ret = <a link="DefaultPARTID" file="shared_pseudocode.xml" hover="constant PARTIDtype DefaultPARTID = 0&lt;15:0&gt;">DefaultPARTID</a>;
        err = TRUE;

    // Check that the physical PARTID is in-range.
    // This physical PARTID came from a virtual mapping entry.
    integer partid_max = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(MPAMIDR_EL1.PARTID_MAX);
    if <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(ret) &gt; partid_max then
        // Out of range, so return default physical PARTID
        ret = <a link="DefaultPARTID" file="shared_pseudocode.xml" hover="constant PARTIDtype DefaultPARTID = 0&lt;15:0&gt;">DefaultPARTID</a>;
        err = TRUE;
    return (ret, err);</pstext>
    </ps>
    <ps name="shared/functions/mpam/MPAMisEnabled" mylink="shared.functions.mpam.MPAMisEnabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// MPAMisEnabled()
// ===============
// Returns TRUE if MPAMisEnabled.

boolean <anchor link="impl-shared.MPAMisEnabled.0" hover="function: boolean MPAMisEnabled()">MPAMisEnabled</anchor>()
    el = <a link="impl-shared.HighestEL.0" file="shared_pseudocode.xml" hover="function: bits(2) HighestEL()">HighestEL</a>();
    case el of
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> return MPAM3_EL3.MPAMEN == '1';
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> return MPAM2_EL2.MPAMEN == '1';
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> return MPAM1_EL1.MPAMEN == '1';</pstext>
    </ps>
    <ps name="shared/functions/mpam/MPAMisVirtual" mylink="shared.functions.mpam.MPAMisVirtual" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// MPAMisVirtual()
// ===============
// Returns TRUE if MPAM is configured to be virtual at EL.

boolean <anchor link="impl-shared.MPAMisVirtual.1" hover="function: boolean MPAMisVirtual(bits(2) el)">MPAMisVirtual</anchor>(bits(2) el)
    return (MPAMIDR_EL1.HAS_HCR == '1' &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
            ((el == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; MPAMHCR_EL2.EL0_VPMEN == '1' &amp;&amp;
               (HCR_EL2.E2H == '0' || HCR_EL2.TGE == '0')) ||
             (el == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; MPAMHCR_EL2.EL1_VPMEN == '1')));</pstext>
    </ps>
    <ps name="shared/functions/mpam/PARTIDspaceFromSS" mylink="shared.functions.mpam.PARTIDspaceFromSS" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// PARTIDspaceFromSS()
// ===================
// Returns the primary PARTID space from the Security State.

PARTIDspaceType <anchor link="impl-shared.PARTIDspaceFromSS.1" hover="function: PARTIDspaceType PARTIDspaceFromSS(SecurityState security)">PARTIDspaceFromSS</anchor>(<a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> security)
    case security of
        when <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a>
            return <a link="PIdSpace_NonSecure" file="shared_pseudocode.xml" hover="constant PARTIDspaceType PIdSpace_NonSecure = '1'">PIdSpace_NonSecure</a>;
        when <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>
            return <a link="PIdSpace_Secure" file="shared_pseudocode.xml" hover="constant PARTIDspaceType PIdSpace_Secure = '0'">PIdSpace_Secure</a>;
        otherwise
            <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();</pstext>
    </ps>
    <ps name="shared/functions/mpam/genMPAM" mylink="shared.functions.mpam.genMPAM" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// genMPAM()
// =========
// Returns MPAMinfo for exception level el.
// If InD is TRUE returns MPAM information using PARTID_I and PMG_I fields
// of MPAMel_ELx register and otherwise using PARTID_D and PMG_D fields.
// Produces a PARTID in PARTID space pspace.

MPAMinfo <anchor link="impl-shared.genMPAM.3" hover="function: MPAMinfo genMPAM(bits(2) el, boolean InD, PARTIDspaceType pspace)">genMPAM</anchor>(bits(2) el, boolean InD, <a link="PARTIDspaceType" file="shared_pseudocode.xml" hover="type PARTIDspaceType">PARTIDspaceType</a> pspace)
    <a link="MPAMinfo" file="shared_pseudocode.xml" hover="type MPAMinfo is ( PARTIDspaceType mpam_ns, PARTIDtype partid, PMGtype pmg )">MPAMinfo</a> returninfo;
    <a link="PARTIDtype" file="shared_pseudocode.xml" hover="type PARTIDtype">PARTIDtype</a> partidel;
    boolean perr;
    // gstplk is guest OS application locked by the EL2 hypervisor to
    // only use EL1 the virtual machine's PARTIDs.
    boolean gstplk = (el == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                      MPAMHCR_EL2.GSTAPP_PLK == '1' &amp;&amp;
                      HCR_EL2.TGE == '0');
    bits(2) eff_el = if gstplk then <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> else el;
    (partidel, perr) = <a link="impl-shared.genPARTID.2" file="shared_pseudocode.xml" hover="function: (PARTIDtype, boolean) genPARTID(bits(2) el, boolean InD)">genPARTID</a>(eff_el, InD);
    <a link="PMGtype" file="shared_pseudocode.xml" hover="type PMGtype">PMGtype</a> groupel  = <a link="impl-shared.genPMG.3" file="shared_pseudocode.xml" hover="function: PMGtype genPMG(bits(2) el, boolean InD, boolean partid_err)">genPMG</a>(eff_el, InD, perr);
    returninfo.mpam_ns = pspace;
    returninfo.partid  = partidel;
    returninfo.pmg     = groupel;
    return returninfo;</pstext>
    </ps>
    <ps name="shared/functions/mpam/genMPAMel" mylink="shared.functions.mpam.genMPAMel" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// genMPAMel()
// ===========
// Returns MPAMinfo for specified EL in the current security state.
// InD is TRUE for instruction access and FALSE otherwise.

MPAMinfo <anchor link="impl-shared.genMPAMel.2" hover="function: MPAMinfo genMPAMel(bits(2) el, boolean InD)">genMPAMel</anchor>(bits(2) el, boolean InD)
    <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> security = <a link="impl-shared.SecurityStateAtEL.1" file="shared_pseudocode.xml" hover="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(el);
    <a link="PARTIDspaceType" file="shared_pseudocode.xml" hover="type PARTIDspaceType">PARTIDspaceType</a> space = <a link="impl-shared.PARTIDspaceFromSS.1" file="shared_pseudocode.xml" hover="function: PARTIDspaceType PARTIDspaceFromSS(SecurityState security)">PARTIDspaceFromSS</a>(security);
    boolean use_default = !(<a link="impl-shared.HaveMPAMExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveMPAMExt()">HaveMPAMExt</a>() &amp;&amp; <a link="impl-shared.MPAMisEnabled.0" file="shared_pseudocode.xml" hover="function: boolean MPAMisEnabled()">MPAMisEnabled</a>());
    if <a link="impl-shared.HaveEMPAMExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveEMPAMExt()">HaveEMPAMExt</a>() &amp;&amp; security == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> then
        if MPAM3_EL3.FORCE_NS == '1' then
            space = <a link="PIdSpace_NonSecure" file="shared_pseudocode.xml" hover="constant PARTIDspaceType PIdSpace_NonSecure = '1'">PIdSpace_NonSecure</a>;
        if MPAM3_EL3.SDEFLT == '1' then
            use_default = TRUE;
    if !use_default then
        return <a link="impl-shared.genMPAM.3" file="shared_pseudocode.xml" hover="function: MPAMinfo genMPAM(bits(2) el, boolean InD, PARTIDspaceType pspace)">genMPAM</a>(el, InD, space);
    else
        return <a link="impl-shared.DefaultMPAMinfo.1" file="shared_pseudocode.xml" hover="function: MPAMinfo DefaultMPAMinfo(PARTIDspaceType partidspace)">DefaultMPAMinfo</a>(space);</pstext>
    </ps>
    <ps name="shared/functions/mpam/genPARTID" mylink="shared.functions.mpam.genPARTID" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// genPARTID()
// ===========
// Returns physical PARTID and error boolean for exception level el.
// If InD is TRUE then PARTID is from MPAMel_ELx.PARTID_I and
// otherwise from MPAMel_ELx.PARTID_D.

(PARTIDtype, boolean) <anchor link="impl-shared.genPARTID.2" hover="function: (PARTIDtype, boolean) genPARTID(bits(2) el, boolean InD)">genPARTID</anchor>(bits(2) el, boolean InD)
    <a link="PARTIDtype" file="shared_pseudocode.xml" hover="type PARTIDtype">PARTIDtype</a> partidel = <a link="impl-shared.getMPAM_PARTID.2" file="shared_pseudocode.xml" hover="function: PARTIDtype getMPAM_PARTID(bits(2) MPAMn, boolean InD)">getMPAM_PARTID</a>(el, InD);
    <a link="PARTIDtype" file="shared_pseudocode.xml" hover="type PARTIDtype">PARTIDtype</a> partid_max = MPAMIDR_EL1.PARTID_MAX;
    if <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(partidel) &gt; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(partid_max) then
        return (<a link="DefaultPARTID" file="shared_pseudocode.xml" hover="constant PARTIDtype DefaultPARTID = 0&lt;15:0&gt;">DefaultPARTID</a>, TRUE);
    if <a link="impl-shared.MPAMisVirtual.1" file="shared_pseudocode.xml" hover="function: boolean MPAMisVirtual(bits(2) el)">MPAMisVirtual</a>(el) then
        return <a link="impl-shared.MAP_vPARTID.1" file="shared_pseudocode.xml" hover="function: (PARTIDtype, boolean) MAP_vPARTID(PARTIDtype vpartid)">MAP_vPARTID</a>(partidel);
    else
        return (partidel, FALSE);</pstext>
    </ps>
    <ps name="shared/functions/mpam/genPMG" mylink="shared.functions.mpam.genPMG" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// genPMG()
// ========
// Returns PMG for exception level el and I- or D-side (InD).
// If PARTID generation (genPARTID) encountered an error, genPMG() should be
// called with partid_err as TRUE.

PMGtype <anchor link="impl-shared.genPMG.3" hover="function: PMGtype genPMG(bits(2) el, boolean InD, boolean partid_err)">genPMG</anchor>(bits(2) el, boolean InD, boolean partid_err)
    integer pmg_max = <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(MPAMIDR_EL1.PMG_MAX);
    // It is CONSTRAINED UNPREDICTABLE whether partid_err forces PMG to
    // use the default or if it uses the PMG from getMPAM_PMG.
    if partid_err then
        return <a link="DefaultPMG" file="shared_pseudocode.xml" hover="constant PMGtype DefaultPMG = 0&lt;7:0&gt;">DefaultPMG</a>;
    <a link="PMGtype" file="shared_pseudocode.xml" hover="type PMGtype">PMGtype</a> groupel = <a link="impl-shared.getMPAM_PMG.2" file="shared_pseudocode.xml" hover="function: PMGtype getMPAM_PMG(bits(2) MPAMn, boolean InD)">getMPAM_PMG</a>(el, InD);
    if <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(groupel) &lt;= pmg_max then
        return groupel;
    return <a link="DefaultPMG" file="shared_pseudocode.xml" hover="constant PMGtype DefaultPMG = 0&lt;7:0&gt;">DefaultPMG</a>;</pstext>
    </ps>
    <ps name="shared/functions/mpam/getMPAM_PARTID" mylink="shared.functions.mpam.getMPAM_PARTID" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// getMPAM_PARTID()
// ================
// Returns a PARTID from one of the MPAMn_ELx registers.
// MPAMn selects the MPAMn_ELx register used.
// If InD is TRUE, selects the PARTID_I field of that
// register.  Otherwise, selects the PARTID_D field.

PARTIDtype <anchor link="impl-shared.getMPAM_PARTID.2" hover="function: PARTIDtype getMPAM_PARTID(bits(2) MPAMn, boolean InD)">getMPAM_PARTID</anchor>(bits(2) MPAMn, boolean InD)
    <a link="PARTIDtype" file="shared_pseudocode.xml" hover="type PARTIDtype">PARTIDtype</a> partid;
    boolean el2avail = <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>();

    if InD then
        case MPAMn of
            when '11' partid = MPAM3_EL3.PARTID_I;
            when '10' partid = if el2avail then MPAM2_EL2.PARTID_I else <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();
            when '01' partid = MPAM1_EL1.PARTID_I;
            when '00' partid = MPAM0_EL1.PARTID_I;
            otherwise partid = <a link="PARTIDtype" file="shared_pseudocode.xml" hover="type PARTIDtype">PARTIDtype</a> UNKNOWN;
    else
        case MPAMn of
            when '11' partid = MPAM3_EL3.PARTID_D;
            when '10' partid = if el2avail then MPAM2_EL2.PARTID_D else <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();
            when '01' partid = MPAM1_EL1.PARTID_D;
            when '00' partid = MPAM0_EL1.PARTID_D;
            otherwise partid = <a link="PARTIDtype" file="shared_pseudocode.xml" hover="type PARTIDtype">PARTIDtype</a> UNKNOWN;
    return partid;</pstext>
    </ps>
    <ps name="shared/functions/mpam/getMPAM_PMG" mylink="shared.functions.mpam.getMPAM_PMG" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// getMPAM_PMG()
// =============
// Returns a PMG from one of the MPAMn_ELx registers.
// MPAMn selects the MPAMn_ELx register used.
// If InD is TRUE, selects the PMG_I field of that
// register.  Otherwise, selects the PMG_D field.

PMGtype <anchor link="impl-shared.getMPAM_PMG.2" hover="function: PMGtype getMPAM_PMG(bits(2) MPAMn, boolean InD)">getMPAM_PMG</anchor>(bits(2) MPAMn, boolean InD)
    <a link="PMGtype" file="shared_pseudocode.xml" hover="type PMGtype">PMGtype</a> pmg;
    boolean el2avail = <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>();

    if InD then
        case MPAMn of
            when '11' pmg = MPAM3_EL3.PMG_I;
            when '10' pmg = if el2avail then MPAM2_EL2.PMG_I else <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();
            when '01' pmg = MPAM1_EL1.PMG_I;
            when '00' pmg = MPAM0_EL1.PMG_I;
            otherwise pmg = <a link="PMGtype" file="shared_pseudocode.xml" hover="type PMGtype">PMGtype</a> UNKNOWN;
    else
        case MPAMn of
            when '11' pmg = MPAM3_EL3.PMG_D;
            when '10' pmg = if el2avail then MPAM2_EL2.PMG_D else <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();
            when '01' pmg = MPAM1_EL1.PMG_D;
            when '00' pmg = MPAM0_EL1.PMG_D;
            otherwise pmg = <a link="PMGtype" file="shared_pseudocode.xml" hover="type PMGtype">PMGtype</a> UNKNOWN;
    return pmg;</pstext>
    </ps>
    <ps name="shared/functions/mpam/mapvpmw" mylink="shared.functions.mpam.mapvpmw" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// mapvpmw()
// =========
// Map a virtual PARTID into a physical PARTID using
// the MPAMVPMn_EL2 registers.
// vpartid is now assumed in-range and valid (checked by caller)
// returns physical PARTID from mapping entry.

PARTIDtype <anchor link="impl-shared.mapvpmw.1" hover="function: PARTIDtype mapvpmw(integer vpartid)">mapvpmw</anchor>(integer vpartid)
    bits(64) vpmw;
    integer  wd = vpartid DIV 4;
    case wd of
        when 0 vpmw = MPAMVPM0_EL2;
        when 1 vpmw = MPAMVPM1_EL2;
        when 2 vpmw = MPAMVPM2_EL2;
        when 3 vpmw = MPAMVPM3_EL2;
        when 4 vpmw = MPAMVPM4_EL2;
        when 5 vpmw = MPAMVPM5_EL2;
        when 6 vpmw = MPAMVPM6_EL2;
        when 7 vpmw = MPAMVPM7_EL2;
        otherwise vpmw = <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(64);
    // vpme_lsb selects LSB of field within register
    integer vpme_lsb = (vpartid MOD 4) * 16;
    return vpmw&lt;vpme_lsb +: 16&gt;;</pstext>
    </ps>
    <ps name="shared/functions/predictionrestrict/ASID" mylink="shared.functions.predictionrestrict.ASID" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ASID[]
// ======
// Effective ASID.

bits(16) <anchor link="impl-shared.ASID.read.0" hover="accessor: bits(16) ASID[]">ASID</anchor>[]
    if <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR_EL2.&lt;E2H, TGE&gt; == '11' then
        if TCR_EL2.A1 == '1' then
            return TTBR1_EL2.ASID;
        else
            return TTBR0_EL2.ASID;

    elsif !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then
        if TCR_EL1.A1 == '1' then
            return TTBR1_EL1.ASID;
        else
            return TTBR0_EL1.ASID;

    else
        if TTBCR.EAE == '0' then
            return <a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(CONTEXTIDR.ASID, 16);
        else
            if TTBCR.A1 == '1' then
                return <a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(TTBR1.ASID, 16);
            else
                return <a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(TTBR0.ASID, 16);</pstext>
    </ps>
    <ps name="shared/functions/predictionrestrict/ExecutionCntxt" mylink="shared.functions.predictionrestrict.ExecutionCntxt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">type <anchor link="ExecutionCntxt" hover="type ExecutionCntxt is ( boolean is_vmid_valid, boolean all_vmid, bits(16) vmid, boolean is_asid_valid, boolean all_asid, bits(16) asid, bits(2) target_el, SecurityState security, RestrictType restriction )">ExecutionCntxt</anchor> is (
    boolean          is_vmid_valid, // is vmid valid for current context
    boolean          all_vmid,      // should the operation be applied for all vmids
    bits(16)         vmid,          // if all_vmid = FALSE, vmid to which operation is applied
    boolean          is_asid_valid, // is asid valid for current context
    boolean          all_asid,      // should the operation be applied for all asids
    bits(16)         asid,          // if all_asid = FALSE, ASID to which operation is applied
    bits(2)          target_el,     // target EL at which operation is performed
    <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a>    security,
    <a link="RestrictType" file="shared_pseudocode.xml" hover="enumeration RestrictType {&#13; RestrictType_DataValue,&#13; RestrictType_ControlFlow,&#13; RestrictType_CachePrefetch&#13; }">RestrictType</a>     restriction    // type of restriction operation
)</pstext>
    </ps>
    <ps name="shared/functions/predictionrestrict/RESTRICT_PREDICTIONS" mylink="shared.functions.predictionrestrict.RESTRICT_PREDICTIONS" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// RESTRICT_PREDICTIONS()
// ======================
// Clear all speculated values.

<anchor link="impl-shared.RESTRICT_PREDICTIONS.1" hover="function: RESTRICT_PREDICTIONS(ExecutionCntxt c)">RESTRICT_PREDICTIONS</anchor>(<a link="ExecutionCntxt" file="shared_pseudocode.xml" hover="type ExecutionCntxt is ( boolean is_vmid_valid, boolean all_vmid, bits(16) vmid, boolean is_asid_valid, boolean all_asid, bits(16) asid, bits(2) target_el, SecurityState security, RestrictType restriction )">ExecutionCntxt</a> c)
    IMPLEMENTATION_DEFINED;</pstext>
    </ps>
    <ps name="shared/functions/predictionrestrict/RestrictType" mylink="shared.functions.predictionrestrict.RestrictType" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="RestrictType" hover="enumeration RestrictType {&#13; RestrictType_DataValue,&#13; RestrictType_ControlFlow,&#13; RestrictType_CachePrefetch&#13; }">RestrictType</anchor> {
    <anchor link="RestrictType_DataValue" hover="enumeration RestrictType {&#13; RestrictType_DataValue,&#13; RestrictType_ControlFlow,&#13; RestrictType_CachePrefetch&#13; }">RestrictType_DataValue</anchor>,
    <anchor link="RestrictType_ControlFlow" hover="enumeration RestrictType {&#13; RestrictType_DataValue,&#13; RestrictType_ControlFlow,&#13; RestrictType_CachePrefetch&#13; }">RestrictType_ControlFlow</anchor>,
    <anchor link="RestrictType_CachePrefetch" hover="enumeration RestrictType {&#13; RestrictType_DataValue,&#13; RestrictType_ControlFlow,&#13; RestrictType_CachePrefetch&#13; }">RestrictType_CachePrefetch</anchor>
};</pstext>
    </ps>
    <ps name="shared/functions/predictionrestrict/TargetSecurityState" mylink="shared.functions.predictionrestrict.TargetSecurityState" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// TargetSecurityState()
// =====================
// Decode the target security state for the prediction context.

SecurityState <anchor link="impl-shared.TargetSecurityState.1" hover="function: SecurityState TargetSecurityState(bit NS)">TargetSecurityState</anchor>(bit NS)
    curr_ss =  <a link="impl-shared.SecurityStateAtEL.1" file="shared_pseudocode.xml" hover="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(PSTATE.EL);
    if curr_ss == <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a> then
        return <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a>;
    elsif curr_ss == <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a> then
        case NS of
            when '0' return <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>;
            when '1' return <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a>;</pstext>
    </ps>
    <ps name="shared/functions/registers/BranchTo" mylink="shared.functions.registers.BranchTo" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// BranchTo()
// ==========
// Set program counter to a new address, with a branch type.
// Parameter branch_conditional indicates whether the executed branch has a conditional encoding.
// In AArch64 state the address might include a tag in the top eight bits.

<anchor link="impl-shared.BranchTo.3" hover="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</anchor>(bits(N) target, <a link="BranchType" file="shared_pseudocode.xml" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType</a> branch_type, boolean branch_conditional)
    <a link="impl-shared.Hint_Branch.1" file="shared_pseudocode.xml" hover="function: Hint_Branch(BranchType hint)">Hint_Branch</a>(branch_type);
    if N == 32 then
        assert <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>();
        _PC = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(target);
    else
        assert N == 64 &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>();
        bits(64) target_vaddress = <a link="AArch64.BranchAddr.1" file="shared_pseudocode.xml" hover="function: bits(64) AArch64.BranchAddr(bits(64) vaddress)">AArch64.BranchAddr</a>(target&lt;63:0&gt;);
        _PC = target_vaddress;
    return;</pstext>
    </ps>
    <ps name="shared/functions/registers/BranchToAddr" mylink="shared.functions.registers.BranchToAddr" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// BranchToAddr()
// ==============
// Set program counter to a new address, with a branch type.
// In AArch64 state the address does not include a tag in the top eight bits.

<anchor link="impl-shared.BranchToAddr.2" hover="function: BranchToAddr(bits(N) target, BranchType branch_type)">BranchToAddr</anchor>(bits(N) target, <a link="BranchType" file="shared_pseudocode.xml" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType</a> branch_type)
    <a link="impl-shared.Hint_Branch.1" file="shared_pseudocode.xml" hover="function: Hint_Branch(BranchType hint)">Hint_Branch</a>(branch_type);
    if N == 32 then
        assert <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>();
        _PC = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(target);
    else
        assert N == 64 &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>();
        _PC = target&lt;63:0&gt;;
    return;</pstext>
    </ps>
    <ps name="shared/functions/registers/BranchType" mylink="shared.functions.registers.BranchType" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="BranchType" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType</anchor> {
    <anchor link="BranchType_DIRCALL" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType_DIRCALL</anchor>,     // Direct Branch with link
    <anchor link="BranchType_INDCALL" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType_INDCALL</anchor>,     // Indirect Branch with link
    <anchor link="BranchType_ERET" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType_ERET</anchor>,        // Exception return (indirect)
    <anchor link="BranchType_DBGEXIT" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType_DBGEXIT</anchor>,     // Exit from Debug state
    <anchor link="BranchType_RET" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType_RET</anchor>,         // Indirect branch with function return hint
    <anchor link="BranchType_DIR" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType_DIR</anchor>,         // Direct branch
    <anchor link="BranchType_INDIR" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType_INDIR</anchor>,       // Indirect branch
    <anchor link="BranchType_EXCEPTION" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType_EXCEPTION</anchor>,   // Exception entry
    <anchor link="BranchType_RESET" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType_RESET</anchor>,       // Reset
    <anchor link="BranchType_UNKNOWN" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType_UNKNOWN</anchor>};    // Other</pstext>
    </ps>
    <ps name="shared/functions/registers/Hint_Branch" mylink="shared.functions.registers.Hint_Branch" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Report the hint passed to BranchTo() and BranchToAddr(), for consideration when processing
// the next instruction.
<anchor link="impl-shared.Hint_Branch.1" hover="function: Hint_Branch(BranchType hint)">Hint_Branch</anchor>(<a link="BranchType" file="shared_pseudocode.xml" hover="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType</a> hint);</pstext>
    </ps>
    <ps name="shared/functions/registers/NextInstrAddr" mylink="shared.functions.registers.NextInstrAddr" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Return address of the sequentially next instruction.
bits(N) <anchor link="impl-shared.NextInstrAddr.0" hover="function: bits(N) NextInstrAddr()">NextInstrAddr</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/registers/ResetExternalDebugRegisters" mylink="shared.functions.registers.ResetExternalDebugRegisters" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Reset the External Debug registers in the Core power domain.
<anchor link="impl-shared.ResetExternalDebugRegisters.1" hover="function: ResetExternalDebugRegisters(boolean cold_reset)">ResetExternalDebugRegisters</anchor>(boolean cold_reset);</pstext>
    </ps>
    <ps name="shared/functions/registers/ThisInstrAddr" mylink="shared.functions.registers.ThisInstrAddr" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ThisInstrAddr()
// ===============
// Return address of the current instruction.

bits(N) <anchor link="impl-shared.ThisInstrAddr.0" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</anchor>()
    assert N == 64 || (N == 32 &amp;&amp; <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>());
    return _PC&lt;N-1:0&gt;;</pstext>
    </ps>
    <ps name="shared/functions/registers/_PC" mylink="shared.functions.registers._PC" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">bits(64) _PC;</pstext>
    </ps>
    <ps name="shared/functions/registers/_R" mylink="shared.functions.registers._R" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">array bits(64) _R[0..30];</pstext>
    </ps>
    <ps name="shared/functions/registers/_V" mylink="shared.functions.registers._V" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">array bits(128) _V[0..31];</pstext>
    </ps>
    <ps name="shared/functions/sysregisters/SPSR" mylink="shared.functions.sysregisters.SPSR" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SPSR[] - non-assignment form
// ============================

bits(N) <anchor link="impl-shared.SPSR.read.0" hover="accessor: bits(N) SPSR[]">SPSR</anchor>[]
    bits(N) result;
    if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
        assert N == 32;
        case PSTATE.M of
            when <a link="M32_FIQ" file="shared_pseudocode.xml" hover="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>      result = SPSR_fiq&lt;N-1:0&gt;;
            when <a link="M32_IRQ" file="shared_pseudocode.xml" hover="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>      result = SPSR_irq&lt;N-1:0&gt;;
            when <a link="M32_Svc" file="shared_pseudocode.xml" hover="constant bits(5) M32_Svc = '10011'">M32_Svc</a>      result = SPSR_svc&lt;N-1:0&gt;;
            when <a link="M32_Monitor" file="shared_pseudocode.xml" hover="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>  result = SPSR_mon&lt;N-1:0&gt;;
            when <a link="M32_Abort" file="shared_pseudocode.xml" hover="constant bits(5) M32_Abort = '10111'">M32_Abort</a>    result = SPSR_abt&lt;N-1:0&gt;;
            when <a link="M32_Hyp" file="shared_pseudocode.xml" hover="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>      result = SPSR_hyp&lt;N-1:0&gt;;
            when <a link="M32_Undef" file="shared_pseudocode.xml" hover="constant bits(5) M32_Undef = '11011'">M32_Undef</a>    result = SPSR_und&lt;N-1:0&gt;;
            otherwise         <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();
    else
        assert N == 64;
        case PSTATE.EL of
            when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>          result = SPSR_EL1&lt;N-1:0&gt;;
            when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>          result = SPSR_EL2&lt;N-1:0&gt;;
            when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>          result = SPSR_EL3&lt;N-1:0&gt;;
            otherwise         <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();
    return result;

// SPSR[] - assignment form
// ========================

<anchor link="impl-shared.SPSR.write.0" hover="accessor: SPSR[] = bits(N) value">SPSR</anchor>[] = bits(N) value
    if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
        assert N == 32;
        case PSTATE.M of
            when <a link="M32_FIQ" file="shared_pseudocode.xml" hover="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>      SPSR_fiq = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
            when <a link="M32_IRQ" file="shared_pseudocode.xml" hover="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>      SPSR_irq = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
            when <a link="M32_Svc" file="shared_pseudocode.xml" hover="constant bits(5) M32_Svc = '10011'">M32_Svc</a>      SPSR_svc = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
            when <a link="M32_Monitor" file="shared_pseudocode.xml" hover="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>  SPSR_mon = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
            when <a link="M32_Abort" file="shared_pseudocode.xml" hover="constant bits(5) M32_Abort = '10111'">M32_Abort</a>    SPSR_abt = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
            when <a link="M32_Hyp" file="shared_pseudocode.xml" hover="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>      SPSR_hyp = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
            when <a link="M32_Undef" file="shared_pseudocode.xml" hover="constant bits(5) M32_Undef = '11011'">M32_Undef</a>    SPSR_und = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
            otherwise         <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();
    else
        assert N == 64;
        case PSTATE.EL of
            when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>          SPSR_EL1 = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
            when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>          SPSR_EL2 = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
            when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>          SPSR_EL3 = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
            otherwise         <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();
    return;</pstext>
    </ps>
    <ps name="shared/functions/system/ArchVersion" mylink="shared.functions.system.ArchVersion" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="ArchVersion" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ArchVersion</anchor> {
    <anchor link="ARMv8p0" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p0</anchor>
    , <anchor link="ARMv8p1" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p1</anchor>
    , <anchor link="ARMv8p2" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</anchor>
    , <anchor link="ARMv8p3" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p3</anchor>
    , <anchor link="ARMv8p4" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</anchor>
    , <anchor link="ARMv8p5" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p5</anchor>
    , <anchor link="ARMv8p6" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p6</anchor>
    , <anchor link="ARMv8p7" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p7</anchor>
    , <anchor link="ARMv8p8" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p8</anchor>
};</pstext>
    </ps>
    <ps name="shared/functions/system/BranchTargetCheck" mylink="shared.functions.system.BranchTargetCheck" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// BranchTargetCheck()
// ===================
// This function is executed checks if the current instruction is a valid target for a branch
// taken into, or inside, a guarded page. It is executed on every cycle once the current
// instruction has been decoded and the values of InGuardedPage and BTypeCompatible have been
// determined for the current instruction.

<anchor link="impl-shared.BranchTargetCheck.0" hover="function: BranchTargetCheck()">BranchTargetCheck</anchor>()
    assert <a link="impl-shared.HaveBTIExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveBTIExt()">HaveBTIExt</a>() &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>();

    // The branch target check considers two state variables:
    // * InGuardedPage, which is evaluated during instruction fetch.
    // * BTypeCompatible, which is evaluated during instruction decode.
    if InGuardedPage &amp;&amp; PSTATE.BTYPE != '00' &amp;&amp; !BTypeCompatible &amp;&amp; !<a link="impl-shared.Halted.0" file="shared_pseudocode.xml" hover="function: boolean Halted()">Halted</a>() then
        bits(64) pc = <a link="impl-shared.ThisInstrAddr.0" file="shared_pseudocode.xml" hover="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
        <a link="AArch64.BranchTargetException.1" file="shared_pseudocode.xml" hover="function: AArch64.BranchTargetException(bits(52) vaddress)">AArch64.BranchTargetException</a>(pc&lt;51:0&gt;);

    boolean branch_instr = <a link="AArch64.ExecutingBROrBLROrRetInstr.0" file="shared_pseudocode.xml" hover="function: boolean AArch64.ExecutingBROrBLROrRetInstr()">AArch64.ExecutingBROrBLROrRetInstr</a>();
    boolean bti_instr    = <a link="AArch64.ExecutingBTIInstr.0" file="shared_pseudocode.xml" hover="function: boolean AArch64.ExecutingBTIInstr()">AArch64.ExecutingBTIInstr</a>();

    // PSTATE.BTYPE defaults to 00 for instructions that do not explictly set BTYPE.
    if !(branch_instr || bti_instr) then
        BTypeNext = '00';</pstext>
    </ps>
    <ps name="shared/functions/system/ClearEventRegister" mylink="shared.functions.system.ClearEventRegister" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ClearEventRegister()
// ====================
// Clear the Event Register of this PE.

<anchor link="impl-shared.ClearEventRegister.0" hover="function: ClearEventRegister()">ClearEventRegister</anchor>()
    EventRegister = '0';
    return;</pstext>
    </ps>
    <ps name="shared/functions/system/ClearPendingPhysicalSError" mylink="shared.functions.system.ClearPendingPhysicalSError" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Clear a pending physical SError interrupt.
<anchor link="impl-shared.ClearPendingPhysicalSError.0" hover="function: ClearPendingPhysicalSError()">ClearPendingPhysicalSError</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/system/ClearPendingVirtualSError" mylink="shared.functions.system.ClearPendingVirtualSError" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Clear a pending virtual SError interrupt.
<anchor link="impl-shared.ClearPendingVirtualSError.0" hover="function: ClearPendingVirtualSError()">ClearPendingVirtualSError</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/system/ConditionHolds" mylink="shared.functions.system.ConditionHolds" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ConditionHolds()
// ================
// Return TRUE iff COND currently holds

boolean <anchor link="impl-shared.ConditionHolds.1" hover="function: boolean ConditionHolds(bits(4) cond)">ConditionHolds</anchor>(bits(4) cond)
    // Evaluate base condition.
    boolean result;
    case cond&lt;3:1&gt; of
        when '000' result = (PSTATE.Z == '1');                          // EQ or NE
        when '001' result = (PSTATE.C == '1');                          // CS or CC
        when '010' result = (PSTATE.N == '1');                          // MI or PL
        when '011' result = (PSTATE.V == '1');                          // VS or VC
        when '100' result = (PSTATE.C == '1' &amp;&amp; PSTATE.Z == '0');       // HI or LS
        when '101' result = (PSTATE.N == PSTATE.V);                     // GE or LT
        when '110' result = (PSTATE.N == PSTATE.V &amp;&amp; PSTATE.Z == '0');  // GT or LE
        when '111' result = TRUE;                                       // AL

    // Condition flag values in the set '111x' indicate always true
    // Otherwise, invert condition if necessary.
    if cond&lt;0&gt; == '1' &amp;&amp; cond != '1111' then
        result = !result;

    return result;</pstext>
    </ps>
    <ps name="shared/functions/system/ConsumptionOfSpeculativeDataBarrier" mylink="shared.functions.system.ConsumptionOfSpeculativeDataBarrier" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions"><anchor link="impl-shared.ConsumptionOfSpeculativeDataBarrier.0" hover="function: ConsumptionOfSpeculativeDataBarrier()">ConsumptionOfSpeculativeDataBarrier</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/system/CurrentInstrSet" mylink="shared.functions.system.CurrentInstrSet" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CurrentInstrSet()
// =================

InstrSet <anchor link="impl-shared.CurrentInstrSet.0" hover="function: InstrSet CurrentInstrSet()">CurrentInstrSet</anchor>()
    <a link="InstrSet" file="shared_pseudocode.xml" hover="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet</a> result;
    if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then
        result = if PSTATE.T == '0' then <a link="InstrSet_A32" file="shared_pseudocode.xml" hover="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> else <a link="InstrSet_T32" file="shared_pseudocode.xml" hover="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_T32</a>;
        // PSTATE.J is RES0. Implementation of T32EE or Jazelle state not permitted.
    else
        result = <a link="InstrSet_A64" file="shared_pseudocode.xml" hover="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A64</a>;
    return result;</pstext>
    </ps>
    <ps name="shared/functions/system/CurrentPL" mylink="shared.functions.system.CurrentPL" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CurrentPL()
// ===========

PrivilegeLevel <anchor link="impl-shared.CurrentPL.0" hover="function: PrivilegeLevel CurrentPL()">CurrentPL</anchor>()
    return <a link="impl-shared.PLOfEL.1" file="shared_pseudocode.xml" hover="function: PrivilegeLevel PLOfEL(bits(2) el)">PLOfEL</a>(PSTATE.EL);</pstext>
    </ps>
    <ps name="shared/functions/system/CurrentSecurityState" mylink="shared.functions.system.CurrentSecurityState" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CurrentSecurityState()
// ======================
// Returns the effective security state at the exception level based off current settings.

SecurityState <anchor link="impl-shared.CurrentSecurityState.0" hover="function: SecurityState CurrentSecurityState()">CurrentSecurityState</anchor>()
    return <a link="impl-shared.SecurityStateAtEL.1" file="shared_pseudocode.xml" hover="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(PSTATE.EL);</pstext>
    </ps>
    <ps name="shared/functions/system/DSBAlias" mylink="shared.functions.system.DSBAlias" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="DSBAlias" hover="enumeration DSBAlias {DSBAlias_SSBB, DSBAlias_PSSBB, DSBAlias_DSB}">DSBAlias</anchor> {<anchor link="DSBAlias_SSBB" hover="enumeration DSBAlias {DSBAlias_SSBB, DSBAlias_PSSBB, DSBAlias_DSB}">DSBAlias_SSBB</anchor>, <anchor link="DSBAlias_PSSBB" hover="enumeration DSBAlias {DSBAlias_SSBB, DSBAlias_PSSBB, DSBAlias_DSB}">DSBAlias_PSSBB</anchor>, <anchor link="DSBAlias_DSB" hover="enumeration DSBAlias {DSBAlias_SSBB, DSBAlias_PSSBB, DSBAlias_DSB}">DSBAlias_DSB</anchor>};</pstext>
    </ps>
    <ps name="shared/functions/system/EL0" mylink="shared.functions.system.EL0" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">constant bits(2) <anchor link="EL3" hover="constant bits(2) EL3 = '11'">EL3</anchor> = '11';
constant bits(2) <anchor link="EL2" hover="constant bits(2) EL2 = '10'">EL2</anchor> = '10';
constant bits(2) <anchor link="EL1" hover="constant bits(2) EL1 = '01'">EL1</anchor> = '01';
constant bits(2) <anchor link="EL0" hover="constant bits(2) EL0 = '00'">EL0</anchor> = '00';</pstext>
    </ps>
    <ps name="shared/functions/system/EL2Enabled" mylink="shared.functions.system.EL2Enabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// EL2Enabled()
// ============
// Returns TRUE if EL2 is present and executing
// - with the PE in Non-secure state when Non-secure EL2 is implemented, or
// - with the PE in Secure state when Secure EL2 is implemented and enabled, or
// - when EL3 is not implemented.

boolean <anchor link="impl-shared.EL2Enabled.0" hover="function: boolean EL2Enabled()">EL2Enabled</anchor>()
    return <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; (!<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) || <a link="impl-shared.SCR_GEN.read.0" file="shared_pseudocode.xml" hover="accessor: SCRType SCR_GEN[]">SCR_GEN</a>[].NS == '1' || <a link="impl-shared.IsSecureEL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>());</pstext>
    </ps>
    <ps name="shared/functions/system/ELFromM32" mylink="shared.functions.system.ELFromM32" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ELFromM32()
// ===========

(boolean,bits(2)) <anchor link="impl-shared.ELFromM32.1" hover="function: (boolean,bits(2)) ELFromM32(bits(5) mode)">ELFromM32</anchor>(bits(5) mode)
    // Convert an AArch32 mode encoding to an Exception level.
    // Returns (valid,EL):
    //   'valid' is TRUE if 'mode&lt;4:0&gt;' encodes a mode that is both valid for this implementation
    //           and the current value of SCR.NS/SCR_EL3.NS.
    //   'EL'    is the Exception level decoded from 'mode'.
    bits(2) el;
    boolean valid = !<a link="impl-aarch32.BadMode.1" file="shared_pseudocode.xml" hover="function: boolean BadMode(bits(5) mode)">BadMode</a>(mode);  // Check for modes that are not valid for this implementation
    case mode of
        when <a link="M32_Monitor" file="shared_pseudocode.xml" hover="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>
            el = <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>;
        when <a link="M32_Hyp" file="shared_pseudocode.xml" hover="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>
            el = <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;
            valid = valid &amp;&amp; (!<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) || <a link="impl-shared.SCR_GEN.read.0" file="shared_pseudocode.xml" hover="accessor: SCRType SCR_GEN[]">SCR_GEN</a>[].NS == '1');
        when <a link="M32_FIQ" file="shared_pseudocode.xml" hover="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>, <a link="M32_IRQ" file="shared_pseudocode.xml" hover="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>, <a link="M32_Svc" file="shared_pseudocode.xml" hover="constant bits(5) M32_Svc = '10011'">M32_Svc</a>, <a link="M32_Abort" file="shared_pseudocode.xml" hover="constant bits(5) M32_Abort = '10111'">M32_Abort</a>, <a link="M32_Undef" file="shared_pseudocode.xml" hover="constant bits(5) M32_Undef = '11011'">M32_Undef</a>, <a link="M32_System" file="shared_pseudocode.xml" hover="constant bits(5) M32_System = '11111'">M32_System</a>
            // If EL3 is implemented and using AArch32, then these modes are EL3 modes in Secure
            // state, and EL1 modes in Non-secure state. If EL3 is not implemented or is using
            // AArch64, then these modes are EL1 modes.
            el = (if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a link="impl-shared.HaveAArch64.0" file="shared_pseudocode.xml" hover="function: boolean HaveAArch64()">HaveAArch64</a>() &amp;&amp; SCR.NS == '0' then <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> else <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>);
        when <a link="M32_User" file="shared_pseudocode.xml" hover="constant bits(5) M32_User = '10000'">M32_User</a>
            el = <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>;
        otherwise
            valid = FALSE;           // Passed an illegal mode value
    if !valid then el = bits(2) UNKNOWN;
    return (valid, el);</pstext>
    </ps>
    <ps name="shared/functions/system/ELFromSPSR" mylink="shared.functions.system.ELFromSPSR" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ELFromSPSR()
// ============

// Convert an SPSR value encoding to an Exception level.
// Returns (valid,EL):
//   'valid' is TRUE if 'spsr&lt;4:0&gt;' encodes a valid mode for the current state.
//   'EL'    is the Exception level decoded from 'spsr'.

(boolean,bits(2)) <anchor link="impl-shared.ELFromSPSR.1" hover="function: (boolean,bits(2)) ELFromSPSR(bits(N) spsr)">ELFromSPSR</anchor>(bits(N) spsr)
    bits(2) el;
    boolean valid;
    if spsr&lt;4&gt; == '0' then                      // AArch64 state
        el = spsr&lt;3:2&gt;;
        if !<a link="impl-shared.HaveAArch64.0" file="shared_pseudocode.xml" hover="function: boolean HaveAArch64()">HaveAArch64</a>() then                  // No AArch64 support
            valid = FALSE;
        elsif !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(el) then                  // Exception level not implemented
            valid = FALSE;
        elsif spsr&lt;1&gt; == '1' then               // M[1] must be 0
            valid = FALSE;
        elsif el == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; spsr&lt;0&gt; == '1' then  // for EL0, M[0] must be 0
            valid = FALSE;
        elsif el == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a link="impl-shared.IsSecureEL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>() &amp;&amp; SCR_EL3.NS == '0' then
            valid = FALSE;                      // Unless Secure EL2 is enabled, EL2 only valid in Non-secure state
        else
            valid = TRUE;
    elsif <a link="impl-shared.HaveAArch32.0" file="shared_pseudocode.xml" hover="function: boolean HaveAArch32()">HaveAArch32</a>() then                    // AArch32 state
        (valid, el) = <a link="impl-shared.ELFromM32.1" file="shared_pseudocode.xml" hover="function: (boolean,bits(2)) ELFromM32(bits(5) mode)">ELFromM32</a>(spsr&lt;4:0&gt;);
    else
        valid = FALSE;

    if !valid then el = bits(2) UNKNOWN;
    return (valid,el);</pstext>
    </ps>
    <ps name="shared/functions/system/ELIsInHost" mylink="shared.functions.system.ELIsInHost" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ELIsInHost()
// ============

boolean <anchor link="impl-shared.ELIsInHost.1" hover="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</anchor>(bits(2) el)
    if !<a link="impl-shared.HaveVirtHostExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() || <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
        return FALSE;
    case el of
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>
            return FALSE;
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>
            return <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.E2H == '1';
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>
            return FALSE;
        when <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>
            return <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; == '11';
        otherwise
            <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();</pstext>
    </ps>
    <ps name="shared/functions/system/ELStateUsingAArch32" mylink="shared.functions.system.ELStateUsingAArch32" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ELStateUsingAArch32()
// =====================

boolean <anchor link="impl-shared.ELStateUsingAArch32.2" hover="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)">ELStateUsingAArch32</anchor>(bits(2) el, boolean secure)
    // See ELStateUsingAArch32K() for description. Must only be called in circumstances where
    // result is valid (typically, that means 'el IN {EL1,EL2,EL3}').
    (known, aarch32) = <a link="impl-shared.ELStateUsingAArch32K.2" file="shared_pseudocode.xml" hover="function: (boolean,boolean) ELStateUsingAArch32K(bits(2) el, boolean secure)">ELStateUsingAArch32K</a>(el, secure);
    assert known;
    return aarch32;</pstext>
    </ps>
    <ps name="shared/functions/system/ELStateUsingAArch32K" mylink="shared.functions.system.ELStateUsingAArch32K" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ELStateUsingAArch32K()
// ======================

(boolean,boolean) <anchor link="impl-shared.ELStateUsingAArch32K.2" hover="function: (boolean,boolean) ELStateUsingAArch32K(bits(2) el, boolean secure)">ELStateUsingAArch32K</anchor>(bits(2) el, boolean secure)
    // Returns (known, aarch32):
    //   'known'   is FALSE for EL0 if the current Exception level is not EL0 and EL1 is
    //             using AArch64, since it cannot determine the state of EL0; TRUE otherwise.
    //   'aarch32' is TRUE if the specified Exception level is using AArch32; FALSE otherwise.
    if !<a link="impl-shared.HaveAArch32EL.1" file="shared_pseudocode.xml" hover="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(el) then
        return (TRUE, FALSE);                      // Exception level is using AArch64
    elsif secure &amp;&amp; el == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then
        return (TRUE, FALSE);                      // Secure EL2 is using AArch64
    elsif !<a link="impl-shared.HaveAArch64.0" file="shared_pseudocode.xml" hover="function: boolean HaveAArch64()">HaveAArch64</a>() then
        return (TRUE, TRUE);                       // Highest Exception level, and therefore all levels are using AArch32

    // Remainder of function deals with the interprocessing cases when highest Exception level is using AArch64

    boolean aarch32 = boolean UNKNOWN;
    boolean known = TRUE;

    aarch32_below_el3 = <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.RW == '0' &amp;&amp; (!secure || !<a link="impl-shared.HaveSecureEL2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() || SCR_EL3.EEL2 == '0');
    aarch32_at_el1 = (aarch32_below_el3 || (<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp;
                                            ((<a link="impl-shared.HaveSecureEL2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() &amp;&amp; SCR_EL3.EEL2 == '1') || !secure) &amp;&amp; HCR_EL2.RW == '0' &amp;&amp;
                                            !(HCR_EL2.E2H == '1' &amp;&amp; HCR_EL2.TGE == '1' &amp;&amp; <a link="impl-shared.HaveVirtHostExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>())));
    if el == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !aarch32_at_el1 then       // Only know if EL0 using AArch32 from PSTATE
        if PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then
            aarch32 = PSTATE.nRW == '1';       // EL0 controlled by PSTATE
        else
            known = FALSE;                     // EL0 state is UNKNOWN
    else
        aarch32 = (aarch32_below_el3 &amp;&amp; el != <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) || (aarch32_at_el1 &amp;&amp; el IN {<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>,<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>});

    if !known then aarch32 = boolean UNKNOWN;
    return (known, aarch32);</pstext>
    </ps>
    <ps name="shared/functions/system/ELUsingAArch32" mylink="shared.functions.system.ELUsingAArch32" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ELUsingAArch32()
// ================

boolean <anchor link="impl-shared.ELUsingAArch32.1" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</anchor>(bits(2) el)
    return <a link="impl-shared.ELStateUsingAArch32.2" file="shared_pseudocode.xml" hover="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)">ELStateUsingAArch32</a>(el, <a link="impl-shared.IsSecureBelowEL3.0" file="shared_pseudocode.xml" hover="function: boolean IsSecureBelowEL3()">IsSecureBelowEL3</a>());</pstext>
    </ps>
    <ps name="shared/functions/system/ELUsingAArch32K" mylink="shared.functions.system.ELUsingAArch32K" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ELUsingAArch32K()
// =================

(boolean,boolean) <anchor link="impl-shared.ELUsingAArch32K.1" hover="function: (boolean,boolean) ELUsingAArch32K(bits(2) el)">ELUsingAArch32K</anchor>(bits(2) el)
    return <a link="impl-shared.ELStateUsingAArch32K.2" file="shared_pseudocode.xml" hover="function: (boolean,boolean) ELStateUsingAArch32K(bits(2) el, boolean secure)">ELStateUsingAArch32K</a>(el, <a link="impl-shared.IsSecureBelowEL3.0" file="shared_pseudocode.xml" hover="function: boolean IsSecureBelowEL3()">IsSecureBelowEL3</a>());</pstext>
    </ps>
    <ps name="shared/functions/system/EffectiveTGE" mylink="shared.functions.system.EffectiveTGE" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// EffectiveTGE()
// ==============
// Returns effective TGE value

bit <anchor link="impl-shared.EffectiveTGE.0" hover="function: bit EffectiveTGE()">EffectiveTGE</anchor>()
    if <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() then
        return if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then HCR.TGE else HCR_EL2.TGE;
    else
        return '0';        // Effective value of TGE is zero</pstext>
    </ps>
    <ps name="shared/functions/system/EndOfInstruction" mylink="shared.functions.system.EndOfInstruction" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Terminate processing of the current instruction.
<anchor link="impl-shared.EndOfInstruction.0" hover="function: EndOfInstruction()">EndOfInstruction</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/system/EnterLowPowerState" mylink="shared.functions.system.EnterLowPowerState" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// PE enters a low-power state.
<anchor link="impl-shared.EnterLowPowerState.0" hover="function: EnterLowPowerState()">EnterLowPowerState</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/system/EventRegister" mylink="shared.functions.system.EventRegister" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">bits(1) EventRegister;</pstext>
    </ps>
    <ps name="shared/functions/system/ExceptionalOccurrenceTargetState" mylink="shared.functions.system.ExceptionalOccurrenceTargetState" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="ExceptionalOccurrenceTargetState" hover="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">ExceptionalOccurrenceTargetState</anchor> {
    <anchor link="AArch32_NonDebugState" hover="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">AArch32_NonDebugState</anchor>,
    <anchor link="AArch64_NonDebugState" hover="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">AArch64_NonDebugState</anchor>,
    <anchor link="DebugState" hover="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">DebugState</anchor>
};</pstext>
    </ps>
    <ps name="shared/functions/system/FIQPending" mylink="shared.functions.system.FIQPending" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns a tuple indicating if there is any pending physical FIQ
// and if the pending FIQ has superpriority.
(boolean, boolean) <anchor link="impl-shared.FIQPending.0" hover="function: (boolean, boolean) FIQPending()">FIQPending</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/system/GetAccumulatedFPExceptions" mylink="shared.functions.system.GetAccumulatedFPExceptions" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns FP exceptions accumulated by the PE.
bits(8) <anchor link="impl-shared.GetAccumulatedFPExceptions.0" hover="function: bits(8) GetAccumulatedFPExceptions()">GetAccumulatedFPExceptions</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/system/GetPSRFromPSTATE" mylink="shared.functions.system.GetPSRFromPSTATE" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// GetPSRFromPSTATE()
// ==================
// Return a PSR value which represents the current PSTATE

bits(N) <anchor link="impl-shared.GetPSRFromPSTATE.1" hover="function: bits(N) GetPSRFromPSTATE(ExceptionalOccurrenceTargetState targetELState)">GetPSRFromPSTATE</anchor>(<a link="ExceptionalOccurrenceTargetState" file="shared_pseudocode.xml" hover="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">ExceptionalOccurrenceTargetState</a> targetELState)
    if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; (targetELState IN {<a link="AArch32_NonDebugState" file="shared_pseudocode.xml" hover="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">AArch32_NonDebugState</a>, <a link="DebugState" file="shared_pseudocode.xml" hover="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">DebugState</a>}) then
        assert N == 32;
    else
        assert N == 64;
    bits(N) spsr = <a link="impl-shared.Zeros.0" file="shared_pseudocode.xml" hover="function: bits(N) Zeros()">Zeros</a>();
    spsr&lt;31:28&gt; = PSTATE.&lt;N,Z,C,V&gt;;
    if <a link="impl-shared.HavePANExt.0" file="shared_pseudocode.xml" hover="function: boolean HavePANExt()">HavePANExt</a>() then spsr&lt;22&gt; = PSTATE.PAN;
    spsr&lt;20&gt;    = PSTATE.IL;
    if PSTATE.nRW == '1' then                           // AArch32 state
        spsr&lt;27&gt;    = PSTATE.Q;
        spsr&lt;26:25&gt; = PSTATE.IT&lt;1:0&gt;;
        if <a link="impl-shared.HaveSSBSExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then spsr&lt;23&gt; = PSTATE.SSBS;
        if <a link="impl-shared.HaveDITExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveDITExt()">HaveDITExt</a>() then
            if targetELState == <a link="AArch32_NonDebugState" file="shared_pseudocode.xml" hover="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">AArch32_NonDebugState</a> then
                spsr&lt;21&gt; = PSTATE.DIT;
            else                                        //AArch64_NonDebugState or DebugState
                spsr&lt;24&gt; = PSTATE.DIT;
        if targetELState IN {<a link="AArch64_NonDebugState" file="shared_pseudocode.xml" hover="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">AArch64_NonDebugState</a>, <a link="DebugState" file="shared_pseudocode.xml" hover="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">DebugState</a>} then
            spsr&lt;21&gt; = PSTATE.SS;
        spsr&lt;19:16&gt; = PSTATE.GE;
        spsr&lt;15:10&gt; = PSTATE.IT&lt;7:2&gt;;
        spsr&lt;9&gt;     = PSTATE.E;
        spsr&lt;8:6&gt;   = PSTATE.&lt;A,I,F&gt;;                   // No PSTATE.D in AArch32 state
        spsr&lt;5&gt;     = PSTATE.T;
        assert PSTATE.M&lt;4&gt; == PSTATE.nRW;               // bit [4] is the discriminator
        spsr&lt;4:0&gt;   = PSTATE.M;
    else                                                // AArch64 state
        if <a link="impl-shared.HaveMTEExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveMTEExt()">HaveMTEExt</a>() then spsr&lt;25&gt; = PSTATE.TCO;
        if <a link="impl-shared.HaveDITExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveDITExt()">HaveDITExt</a>() then spsr&lt;24&gt; = PSTATE.DIT;
        if <a link="impl-shared.HaveUAOExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveUAOExt()">HaveUAOExt</a>() then spsr&lt;23&gt; = PSTATE.UAO;
        spsr&lt;21&gt;    = PSTATE.SS;
        if <a link="impl-shared.HaveFeatNMI.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatNMI()">HaveFeatNMI</a>() then spsr&lt;13&gt; = PSTATE.ALLINT;
        if <a link="impl-shared.HaveSSBSExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then spsr&lt;12&gt; = PSTATE.SSBS;
        if <a link="impl-shared.HaveBTIExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveBTIExt()">HaveBTIExt</a>() then spsr&lt;11:10&gt; = PSTATE.BTYPE;
        spsr&lt;9:6&gt;   = PSTATE.&lt;D,A,I,F&gt;;
        spsr&lt;4&gt;     = PSTATE.nRW;
        spsr&lt;3:2&gt;   = PSTATE.EL;
        spsr&lt;0&gt;     = PSTATE.SP;
    return spsr;</pstext>
    </ps>
    <ps name="shared/functions/system/HasArchVersion" mylink="shared.functions.system.HasArchVersion" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HasArchVersion()
// ================
// Returns TRUE if the implemented architecture includes the extensions defined in the specified
// architecture version.

boolean <anchor link="impl-shared.HasArchVersion.1" hover="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</anchor>(<a link="ArchVersion" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ArchVersion</a> version)
    return version == <a link="ARMv8p0" file="shared_pseudocode.xml" hover="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p0</a> || boolean IMPLEMENTATION_DEFINED;</pstext>
    </ps>
    <ps name="shared/functions/system/HaveAArch32" mylink="shared.functions.system.HaveAArch32" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveAArch32()
// =============
// Return TRUE if AArch32 state is supported at at least EL0.

boolean <anchor link="impl-shared.HaveAArch32.0" hover="function: boolean HaveAArch32()">HaveAArch32</anchor>()
    return boolean IMPLEMENTATION_DEFINED "AArch32 state is supported at at least <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>";</pstext>
    </ps>
    <ps name="shared/functions/system/HaveAArch32EL" mylink="shared.functions.system.HaveAArch32EL" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveAArch32EL()
// ===============

boolean <anchor link="impl-shared.HaveAArch32EL.1" hover="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</anchor>(bits(2) el)
    // Return TRUE if Exception level 'el' supports AArch32 in this implementation
    if !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(el) then
        return FALSE;                    // The Exception level is not implemented
    elsif !<a link="impl-shared.HaveAArch32.0" file="shared_pseudocode.xml" hover="function: boolean HaveAArch32()">HaveAArch32</a>() then
        return FALSE;                    // No Exception level can use AArch32
    elsif !<a link="impl-shared.HaveAArch64.0" file="shared_pseudocode.xml" hover="function: boolean HaveAArch64()">HaveAArch64</a>() then
        return TRUE;                     // All Exception levels are using AArch32
    elsif el == <a link="impl-shared.HighestEL.0" file="shared_pseudocode.xml" hover="function: bits(2) HighestEL()">HighestEL</a>() then
        return FALSE;                    // The highest Exception level is using AArch64
    elsif el == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then
        return TRUE;                     // EL0 must support using AArch32 if any AArch32
    return boolean IMPLEMENTATION_DEFINED;</pstext>
    </ps>
    <ps name="shared/functions/system/HaveAArch64" mylink="shared.functions.system.HaveAArch64" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveAArch64()
// =============
// Return TRUE if the highest Exception level is using AArch64 state.

boolean <anchor link="impl-shared.HaveAArch64.0" hover="function: boolean HaveAArch64()">HaveAArch64</anchor>()
    return boolean IMPLEMENTATION_DEFINED "Highest EL using AArch64";</pstext>
    </ps>
    <ps name="shared/functions/system/HaveEL" mylink="shared.functions.system.HaveEL" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveEL()
// ========
// Return TRUE if Exception level 'el' is supported

boolean <anchor link="impl-shared.HaveEL.1" hover="function: boolean HaveEL(bits(2) el)">HaveEL</anchor>(bits(2) el)
    if el IN {<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>,<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>} then
        return TRUE;                             // EL1 and EL0 must exist
    return boolean IMPLEMENTATION_DEFINED;</pstext>
    </ps>
    <ps name="shared/functions/system/HaveELUsingSecurityState" mylink="shared.functions.system.HaveELUsingSecurityState" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveELUsingSecurityState()
// ==========================
// Returns TRUE if Exception level 'el' with Security state 'secure' is supported,
// FALSE otherwise.

boolean <anchor link="impl-shared.HaveELUsingSecurityState.2" hover="function: boolean HaveELUsingSecurityState(bits(2) el, boolean secure)">HaveELUsingSecurityState</anchor>(bits(2) el, boolean secure)

    case el of
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>
            assert secure;
            return <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>);
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>
            if secure then
                return <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; <a link="impl-shared.HaveSecureEL2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>();
            else
                return <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>);
        otherwise
            return (<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) ||
                    (secure == boolean IMPLEMENTATION_DEFINED "Secure-only implementation"));</pstext>
    </ps>
    <ps name="shared/functions/system/HaveFP16Ext" mylink="shared.functions.system.HaveFP16Ext" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HaveFP16Ext()
// =============
// Return TRUE if FP16 extension is supported

boolean <anchor link="impl-shared.HaveFP16Ext.0" hover="function: boolean HaveFP16Ext()">HaveFP16Ext</anchor>()
    return boolean IMPLEMENTATION_DEFINED;</pstext>
    </ps>
    <ps name="shared/functions/system/HighestEL" mylink="shared.functions.system.HighestEL" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HighestEL()
// ===========
// Returns the highest implemented Exception level.

bits(2) <anchor link="impl-shared.HighestEL.0" hover="function: bits(2) HighestEL()">HighestEL</anchor>()
    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
        return <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>;
    elsif <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
        return <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;
    else
        return <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;</pstext>
    </ps>
    <ps name="shared/functions/system/Hint_DGH" mylink="shared.functions.system.Hint_DGH" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Provides a hint to close any gathering occurring within the micro-architecture.
<anchor link="impl-shared.Hint_DGH.0" hover="function: Hint_DGH()">Hint_DGH</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/system/Hint_WFE" mylink="shared.functions.system.Hint_WFE" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Hint_WFE()
// ==========
// Provides a hint indicating that the PE can enter a low-power state
// and remain there until a wakeup event occurs or, for WFET,  a local
// timeout event is generated when the virtual timer value equals or
// exceeds the supplied threshold value.

<anchor link="impl-shared.Hint_WFE.2" hover="function: Hint_WFE(integer localtimeout, WFxType wfxtype)">Hint_WFE</anchor>(integer localtimeout, <a link="WFxType" file="shared_pseudocode.xml" hover="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType</a> wfxtype)
    if <a link="impl-shared.IsEventRegisterSet.0" file="shared_pseudocode.xml" hover="function: boolean IsEventRegisterSet()">IsEventRegisterSet</a>() then
        <a link="impl-shared.ClearEventRegister.0" file="shared_pseudocode.xml" hover="function: ClearEventRegister()">ClearEventRegister</a>();
    elsif <a link="impl-shared.HaveFeatWFxT.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatWFxT()">HaveFeatWFxT</a>() &amp;&amp; <a link="impl-shared.LocalTimeoutEvent.1" file="shared_pseudocode.xml" hover="function: boolean LocalTimeoutEvent(integer localtimeout)">LocalTimeoutEvent</a>(localtimeout) then
        // No further operation if the local timeout has expired.
        <a link="impl-shared.EndOfInstruction.0" file="shared_pseudocode.xml" hover="function: EndOfInstruction()">EndOfInstruction</a>();
    else
        bits(2) target_el;
        trap = FALSE;
        if PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then
            // Check for traps described by the OS which may be EL1 or EL2.
            if <a link="impl-shared.HaveTWEDExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveTWEDExt()">HaveTWEDExt</a>() then
                sctlr     = <a link="impl-aarch64.SCTLR.read.0" file="shared_pseudocode.xml" hover="accessor: SCTLRType SCTLR[]">SCTLR</a>[];
                trap      = sctlr.nTWE == '0';
                target_el = <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;
            else
                <a link="AArch64.CheckForWFxTrap.2" file="shared_pseudocode.xml" hover="function: AArch64.CheckForWFxTrap(bits(2) target_el, WFxType wfxtype)">AArch64.CheckForWFxTrap</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>, wfxtype);
        if !trap &amp;&amp; PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a link="impl-shared.IsInHost.0" file="shared_pseudocode.xml" hover="function: boolean IsInHost()">IsInHost</a>() then
            // Check for traps described by the Hypervisor.
            if <a link="impl-shared.HaveTWEDExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveTWEDExt()">HaveTWEDExt</a>() then
                trap      = HCR_EL2.TWE == '1';
                target_el = <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;
            else
                <a link="AArch64.CheckForWFxTrap.2" file="shared_pseudocode.xml" hover="function: AArch64.CheckForWFxTrap(bits(2) target_el, WFxType wfxtype)">AArch64.CheckForWFxTrap</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, wfxtype);

        if !trap &amp;&amp; <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; PSTATE.EL != <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> then
            // Check for traps described by the Secure Monitor.
            if <a link="impl-shared.HaveTWEDExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveTWEDExt()">HaveTWEDExt</a>() then
                trap      = SCR_EL3.TWE == '1';
                target_el = <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>;
            else
                <a link="AArch64.CheckForWFxTrap.2" file="shared_pseudocode.xml" hover="function: AArch64.CheckForWFxTrap(bits(2) target_el, WFxType wfxtype)">AArch64.CheckForWFxTrap</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, wfxtype);

        if trap &amp;&amp; PSTATE.EL != <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> then
            (delay_enabled, delay) = <a link="impl-aarch64.WFETrapDelay.1" file="shared_pseudocode.xml" hover="function: (boolean, integer) WFETrapDelay(bits(2) target_el)">WFETrapDelay</a>(target_el);    // (If trap delay is enabled, Delay amount)
            if !<a link="impl-aarch64.WaitForEventUntilDelay.2" file="shared_pseudocode.xml" hover="function: boolean WaitForEventUntilDelay(boolean delay_enabled, integer delay)">WaitForEventUntilDelay</a>(delay_enabled, delay) then
                // Event did not arrive before delay expired
                <a link="AArch64.WFxTrap.2" file="shared_pseudocode.xml" hover="function: AArch64.WFxTrap(WFxType wfxtype, bits(2) target_el)">AArch64.WFxTrap</a>(wfxtype, target_el);             // Trap WFE
        else
            <a link="impl-shared.WaitForEvent.1" file="shared_pseudocode.xml" hover="function: WaitForEvent(integer localtimeout)">WaitForEvent</a>(localtimeout);</pstext>
    </ps>
    <ps name="shared/functions/system/Hint_WFI" mylink="shared.functions.system.Hint_WFI" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Hint_WFI()
// ==========
// Provides a hint indicating that the PE can enter a low-power state and
// remain there until a wakeup event occurs or, for WFIT, a local timeout
// event is generated when the virtual timer value equals or exceeds the
// supplied threshold value.

<anchor link="impl-shared.Hint_WFI.2" hover="function: Hint_WFI(integer localtimeout, WFxType wfxtype)">Hint_WFI</anchor>(integer localtimeout, <a link="WFxType" file="shared_pseudocode.xml" hover="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType</a> wfxtype)
    if <a link="impl-shared.InterruptPending.0" file="shared_pseudocode.xml" hover="function: boolean InterruptPending()">InterruptPending</a>() || (<a link="impl-shared.HaveFeatWFxT.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatWFxT()">HaveFeatWFxT</a>() &amp;&amp; <a link="impl-shared.LocalTimeoutEvent.1" file="shared_pseudocode.xml" hover="function: boolean LocalTimeoutEvent(integer localtimeout)">LocalTimeoutEvent</a>(localtimeout)) then
        // No further operation if an interrupt is pending or the local timeout has expired.
        <a link="impl-shared.EndOfInstruction.0" file="shared_pseudocode.xml" hover="function: EndOfInstruction()">EndOfInstruction</a>();
    else
        if PSTATE.EL == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then
            // Check for traps described by the OS.
            <a link="AArch64.CheckForWFxTrap.2" file="shared_pseudocode.xml" hover="function: AArch64.CheckForWFxTrap(bits(2) target_el, WFxType wfxtype)">AArch64.CheckForWFxTrap</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>, wfxtype);
        if PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a link="impl-shared.IsInHost.0" file="shared_pseudocode.xml" hover="function: boolean IsInHost()">IsInHost</a>() then
            // Check for traps described by the Hypervisor.
            <a link="AArch64.CheckForWFxTrap.2" file="shared_pseudocode.xml" hover="function: AArch64.CheckForWFxTrap(bits(2) target_el, WFxType wfxtype)">AArch64.CheckForWFxTrap</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>, wfxtype);
        if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; PSTATE.EL != <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> then
            // Check for traps described by the Secure Monitor.
            <a link="AArch64.CheckForWFxTrap.2" file="shared_pseudocode.xml" hover="function: AArch64.CheckForWFxTrap(bits(2) target_el, WFxType wfxtype)">AArch64.CheckForWFxTrap</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>, wfxtype);
        <a link="impl-shared.WaitForInterrupt.1" file="shared_pseudocode.xml" hover="function: WaitForInterrupt(integer localtimeout)">WaitForInterrupt</a>(localtimeout);</pstext>
    </ps>
    <ps name="shared/functions/system/Hint_Yield" mylink="shared.functions.system.Hint_Yield" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Provides a hint that the task performed by a thread is of low
// importance so that it could yield to improve overall performance.
<anchor link="impl-shared.Hint_Yield.0" hover="function: Hint_Yield()">Hint_Yield</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/system/IRQPending" mylink="shared.functions.system.IRQPending" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns a tuple indicating if there is any pending physical IRQ
// and if the pending IRQ has superpriority.
(boolean, boolean) <anchor link="impl-shared.IRQPending.0" hover="function: (boolean, boolean) IRQPending()">IRQPending</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/system/IllegalExceptionReturn" mylink="shared.functions.system.IllegalExceptionReturn" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// IllegalExceptionReturn()
// ========================

boolean <anchor link="impl-shared.IllegalExceptionReturn.1" hover="function: boolean IllegalExceptionReturn(bits(N) spsr)">IllegalExceptionReturn</anchor>(bits(N) spsr)

    // Check for illegal return:
    //   * To an unimplemented Exception level.
    //   * To EL2 in Secure state, when SecureEL2 is not enabled.
    //   * To EL0 using AArch64 state, with SPSR.M[0]==1.
    //   * To AArch64 state with SPSR.M[1]==1.
    //   * To AArch32 state with an illegal value of SPSR.M.
    (valid, target) = <a link="impl-shared.ELFromSPSR.1" file="shared_pseudocode.xml" hover="function: (boolean,bits(2)) ELFromSPSR(bits(N) spsr)">ELFromSPSR</a>(spsr);
    if !valid then return TRUE;

    // Check for return to higher Exception level
    if <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(target) &gt; <a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) then return TRUE;

    spsr_mode_is_aarch32 = (spsr&lt;4&gt; == '1');

    // Check for illegal return:
    //   * To EL1, EL2 or EL3 with register width specified in the SPSR different from the
    //     Execution state used in the Exception level being returned to, as determined by
    //     the SCR_EL3.RW or HCR_EL2.RW bits, or as configured from reset.
    //   * To EL0 using AArch64 state when EL1 is using AArch32 state as determined by the
    //     SCR_EL3.RW or HCR_EL2.RW bits or as configured from reset.
    //   * To AArch64 state from AArch32 state (should be caught by above)
    (known, target_el_is_aarch32) = <a link="impl-shared.ELUsingAArch32K.1" file="shared_pseudocode.xml" hover="function: (boolean,boolean) ELUsingAArch32K(bits(2) el)">ELUsingAArch32K</a>(target);
    assert known || (target == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>));
    if known &amp;&amp; spsr_mode_is_aarch32 != target_el_is_aarch32 then return TRUE;

    // Check for illegal return from AArch32 to AArch64
    if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; !spsr_mode_is_aarch32 then return TRUE;

    // Check for illegal return to EL1 when HCR.TGE is set and when either of
    // * SecureEL2 is enabled.
    // * SecureEL2 is not enabled and EL1 is in Non-secure state.
    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; target == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; HCR_EL2.TGE == '1' then
        if (!<a link="impl-shared.IsSecureBelowEL3.0" file="shared_pseudocode.xml" hover="function: boolean IsSecureBelowEL3()">IsSecureBelowEL3</a>() || <a link="impl-shared.IsSecureEL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>()) then return TRUE;
    return FALSE;</pstext>
    </ps>
    <ps name="shared/functions/system/InstrSet" mylink="shared.functions.system.InstrSet" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="InstrSet" hover="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet</anchor> {<anchor link="InstrSet_A64" hover="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A64</anchor>, <anchor link="InstrSet_A32" hover="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</anchor>, <anchor link="InstrSet_T32" hover="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_T32</anchor>};</pstext>
    </ps>
    <ps name="shared/functions/system/InstructionSynchronizationBarrier" mylink="shared.functions.system.InstructionSynchronizationBarrier" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions"><anchor link="impl-shared.InstructionSynchronizationBarrier.0" hover="function: InstructionSynchronizationBarrier()">InstructionSynchronizationBarrier</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/system/InterruptPending" mylink="shared.functions.system.InterruptPending" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// InterruptPending()
// ==================
// Returns TRUE if there are any pending physical or virtual
// interrupts, and FALSE otherwise.

boolean <anchor link="impl-shared.InterruptPending.0" hover="function: boolean InterruptPending()">InterruptPending</anchor>()
    boolean pending_virtual_interrupt = FALSE;
    (irq_pending, -) = <a link="impl-shared.IRQPending.0" file="shared_pseudocode.xml" hover="function: (boolean, boolean) IRQPending()">IRQPending</a>();
    (fiq_pending, -) = <a link="impl-shared.FIQPending.0" file="shared_pseudocode.xml" hover="function: (boolean, boolean) FIQPending()">FIQPending</a>();
    boolean pending_physical_interrupt = (irq_pending || fiq_pending ||
                                          <a link="impl-shared.IsPhysicalSErrorPending.0" file="shared_pseudocode.xml" hover="function: boolean IsPhysicalSErrorPending()">IsPhysicalSErrorPending</a>());

    if <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>, <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; HCR_EL2.TGE == '0' then
        boolean virq_pending = HCR_EL2.IMO == '1' &amp;&amp; (<a link="impl-shared.VirtualIRQPending.0" file="shared_pseudocode.xml" hover="function: boolean VirtualIRQPending()">VirtualIRQPending</a>() || HCR_EL2.VI == '1') ;
        boolean vfiq_pending = HCR_EL2.FMO == '1' &amp;&amp; (<a link="impl-shared.VirtualFIQPending.0" file="shared_pseudocode.xml" hover="function: boolean VirtualFIQPending()">VirtualFIQPending</a>() || HCR_EL2.VF == '1');
        boolean vsei_pending = HCR_EL2.AMO == '1' &amp;&amp; (<a link="impl-shared.IsVirtualSErrorPending.0" file="shared_pseudocode.xml" hover="function: boolean IsVirtualSErrorPending()">IsVirtualSErrorPending</a>() || HCR_EL2.VSE == '1');
        pending_virtual_interrupt = vsei_pending || virq_pending || vfiq_pending;

    return pending_physical_interrupt || pending_virtual_interrupt;</pstext>
    </ps>
    <ps name="shared/functions/system/IsASEInstruction" mylink="shared.functions.system.IsASEInstruction" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns TRUE if the current instruction is an ASIMD or SVE vector instruction.
boolean <anchor link="impl-shared.IsASEInstruction.0" hover="function: boolean IsASEInstruction()">IsASEInstruction</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/system/IsCMOWControlledInstruction" mylink="shared.functions.system.IsCMOWControlledInstruction" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// When using AArch64, returns TRUE if the current instruction is one of IC IVAU,
// DC CIVAC, DC CIGDVAC, or DC CIGVAC.
// When using AArch32, returns TRUE if the current instruction is ICIMVAU or DCCIMVAC.
boolean <anchor link="impl-shared.IsCMOWControlledInstruction.0" hover="function: boolean IsCMOWControlledInstruction()">IsCMOWControlledInstruction</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/system/IsEventRegisterSet" mylink="shared.functions.system.IsEventRegisterSet" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// IsEventRegisterSet()
// ====================
// Return TRUE if the Event Register of this PE is set, and FALSE if it is clear.

boolean <anchor link="impl-shared.IsEventRegisterSet.0" hover="function: boolean IsEventRegisterSet()">IsEventRegisterSet</anchor>()
    return EventRegister == '1';</pstext>
    </ps>
    <ps name="shared/functions/system/IsHighestEL" mylink="shared.functions.system.IsHighestEL" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// IsHighestEL()
// =============
// Returns TRUE if given exception level is the highest exception level implemented

boolean <anchor link="impl-shared.IsHighestEL.1" hover="function: boolean IsHighestEL(bits(2) el)">IsHighestEL</anchor>(bits(2) el)
    return <a link="impl-shared.HighestEL.0" file="shared_pseudocode.xml" hover="function: bits(2) HighestEL()">HighestEL</a>() == el;</pstext>
    </ps>
    <ps name="shared/functions/system/IsInHost" mylink="shared.functions.system.IsInHost" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// IsInHost()
// ==========

boolean <anchor link="impl-shared.IsInHost.0" hover="function: boolean IsInHost()">IsInHost</anchor>()
    return <a link="impl-shared.ELIsInHost.1" file="shared_pseudocode.xml" hover="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(PSTATE.EL);</pstext>
    </ps>
    <ps name="shared/functions/system/IsPhysicalSErrorPending" mylink="shared.functions.system.IsPhysicalSErrorPending" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns TRUE if a physical SError interrupt is pending.
boolean <anchor link="impl-shared.IsPhysicalSErrorPending.0" hover="function: boolean IsPhysicalSErrorPending()">IsPhysicalSErrorPending</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/system/IsSErrorEdgeTriggered" mylink="shared.functions.system.IsSErrorEdgeTriggered" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// IsSErrorEdgeTriggered()
// =======================
// Returns TRUE if the physical SError interrupt is edge-triggered
// and FALSE otherwise.

boolean <anchor link="impl-shared.IsSErrorEdgeTriggered.2" hover="function: boolean IsSErrorEdgeTriggered(bits(2) target_el, bits(25) syndrome)">IsSErrorEdgeTriggered</anchor>(bits(2) target_el, bits(25) syndrome)
    if <a link="impl-shared.HaveRASExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveRASExt()">HaveRASExt</a>() then
        if <a link="impl-shared.HaveDoubleFaultExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>() then
            return TRUE;

        if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(target_el) then
            if syndrome&lt;11:10&gt; != '00' then
                // AArch32 and not Uncontainable.
                return TRUE;
        else
            if syndrome&lt;24&gt; == '0' &amp;&amp; syndrome&lt;5:0&gt; != '000000' then
                // AArch64 and neither IMPLEMENTATION DEFINED syndrome nor Uncategorized.
                return TRUE;
    return boolean IMPLEMENTATION_DEFINED "Edge-triggered SError";</pstext>
    </ps>
    <ps name="shared/functions/system/IsSecure" mylink="shared.functions.system.IsSecure" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// IsSecure()
// ==========
// Returns TRUE if current Exception level is in Secure state.

boolean <anchor link="impl-shared.IsSecure.0" hover="function: boolean IsSecure()">IsSecure</anchor>()
    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; PSTATE.EL == <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> then
        return TRUE;
    elsif <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; PSTATE.M == <a link="M32_Monitor" file="shared_pseudocode.xml" hover="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then
        return TRUE;
    return <a link="impl-shared.IsSecureBelowEL3.0" file="shared_pseudocode.xml" hover="function: boolean IsSecureBelowEL3()">IsSecureBelowEL3</a>();</pstext>
    </ps>
    <ps name="shared/functions/system/IsSecureBelowEL3" mylink="shared.functions.system.IsSecureBelowEL3" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// IsSecureBelowEL3()
// ==================
// Return TRUE if an Exception level below EL3 is in Secure state
// or would be following an exception return to that level.
//
// Differs from IsSecure in that it ignores the current EL or Mode
// in considering security state.
// That is, if at AArch64 EL3 or in AArch32 Monitor mode, whether an
// exception return would pass to Secure or Non-secure state.

boolean <anchor link="impl-shared.IsSecureBelowEL3.0" hover="function: boolean IsSecureBelowEL3()">IsSecureBelowEL3</anchor>()
    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
        return <a link="impl-shared.SCR_GEN.read.0" file="shared_pseudocode.xml" hover="accessor: SCRType SCR_GEN[]">SCR_GEN</a>[].NS == '0';
    elsif <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; (!<a link="impl-shared.HaveSecureEL2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() || !<a link="impl-shared.HaveAArch64.0" file="shared_pseudocode.xml" hover="function: boolean HaveAArch64()">HaveAArch64</a>()) then
        // If Secure EL2 is not an architecture option then we must be Non-secure.
        return FALSE;
    else
        // TRUE if processor is Secure or FALSE if Non-secure.
        return boolean IMPLEMENTATION_DEFINED "Secure-only implementation";</pstext>
    </ps>
    <ps name="shared/functions/system/IsSecureEL2Enabled" mylink="shared.functions.system.IsSecureEL2Enabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// IsSecureEL2Enabled()
// ====================
// Returns TRUE if Secure EL2 is enabled, FALSE otherwise.

boolean <anchor link="impl-shared.IsSecureEL2Enabled.0" hover="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</anchor>()
    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; <a link="impl-shared.HaveSecureEL2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() then
        if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
            if !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.EEL2 == '1' then
                return TRUE;
            else
                return FALSE;
        else
            return <a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>();
    else
        return FALSE;</pstext>
    </ps>
    <ps name="shared/functions/system/IsSynchronizablePhysicalSErrorPending" mylink="shared.functions.system.IsSynchronizablePhysicalSErrorPending" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns TRUE if a synchronizable physical SError interrupt is pending.
boolean <anchor link="impl-shared.IsSynchronizablePhysicalSErrorPending.0" hover="function: boolean IsSynchronizablePhysicalSErrorPending()">IsSynchronizablePhysicalSErrorPending</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/system/IsVirtualSErrorPending" mylink="shared.functions.system.IsVirtualSErrorPending" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns TRUE if a virtual SError interrupt is pending.
boolean <anchor link="impl-shared.IsVirtualSErrorPending.0" hover="function: boolean IsVirtualSErrorPending()">IsVirtualSErrorPending</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/system/LocalTimeoutEvent" mylink="shared.functions.system.LocalTimeoutEvent" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns TRUE if CNTVCT_EL0 equals or exceeds the localtimeout value.
boolean <anchor link="impl-shared.LocalTimeoutEvent.1" hover="function: boolean LocalTimeoutEvent(integer localtimeout)">LocalTimeoutEvent</anchor>(integer localtimeout);</pstext>
    </ps>
    <ps name="shared/functions/system/Mode_Bits" mylink="shared.functions.system.Mode_Bits" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">constant bits(5) <anchor link="M32_User" hover="constant bits(5) M32_User = '10000'">M32_User</anchor>    = '10000';
constant bits(5) <anchor link="M32_FIQ" hover="constant bits(5) M32_FIQ = '10001'">M32_FIQ</anchor>     = '10001';
constant bits(5) <anchor link="M32_IRQ" hover="constant bits(5) M32_IRQ = '10010'">M32_IRQ</anchor>     = '10010';
constant bits(5) <anchor link="M32_Svc" hover="constant bits(5) M32_Svc = '10011'">M32_Svc</anchor>     = '10011';
constant bits(5) <anchor link="M32_Monitor" hover="constant bits(5) M32_Monitor = '10110'">M32_Monitor</anchor> = '10110';
constant bits(5) <anchor link="M32_Abort" hover="constant bits(5) M32_Abort = '10111'">M32_Abort</anchor>   = '10111';
constant bits(5) <anchor link="M32_Hyp" hover="constant bits(5) M32_Hyp = '11010'">M32_Hyp</anchor>     = '11010';
constant bits(5) <anchor link="M32_Undef" hover="constant bits(5) M32_Undef = '11011'">M32_Undef</anchor>   = '11011';
constant bits(5) <anchor link="M32_System" hover="constant bits(5) M32_System = '11111'">M32_System</anchor>  = '11111';</pstext>
    </ps>
    <ps name="shared/functions/system/NonSecureOnlyImplementation" mylink="shared.functions.system.NonSecureOnlyImplementation" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// NonSecureOnlyImplementation()
// =============================
// Returns TRUE if the security state is always Non-secure for this implementation.

boolean <anchor link="impl-shared.NonSecureOnlyImplementation.0" hover="function: boolean NonSecureOnlyImplementation()">NonSecureOnlyImplementation</anchor>()
    return boolean IMPLEMENTATION_DEFINED "Non-secure only implementation";</pstext>
    </ps>
    <ps name="shared/functions/system/PLOfEL" mylink="shared.functions.system.PLOfEL" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// PLOfEL()
// ========

PrivilegeLevel <anchor link="impl-shared.PLOfEL.1" hover="function: PrivilegeLevel PLOfEL(bits(2) el)">PLOfEL</anchor>(bits(2) el)
    case el of
        when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>  return if !<a link="impl-shared.HaveAArch64.0" file="shared_pseudocode.xml" hover="function: boolean HaveAArch64()">HaveAArch64</a>() then <a link="PL1" file="shared_pseudocode.xml" hover="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}">PL1</a> else <a link="PL3" file="shared_pseudocode.xml" hover="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}">PL3</a>;
        when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>  return <a link="PL2" file="shared_pseudocode.xml" hover="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}">PL2</a>;
        when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>  return <a link="PL1" file="shared_pseudocode.xml" hover="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}">PL1</a>;
        when <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>  return <a link="PL0" file="shared_pseudocode.xml" hover="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}">PL0</a>;</pstext>
    </ps>
    <ps name="shared/functions/system/PSTATE" mylink="shared.functions.system.PSTATE" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions"><a link="ProcState" file="shared_pseudocode.xml" hover="type ProcState is ( bits (1) N, bits (1) Z, bits (1) C, bits (1) V, bits (1) D, bits (1) A, bits (1) I, bits (1) F, bits (1) PAN, bits (1) UAO, bits (1) DIT, bits (1) TCO, bits (2) BTYPE, bits (1) ALLINT, bits (1) SS, bits (1) IL, bits (2) EL, bits (1) nRW, bits (1) SP, bits (1) Q, bits (4) GE, bits (1) SSBS, bits (8) IT, bits (1) J, bits (1) T, bits (1) E, bits (5) M )">ProcState</a> PSTATE;</pstext>
    </ps>
    <ps name="shared/functions/system/PhysicalCountInt" mylink="shared.functions.system.PhysicalCountInt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// PhysicalCountInt()
// ==================
// Returns the integral part of physical count value of the System counter.

bits(64) <anchor link="impl-shared.PhysicalCountInt.0" hover="function: bits(64) PhysicalCountInt()">PhysicalCountInt</anchor>()
    return PhysicalCount&lt;87:24&gt;;</pstext>
    </ps>
    <ps name="shared/functions/system/PrivilegeLevel" mylink="shared.functions.system.PrivilegeLevel" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="PrivilegeLevel" hover="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}">PrivilegeLevel</anchor> {<anchor link="PL3" hover="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}">PL3</anchor>, <anchor link="PL2" hover="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}">PL2</anchor>, <anchor link="PL1" hover="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}">PL1</anchor>, <anchor link="PL0" hover="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}">PL0</anchor>};</pstext>
    </ps>
    <ps name="shared/functions/system/ProcState" mylink="shared.functions.system.ProcState" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">type <anchor link="ProcState" hover="type ProcState is ( bits (1) N, bits (1) Z, bits (1) C, bits (1) V, bits (1) D, bits (1) A, bits (1) I, bits (1) F, bits (1) PAN, bits (1) UAO, bits (1) DIT, bits (1) TCO, bits (2) BTYPE, bits (1) ALLINT, bits (1) SS, bits (1) IL, bits (2) EL, bits (1) nRW, bits (1) SP, bits (1) Q, bits (4) GE, bits (1) SSBS, bits (8) IT, bits (1) J, bits (1) T, bits (1) E, bits (5) M )">ProcState</anchor> is (
    bits (1) N,        // Negative condition flag
    bits (1) Z,        // Zero condition flag
    bits (1) C,        // Carry condition flag
    bits (1) V,        // Overflow condition flag
    bits (1) D,        // Debug mask bit                     [AArch64 only]
    bits (1) A,        // SError interrupt mask bit
    bits (1) I,        // IRQ mask bit
    bits (1) F,        // FIQ mask bit
    bits (1) PAN,      // Privileged Access Never Bit        [v8.1]
    bits (1) UAO,      // User Access Override               [v8.2]
    bits (1) DIT,      // Data Independent Timing            [v8.4]
    bits (1) TCO,      // Tag Check Override                 [v8.5, AArch64 only]
    bits (2) BTYPE,    // Branch Type                        [v8.5]
    bits (1) ALLINT,   // Interrupt mask bit
    bits (1) SS,       // Software step bit
    bits (1) IL,       // Illegal Execution state bit
    bits (2) EL,       // Exception level
    bits (1) nRW,      // not Register Width: 0=64, 1=32
    bits (1) <a link="impl-aarch32.SP.write.none" file="shared_pseudocode.xml" hover="accessor: SP = bits(32) value">SP</a>,       // Stack pointer select: 0=SP0, 1=SPx [AArch64 only]
    bits (1) Q,        // Cumulative saturation flag         [AArch32 only]
    bits (4) GE,       // Greater than or Equal flags        [AArch32 only]
    bits (1) SSBS,     // Speculative Store Bypass Safe
    bits (8) IT,       // If-then bits, RES0 in CPSR         [AArch32 only]
    bits (1) J,        // J bit, RES0                        [AArch32 only, RES0 in SPSR and CPSR]
    bits (1) T,        // T32 bit, RES0 in CPSR              [AArch32 only]
    bits (1) E,        // Endianness bit                     [AArch32 only]
    bits (5) M         // Mode field                         [AArch32 only]
)</pstext>
    </ps>
    <ps name="shared/functions/system/RestoredITBits" mylink="shared.functions.system.RestoredITBits" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// RestoredITBits()
// ================
// Get the value of PSTATE.IT to be restored on this exception return.

bits(8) <anchor link="impl-shared.RestoredITBits.1" hover="function: bits(8) RestoredITBits(bits(N) spsr)">RestoredITBits</anchor>(bits(N) spsr)
    it = spsr&lt;15:10,26:25&gt;;

    // When PSTATE.IL is set, it is CONSTRAINED UNPREDICTABLE whether the IT bits are each set
    // to zero or copied from the SPSR.
    if PSTATE.IL == '1' then
        if <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_ILZEROIT" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_ILZEROIT</a>) then return '00000000';
        else return it;

    // The IT bits are forced to zero when they are set to a reserved value.
    if !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(it&lt;7:4&gt;) &amp;&amp; <a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(it&lt;3:0&gt;) then
        return '00000000';

    // The IT bits are forced to zero when returning to A32 state, or when returning to an EL
    // with the ITD bit set to 1, and the IT bits are describing a multi-instruction block.
    itd = if PSTATE.EL == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then HSCTLR.ITD else SCTLR.ITD;
    if (spsr&lt;5&gt; == '0' &amp;&amp; !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(it)) || (itd == '1' &amp;&amp; !<a link="impl-shared.IsZero.1" file="shared_pseudocode.xml" hover="function: boolean IsZero(bits(N) x)">IsZero</a>(it&lt;2:0&gt;)) then
        return '00000000';
    else
        return it;</pstext>
    </ps>
    <ps name="shared/functions/system/SCRType" mylink="shared.functions.system.SCRType" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">type <anchor link="SCRType" hover="type SCRType">SCRType</anchor>;</pstext>
    </ps>
    <ps name="shared/functions/system/SCR_GEN" mylink="shared.functions.system.SCR_GEN" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SCR_GEN[]
// =========

SCRType <anchor link="impl-shared.SCR_GEN.read.0" hover="accessor: SCRType SCR_GEN[]">SCR_GEN</anchor>[]
    // AArch32 secure &amp; AArch64 EL3 registers are not architecturally mapped
    assert <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>);
    bits(64) r;
    if !<a link="impl-shared.HaveAArch64.0" file="shared_pseudocode.xml" hover="function: boolean HaveAArch64()">HaveAArch64</a>() then
        r = <a link="impl-shared.ZeroExtend.1" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(SCR);
    else
        r = SCR_EL3;
    return r;</pstext>
    </ps>
    <ps name="shared/functions/system/SecureOnlyImplementation" mylink="shared.functions.system.SecureOnlyImplementation" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SecureOnlyImplementation()
// ==========================
// Returns TRUE if the security state is always Secure for this implementation.

boolean <anchor link="impl-shared.SecureOnlyImplementation.0" hover="function: boolean SecureOnlyImplementation()">SecureOnlyImplementation</anchor>()
    return boolean IMPLEMENTATION_DEFINED "Secure-only implementation";</pstext>
    </ps>
    <ps name="shared/functions/system/SecurityState" mylink="shared.functions.system.SecurityState" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="SecurityState" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</anchor> {
    <anchor link="SS_NonSecure" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</anchor>,
    <anchor link="SS_Secure" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</anchor>
};</pstext>
    </ps>
    <ps name="shared/functions/system/SecurityStateAtEL" mylink="shared.functions.system.SecurityStateAtEL" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SecurityStateAtEL()
// ===================
// Returns the effective security state at the exception level based off current settings.

SecurityState <anchor link="impl-shared.SecurityStateAtEL.1" hover="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</anchor>(bits(2) EL)
    if !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
        if <a link="impl-shared.SecureOnlyImplementation.0" file="shared_pseudocode.xml" hover="function: boolean SecureOnlyImplementation()">SecureOnlyImplementation</a>() then
            return <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>;
        else
            return <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a>;
    elsif EL == <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> then
        return <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>;
    else
        // For EL2 call only when EL2 is enabled in current security state
        assert(EL != <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> || <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>());
        if !<a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
            return if SCR_EL3.NS == '1' then <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a> else <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>;
        else
            return if SCR.NS == '1' then <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a> else <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>;</pstext>
    </ps>
    <ps name="shared/functions/system/SendEvent" mylink="shared.functions.system.SendEvent" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Signal an event to all PEs in a multiprocessor system to set their Event Registers.
// When a PE executes the SEV instruction, it causes this function to be executed.
<anchor link="impl-shared.SendEvent.0" hover="function: SendEvent()">SendEvent</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/system/SendEventLocal" mylink="shared.functions.system.SendEventLocal" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SendEventLocal()
// ================
// Set the local Event Register of this PE.
// When a PE executes the SEVL instruction, it causes this function to be executed.

<anchor link="impl-shared.SendEventLocal.0" hover="function: SendEventLocal()">SendEventLocal</anchor>()
    EventRegister = '1';
    return;</pstext>
    </ps>
    <ps name="shared/functions/system/SetAccumulatedFPExceptions" mylink="shared.functions.system.SetAccumulatedFPExceptions" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Stores FP Exceptions accumulated by the PE.
<anchor link="impl-shared.SetAccumulatedFPExceptions.1" hover="function: SetAccumulatedFPExceptions(bits(8) accumulated_exceptions)">SetAccumulatedFPExceptions</anchor>(bits(8) accumulated_exceptions);</pstext>
    </ps>
    <ps name="shared/functions/system/SetPSTATEFromPSR" mylink="shared.functions.system.SetPSTATEFromPSR" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SetPSTATEFromPSR()
// ==================

<anchor link="impl-shared.SetPSTATEFromPSR.1" hover="function: SetPSTATEFromPSR(bits(N) spsr)">SetPSTATEFromPSR</anchor>(bits(N) spsr)
    boolean illegal_psr_state = <a link="impl-shared.IllegalExceptionReturn.1" file="shared_pseudocode.xml" hover="function: boolean IllegalExceptionReturn(bits(N) spsr)">IllegalExceptionReturn</a>(spsr);
    <a link="impl-shared.SetPSTATEFromPSR.2" file="shared_pseudocode.xml" hover="function: SetPSTATEFromPSR(bits(N) spsr_in, boolean illegal_psr_state)">SetPSTATEFromPSR</a>(spsr, illegal_psr_state);

// SetPSTATEFromPSR()
// ==================
// Set PSTATE based on a PSR value

<anchor link="impl-shared.SetPSTATEFromPSR.2" hover="function: SetPSTATEFromPSR(bits(N) spsr_in, boolean illegal_psr_state)">SetPSTATEFromPSR</anchor>(bits(N) spsr_in, boolean illegal_psr_state)
    bits(N) spsr = spsr_in;
    boolean from_aarch64 = !<a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>();
    assert N == (if from_aarch64 then 64 else 32);
    PSTATE.SS = <a link="impl-shared.DebugExceptionReturnSS.1" file="shared_pseudocode.xml" hover="function: bit DebugExceptionReturnSS(bits(N) spsr)">DebugExceptionReturnSS</a>(spsr);
    ShouldAdvanceSS = FALSE;
    if illegal_psr_state then
        PSTATE.IL = '1';
        if <a link="impl-shared.HaveSSBSExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = bit UNKNOWN;
        if <a link="impl-shared.HaveBTIExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveBTIExt()">HaveBTIExt</a>() then PSTATE.BTYPE = bits(2) UNKNOWN;
        if <a link="impl-shared.HaveUAOExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveUAOExt()">HaveUAOExt</a>() then PSTATE.UAO = bit UNKNOWN;
        if <a link="impl-shared.HaveDITExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveDITExt()">HaveDITExt</a>() then PSTATE.DIT = bit UNKNOWN;
        if <a link="impl-shared.HaveMTEExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveMTEExt()">HaveMTEExt</a>() then PSTATE.TCO = bit UNKNOWN;
    else
        // State that is reinstated only on a legal exception return
        PSTATE.IL = spsr&lt;20&gt;;
        if spsr&lt;4&gt; == '1' then                    // AArch32 state
            <a link="AArch32.WriteMode.1" file="shared_pseudocode.xml" hover="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(spsr&lt;4:0&gt;);         // Sets PSTATE.EL correctly
            if <a link="impl-shared.HaveSSBSExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = spsr&lt;23&gt;;
        else                                      // AArch64 state
            PSTATE.nRW = '0';
            PSTATE.EL  = spsr&lt;3:2&gt;;
            PSTATE.SP  = spsr&lt;0&gt;;
            if <a link="impl-shared.HaveBTIExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveBTIExt()">HaveBTIExt</a>() then PSTATE.BTYPE = spsr&lt;11:10&gt;;
            if <a link="impl-shared.HaveSSBSExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = spsr&lt;12&gt;;
            if <a link="impl-shared.HaveUAOExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveUAOExt()">HaveUAOExt</a>() then PSTATE.UAO = spsr&lt;23&gt;;
            if <a link="impl-shared.HaveDITExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveDITExt()">HaveDITExt</a>() then PSTATE.DIT = spsr&lt;24&gt;;
            if <a link="impl-shared.HaveMTEExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveMTEExt()">HaveMTEExt</a>() then PSTATE.TCO = spsr&lt;25&gt;;

    // If PSTATE.IL is set, it is CONSTRAINED UNPREDICTABLE whether the T bit is set to zero or
    // copied from SPSR.
    if PSTATE.IL == '1' &amp;&amp; PSTATE.nRW == '1' then
        if <a link="impl-shared.ConstrainUnpredictableBool.1" file="shared_pseudocode.xml" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a link="Unpredictable_ILZEROT" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_ILZEROT</a>) then spsr&lt;5&gt; = '0';

    // State that is reinstated regardless of illegal exception return
    PSTATE.&lt;N,Z,C,V&gt; = spsr&lt;31:28&gt;;
    if <a link="impl-shared.HavePANExt.0" file="shared_pseudocode.xml" hover="function: boolean HavePANExt()">HavePANExt</a>() then PSTATE.PAN = spsr&lt;22&gt;;
    if PSTATE.nRW == '1' then                     // AArch32 state
        PSTATE.Q         = spsr&lt;27&gt;;
        PSTATE.IT        = <a link="impl-shared.RestoredITBits.1" file="shared_pseudocode.xml" hover="function: bits(8) RestoredITBits(bits(N) spsr)">RestoredITBits</a>(spsr);
        ShouldAdvanceIT  = FALSE;
        if <a link="impl-shared.HaveDITExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveDITExt()">HaveDITExt</a>() then PSTATE.DIT = (if (<a link="impl-shared.Restarting.0" file="shared_pseudocode.xml" hover="function: boolean Restarting()">Restarting</a>() || from_aarch64) then spsr&lt;24&gt; else spsr&lt;21&gt;);
        PSTATE.GE        = spsr&lt;19:16&gt;;
        PSTATE.E         = spsr&lt;9&gt;;
        PSTATE.&lt;A,I,F&gt;   = spsr&lt;8:6&gt;;             // No PSTATE.D in AArch32 state
        PSTATE.T         = spsr&lt;5&gt;;               // PSTATE.J is RES0
    else                                          // AArch64 state
        if <a link="impl-shared.HaveFeatNMI.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatNMI()">HaveFeatNMI</a>() then PSTATE.ALLINT = spsr&lt;13&gt;;
        PSTATE.&lt;D,A,I,F&gt; = spsr&lt;9:6&gt;;             // No PSTATE.&lt;Q,IT,GE,E,T&gt; in AArch64 state
    return;</pstext>
    </ps>
    <ps name="shared/functions/system/ShouldAdvanceIT" mylink="shared.functions.system.ShouldAdvanceIT" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">boolean ShouldAdvanceIT;</pstext>
    </ps>
    <ps name="shared/functions/system/ShouldAdvanceSS" mylink="shared.functions.system.ShouldAdvanceSS" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">boolean ShouldAdvanceSS;</pstext>
    </ps>
    <ps name="shared/functions/system/SpeculationBarrier" mylink="shared.functions.system.SpeculationBarrier" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions"><anchor link="impl-shared.SpeculationBarrier.0" hover="function: SpeculationBarrier()">SpeculationBarrier</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/system/SynchronizeContext" mylink="shared.functions.system.SynchronizeContext" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions"><anchor link="impl-shared.SynchronizeContext.0" hover="function: SynchronizeContext()">SynchronizeContext</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/system/SynchronizeErrors" mylink="shared.functions.system.SynchronizeErrors" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Implements the error synchronization event.
<anchor link="impl-shared.SynchronizeErrors.0" hover="function: SynchronizeErrors()">SynchronizeErrors</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/system/TakeUnmaskedPhysicalSErrorInterrupts" mylink="shared.functions.system.TakeUnmaskedPhysicalSErrorInterrupts" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Take any pending unmasked physical SError interrupt.
<anchor link="impl-shared.TakeUnmaskedPhysicalSErrorInterrupts.1" hover="function: TakeUnmaskedPhysicalSErrorInterrupts(boolean iesb_req)">TakeUnmaskedPhysicalSErrorInterrupts</anchor>(boolean iesb_req);</pstext>
    </ps>
    <ps name="shared/functions/system/TakeUnmaskedSErrorInterrupts" mylink="shared.functions.system.TakeUnmaskedSErrorInterrupts" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Take any pending unmasked physical SError interrupt or unmasked virtual SError
// interrupt.
<anchor link="impl-shared.TakeUnmaskedSErrorInterrupts.0" hover="function: TakeUnmaskedSErrorInterrupts()">TakeUnmaskedSErrorInterrupts</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/system/ThisInstr" mylink="shared.functions.system.ThisInstr" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">bits(32) <anchor link="impl-shared.ThisInstr.0" hover="function: bits(32) ThisInstr()">ThisInstr</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/system/ThisInstrLength" mylink="shared.functions.system.ThisInstrLength" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">integer <anchor link="impl-shared.ThisInstrLength.0" hover="function: integer ThisInstrLength()">ThisInstrLength</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/system/Unreachable" mylink="shared.functions.system.Unreachable" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions"><anchor link="impl-shared.Unreachable.0" hover="function: Unreachable()">Unreachable</anchor>()
    assert FALSE;</pstext>
    </ps>
    <ps name="shared/functions/system/UsingAArch32" mylink="shared.functions.system.UsingAArch32" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// UsingAArch32()
// ==============
// Return TRUE if the current Exception level is using AArch32, FALSE if using AArch64.

boolean <anchor link="impl-shared.UsingAArch32.0" hover="function: boolean UsingAArch32()">UsingAArch32</anchor>()
    boolean aarch32 = (PSTATE.nRW == '1');
    if !<a link="impl-shared.HaveAArch32.0" file="shared_pseudocode.xml" hover="function: boolean HaveAArch32()">HaveAArch32</a>() then assert !aarch32;
    if !<a link="impl-shared.HaveAArch64.0" file="shared_pseudocode.xml" hover="function: boolean HaveAArch64()">HaveAArch64</a>() then assert aarch32;
    return aarch32;</pstext>
    </ps>
    <ps name="shared/functions/system/VirtualFIQPending" mylink="shared.functions.system.VirtualFIQPending" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns TRUE if there is any pending virtual FIQ.
boolean <anchor link="impl-shared.VirtualFIQPending.0" hover="function: boolean VirtualFIQPending()">VirtualFIQPending</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/system/VirtualIRQPending" mylink="shared.functions.system.VirtualIRQPending" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Returns TRUE if there is any pending virtual IRQ.
boolean <anchor link="impl-shared.VirtualIRQPending.0" hover="function: boolean VirtualIRQPending()">VirtualIRQPending</anchor>();</pstext>
    </ps>
    <ps name="shared/functions/system/WFxType" mylink="shared.functions.system.WFxType" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="WFxType" hover="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType</anchor> {<anchor link="WFxType_WFE" hover="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFE</anchor>, <anchor link="WFxType_WFI" hover="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFI</anchor>, <anchor link="WFxType_WFET" hover="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFET</anchor>, <anchor link="WFxType_WFIT" hover="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFIT</anchor>};</pstext>
    </ps>
    <ps name="shared/functions/system/WaitForEvent" mylink="shared.functions.system.WaitForEvent" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// WaitForEvent()
// ==============
// PE optionally suspends execution until one of the following occurs:
// - A WFE wake-up event.
// - A reset.
// - The implementation chooses to resume execution.
// - A Wait for Event with Timeout (WFET) is executing, and a local timeout event occurs
// It is IMPLEMENTATION DEFINED whether restarting execution after the period of
// suspension causes the Event Register to be cleared.

<anchor link="impl-shared.WaitForEvent.1" hover="function: WaitForEvent(integer localtimeout)">WaitForEvent</anchor>(integer localtimeout)
    if !(<a link="impl-shared.IsEventRegisterSet.0" file="shared_pseudocode.xml" hover="function: boolean IsEventRegisterSet()">IsEventRegisterSet</a>() || (<a link="impl-shared.HaveFeatWFxT.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatWFxT()">HaveFeatWFxT</a>() &amp;&amp; <a link="impl-shared.LocalTimeoutEvent.1" file="shared_pseudocode.xml" hover="function: boolean LocalTimeoutEvent(integer localtimeout)">LocalTimeoutEvent</a>(localtimeout))) then
        <a link="impl-shared.EnterLowPowerState.0" file="shared_pseudocode.xml" hover="function: EnterLowPowerState()">EnterLowPowerState</a>();
    return;</pstext>
    </ps>
    <ps name="shared/functions/system/WaitForInterrupt" mylink="shared.functions.system.WaitForInterrupt" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// WaitForInterrupt()
// ==================
// PE optionally suspends execution until one of the following occurs:
// - A WFI wake-up event.
// - A reset.
// - The implementation chooses to resume execution.
// - A Wait for Interrupt with Timeout (WFIT) is executing, and a local timeout event occurs.

<anchor link="impl-shared.WaitForInterrupt.1" hover="function: WaitForInterrupt(integer localtimeout)">WaitForInterrupt</anchor>(integer localtimeout)
    if !(<a link="impl-shared.HaveFeatWFxT.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatWFxT()">HaveFeatWFxT</a>() &amp;&amp; <a link="impl-shared.LocalTimeoutEvent.1" file="shared_pseudocode.xml" hover="function: boolean LocalTimeoutEvent(integer localtimeout)">LocalTimeoutEvent</a>(localtimeout)) then
        <a link="impl-shared.EnterLowPowerState.0" file="shared_pseudocode.xml" hover="function: EnterLowPowerState()">EnterLowPowerState</a>();
    return;</pstext>
    </ps>
    <ps name="shared/functions/unpredictable/ConstrainUnpredictable" mylink="shared.functions.unpredictable.ConstrainUnpredictable" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ConstrainUnpredictable()
// ========================
// Return the appropriate Constraint result to control the caller's behavior. The return value
// is IMPLEMENTATION DEFINED within a permitted list for each UNPREDICTABLE case.
// (The permitted list is determined by an assert or case statement at the call site.)

// NOTE: This version of the function uses an Unpredictable argument to define the call site.
// This argument does not appear in the version used in the Armv8 Architecture Reference Manual.
// The extra argument is used here to allow this example definition. This is an example only and
// does not imply a fixed implementation of these behaviors. Indeed the intention is that it should
// be defined by each implementation, according to its implementation choices.

Constraint <anchor link="impl-shared.ConstrainUnpredictable.1" hover="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</anchor>(<a link="Unpredictable" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable</a> which)
    case which of
        when <a link="Unpredictable_VMSR" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_VMSR</a>
            return <a link="Constraint_UNDEF" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNDEF</a>;
        when <a link="Unpredictable_WBOVERLAPLD" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_WBOVERLAPLD</a>
            return <a link="Constraint_WBSUPPRESS" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_WBSUPPRESS</a>; // return loaded value
        when <a link="Unpredictable_WBOVERLAPST" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_WBOVERLAPST</a>
            return <a link="Constraint_NONE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>;     // store pre-writeback value
        when <a link="Unpredictable_LDPOVERLAP" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_LDPOVERLAP</a>
            return <a link="Constraint_UNDEF" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNDEF</a>;    // instruction is UNDEFINED
        when <a link="Unpredictable_BASEOVERLAP" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_BASEOVERLAP</a>
            return <a link="Constraint_UNKNOWN" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>;  // use UNKNOWN address
        when <a link="Unpredictable_DATAOVERLAP" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_DATAOVERLAP</a>
            return <a link="Constraint_UNKNOWN" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>;  // store UNKNOWN value
        when <a link="Unpredictable_DEVPAGE2" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_DEVPAGE2</a>
            return <a link="Constraint_FAULT" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a>;    // take an alignment fault
        when <a link="Unpredictable_DEVICETAGSTORE" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_DEVICETAGSTORE</a>
            return <a link="Constraint_NONE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>;     // Do not take a fault
        when <a link="Unpredictable_INSTRDEVICE" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_INSTRDEVICE</a>
            return <a link="Constraint_NONE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>;     // Do not take a fault
        when <a link="Unpredictable_RESCPACR" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESCPACR</a>
            return <a link="Constraint_TRUE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>;     // Map to UNKNOWN value
        when <a link="Unpredictable_RESMAIR" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESMAIR</a>
            return <a link="Constraint_UNKNOWN" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>;  // Map to UNKNOWN value
        when <a link="Unpredictable_S1CTAGGED" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_S1CTAGGED</a>
            return <a link="Constraint_FALSE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;    // SCTLR_ELx.C == '0' marks address as untagged
        when <a link="Unpredictable_S2RESMEMATTR" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_S2RESMEMATTR</a>
            return <a link="Constraint_NC" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NC</a>;       // Map to Noncacheable value
        when <a link="Unpredictable_RESTEXCB" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESTEXCB</a>
            return <a link="Constraint_UNKNOWN" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>;  // Map to UNKNOWN value
        when <a link="Unpredictable_RESDACR" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESDACR</a>
            return <a link="Constraint_UNKNOWN" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>;  // Map to UNKNOWN value
        when <a link="Unpredictable_RESPRRR" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESPRRR</a>
            return <a link="Constraint_UNKNOWN" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>;  // Map to UNKNOWN value
        when <a link="Unpredictable_RESVTCRS" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESVTCRS</a>
            return <a link="Constraint_UNKNOWN" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>;  // Map to UNKNOWN value
        when <a link="Unpredictable_RESTnSZ" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESTnSZ</a>
            return <a link="Constraint_FORCE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FORCE</a>;    // Map to the limit value
        when <a link="Unpredictable_OORTnSZ" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_OORTnSZ</a>
            return <a link="Constraint_FORCE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FORCE</a>;    // Map to the limit value
        when <a link="Unpredictable_LARGEIPA" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_LARGEIPA</a>
            return <a link="Constraint_FORCE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FORCE</a>;    // Restrict the IA size to the PAMax value
        when <a link="Unpredictable_ESRCONDPASS" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_ESRCONDPASS</a>
            return <a link="Constraint_FALSE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;    // Report as "AL"
        when <a link="Unpredictable_ILZEROIT" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_ILZEROIT</a>
            return <a link="Constraint_FALSE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;    // Do not zero PSTATE.IT
        when <a link="Unpredictable_ILZEROT" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_ILZEROT</a>
            return <a link="Constraint_FALSE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;    // Do not zero PSTATE.T
        when <a link="Unpredictable_BPVECTORCATCHPRI" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_BPVECTORCATCHPRI</a>
            return <a link="Constraint_TRUE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>;     // Debug Vector Catch: match on 2nd halfword
        when <a link="Unpredictable_VCMATCHHALF" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_VCMATCHHALF</a>
            return <a link="Constraint_FALSE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;    // No match
        when <a link="Unpredictable_VCMATCHDAPA" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_VCMATCHDAPA</a>
            return <a link="Constraint_FALSE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;    // No match on Data Abort or Prefetch abort
        when <a link="Unpredictable_WPMASKANDBAS" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_WPMASKANDBAS</a>
            return <a link="Constraint_FALSE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;    // Watchpoint disabled
        when <a link="Unpredictable_WPBASCONTIGUOUS" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_WPBASCONTIGUOUS</a>
            return <a link="Constraint_FALSE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;    // Watchpoint disabled
        when <a link="Unpredictable_RESWPMASK" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESWPMASK</a>
            return <a link="Constraint_DISABLED" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>; // Watchpoint disabled
        when <a link="Unpredictable_WPMASKEDBITS" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_WPMASKEDBITS</a>
            return <a link="Constraint_FALSE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;    // Watchpoint disabled
        when <a link="Unpredictable_RESBPWPCTRL" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESBPWPCTRL</a>
            return <a link="Constraint_DISABLED" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>; // Breakpoint/watchpoint disabled
        when <a link="Unpredictable_BPNOTIMPL" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_BPNOTIMPL</a>
            return <a link="Constraint_DISABLED" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>; // Breakpoint disabled
        when <a link="Unpredictable_RESBPTYPE" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESBPTYPE</a>
            return <a link="Constraint_DISABLED" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>; // Breakpoint disabled
        when <a link="Unpredictable_BPNOTCTXCMP" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_BPNOTCTXCMP</a>
            return <a link="Constraint_DISABLED" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>; // Breakpoint disabled
        when <a link="Unpredictable_BPMATCHHALF" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_BPMATCHHALF</a>
            return <a link="Constraint_FALSE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;    // No match
        when <a link="Unpredictable_BPMISMATCHHALF" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_BPMISMATCHHALF</a>
            return <a link="Constraint_FALSE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;    // No match
        when <a link="Unpredictable_RESTARTALIGNPC" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESTARTALIGNPC</a>
            return <a link="Constraint_FALSE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;    // Do not force alignment
        when <a link="Unpredictable_RESTARTZEROUPPERPC" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESTARTZEROUPPERPC</a>
            return <a link="Constraint_TRUE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>;     // Force zero extension
        when <a link="Unpredictable_ZEROUPPER" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_ZEROUPPER</a>
            return <a link="Constraint_TRUE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>;     // zero top halves of X registers
        when <a link="Unpredictable_ERETZEROUPPERPC" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_ERETZEROUPPERPC</a>
            return <a link="Constraint_TRUE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>;     // zero top half of PC
        when <a link="Unpredictable_A32FORCEALIGNPC" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_A32FORCEALIGNPC</a>
            return <a link="Constraint_FALSE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;    // Do not force alignment
        when <a link="Unpredictable_SMD" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_SMD</a>
            return <a link="Constraint_UNDEF" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNDEF</a>;    // disabled SMC is Unallocated
        when <a link="Unpredictable_NVNV1" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_NVNV1</a>
            return <a link="Constraint_NVNV1_00" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NVNV1_00</a>; // Map unpredictable configuration of HCR_EL2&lt;NV,NV1&gt;
                                        // to NV = 0 and NV1 = 0
        when <a link="Unpredictable_Shareability" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_Shareability</a>
            return <a link="Constraint_OSH" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_OSH</a>;      // Map reserved encoding of shareability to outer shareable
        when <a link="Unpredictable_AFUPDATE" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_AFUPDATE</a>     // AF update for alignment or permission fault
            return <a link="Constraint_TRUE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>;
        when <a link="Unpredictable_IESBinDebug" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_IESBinDebug</a>  // Use SCTLR[].IESB in Debug state
            return <a link="Constraint_TRUE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>;
        when <a link="Unpredictable_BADPMSFCR" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_BADPMSFCR</a>    // Bad settings for PMSFCR_EL1/PMSEVFR_EL1/PMSLATFR_EL1
            return <a link="Constraint_TRUE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>;
        when <a link="Unpredictable_ZEROBTYPE" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_ZEROBTYPE</a>
            return <a link="Constraint_TRUE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>;     // Save BTYPE in SPSR_ELx/DPSR_EL0 as '00'
        when <a link="Unpredictable_CLEARERRITEZERO" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_CLEARERRITEZERO</a> // Clearing sticky errors when instruction in flight
            return <a link="Constraint_FALSE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;
        when <a link="Unpredictable_ALUEXCEPTIONRETURN" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_ALUEXCEPTIONRETURN</a>
            return <a link="Constraint_UNDEF" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNDEF</a>;
        when <a link="Unpredictable_DBGxVR_RESS" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_DBGxVR_RESS</a>
            return <a link="Constraint_FALSE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;
        when <a link="Unpredictable_PMSCR_PCT" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_PMSCR_PCT</a>
            return <a link="Constraint_PMSCR_PCT_VIRT" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_PMSCR_PCT_VIRT</a>;
        when <a link="Unpredictable_WFxTDEBUG" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_WFxTDEBUG</a>
            return <a link="Constraint_FALSE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;    // WFxT in Debug state does not execute as a NOP
        when <a link="Unpredictable_LS64UNSUPPORTED" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_LS64UNSUPPORTED</a>
            return <a link="Constraint_LIMITED_ATOMICITY" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_LIMITED_ATOMICITY</a>; // Accesses are not single-copy atomic above the byte level
       // Misaligned exclusives, atomics, acquire/release to region that is not Normal Cacheable WB are atomic
        when <a link="Unpredictable_MISALIGNEDATOMIC" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_MISALIGNEDATOMIC</a>
            return <a link="Constraint_FALSE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;

        when <a link="Unpredictable_IGNORETRAPINDEBUG" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_IGNORETRAPINDEBUG</a>
            return <a link="Constraint_TRUE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>;     // Trap to register access in debug state is ignored
        when <a link="Unpredictable_PMUEVENTCOUNTER" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_PMUEVENTCOUNTER</a>
            return <a link="Constraint_UNDEF" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNDEF</a>;    // Accesses to the register are UNDEFINED</pstext>
    </ps>
    <ps name="shared/functions/unpredictable/ConstrainUnpredictableBits" mylink="shared.functions.unpredictable.ConstrainUnpredictableBits" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ConstrainUnpredictableBits()
// ============================

// This is a variant of ConstrainUnpredictable for when the result can be Constraint_UNKNOWN.
// If the result is Constraint_UNKNOWN then the function also returns UNKNOWN value, but that
// value is always an allocated value; that is, one for which the behavior is not itself
// CONSTRAINED.

// NOTE: This version of the function uses an Unpredictable argument to define the call site.
// This argument does not appear in the version used in the Armv8 Architecture Reference Manual.
// See the NOTE on ConstrainUnpredictable() for more information.

// This is an example placeholder only and does not imply a fixed implementation of the bits part
// of the result, and may not be applicable in all cases.

(Constraint,bits(width)) <anchor link="impl-shared.ConstrainUnpredictableBits.1" hover="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</anchor>(<a link="Unpredictable" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable</a> which)

    c = <a link="impl-shared.ConstrainUnpredictable.1" file="shared_pseudocode.xml" hover="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(which);

    if c == <a link="Constraint_UNKNOWN" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a> then
        return (c, <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(width));           // See notes; this is an example implementation only
    elsif c == <a link="Constraint_PMSCR_PCT_VIRT" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_PMSCR_PCT_VIRT</a> then
        return (c,<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(width));
    else
        return (c, bits(width) UNKNOWN);    // bits result not used</pstext>
    </ps>
    <ps name="shared/functions/unpredictable/ConstrainUnpredictableBool" mylink="shared.functions.unpredictable.ConstrainUnpredictableBool" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ConstrainUnpredictableBool()
// ============================

// This is a simple wrapper function for cases where the constrained result is either TRUE or FALSE.

// NOTE: This version of the function uses an Unpredictable argument to define the call site.
// This argument does not appear in the version used in the Armv8 Architecture Reference Manual.
// See the NOTE on ConstrainUnpredictable() for more information.

boolean <anchor link="impl-shared.ConstrainUnpredictableBool.1" hover="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</anchor>(<a link="Unpredictable" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable</a> which)

    c = <a link="impl-shared.ConstrainUnpredictable.1" file="shared_pseudocode.xml" hover="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(which);
    assert c IN {<a link="Constraint_TRUE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>, <a link="Constraint_FALSE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>};
    return (c == <a link="Constraint_TRUE" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>);</pstext>
    </ps>
    <ps name="shared/functions/unpredictable/ConstrainUnpredictableInteger" mylink="shared.functions.unpredictable.ConstrainUnpredictableInteger" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ConstrainUnpredictableInteger()
// ===============================

// This is a variant of ConstrainUnpredictable for when the result can be Constraint_UNKNOWN. If
// the result is Constraint_UNKNOWN then the function also returns an UNKNOWN value in the range
// low to high, inclusive.

// NOTE: This version of the function uses an Unpredictable argument to define the call site.
// This argument does not appear in the version used in the Armv8 Architecture Reference Manual.
// See the NOTE on ConstrainUnpredictable() for more information.

// This is an example placeholder only and does not imply a fixed implementation of the integer part
// of the result.

(Constraint,integer) <anchor link="impl-shared.ConstrainUnpredictableInteger.3" hover="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high, Unpredictable which)">ConstrainUnpredictableInteger</anchor>(integer low, integer high, <a link="Unpredictable" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable</a> which)

    c = <a link="impl-shared.ConstrainUnpredictable.1" file="shared_pseudocode.xml" hover="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(which);

    if c == <a link="Constraint_UNKNOWN" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a> then
        return (c, low);                // See notes; this is an example implementation only
    else
        return (c, integer UNKNOWN);    // integer result not used</pstext>
    </ps>
    <ps name="shared/functions/unpredictable/Constraint" mylink="shared.functions.unpredictable.Constraint" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="Constraint" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint</anchor>    {// General
                           <anchor link="Constraint_NONE" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</anchor>,              // Instruction executes with
                                                         //   no change or side-effect to its described behavior
                           <anchor link="Constraint_UNKNOWN" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</anchor>,           // Destination register has UNKNOWN value
                           <anchor link="Constraint_UNDEF" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNDEF</anchor>,             // Instruction is UNDEFINED
                           <anchor link="Constraint_UNDEFEL0" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNDEFEL0</anchor>,          // Instruction is UNDEFINED at EL0 only
                           <anchor link="Constraint_NOP" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NOP</anchor>,               // Instruction executes as NOP
                           <anchor link="Constraint_TRUE" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</anchor>,
                           <anchor link="Constraint_FALSE" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</anchor>,
                           <anchor link="Constraint_DISABLED" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</anchor>,
                           <anchor link="Constraint_UNCOND" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNCOND</anchor>,            // Instruction executes unconditionally
                           <anchor link="Constraint_COND" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_COND</anchor>,              // Instruction executes conditionally
                           <anchor link="Constraint_ADDITIONAL_DECODE" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_ADDITIONAL_DECODE</anchor>, // Instruction executes with additional decode
                           // Load-store
                           <anchor link="Constraint_WBSUPPRESS" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_WBSUPPRESS</anchor>,
                           <anchor link="Constraint_FAULT" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</anchor>,
                           <anchor link="Constraint_LIMITED_ATOMICITY" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_LIMITED_ATOMICITY</anchor>, // Accesses are not single-copy atomic above the byte level
                           <anchor link="Constraint_NVNV1_00" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NVNV1_00</anchor>,
                           <anchor link="Constraint_NVNV1_01" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NVNV1_01</anchor>,
                           <anchor link="Constraint_NVNV1_11" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NVNV1_11</anchor>,
                           <anchor link="Constraint_OSH" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_OSH</anchor>,               // Constrain to Outer shareable
                           <anchor link="Constraint_ISH" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_ISH</anchor>,               // Constrain to Inner shareable
                           <anchor link="Constraint_NSH" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NSH</anchor>,               // Constrain to Nonshareable

                           <anchor link="Constraint_NC" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NC</anchor>,                // Constrain to Noncacheable
                           <anchor link="Constraint_WT" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_WT</anchor>,                // Constrain to Writethrough
                           <anchor link="Constraint_WB" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_WB</anchor>,                // Constrain to Writeback

                           // IPA too large
                           <anchor link="Constraint_FORCE" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FORCE</anchor>, <anchor link="Constraint_FORCENOSLCHECK" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FORCENOSLCHECK</anchor>,
                           // PMSCR_PCT reserved values select Virtual timestamp
                           <anchor link="Constraint_PMSCR_PCT_VIRT" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_PMSCR_PCT_VIRT</anchor>};</pstext>
    </ps>
    <ps name="shared/functions/unpredictable/Unpredictable" mylink="shared.functions.unpredictable.Unpredictable" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="Unpredictable" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable</anchor> {// VMSR on MVFR
                           <anchor link="Unpredictable_VMSR" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_VMSR</anchor>,
                           // Writeback/transfer register overlap (load)
                           <anchor link="Unpredictable_WBOVERLAPLD" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_WBOVERLAPLD</anchor>,
                           // Writeback/transfer register overlap (store)
                           <anchor link="Unpredictable_WBOVERLAPST" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_WBOVERLAPST</anchor>,
                           // Load Pair transfer register overlap
                           <anchor link="Unpredictable_LDPOVERLAP" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_LDPOVERLAP</anchor>,
                           // Store-exclusive base/status register overlap
                           <anchor link="Unpredictable_BASEOVERLAP" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_BASEOVERLAP</anchor>,
                           // Store-exclusive data/status register overlap
                           <anchor link="Unpredictable_DATAOVERLAP" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_DATAOVERLAP</anchor>,
                           // Load-store alignment checks
                           <anchor link="Unpredictable_DEVPAGE2" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_DEVPAGE2</anchor>,
                           // Instruction fetch from Device memory
                           <anchor link="Unpredictable_INSTRDEVICE" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_INSTRDEVICE</anchor>,
                           // Reserved CPACR value
                           <anchor link="Unpredictable_RESCPACR" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESCPACR</anchor>,
                           // Reserved MAIR value
                           <anchor link="Unpredictable_RESMAIR" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESMAIR</anchor>,
                           // Effect of SCTLR_ELx.C on Tagged attribute
                           <anchor link="Unpredictable_S1CTAGGED" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_S1CTAGGED</anchor>,
                           // Reserved Stage 2 MemAttr value
                           <anchor link="Unpredictable_S2RESMEMATTR" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_S2RESMEMATTR</anchor>,
                           // Reserved TEX:C:B value
                           <anchor link="Unpredictable_RESTEXCB" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESTEXCB</anchor>,
                           // Reserved PRRR value
                           <anchor link="Unpredictable_RESPRRR" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESPRRR</anchor>,
                           // Reserved DACR field
                           <anchor link="Unpredictable_RESDACR" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESDACR</anchor>,
                           // Reserved VTCR.S value
                           <anchor link="Unpredictable_RESVTCRS" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESVTCRS</anchor>,
                           // Reserved TCR.TnSZ value
                           <anchor link="Unpredictable_RESTnSZ" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESTnSZ</anchor>,
                           // Reserved SCTLR_ELx.TCF value
                           <anchor link="Unpredictable_RESTCF" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESTCF</anchor>,
                           // Tag stored to Device memory
                           <anchor link="Unpredictable_DEVICETAGSTORE" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_DEVICETAGSTORE</anchor>,
                           // Out-of-range TCR.TnSZ value
                           <anchor link="Unpredictable_OORTnSZ" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_OORTnSZ</anchor>,
                           // IPA size exceeds PA size
                           <anchor link="Unpredictable_LARGEIPA" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_LARGEIPA</anchor>,
                           // Syndrome for a known-passing conditional A32 instruction
                           <anchor link="Unpredictable_ESRCONDPASS" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_ESRCONDPASS</anchor>,
                           // Illegal State exception: zero PSTATE.IT
                           <anchor link="Unpredictable_ILZEROIT" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_ILZEROIT</anchor>,
                           // Illegal State exception: zero PSTATE.T
                           <anchor link="Unpredictable_ILZEROT" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_ILZEROT</anchor>,
                           // Debug: prioritization of Vector Catch
                           <anchor link="Unpredictable_BPVECTORCATCHPRI" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_BPVECTORCATCHPRI</anchor>,
                           // Debug Vector Catch: match on 2nd halfword
                           <anchor link="Unpredictable_VCMATCHHALF" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_VCMATCHHALF</anchor>,
                           // Debug Vector Catch: match on Data Abort or Prefetch abort
                           <anchor link="Unpredictable_VCMATCHDAPA" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_VCMATCHDAPA</anchor>,
                           // Debug watchpoints: non-zero MASK and non-ones BAS
                           <anchor link="Unpredictable_WPMASKANDBAS" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_WPMASKANDBAS</anchor>,
                           // Debug watchpoints: non-contiguous BAS
                           <anchor link="Unpredictable_WPBASCONTIGUOUS" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_WPBASCONTIGUOUS</anchor>,
                           // Debug watchpoints: reserved MASK
                           <anchor link="Unpredictable_RESWPMASK" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESWPMASK</anchor>,
                           // Debug watchpoints: non-zero MASKed bits of address
                           <anchor link="Unpredictable_WPMASKEDBITS" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_WPMASKEDBITS</anchor>,
                           // Debug breakpoints and watchpoints: reserved control bits
                           <anchor link="Unpredictable_RESBPWPCTRL" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESBPWPCTRL</anchor>,
                           // Debug breakpoints: not implemented
                           <anchor link="Unpredictable_BPNOTIMPL" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_BPNOTIMPL</anchor>,
                           // Debug breakpoints: reserved type
                           <anchor link="Unpredictable_RESBPTYPE" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESBPTYPE</anchor>,
                           // Debug breakpoints: not-context-aware breakpoint
                           <anchor link="Unpredictable_BPNOTCTXCMP" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_BPNOTCTXCMP</anchor>,
                           // Debug breakpoints: match on 2nd halfword of instruction
                           <anchor link="Unpredictable_BPMATCHHALF" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_BPMATCHHALF</anchor>,
                           // Debug breakpoints: mismatch on 2nd halfword of instruction
                           <anchor link="Unpredictable_BPMISMATCHHALF" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_BPMISMATCHHALF</anchor>,
                           // Debug: restart to a misaligned AArch32 PC value
                           <anchor link="Unpredictable_RESTARTALIGNPC" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESTARTALIGNPC</anchor>,
                           // Debug: restart to a not-zero-extended AArch32 PC value
                           <anchor link="Unpredictable_RESTARTZEROUPPERPC" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESTARTZEROUPPERPC</anchor>,
                           // Zero top 32 bits of X registers in AArch32 state
                           <anchor link="Unpredictable_ZEROUPPER" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_ZEROUPPER</anchor>,
                           // Zero top 32 bits of PC on illegal return to AArch32 state
                           <anchor link="Unpredictable_ERETZEROUPPERPC" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_ERETZEROUPPERPC</anchor>,
                           // Force address to be aligned when interworking branch to A32 state
                           <anchor link="Unpredictable_A32FORCEALIGNPC" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_A32FORCEALIGNPC</anchor>,
                           // SMC disabled
                           <anchor link="Unpredictable_SMD" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_SMD</anchor>,
                           // HCR_EL2.&lt;NV,NV1&gt; == '01'
                           <anchor link="Unpredictable_NVNV1" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_NVNV1</anchor>,
                           // Reserved shareability encoding
                           <anchor link="Unpredictable_Shareability" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_Shareability</anchor>,
                           // Access Flag Update by HW
                           <anchor link="Unpredictable_AFUPDATE" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_AFUPDATE</anchor>,
                           // Consider SCTLR[].IESB in Debug state
                           <anchor link="Unpredictable_IESBinDebug" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_IESBinDebug</anchor>,
                           // Bad settings for PMSFCR_EL1/PMSEVFR_EL1/PMSLATFR_EL1
                           <anchor link="Unpredictable_BADPMSFCR" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_BADPMSFCR</anchor>,
                           // Zero saved BType value in SPSR_ELx/DPSR_EL0
                           <anchor link="Unpredictable_ZEROBTYPE" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_ZEROBTYPE</anchor>,
                           // Timestamp constrained to virtual or physical
                           <anchor link="Unpredictable_EL2TIMESTAMP" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_EL2TIMESTAMP</anchor>,
                           <anchor link="Unpredictable_EL1TIMESTAMP" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_EL1TIMESTAMP</anchor>,
                           // WFET or WFIT instruction in Debug state
                           <anchor link="Unpredictable_WFxTDEBUG" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_WFxTDEBUG</anchor>,
                           // Address does not support LS64 instructions
                           <anchor link="Unpredictable_LS64UNSUPPORTED" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_LS64UNSUPPORTED</anchor>,
                           // Misaligned exclusives, atomics, acquire/release to region that is not Normal Cacheable WB are atomic
                           <anchor link="Unpredictable_MISALIGNEDATOMIC" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_MISALIGNEDATOMIC</anchor>,
                           // Clearing DCC/ITR sticky flags when instruction is in flight
                           <anchor link="Unpredictable_CLEARERRITEZERO" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_CLEARERRITEZERO</anchor>,
                           // ALUEXCEPTIONRETURN when in user/system mode in A32 instructions
                           <anchor link="Unpredictable_ALUEXCEPTIONRETURN" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_ALUEXCEPTIONRETURN</anchor>,
                           // Trap to register in debug state are ignored
                           <anchor link="Unpredictable_IGNORETRAPINDEBUG" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_IGNORETRAPINDEBUG</anchor>,
                           // Compare DBGBVR.RESS for BP/WP
                           <anchor link="Unpredictable_DBGxVR_RESS" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_DBGxVR_RESS</anchor>,
                           // Inaccessible event counter
                           <anchor link="Unpredictable_PMUEVENTCOUNTER" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_PMUEVENTCOUNTER</anchor>,
                           // Reserved PMSCR.PCT behaviour.
                           <anchor link="Unpredictable_PMSCR_PCT" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_PMSCR_PCT</anchor>,
};</pstext>
    </ps>
    <ps name="shared/functions/vector/AdvSIMDExpandImm" mylink="shared.functions.vector.AdvSIMDExpandImm" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AdvSIMDExpandImm()
// ==================

bits(64) <anchor link="impl-shared.AdvSIMDExpandImm.3" hover="function: bits(64) AdvSIMDExpandImm(bit op, bits(4) cmode, bits(8) imm8)">AdvSIMDExpandImm</anchor>(bit op, bits(4) cmode, bits(8) imm8)
    bits(64) imm64;
    case cmode&lt;3:1&gt; of
        when '000'
            imm64 = <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(24):imm8, 2);
        when '001'
            imm64 = <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(16):imm8:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(8), 2);
        when '010'
            imm64 = <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(8):imm8:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(16), 2);
        when '011'
            imm64 = <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(24), 2);
        when '100'
            imm64 = <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(8):imm8, 4);
        when '101'
            imm64 = <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(8), 4);
        when '110'
            if cmode&lt;0&gt; == '0' then
                imm64 = <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(16):imm8:<a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(8), 2);
            else
                imm64 = <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(8):imm8:<a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(16), 2);
        when '111'
            if cmode&lt;0&gt; == '0' &amp;&amp; op == '0' then
                imm64 = <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8, 8);
            if cmode&lt;0&gt; == '0' &amp;&amp; op == '1' then
                imm8a = <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;7&gt;, 8); imm8b = <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;6&gt;, 8);
                imm8c = <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;5&gt;, 8); imm8d = <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;4&gt;, 8);
                imm8e = <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;3&gt;, 8); imm8f = <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;2&gt;, 8);
                imm8g = <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;1&gt;, 8); imm8h = <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;0&gt;, 8);
                imm64 = imm8a:imm8b:imm8c:imm8d:imm8e:imm8f:imm8g:imm8h;
            if cmode&lt;0&gt; == '1' &amp;&amp; op == '0' then
                imm32 = imm8&lt;7&gt;:NOT(imm8&lt;6&gt;):<a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;6&gt;,5):imm8&lt;5:0&gt;:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(19);
                imm64 = <a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm32, 2);
            if cmode&lt;0&gt; == '1' &amp;&amp; op == '1' then
                if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then ReservedEncoding();
                imm64 = imm8&lt;7&gt;:NOT(imm8&lt;6&gt;):<a link="impl-shared.Replicate.2" file="shared_pseudocode.xml" hover="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;6&gt;,8):imm8&lt;5:0&gt;:<a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(48);

    return imm64;</pstext>
    </ps>
    <ps name="shared/functions/vector/MatMulAdd" mylink="shared.functions.vector.MatMulAdd" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// MatMulAdd()
// ===========
//
// Signed or unsigned 8-bit integer matrix multiply and add to 32-bit integer matrix
// result[2, 2] = addend[2, 2] + (op1[2, 8] * op2[8, 2])

bits(N) <anchor link="impl-shared.MatMulAdd.5" hover="function: bits(N) MatMulAdd(bits(N) addend, bits(N) op1, bits(N) op2, boolean op1_unsigned, boolean op2_unsigned)">MatMulAdd</anchor>(bits(N) addend, bits(N) op1, bits(N) op2, boolean op1_unsigned, boolean op2_unsigned)
    assert N == 128;

    bits(N)  result;
    bits(32) sum;
    integer  prod;

    for i = 0 to 1
        for j = 0 to 1
            sum = <a link="impl-shared.Elem.read.3" file="shared_pseudocode.xml" hover="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[addend, 2*i + j, 32];
            for k = 0 to 7
                prod = <a link="impl-shared.Int.2" file="shared_pseudocode.xml" hover="function: integer Int(bits(N) x, boolean unsigned)">Int</a>(<a link="impl-shared.Elem.read.3" file="shared_pseudocode.xml" hover="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[op1, 8*i + k, 8], op1_unsigned) * <a link="impl-shared.Int.2" file="shared_pseudocode.xml" hover="function: integer Int(bits(N) x, boolean unsigned)">Int</a>(<a link="impl-shared.Elem.read.3" file="shared_pseudocode.xml" hover="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[op2, 8*j + k, 8], op2_unsigned);
                sum  = sum + prod;
            <a link="impl-shared.Elem.write.3" file="shared_pseudocode.xml" hover="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[result, 2*i + j, 32] = sum;

    return result;</pstext>
    </ps>
    <ps name="shared/functions/vector/PolynomialMult" mylink="shared.functions.vector.PolynomialMult" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// PolynomialMult()
// ================

bits(M+N) <anchor link="impl-shared.PolynomialMult.2" hover="function: bits(M+N) PolynomialMult(bits(M) op1, bits(N) op2)">PolynomialMult</anchor>(bits(M) op1, bits(N) op2)
    result = <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(M+N);
    extended_op2 = <a link="impl-shared.ZeroExtend.2" file="shared_pseudocode.xml" hover="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(op2, M+N);
    for i=0 to M-1
        if op1&lt;i&gt; == '1' then
            result = result EOR <a link="impl-shared.LSL.2" file="shared_pseudocode.xml" hover="function: bits(N) LSL(bits(N) x, integer shift)">LSL</a>(extended_op2, i);
    return result;</pstext>
    </ps>
    <ps name="shared/functions/vector/SatQ" mylink="shared.functions.vector.SatQ" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SatQ()
// ======

(bits(N), boolean) <anchor link="impl-shared.SatQ.3" hover="function: (bits(N), boolean) SatQ(integer i, integer N, boolean unsigned)">SatQ</anchor>(integer i, integer N, boolean unsigned)
    (result, sat) = if unsigned then <a link="impl-shared.UnsignedSatQ.2" file="shared_pseudocode.xml" hover="function: (bits(N), boolean) UnsignedSatQ(integer i, integer N)">UnsignedSatQ</a>(i, N) else <a link="impl-shared.SignedSatQ.2" file="shared_pseudocode.xml" hover="function: (bits(N), boolean) SignedSatQ(integer i, integer N)">SignedSatQ</a>(i, N);
    return (result, sat);</pstext>
    </ps>
    <ps name="shared/functions/vector/SignedSatQ" mylink="shared.functions.vector.SignedSatQ" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SignedSatQ()
// ============

(bits(N), boolean) <anchor link="impl-shared.SignedSatQ.2" hover="function: (bits(N), boolean) SignedSatQ(integer i, integer N)">SignedSatQ</anchor>(integer i, integer N)
    integer result;
    boolean saturated;
    if i &gt; 2^(N-1) - 1 then
        result = 2^(N-1) - 1;  saturated = TRUE;
    elsif i &lt; -(2^(N-1)) then
        result = -(2^(N-1));  saturated = TRUE;
    else
        result = i;  saturated = FALSE;
    return (result&lt;N-1:0&gt;, saturated);</pstext>
    </ps>
    <ps name="shared/functions/vector/UnsignedRSqrtEstimate" mylink="shared.functions.vector.UnsignedRSqrtEstimate" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// UnsignedRSqrtEstimate()
// =======================

bits(N) <anchor link="impl-shared.UnsignedRSqrtEstimate.1" hover="function: bits(N) UnsignedRSqrtEstimate(bits(N) operand)">UnsignedRSqrtEstimate</anchor>(bits(N) operand)
    assert N == 32;
    bits(N) result;
    if operand&lt;N-1:N-2&gt; == '00' then  // Operands &lt;= 0x3FFFFFFF produce 0xFFFFFFFF
        result = <a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(N);
    else
        // input is in the range 0x40000000 .. 0xffffffff representing [0.25 .. 1.0)
        // estimate is in the range 256 .. 511 representing [1.0 .. 2.0)
        increasedprecision = FALSE;
        estimate = <a link="impl-shared.RecipSqrtEstimate.2" file="shared_pseudocode.xml" hover="function: integer RecipSqrtEstimate(integer a_in, boolean increasedprecision)">RecipSqrtEstimate</a>(<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(operand&lt;31:23&gt;), increasedprecision);
        // result is in the range 0x80000000 .. 0xff800000 representing [1.0 .. 2.0)
        result = estimate&lt;8:0&gt; : <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(N-9);

    return result;</pstext>
    </ps>
    <ps name="shared/functions/vector/UnsignedRecipEstimate" mylink="shared.functions.vector.UnsignedRecipEstimate" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// UnsignedRecipEstimate()
// =======================

bits(N) <anchor link="impl-shared.UnsignedRecipEstimate.1" hover="function: bits(N) UnsignedRecipEstimate(bits(N) operand)">UnsignedRecipEstimate</anchor>(bits(N) operand)
    assert N == 32;
    bits(N) result;
    if operand&lt;N-1&gt; == '0' then  // Operands &lt;= 0x7FFFFFFF produce 0xFFFFFFFF
        result = <a link="impl-shared.Ones.1" file="shared_pseudocode.xml" hover="function: bits(N) Ones(integer N)">Ones</a>(N);
    else
        // input is in the range 0x80000000 .. 0xffffffff representing [0.5 .. 1.0)

        // estimate is in the range 256 to 511 representing [1.0 .. 2.0)
        increasedprecision = FALSE;
        estimate = <a link="impl-shared.RecipEstimate.2" file="shared_pseudocode.xml" hover="function: integer RecipEstimate(integer a_in, boolean increasedprecision)">RecipEstimate</a>(<a link="impl-shared.UInt.1" file="shared_pseudocode.xml" hover="function: integer UInt(bits(N) x)">UInt</a>(operand&lt;31:23&gt;), increasedprecision);

        // result is in the range 0x80000000 .. 0xff800000 representing [1.0 .. 2.0)
        result = estimate&lt;8:0&gt; : <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(N-9);

    return result;</pstext>
    </ps>
    <ps name="shared/functions/vector/UnsignedSatQ" mylink="shared.functions.vector.UnsignedSatQ" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// UnsignedSatQ()
// ==============

(bits(N), boolean) <anchor link="impl-shared.UnsignedSatQ.2" hover="function: (bits(N), boolean) UnsignedSatQ(integer i, integer N)">UnsignedSatQ</anchor>(integer i, integer N)
    integer result;
    boolean saturated;
    if i &gt; 2^N - 1 then
        result = 2^N - 1;  saturated = TRUE;
    elsif i &lt; 0 then
        result = 0;  saturated = TRUE;
    else
        result = i;  saturated = FALSE;
    return (result&lt;N-1:0&gt;, saturated);</pstext>
    </ps>
    <ps name="shared/trace/Common/GetTimestamp" mylink="shared.trace.Common.GetTimestamp" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// GetTimestamp()
// ==============
// Returns the Timestamp depending on the type

bits(64) <anchor link="impl-shared.GetTimestamp.1" hover="function: bits(64) GetTimestamp(TimeStamp timeStampType)">GetTimestamp</anchor>(<a link="TimeStamp" file="shared_pseudocode.xml" hover="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp</a> timeStampType)
    case timeStampType of
        when <a link="TimeStamp_Physical" file="shared_pseudocode.xml" hover="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Physical</a>
            return <a link="impl-shared.PhysicalCountInt.0" file="shared_pseudocode.xml" hover="function: bits(64) PhysicalCountInt()">PhysicalCountInt</a>();
        when <a link="TimeStamp_Virtual" file="shared_pseudocode.xml" hover="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Virtual</a>
            return <a link="impl-shared.PhysicalCountInt.0" file="shared_pseudocode.xml" hover="function: bits(64) PhysicalCountInt()">PhysicalCountInt</a>() - CNTVOFF_EL2;
        when <a link="TimeStamp_OffsetPhysical" file="shared_pseudocode.xml" hover="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_OffsetPhysical</a>
            return <a link="impl-shared.PhysicalCountInt.0" file="shared_pseudocode.xml" hover="function: bits(64) PhysicalCountInt()">PhysicalCountInt</a>() - CNTPOFF_EL2;
        when <a link="TimeStamp_None" file="shared_pseudocode.xml" hover="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_None</a>
            return <a link="impl-shared.Zeros.1" file="shared_pseudocode.xml" hover="function: bits(N) Zeros(integer N)">Zeros</a>(64);
        when <a link="TimeStamp_CoreSight" file="shared_pseudocode.xml" hover="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_CoreSight</a>
            return bits(64) IMPLEMENTATION_DEFINED "CoreSight timestamp";
        otherwise
            <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();</pstext>
    </ps>
    <ps name="shared/trace/selfhosted/EffectiveE0HTRE" mylink="shared.trace.selfhosted.EffectiveE0HTRE" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// EffectiveE0HTRE()
// =================
// Returns effective E0HTRE value

bit <anchor link="impl-shared.EffectiveE0HTRE.0" hover="function: bit EffectiveE0HTRE()">EffectiveE0HTRE</anchor>()
    return if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then HTRFCR.E0HTRE else TRFCR_EL2.E0HTRE;</pstext>
    </ps>
    <ps name="shared/trace/selfhosted/EffectiveE0TRE" mylink="shared.trace.selfhosted.EffectiveE0TRE" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// EffectiveE0TRE()
// ================
// Returns effective E0TRE value

bit <anchor link="impl-shared.EffectiveE0TRE.0" hover="function: bit EffectiveE0TRE()">EffectiveE0TRE</anchor>()
    return if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>) then TRFCR.E0TRE else TRFCR_EL1.E0TRE;</pstext>
    </ps>
    <ps name="shared/trace/selfhosted/EffectiveE1TRE" mylink="shared.trace.selfhosted.EffectiveE1TRE" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// EffectiveE1TRE()
// ================
// Returns effective E1TRE value

bit <anchor link="impl-shared.EffectiveE1TRE.0" hover="function: bit EffectiveE1TRE()">EffectiveE1TRE</anchor>()
    return if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then TRFCR.E1TRE else TRFCR_EL1.E1TRE;</pstext>
    </ps>
    <ps name="shared/trace/selfhosted/EffectiveE2TRE" mylink="shared.trace.selfhosted.EffectiveE2TRE" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// EffectiveE2TRE()
// ================
// Returns effective E2TRE value

bit <anchor link="impl-shared.EffectiveE2TRE.0" hover="function: bit EffectiveE2TRE()">EffectiveE2TRE</anchor>()
    return if <a link="impl-shared.UsingAArch32.0" file="shared_pseudocode.xml" hover="function: boolean UsingAArch32()">UsingAArch32</a>() then HTRFCR.E2TRE else TRFCR_EL2.E2TRE;</pstext>
    </ps>
    <ps name="shared/trace/selfhosted/SelfHostedTraceEnabled" mylink="shared.trace.selfhosted.SelfHostedTraceEnabled" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SelfHostedTraceEnabled()
// ========================
// Returns TRUE if Self-hosted Trace is enabled.

boolean <anchor link="impl-shared.SelfHostedTraceEnabled.0" hover="function: boolean SelfHostedTraceEnabled()">SelfHostedTraceEnabled</anchor>()
    if !(<a link="impl-shared.HaveTraceExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveTraceExt()">HaveTraceExt</a>() &amp;&amp; <a link="impl-shared.HaveSelfHostedTrace.0" file="shared_pseudocode.xml" hover="function: boolean HaveSelfHostedTrace()">HaveSelfHostedTrace</a>()) then return FALSE;
    if EDSCR.TFO == '0' then return TRUE;
    if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
        secure_trace_enable = if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then SDCR.STE else MDCR_EL3.STE;
        if secure_trace_enable == '1' &amp;&amp; !<a link="impl-shared.ExternalSecureNoninvasiveDebugEnabled.0" file="shared_pseudocode.xml" hover="function: boolean ExternalSecureNoninvasiveDebugEnabled()">ExternalSecureNoninvasiveDebugEnabled</a>() then
            return TRUE;
    else
        if <a link="impl-shared.SecureOnlyImplementation.0" file="shared_pseudocode.xml" hover="function: boolean SecureOnlyImplementation()">SecureOnlyImplementation</a>() &amp;&amp; !<a link="impl-shared.ExternalSecureNoninvasiveDebugEnabled.0" file="shared_pseudocode.xml" hover="function: boolean ExternalSecureNoninvasiveDebugEnabled()">ExternalSecureNoninvasiveDebugEnabled</a>() then
            return TRUE;

    return FALSE;</pstext>
    </ps>
    <ps name="shared/trace/selfhosted/TraceAllowed" mylink="shared.trace.selfhosted.TraceAllowed" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// TraceAllowed()
// ==============
// Returns TRUE if Self-hosted Trace is allowed in the given Exception level.

boolean <anchor link="impl-shared.TraceAllowed.1" hover="function: boolean TraceAllowed(bits(2) el)">TraceAllowed</anchor>(bits(2) el)
    if !<a link="impl-shared.HaveTraceExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveTraceExt()">HaveTraceExt</a>() then return FALSE;
    ss = <a link="impl-shared.SecurityStateAtEL.1" file="shared_pseudocode.xml" hover="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(el);
    if <a link="impl-shared.SelfHostedTraceEnabled.0" file="shared_pseudocode.xml" hover="function: boolean SelfHostedTraceEnabled()">SelfHostedTraceEnabled</a>() then
        boolean trace_allowed;
        // Detect scenarios where tracing in this Security state is never allowed.
        case ss of
            when <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a>
                trace_allowed = TRUE;
            when <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>
                bit trace_bit;
                if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
                    trace_bit = if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then SDCR.STE else MDCR_EL3.STE;
                else
                    trace_bit = '1';
                trace_allowed = trace_bit == '1';

        bit TRE_bit;
        case el of
            when <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>  TRE_bit = if !<a link="impl-shared.HaveAArch64.0" file="shared_pseudocode.xml" hover="function: boolean HaveAArch64()">HaveAArch64</a>() then TRFCR.E1TRE else '0';
            when <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>  TRE_bit = <a link="impl-shared.EffectiveE2TRE.0" file="shared_pseudocode.xml" hover="function: bit EffectiveE2TRE()">EffectiveE2TRE</a>();
            when <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>  TRE_bit = <a link="impl-shared.EffectiveE1TRE.0" file="shared_pseudocode.xml" hover="function: bit EffectiveE1TRE()">EffectiveE1TRE</a>();
            when <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>
                if <a link="impl-shared.EffectiveTGE.0" file="shared_pseudocode.xml" hover="function: bit EffectiveTGE()">EffectiveTGE</a>() == '1' then
                    TRE_bit = <a link="impl-shared.EffectiveE0HTRE.0" file="shared_pseudocode.xml" hover="function: bit EffectiveE0HTRE()">EffectiveE0HTRE</a>();
                else
                    TRE_bit = <a link="impl-shared.EffectiveE0TRE.0" file="shared_pseudocode.xml" hover="function: bit EffectiveE0TRE()">EffectiveE0TRE</a>();

        return trace_allowed &amp;&amp; TRE_bit == '1';
    else
        case ss of
            when <a link="SS_NonSecure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_NonSecure</a> return <a link="impl-shared.ExternalNoninvasiveDebugEnabled.0" file="shared_pseudocode.xml" hover="function: boolean ExternalNoninvasiveDebugEnabled()">ExternalNoninvasiveDebugEnabled</a>();
            when <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>    return <a link="impl-shared.ExternalSecureNoninvasiveDebugEnabled.0" file="shared_pseudocode.xml" hover="function: boolean ExternalSecureNoninvasiveDebugEnabled()">ExternalSecureNoninvasiveDebugEnabled</a>();</pstext>
    </ps>
    <ps name="shared/trace/selfhosted/TraceContextIDR2" mylink="shared.trace.selfhosted.TraceContextIDR2" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// TraceContextIDR2()
// ==================

boolean <anchor link="impl-shared.TraceContextIDR2.0" hover="function: boolean TraceContextIDR2()">TraceContextIDR2</anchor>()
    if !<a link="impl-shared.TraceAllowed.1" file="shared_pseudocode.xml" hover="function: boolean TraceAllowed(bits(2) el)">TraceAllowed</a>(PSTATE.EL)|| !<a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then return FALSE;
    return (!<a link="impl-shared.SelfHostedTraceEnabled.0" file="shared_pseudocode.xml" hover="function: boolean SelfHostedTraceEnabled()">SelfHostedTraceEnabled</a>() || TRFCR_EL2.CX == '1');</pstext>
    </ps>
    <ps name="shared/trace/selfhosted/TraceSynchronizationBarrier" mylink="shared.trace.selfhosted.TraceSynchronizationBarrier" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// Memory barrier instruction that preserves the relative order of memory accesses to System
// registers due to trace operations and other memory accesses to the same registers
<anchor link="impl-shared.TraceSynchronizationBarrier.0" hover="function: TraceSynchronizationBarrier()">TraceSynchronizationBarrier</anchor>();</pstext>
    </ps>
    <ps name="shared/trace/selfhosted/TraceTimeStamp" mylink="shared.trace.selfhosted.TraceTimeStamp" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// TraceTimeStamp()
// ================

TimeStamp <anchor link="impl-shared.TraceTimeStamp.0" hover="function: TimeStamp TraceTimeStamp()">TraceTimeStamp</anchor>()
    if <a link="impl-shared.SelfHostedTraceEnabled.0" file="shared_pseudocode.xml" hover="function: boolean SelfHostedTraceEnabled()">SelfHostedTraceEnabled</a>() then
        if <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then
            TS_el2 = TRFCR_EL2.TS;
            if !<a link="impl-shared.HaveECVExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveECVExt()">HaveECVExt</a>() &amp;&amp; TS_el2 == '10' then
                // Reserved value
                (-, TS_el2) = <a link="impl-shared.ConstrainUnpredictableBits.1" file="shared_pseudocode.xml" hover="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a link="Unpredictable_EL2TIMESTAMP" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_EL2TIMESTAMP</a>);

            case TS_el2 of
                when '00'
                    // Falls out to check TRFCR_EL1.TS
                when '01'
                    return <a link="TimeStamp_Virtual" file="shared_pseudocode.xml" hover="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Virtual</a>;
                when '10'
                    assert <a link="impl-shared.HaveECVExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveECVExt()">HaveECVExt</a>();  // Otherwise ConstrainUnpredictableBits removes this case
                    return <a link="TimeStamp_OffsetPhysical" file="shared_pseudocode.xml" hover="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_OffsetPhysical</a>;
                when '11'
                    return <a link="TimeStamp_Physical" file="shared_pseudocode.xml" hover="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Physical</a>;

        TS_el1 = TRFCR_EL1.TS;
        if TS_el1 == '00' || (!<a link="impl-shared.HaveECVExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveECVExt()">HaveECVExt</a>() &amp;&amp; TS_el1 == '10') then
            // Reserved value
            (-, TS_el1) = <a link="impl-shared.ConstrainUnpredictableBits.1" file="shared_pseudocode.xml" hover="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a link="Unpredictable_EL1TIMESTAMP" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_EL1TIMESTAMP</a>);

        case TS_el1 of
            when '01'
                return <a link="TimeStamp_Virtual" file="shared_pseudocode.xml" hover="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Virtual</a>;
            when '10'
                assert <a link="impl-shared.HaveECVExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveECVExt()">HaveECVExt</a>();
                return <a link="TimeStamp_OffsetPhysical" file="shared_pseudocode.xml" hover="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_OffsetPhysical</a>;
            when '11'
                return <a link="TimeStamp_Physical" file="shared_pseudocode.xml" hover="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Physical</a>;
            otherwise
                <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();         // ConstrainUnpredictableBits removes this case
    else
        return <a link="TimeStamp_CoreSight" file="shared_pseudocode.xml" hover="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_CoreSight</a>;</pstext>
    </ps>
    <ps name="shared/translation/at/ATAccess" mylink="shared.translation.at.ATAccess" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="ATAccess" hover="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess</anchor> {
    <anchor link="ATAccess_Read" hover="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess_Read</anchor>,
    <anchor link="ATAccess_Write" hover="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess_Write</anchor>,
    <anchor link="ATAccess_ReadPAN" hover="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess_ReadPAN</anchor>,
    <anchor link="ATAccess_WritePAN" hover="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess_WritePAN</anchor>
};</pstext>
    </ps>
    <ps name="shared/translation/at/EncodePARAttrs" mylink="shared.translation.at.EncodePARAttrs" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// EncodePARAttrs()
// ================
// Convert orthogonal attributes and hints to 64-bit PAR ATTR field.

bits(8) <anchor link="impl-shared.EncodePARAttrs.1" hover="function: bits(8) EncodePARAttrs(MemoryAttributes memattrs)">EncodePARAttrs</anchor>(<a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs)
    bits(8) result;

    if <a link="impl-shared.HaveMTEExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveMTEExt()">HaveMTEExt</a>() &amp;&amp; memattrs.tagged then
        result&lt;7:0&gt; = '11110000';
        return result;

    if memattrs.memtype == <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
        result&lt;7:4&gt; = '0000';
        if memattrs.device == <a link="DeviceType_nGnRnE" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a> then
            result&lt;3:0&gt; = '0000';
        elsif memattrs.device == <a link="DeviceType_nGnRE" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRE</a> then
            result&lt;3:0&gt; = '0100';
        elsif memattrs.device == <a link="DeviceType_nGRE" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGRE</a> then
            result&lt;3:0&gt; = '1000';
        else // DeviceType_GRE
            result&lt;3:0&gt; = '1100';
    else
        if memattrs.outer.attrs == <a link="MemAttr_WT" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a> then
            result&lt;7:6&gt; = if memattrs.outer.transient then '00' else '10';
            result&lt;5:4&gt; = memattrs.outer.hints;
        elsif memattrs.outer.attrs == <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> then
            result&lt;7:6&gt; = if memattrs.outer.transient then '01' else '11';
            result&lt;5:4&gt; = memattrs.outer.hints;
        else // MemAttr_NC
            result&lt;7:4&gt; = '0100';

        if memattrs.inner.attrs == <a link="MemAttr_WT" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a> then
            result&lt;3:2&gt; = if memattrs.inner.transient then '00' else '10';
            result&lt;1:0&gt; = memattrs.inner.hints;
        elsif memattrs.inner.attrs == <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> then
            result&lt;3:2&gt; = if memattrs.inner.transient then '01' else '11';
            result&lt;1:0&gt; = memattrs.inner.hints;
        else // MemAttr_NC
            result&lt;3:0&gt; = '0100';

    return result;</pstext>
    </ps>
    <ps name="shared/translation/at/PAREncodeShareability" mylink="shared.translation.at.PAREncodeShareability" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// PAREncodeShareability()
// =======================
// Derive 64-bit PAR SH field.

bits(2) <anchor link="impl-shared.PAREncodeShareability.1" hover="function: bits(2) PAREncodeShareability(MemoryAttributes memattrs)">PAREncodeShareability</anchor>(<a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs)
    if (memattrs.memtype == <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> ||
            (memattrs.inner.attrs == <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> &amp;&amp;
             memattrs.outer.attrs == <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>)) then
        // Force Outer-Shareable on Device and Normal Non-Cacheable memory
        return '10';

    case memattrs.shareability of
        when <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> return '00';
        when <a link="Shareability_ISH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_ISH</a> return '11';
        when <a link="Shareability_OSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a> return '10';</pstext>
    </ps>
    <ps name="shared/translation/at/TranslationStage" mylink="shared.translation.at.TranslationStage" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="TranslationStage" hover="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage</anchor> {
    <anchor link="TranslationStage_1" hover="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_1</anchor>,
    <anchor link="TranslationStage_12" hover="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_12</anchor>
};</pstext>
    </ps>
    <ps name="shared/translation/attrs/DecodeDevice" mylink="shared.translation.attrs.DecodeDevice" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// DecodeDevice()
// ==============
// Decode output Device type

DeviceType <anchor link="impl-shared.DecodeDevice.1" hover="function: DeviceType DecodeDevice(bits(2) device)">DecodeDevice</anchor>(bits(2) device)
    case device of
        when '00'   return <a link="DeviceType_nGnRnE" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a>;
        when '01'   return <a link="DeviceType_nGnRE" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRE</a>;
        when '10'   return <a link="DeviceType_nGRE" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGRE</a>;
        when '11'   return <a link="DeviceType_GRE" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_GRE</a>;</pstext>
    </ps>
    <ps name="shared/translation/attrs/DecodeLDFAttr" mylink="shared.translation.attrs.DecodeLDFAttr" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// DecodeLDFAttr()
// ===============
// Decode memory attributes using LDF (Long Descriptor Format) mapping

MemAttrHints <anchor link="impl-shared.DecodeLDFAttr.1" hover="function: MemAttrHints DecodeLDFAttr(bits(4) attr)">DecodeLDFAttr</anchor>(bits(4) attr)
    <a link="MemAttrHints" file="shared_pseudocode.xml" hover="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> ldfattr;

    if    attr == 'x0xx' then ldfattr.attrs = <a link="MemAttr_WT" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>; // Write-through
    elsif attr == '0100' then ldfattr.attrs = <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>; // Non-cacheable
    elsif attr == 'x1xx' then ldfattr.attrs = <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>; // Write-back
    else                      <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();

    // Allocation hints are applicable only to cacheable memory.
    if ldfattr.attrs != <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> then
        case attr&lt;1:0&gt; of
            when '00' ldfattr.hints = <a link="MemHint_No" file="shared_pseudocode.xml" hover="constant bits(2) MemHint_No = '00'">MemHint_No</a>;  // No allocation hints
            when '01' ldfattr.hints = <a link="MemHint_WA" file="shared_pseudocode.xml" hover="constant bits(2) MemHint_WA = '01'">MemHint_WA</a>;  // Write-allocate
            when '10' ldfattr.hints = <a link="MemHint_RA" file="shared_pseudocode.xml" hover="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;  // Read-allocate
            when '11' ldfattr.hints = <a link="MemHint_RWA" file="shared_pseudocode.xml" hover="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>; // Read/Write allocate

    // The Transient hint applies only to cacheable memory with some allocation hints.
    if ldfattr.attrs != <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> &amp;&amp; ldfattr.hints != <a link="MemHint_No" file="shared_pseudocode.xml" hover="constant bits(2) MemHint_No = '00'">MemHint_No</a> then
        ldfattr.transient = attr&lt;3&gt; == '0';

    return ldfattr;</pstext>
    </ps>
    <ps name="shared/translation/attrs/DecodeSDFAttr" mylink="shared.translation.attrs.DecodeSDFAttr" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// DecodeSDFAttr()
// ===============
// Decode memory attributes using SDF (Short Descriptor Format) mapping

MemAttrHints <anchor link="impl-shared.DecodeSDFAttr.1" hover="function: MemAttrHints DecodeSDFAttr(bits(2) rgn)">DecodeSDFAttr</anchor>(bits(2) rgn)
    <a link="MemAttrHints" file="shared_pseudocode.xml" hover="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> sdfattr;

    case rgn of
        when '00'                   // Non-cacheable (no allocate)
            sdfattr.attrs = <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;
        when '01'                   // Write-back, Read and Write allocate
            sdfattr.attrs = <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
            sdfattr.hints = <a link="MemHint_RWA" file="shared_pseudocode.xml" hover="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
        when '10'                   // Write-through, Read allocate
            sdfattr.attrs = <a link="MemAttr_WT" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
            sdfattr.hints = <a link="MemHint_RA" file="shared_pseudocode.xml" hover="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
        when '11'                   // Write-back, Read allocate
            sdfattr.attrs = <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
            sdfattr.hints = <a link="MemHint_RA" file="shared_pseudocode.xml" hover="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;

    sdfattr.transient = FALSE;

    return sdfattr;</pstext>
    </ps>
    <ps name="shared/translation/attrs/DecodeShareability" mylink="shared.translation.attrs.DecodeShareability" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// DecodeShareability()
// ====================
// Decode shareability of target memory region

Shareability <anchor link="impl-shared.DecodeShareability.1" hover="function: Shareability DecodeShareability(bits(2) sh)">DecodeShareability</anchor>(bits(2) sh)
    case sh of
        when '10' return <a link="Shareability_OSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        when '11' return <a link="Shareability_ISH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_ISH</a>;
        when '00' return <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        otherwise
            case <a link="impl-shared.ConstrainUnpredictable.1" file="shared_pseudocode.xml" hover="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a link="Unpredictable_Shareability" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_Shareability</a>) of
                when <a link="Constraint_OSH" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_OSH</a> return <a link="Shareability_OSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
                when <a link="Constraint_ISH" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_ISH</a> return <a link="Shareability_ISH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_ISH</a>;
                when <a link="Constraint_NSH" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NSH</a> return <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;</pstext>
    </ps>
    <ps name="shared/translation/attrs/EffectiveShareability" mylink="shared.translation.attrs.EffectiveShareability" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// EffectiveShareability()
// =======================
// Force Outer Shareability on Device and Normal iNCoNC memory

Shareability <anchor link="impl-shared.EffectiveShareability.1" hover="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</anchor>(<a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs)
    if (memattrs.memtype == <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> ||
            (memattrs.inner.attrs == <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> &amp;&amp;
             memattrs.outer.attrs == <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>)) then
        return <a link="Shareability_OSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
    else
        return memattrs.shareability;</pstext>
    </ps>
    <ps name="shared/translation/attrs/MAIRAttr" mylink="shared.translation.attrs.MAIRAttr" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// MAIRAttr()
// ==========
// Retrieve the memory attribute encoding indexed in the given MAIR

bits(8) <anchor link="impl-shared.MAIRAttr.2" hover="function: bits(8) MAIRAttr(integer index, MAIRType mair)">MAIRAttr</anchor>(integer index, <a link="MAIRType" file="shared_pseudocode.xml" hover="type MAIRType">MAIRType</a> mair)
    bit_index = 8 * index;
    return mair&lt;bit_index+7:bit_index&gt;;</pstext>
    </ps>
    <ps name="shared/translation/attrs/NormalNCMemAttr" mylink="shared.translation.attrs.NormalNCMemAttr" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// NormalNCMemAttr()
// =================
// Normal Non-cacheable memory attributes

MemoryAttributes <anchor link="impl-shared.NormalNCMemAttr.0" hover="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</anchor>()
    <a link="MemAttrHints" file="shared_pseudocode.xml" hover="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> non_cacheable;
    non_cacheable.attrs = <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;

    <a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> nc_memattrs;
    nc_memattrs.memtype      = <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
    nc_memattrs.outer        = non_cacheable;
    nc_memattrs.inner        = non_cacheable;
    nc_memattrs.shareability = <a link="Shareability_OSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
    nc_memattrs.tagged       = FALSE;

    return nc_memattrs;</pstext>
    </ps>
    <ps name="shared/translation/attrs/S1ConstrainUnpredictableRESMAIR" mylink="shared.translation.attrs.S1ConstrainUnpredictableRESMAIR" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// S1ConstrainUnpredictableRESMAIR()
// =================================
// Determine whether a reserved value occupies MAIR_ELx.AttrN

boolean <anchor link="impl-shared.S1ConstrainUnpredictableRESMAIR.2" hover="function: boolean S1ConstrainUnpredictableRESMAIR(bits(8) attr, boolean s1aarch64)">S1ConstrainUnpredictableRESMAIR</anchor>(bits(8) attr, boolean s1aarch64)
    case attr of
        when '0000xx01' return !(s1aarch64 &amp;&amp; <a link="impl-shared.HaveFeatXS.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatXS()">HaveFeatXS</a>());
        when '0000xxxx' return attr&lt;1:0&gt; != '00';
        when '01000000' return !(s1aarch64 &amp;&amp; <a link="impl-shared.HaveFeatXS.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatXS()">HaveFeatXS</a>());
        when '10100000' return !(s1aarch64 &amp;&amp; <a link="impl-shared.HaveFeatXS.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatXS()">HaveFeatXS</a>());
        when '11110000' return !(s1aarch64 &amp;&amp; <a link="impl-shared.HaveMTE2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>());
        when 'xxxx0000' return TRUE;
        otherwise       return FALSE;</pstext>
    </ps>
    <ps name="shared/translation/attrs/S1DecodeMemAttrs" mylink="shared.translation.attrs.S1DecodeMemAttrs" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// S1DecodeMemAttrs()
// ==================
// Decode MAIR-format memory attributes assigned in stage 1

MemoryAttributes <anchor link="impl-shared.S1DecodeMemAttrs.3" hover="function: MemoryAttributes S1DecodeMemAttrs(bits(8) attr_in, bits(2) sh, boolean s1aarch64)">S1DecodeMemAttrs</anchor>(bits(8) attr_in, bits(2) sh, boolean s1aarch64)
    bits(8) attr = attr_in;
    if <a link="impl-shared.S1ConstrainUnpredictableRESMAIR.2" file="shared_pseudocode.xml" hover="function: boolean S1ConstrainUnpredictableRESMAIR(bits(8) attr, boolean s1aarch64)">S1ConstrainUnpredictableRESMAIR</a>(attr, s1aarch64) then
        (-, attr) = <a link="impl-shared.ConstrainUnpredictableBits.1" file="shared_pseudocode.xml" hover="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a link="Unpredictable_RESMAIR" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_RESMAIR</a>);

    <a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs;
    case attr of
        when '0000xxxx' // Device memory
            memattrs.memtype = <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
            memattrs.device  = <a link="impl-shared.DecodeDevice.1" file="shared_pseudocode.xml" hover="function: DeviceType DecodeDevice(bits(2) device)">DecodeDevice</a>(attr&lt;3:2&gt;);
            memattrs.tagged  = FALSE;
            memattrs.xs      = if s1aarch64 then NOT attr&lt;0&gt; else '1';
        when '01000000'
            assert s1aarch64 &amp;&amp; <a link="impl-shared.HaveFeatXS.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatXS()">HaveFeatXS</a>();
            memattrs.memtype = <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.tagged  = FALSE;
            memattrs.outer.attrs = <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;
            memattrs.inner.attrs = <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;
            memattrs.xs          = '0';

        when '10100000'
            assert s1aarch64 &amp;&amp; <a link="impl-shared.HaveFeatXS.0" file="shared_pseudocode.xml" hover="function: boolean HaveFeatXS()">HaveFeatXS</a>();
            memattrs.memtype = <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.tagged  = FALSE;
            memattrs.outer.attrs     = <a link="MemAttr_WT" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
            memattrs.outer.hints     = <a link="MemHint_RA" file="shared_pseudocode.xml" hover="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
            memattrs.outer.transient = FALSE;
            memattrs.inner.attrs     = <a link="MemAttr_WT" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
            memattrs.inner.hints     = <a link="MemHint_RA" file="shared_pseudocode.xml" hover="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
            memattrs.inner.transient = FALSE;
            memattrs.xs              = '0';
        when '11110000' // Tagged memory
            assert s1aarch64 &amp;&amp; <a link="impl-shared.HaveMTE2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>();
            memattrs.memtype = <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.tagged  = TRUE;
            memattrs.outer.attrs     = <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
            memattrs.outer.hints     = <a link="MemHint_RWA" file="shared_pseudocode.xml" hover="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
            memattrs.outer.transient = FALSE;
            memattrs.inner.attrs     = <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
            memattrs.inner.hints     = <a link="MemHint_RWA" file="shared_pseudocode.xml" hover="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
            memattrs.inner.transient = FALSE;
            memattrs.xs              = '0';
        otherwise
            memattrs.memtype = <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.outer   = <a link="impl-shared.DecodeLDFAttr.1" file="shared_pseudocode.xml" hover="function: MemAttrHints DecodeLDFAttr(bits(4) attr)">DecodeLDFAttr</a>(attr&lt;7:4&gt;);
            memattrs.inner   = <a link="impl-shared.DecodeLDFAttr.1" file="shared_pseudocode.xml" hover="function: MemAttrHints DecodeLDFAttr(bits(4) attr)">DecodeLDFAttr</a>(attr&lt;3:0&gt;);
            memattrs.tagged  = FALSE;

            if (memattrs.inner.attrs == <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp;
                    memattrs.outer.attrs == <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>) then
                memattrs.xs = '0';
            else
                memattrs.xs = '1';

    memattrs.shareability = <a link="impl-shared.DecodeShareability.1" file="shared_pseudocode.xml" hover="function: Shareability DecodeShareability(bits(2) sh)">DecodeShareability</a>(sh);

    return memattrs;</pstext>
    </ps>
    <ps name="shared/translation/attrs/S2CombineS1AttrHints" mylink="shared.translation.attrs.S2CombineS1AttrHints" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// S2CombineS1AttrHints()
// ======================
// Determine resultant Normal memory cacheability and allocation hints from
// combining stage 1 Normal memory attributes and stage 2 cacheability attributes.

MemAttrHints <anchor link="impl-shared.S2CombineS1AttrHints.2" hover="function: MemAttrHints S2CombineS1AttrHints(MemAttrHints s1_attrhints, MemAttrHints s2_attrhints)">S2CombineS1AttrHints</anchor>(<a link="MemAttrHints" file="shared_pseudocode.xml" hover="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> s1_attrhints, <a link="MemAttrHints" file="shared_pseudocode.xml" hover="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> s2_attrhints)
    <a link="MemAttrHints" file="shared_pseudocode.xml" hover="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> attrhints;

    if s1_attrhints.attrs == <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> || s2_attrhints.attrs == <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> then
        attrhints.attrs = <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;
    elsif s1_attrhints.attrs == <a link="MemAttr_WT" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a> || s2_attrhints.attrs == <a link="MemAttr_WT" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a> then
        attrhints.attrs = <a link="MemAttr_WT" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
    else
        attrhints.attrs = <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;

    // Stage 2 does not assign any allocation hints
    // Instead, they are inherited from stage 1
    if attrhints.attrs != <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> then
        attrhints.hints     = s1_attrhints.hints;
        attrhints.transient = s1_attrhints.transient;

    return attrhints;</pstext>
    </ps>
    <ps name="shared/translation/attrs/S2CombineS1Device" mylink="shared.translation.attrs.S2CombineS1Device" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// S2CombineS1Device()
// ===================
// Determine resultant Device type from combining output memory attributes
// in stage 1 and Device attributes in stage 2

DeviceType <anchor link="impl-shared.S2CombineS1Device.2" hover="function: DeviceType S2CombineS1Device(DeviceType s1_device, DeviceType s2_device)">S2CombineS1Device</anchor>(<a link="DeviceType" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType</a> s1_device, <a link="DeviceType" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType</a> s2_device)
    if s1_device == <a link="DeviceType_nGnRnE" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a> || s2_device == <a link="DeviceType_nGnRnE" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a> then
        return <a link="DeviceType_nGnRnE" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a>;
    elsif s1_device == <a link="DeviceType_nGnRE" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRE</a> || s2_device == <a link="DeviceType_nGnRE" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRE</a> then
        return <a link="DeviceType_nGnRE" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRE</a>;
    elsif s1_device == <a link="DeviceType_nGRE" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGRE</a> || s2_device == <a link="DeviceType_nGRE" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGRE</a> then
        return <a link="DeviceType_nGRE" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGRE</a>;
    else
        return <a link="DeviceType_GRE" file="shared_pseudocode.xml" hover="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_GRE</a>;</pstext>
    </ps>
    <ps name="shared/translation/attrs/S2CombineS1MemAttrs" mylink="shared.translation.attrs.S2CombineS1MemAttrs" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// S2CombineS1MemAttrs()
// =====================
// Combine stage 2 with stage 1 memory attributes

MemoryAttributes <anchor link="impl-shared.S2CombineS1MemAttrs.2" hover="function: MemoryAttributes S2CombineS1MemAttrs(MemoryAttributes s1_memattrs,&#13; MemoryAttributes s2_memattrs)">S2CombineS1MemAttrs</anchor>(<a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> s1_memattrs,
                                     <a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> s2_memattrs)
    <a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs;

    if s1_memattrs.memtype == <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> &amp;&amp; s2_memattrs.memtype == <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
        memattrs.memtype = <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
        memattrs.device  = <a link="impl-shared.S2CombineS1Device.2" file="shared_pseudocode.xml" hover="function: DeviceType S2CombineS1Device(DeviceType s1_device, DeviceType s2_device)">S2CombineS1Device</a>(s1_memattrs.device, s2_memattrs.device);
    elsif s1_memattrs.memtype == <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then    // S2 Normal, S1 Device
        memattrs = s1_memattrs;
    elsif s2_memattrs.memtype == <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then    // S2 Device, S1 Normal
        memattrs = s2_memattrs;
    else                                                // S2 Normal, S1 Normal
        memattrs.memtype = <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
        memattrs.inner   = <a link="impl-shared.S2CombineS1AttrHints.2" file="shared_pseudocode.xml" hover="function: MemAttrHints S2CombineS1AttrHints(MemAttrHints s1_attrhints, MemAttrHints s2_attrhints)">S2CombineS1AttrHints</a>(s1_memattrs.inner, s2_memattrs.inner);
        memattrs.outer   = <a link="impl-shared.S2CombineS1AttrHints.2" file="shared_pseudocode.xml" hover="function: MemAttrHints S2CombineS1AttrHints(MemAttrHints s1_attrhints, MemAttrHints s2_attrhints)">S2CombineS1AttrHints</a>(s1_memattrs.outer, s2_memattrs.outer);

    if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) || !<a link="impl-shared.HaveMTE2Ext.0" file="shared_pseudocode.xml" hover="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() then
        memattrs.tagged = FALSE;
    else
        memattrs.tagged = <a link="AArch64.IsS2ResultTagged.2" file="shared_pseudocode.xml" hover="function: boolean AArch64.IsS2ResultTagged(MemoryAttributes s2_memattrs, boolean s1_tagged)">AArch64.IsS2ResultTagged</a>(memattrs, s1_memattrs.tagged);

    memattrs.shareability = <a link="impl-shared.S2CombineS1Shareability.2" file="shared_pseudocode.xml" hover="function: Shareability S2CombineS1Shareability(Shareability s1_shareability,&#13; Shareability s2_shareability)">S2CombineS1Shareability</a>(s1_memattrs.shareability,
                                                    s2_memattrs.shareability);
    memattrs.xs           = s2_memattrs.xs;

    memattrs.shareability = <a link="impl-shared.EffectiveShareability.1" file="shared_pseudocode.xml" hover="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(memattrs);
    return memattrs;</pstext>
    </ps>
    <ps name="shared/translation/attrs/S2CombineS1Shareability" mylink="shared.translation.attrs.S2CombineS1Shareability" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// S2CombineS1Shareability()
// =========================
// Combine stage 2 shareability with stage 1

Shareability <anchor link="impl-shared.S2CombineS1Shareability.2" hover="function: Shareability S2CombineS1Shareability(Shareability s1_shareability,&#13; Shareability s2_shareability)">S2CombineS1Shareability</anchor>(<a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> s1_shareability,
                                     <a link="Shareability" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> s2_shareability)

    if (s1_shareability == <a link="Shareability_OSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a> ||
            s2_shareability == <a link="Shareability_OSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>) then
        return <a link="Shareability_OSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
    elsif (s1_shareability == <a link="Shareability_ISH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_ISH</a> ||
            s2_shareability == <a link="Shareability_ISH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_ISH</a>) then
        return <a link="Shareability_ISH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_ISH</a>;
    else
        return <a link="Shareability_NSH" file="shared_pseudocode.xml" hover="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;</pstext>
    </ps>
    <ps name="shared/translation/attrs/S2DecodeCacheability" mylink="shared.translation.attrs.S2DecodeCacheability" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// S2DecodeCacheability()
// ======================
// Determine the stage 2 cacheability for Normal memory

MemAttrHints <anchor link="impl-shared.S2DecodeCacheability.1" hover="function: MemAttrHints S2DecodeCacheability(bits(2) attr)">S2DecodeCacheability</anchor>(bits(2) attr)
    <a link="MemAttrHints" file="shared_pseudocode.xml" hover="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> s2attr;

    case attr of
        when '01' s2attr.attrs = <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;  // Non-cacheable
        when '10' s2attr.attrs = <a link="MemAttr_WT" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;  // Write-through
        when '11' s2attr.attrs = <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;  // Write-back
        otherwise // Constrained unpredictable
            case <a link="impl-shared.ConstrainUnpredictable.1" file="shared_pseudocode.xml" hover="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a link="Unpredictable_S2RESMEMATTR" file="shared_pseudocode.xml" hover="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT,&#13; }">Unpredictable_S2RESMEMATTR</a>) of
                when <a link="Constraint_NC" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NC</a> s2attr.attrs = <a link="MemAttr_NC" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;
                when <a link="Constraint_WT" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_WT</a> s2attr.attrs = <a link="MemAttr_WT" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
                when <a link="Constraint_WB" file="shared_pseudocode.xml" hover="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_WB</a> s2attr.attrs = <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;

    // Stage 2 does not assign hints or the transient property
    // They are inherited from stage 1 if the result of the combination allows it
    s2attr.hints     = bits(2) UNKNOWN;
    s2attr.transient = boolean UNKNOWN;

    return s2attr;</pstext>
    </ps>
    <ps name="shared/translation/attrs/S2DecodeMemAttrs" mylink="shared.translation.attrs.S2DecodeMemAttrs" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// S2DecodeMemAttrs()
// ==================
// Decode stage 2 memory attributes

MemoryAttributes <anchor link="impl-shared.S2DecodeMemAttrs.2" hover="function: MemoryAttributes S2DecodeMemAttrs(bits(4) attr, bits(2) sh)">S2DecodeMemAttrs</anchor>(bits(4) attr, bits(2) sh)
    <a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs;

    case attr of
        when '00xx' // Device memory
            memattrs.memtype      = <a link="MemType_Device" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
            memattrs.device       = <a link="impl-shared.DecodeDevice.1" file="shared_pseudocode.xml" hover="function: DeviceType DecodeDevice(bits(2) device)">DecodeDevice</a>(attr&lt;1:0&gt;);
        otherwise   // Normal memory
            memattrs.memtype      = <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.outer        = <a link="impl-shared.S2DecodeCacheability.1" file="shared_pseudocode.xml" hover="function: MemAttrHints S2DecodeCacheability(bits(2) attr)">S2DecodeCacheability</a>(attr&lt;3:2&gt;);
            memattrs.inner        = <a link="impl-shared.S2DecodeCacheability.1" file="shared_pseudocode.xml" hover="function: MemAttrHints S2DecodeCacheability(bits(2) attr)">S2DecodeCacheability</a>(attr&lt;1:0&gt;);

    memattrs.shareability = <a link="impl-shared.DecodeShareability.1" file="shared_pseudocode.xml" hover="function: Shareability DecodeShareability(bits(2) sh)">DecodeShareability</a>(sh);

    return memattrs;</pstext>
    </ps>
    <ps name="shared/translation/attrs/WalkMemAttrs" mylink="shared.translation.attrs.WalkMemAttrs" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// WalkMemAttrs()
// ==============
// Retrieve memory attributes of translation table walk

MemoryAttributes <anchor link="impl-shared.WalkMemAttrs.3" hover="function: MemoryAttributes WalkMemAttrs(bits(2) sh, bits(2) irgn, bits(2) orgn)">WalkMemAttrs</anchor>(bits(2) sh, bits(2) irgn, bits(2) orgn)
    <a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> walkmemattrs;

    walkmemattrs.memtype      = <a link="MemType_Normal" file="shared_pseudocode.xml" hover="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
    walkmemattrs.shareability = <a link="impl-shared.DecodeShareability.1" file="shared_pseudocode.xml" hover="function: Shareability DecodeShareability(bits(2) sh)">DecodeShareability</a>(sh);
    walkmemattrs.inner        = <a link="impl-shared.DecodeSDFAttr.1" file="shared_pseudocode.xml" hover="function: MemAttrHints DecodeSDFAttr(bits(2) rgn)">DecodeSDFAttr</a>(irgn);
    walkmemattrs.outer        = <a link="impl-shared.DecodeSDFAttr.1" file="shared_pseudocode.xml" hover="function: MemAttrHints DecodeSDFAttr(bits(2) rgn)">DecodeSDFAttr</a>(orgn);
    walkmemattrs.tagged       = FALSE;
    if (walkmemattrs.inner.attrs == <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp;
            walkmemattrs.outer.attrs == <a link="MemAttr_WB" file="shared_pseudocode.xml" hover="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>) then
        walkmemattrs.xs = '0';
    else
        walkmemattrs.xs = '1';

    return walkmemattrs;</pstext>
    </ps>
    <ps name="shared/translation/faults/AlignmentFault" mylink="shared.translation.faults.AlignmentFault" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AlignmentFault()
// ================

FaultRecord <anchor link="impl-shared.AlignmentFault.3" hover="function: FaultRecord AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)">AlignmentFault</anchor>(<a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite, boolean secondstage)
    <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault;

    fault.statuscode  = <a link="Fault_Alignment" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>;
    fault.acctype     = acctype;
    fault.write       = iswrite;
    fault.secondstage = secondstage;

    return fault;</pstext>
    </ps>
    <ps name="shared/translation/faults/AsyncExternalAbort" mylink="shared.translation.faults.AsyncExternalAbort" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// AsyncExternalAbort()
// ====================
// Return a fault record indicating an asynchronous external abort

FaultRecord <anchor link="impl-shared.AsyncExternalAbort.3" hover="function: FaultRecord AsyncExternalAbort(boolean parity, bits(2) errortype, bit extflag)">AsyncExternalAbort</anchor>(boolean parity, bits(2) errortype, bit extflag)
    <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault;

    fault.statuscode  = if parity then <a link="Fault_AsyncParity" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncParity</a> else <a link="Fault_AsyncExternal" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>;
    fault.extflag     = extflag;
    fault.errortype   = errortype;
    fault.acctype     = <a link="AccType_NORMAL" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NORMAL</a>;
    fault.secondstage = FALSE;
    fault.s2fs1walk   = FALSE;

    return fault;</pstext>
    </ps>
    <ps name="shared/translation/faults/NoFault" mylink="shared.translation.faults.NoFault" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// NoFault()
// =========
// Return a clear fault record indicating no faults have occured

FaultRecord <anchor link="impl-shared.NoFault.0" hover="function: FaultRecord NoFault()">NoFault</anchor>()
    <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault;

    fault.statuscode  = <a link="Fault_None" file="shared_pseudocode.xml" hover="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;
    fault.acctype     = <a link="AccType_NORMAL" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NORMAL</a>;
    fault.secondstage = FALSE;
    fault.s2fs1walk   = FALSE;

    return fault;</pstext>
    </ps>
    <ps name="shared/translation/translation/S1TranslationRegime" mylink="shared.translation.translation.S1TranslationRegime" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// S1TranslationRegime()
// =====================
// Stage 1 translation regime for the given Exception level

bits(2) <anchor link="impl-shared.S1TranslationRegime.1" hover="function: bits(2) S1TranslationRegime(bits(2) el)">S1TranslationRegime</anchor>(bits(2) el)
    if el != <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then
        return el;
    elsif <a link="impl-shared.HaveEL.1" file="shared_pseudocode.xml" hover="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR.NS == '0' then
        return <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>;
    elsif <a link="impl-shared.HaveVirtHostExt.0" file="shared_pseudocode.xml" hover="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; <a link="impl-shared.ELIsInHost.1" file="shared_pseudocode.xml" hover="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(el) then
        return <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>;
    else
        return <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>;

// S1TranslationRegime()
// =====================
// Returns the Exception level controlling the current Stage 1 translation regime. For the most
// part this is unused in code because the system register accessors (SCTLR[], etc.) implicitly
// return the correct value.

bits(2) <anchor link="impl-shared.S1TranslationRegime.0" hover="function: bits(2) S1TranslationRegime()">S1TranslationRegime</anchor>()
    return <a link="impl-shared.S1TranslationRegime.1" file="shared_pseudocode.xml" hover="function: bits(2) S1TranslationRegime(bits(2) el)">S1TranslationRegime</a>(PSTATE.EL);</pstext>
    </ps>
    <ps name="shared/translation/vmsa/AddressDescriptor" mylink="shared.translation.vmsa.AddressDescriptor" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">type <anchor link="AddressDescriptor" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</anchor> is (
    <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a>      fault,      // fault.statuscode indicates whether the address is valid
    <a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs,
    <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a>      paddress,
    bits(64)         vaddress
)

constant integer <anchor link="FINAL_LEVEL" hover="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</anchor> = 3;</pstext>
    </ps>
    <ps name="shared/translation/vmsa/ContiguousSize" mylink="shared.translation.vmsa.ContiguousSize" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// ContiguousSize()
// ================
// Return the number of entries log 2 marking a contiguous output range

integer <anchor link="impl-shared.ContiguousSize.2" hover="function: integer ContiguousSize(TGx tgx, integer level)">ContiguousSize</anchor>(<a link="TGx" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, integer level)
    case tgx of
        when <a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>
            assert level IN {1, 2, 3};
            return 4;
        when <a link="TGx_16KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>
            assert level IN {2, 3};
            return if level == 2 then 5 else 7;
        when <a link="TGx_64KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a>
            assert level IN {2, 3};
            return 5;</pstext>
    </ps>
    <ps name="shared/translation/vmsa/CreateAddressDescriptor" mylink="shared.translation.vmsa.CreateAddressDescriptor" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CreateAddressDescriptor()
// =========================
// Set internal members for address descriptor type to valid values

AddressDescriptor <anchor link="impl-shared.CreateAddressDescriptor.3" hover="function: AddressDescriptor CreateAddressDescriptor(bits(64) va, FullAddress pa,&#13; MemoryAttributes memattrs)">CreateAddressDescriptor</anchor>(bits(64) va, <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> pa,
                                          <a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs)
    <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> addrdesc;

    addrdesc.paddress = pa;
    addrdesc.vaddress = va;
    addrdesc.memattrs = memattrs;
    addrdesc.fault    = <a link="impl-shared.NoFault.0" file="shared_pseudocode.xml" hover="function: FaultRecord NoFault()">NoFault</a>();

    return addrdesc;</pstext>
    </ps>
    <ps name="shared/translation/vmsa/CreateFaultyAddressDescriptor" mylink="shared.translation.vmsa.CreateFaultyAddressDescriptor" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// CreateFaultyAddressDescriptor()
// ===============================
// Set internal members for address descriptor type with values indicating error

AddressDescriptor <anchor link="impl-shared.CreateFaultyAddressDescriptor.2" hover="function: AddressDescriptor CreateFaultyAddressDescriptor(bits(64) va, FaultRecord fault)">CreateFaultyAddressDescriptor</anchor>(bits(64) va, <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> addrdesc;

    addrdesc.vaddress = va;
    addrdesc.fault    = fault;

    return addrdesc;</pstext>
    </ps>
    <ps name="shared/translation/vmsa/DescriptorType" mylink="shared.translation.vmsa.DescriptorType" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="DescriptorType" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType</anchor> {
    <anchor link="DescriptorType_Table" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Table</anchor>,
    <anchor link="DescriptorType_Block" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Block</anchor>,
    <anchor link="DescriptorType_Page" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Page</anchor>,
    <anchor link="DescriptorType_Invalid" hover="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Invalid</anchor>
};</pstext>
    </ps>
    <ps name="shared/translation/vmsa/Domains" mylink="shared.translation.vmsa.Domains" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">constant bits(2) <anchor link="Domain_NoAccess" hover="constant bits(2) Domain_NoAccess = '00'">Domain_NoAccess</anchor> = '00';
constant bits(2) <anchor link="Domain_Client" hover="constant bits(2) Domain_Client = '01'">Domain_Client</anchor>   = '01';
constant bits(2) <anchor link="Domain_Manager" hover="constant bits(2) Domain_Manager = '11'">Domain_Manager</anchor>  = '11';</pstext>
    </ps>
    <ps name="shared/translation/vmsa/FetchDescriptor" mylink="shared.translation.vmsa.FetchDescriptor" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// FetchDescriptor()
// =================
// Fetch a translation table descriptor

(FaultRecord, bits(N)) <anchor link="impl-shared.FetchDescriptor.3" hover="function: (FaultRecord, bits(N)) FetchDescriptor(bit ee, AddressDescriptor walkaddress, FaultRecord fault_in)">FetchDescriptor</anchor>(bit ee, <a link="AddressDescriptor" file="shared_pseudocode.xml" hover="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> walkaddress, <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault_in)
    // 32-bit descriptors for AArch32 Short-descriptor format
    // 64-bit descriptors for AArch64 or AArch32 Long-descriptor format
    assert N == 32 || N == 64;
    bits(N) descriptor;
    <a link="FaultRecord" file="shared_pseudocode.xml" hover="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault = fault_in;
    <a link="AccessDescriptor" file="shared_pseudocode.xml" hover="type AccessDescriptor is ( MPAMinfo mpam, AccType acctype)">AccessDescriptor</a> walkacc;

    walkacc.acctype = <a link="AccType_TTW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_TTW</a>;
    // MPAM PARTID for translation table walk is determined by the access invoking the translation
    walkacc.mpam    = <a link="impl-shared.GenMPAMcurEL.1" file="shared_pseudocode.xml" hover="function: MPAMinfo GenMPAMcurEL(AccType acctype)">GenMPAMcurEL</a>(fault.acctype);

    <a link="PhysMemRetStatus" file="shared_pseudocode.xml" hover="type PhysMemRetStatus is (Fault statuscode, bit extflag, bits(2) errortype, bits(64) store64bstatus, AccType acctype)">PhysMemRetStatus</a> memstatus;
    (memstatus, descriptor) = <a link="impl-shared.PhysMemRead.3" file="shared_pseudocode.xml" hover="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(walkaddress, N DIV 8, walkacc);
    if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        fault = <a link="impl-shared.HandleExternalTTWAbort.6" file="shared_pseudocode.xml" hover="function: FaultRecord HandleExternalTTWAbort(PhysMemRetStatus memretstatus, boolean iswrite,&#13; AddressDescriptor memaddrdesc,&#13; AccessDescriptor accdesc, integer size,&#13; FaultRecord input_fault)">HandleExternalTTWAbort</a>(memstatus, fault.write, walkaddress,
                                       walkacc, N DIV 8, fault);
        if <a link="impl-shared.IsFault.1" file="shared_pseudocode.xml" hover="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(fault.statuscode) then
            return (fault, bits(N) UNKNOWN);

    if ee == '1' then
        descriptor = <a link="impl-shared.BigEndianReverse.1" file="shared_pseudocode.xml" hover="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(descriptor);

    return (fault, descriptor);</pstext>
    </ps>
    <ps name="shared/translation/vmsa/HasUnprivileged" mylink="shared.translation.vmsa.HasUnprivileged" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// HasUnprivileged()
// =================
// Returns whether a translation regime serves EL0 as well as a higher EL

boolean <anchor link="impl-shared.HasUnprivileged.1" hover="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</anchor>(<a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime)
    return (regime IN {
        <a link="Regime_EL20" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>,
        <a link="Regime_EL30" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a>,
        <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>
    });</pstext>
    </ps>
    <ps name="shared/translation/vmsa/IsAtomicRW" mylink="shared.translation.vmsa.IsAtomicRW" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// IsAtomicRW()
// ============
// Is the access an atomic operation?

boolean <anchor link="impl-shared.IsAtomicRW.1" hover="function: boolean IsAtomicRW(AccType acctype)">IsAtomicRW</anchor>(<a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype)
    return acctype IN {
                <a link="AccType_ATOMICRW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a>,
                <a link="AccType_ORDEREDRW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDRW</a>,
                <a link="AccType_ORDEREDATOMICRW" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMICRW</a>
           };</pstext>
    </ps>
    <ps name="shared/translation/vmsa/Regime" mylink="shared.translation.vmsa.Regime" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="Regime" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</anchor> {
    <anchor link="Regime_EL3" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</anchor>,            // EL3
    <anchor link="Regime_EL30" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</anchor>,           // EL3&amp;0 (PL1&amp;0 when EL3 is AArch32)
    <anchor link="Regime_EL2" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</anchor>,            // EL2
    <anchor link="Regime_EL20" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</anchor>,           // EL2&amp;0
    <anchor link="Regime_EL10" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</anchor>            // EL1&amp;0
};</pstext>
    </ps>
    <ps name="shared/translation/vmsa/RegimeUsingAArch32" mylink="shared.translation.vmsa.RegimeUsingAArch32" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// RegimeUsingAArch32()
// ====================
// Determine if the EL controlling the regime executes in AArch32 state

boolean <anchor link="impl-shared.RegimeUsingAArch32.1" hover="function: boolean RegimeUsingAArch32(Regime regime)">RegimeUsingAArch32</anchor>(<a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime)
    case regime of
        when <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> return <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>);
        when <a link="Regime_EL30" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> return TRUE;
        when <a link="Regime_EL20" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> return FALSE;
        when <a link="Regime_EL2" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  return <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>);
        when <a link="Regime_EL3" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>  return FALSE;</pstext>
    </ps>
    <ps name="shared/translation/vmsa/S1TTWParams" mylink="shared.translation.vmsa.S1TTWParams" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">type <anchor link="S1TTWParams" hover="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</anchor> is (
// A64-VMSA exclusive parameters
    bit         ha,         // TCR_ELx.HA
    bit         hd,         // TCR_ELx.HD
    bit         tbi,        // TCR_ELx.TBI{x}
    bit         tbid,       // TCR_ELx.TBID{x}
    bit         e0pd,       // TCR_EL1.E0PDx or TCR_EL2.E0PDx when HCR_EL2.E2H == '1'
    bit         ds,         // TCR_ELx.DS
    bits(3)     ps,         // TCR_ELx.{I}PS
    bits(6)     txsz,       // TCR_ELx.TxSZ
    bit         epan,       // SCTLR_EL1.EPAN or SCTLR_EL2.EPAN when HCR_EL2.E2H == '1'
    bit         dct,        // HCR_EL2.DCT
    bit         nv1,        // HCR_EL2.NV1
    bit         cmow,       // SCTLR_EL1.CMOW or SCTLR_EL2.CMOW when HCR_EL2.E2H == '1'

// A32-VMSA exclusive parameters
    bits(3)     t0sz,       // TTBCR.T0SZ
    bits(3)     t1sz,       // TTBCR.T1SZ
    bit         uwxn,       // SCTLR.UWXN

// Parameters common to both A64-VMSA &amp; A32-VMSA (A64/A32)
    <a link="TGx" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a>         tgx,        // TCR_ELx.TGx      / Always TGx_4KB
    bits(2)     irgn,       // TCR_ELx.IRGNx    / TTBCR.IRGNx or HTCR.IRGN0
    bits(2)     orgn,       // TCR_ELx.ORGNx    / TTBCR.ORGNx or HTCR.ORGN0
    bits(2)     sh,         // TCR_ELx.SHx      / TTBCR.SHx or HTCR.SH0
    bit         hpd,        // TCR_ELx.HPD{x}   / TTBCR2.HPDx or HTCR.HPD
    bit         ee,         // SCTLR_ELx.EE     / SCTLR.EE or HSCTLR.EE
    bit         wxn,        // SCTLR_ELx.WXN    / SCTLR.WXN or HSCTLR.WXN
    bit         ntlsmd,     // SCTLR_ELx.nTLSMD / SCTLR.nTLSMD or HSCTLR.nTLSMD
    bit         dc,         // HCR_EL2.DC       / HCR.DC
    bit         sif,        // SCR_EL3.SIF      / SCR.SIF
    <a link="MAIRType" file="shared_pseudocode.xml" hover="type MAIRType">MAIRType</a>    mair        // MAIR_ELx         / MAIR1:MAIR0 or HMAIR1:HMAIR0
)</pstext>
    </ps>
    <ps name="shared/translation/vmsa/S2TTWParams" mylink="shared.translation.vmsa.S2TTWParams" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">type <anchor link="S2TTWParams" hover="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</anchor> is (
// A64-VMSA exclusive parameters
    bit         ha,     // VTCR_EL2.HA
    bit         hd,     // VTCR_EL2.HD
    bit         sl2,    // V{S}TCR_EL2.SL2
    bit         ds,     // VTCR_EL2.DS
    bit         sw,     // VSTCR_EL2.SW
    bit         nsw,    // VTCR_EL2.NSW
    bit         sa,     // VSTCR_EL2.SA
    bit         nsa,    // VTCR_EL2.NSA
    bits(3)     ps,     // VTCR_EL2.PS
    bits(6)     txsz,   // V{S}TCR_EL2.T0SZ
    bit         fwb,    // HCR_EL2.PTW
    bit         cmow,   // HCRX_EL2.CMOW

// A32-VMSA exclusive parameters
    bit         s,      // VTCR.S
    bits(4)     t0sz,   // VTCR.T0SZ

// Parameters common to both A64-VMSA &amp; A32-VMSA if implemented (A64/A32)
    <a link="TGx" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a>         tgx,    // V{S}TCR_EL2.TG0  / Always TGx_4KB
    bits(2)     sl0,    // V{S}TCR_EL2.SL0  / VTCR.SL0
    bits(2)     irgn,   // VTCR_EL2.IRGN0   / VTCR.IRGN0
    bits(2)     orgn,   // VTCR_EL2.ORGN0   / VTCR.ORGN0
    bits(2)     sh,     // VTCR_EL2.SH0     / VTCR.SH0
    bit         ee,     // SCTLR_EL2.EE     / HSCTLR.EE
    bit         ptw,    // HCR_EL2.PTW      / HCR.PTW
    bit         vm      // HCR_EL2.VM       / HCR.VM
)</pstext>
    </ps>
    <ps name="shared/translation/vmsa/SDFType" mylink="shared.translation.vmsa.SDFType" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="SDFType" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType</anchor> {
    <anchor link="SDFType_Table" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Table</anchor>,
    <anchor link="SDFType_Invalid" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Invalid</anchor>,
    <anchor link="SDFType_Supersection" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Supersection</anchor>,
    <anchor link="SDFType_Section" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Section</anchor>,
    <anchor link="SDFType_LargePage" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_LargePage</anchor>,
    <anchor link="SDFType_SmallPage" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_SmallPage</anchor>
};</pstext>
    </ps>
    <ps name="shared/translation/vmsa/SecurityStateForRegime" mylink="shared.translation.vmsa.SecurityStateForRegime" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// SecurityStateForRegime()
// ========================
// Return the Security State of the given translation regime

SecurityState <anchor link="impl-shared.SecurityStateForRegime.1" hover="function: SecurityState SecurityStateForRegime(Regime regime)">SecurityStateForRegime</anchor>(<a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime)
    case regime of
        when <a link="Regime_EL3" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>     return <a link="impl-shared.SecurityStateAtEL.1" file="shared_pseudocode.xml" hover="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>);
        when <a link="Regime_EL30" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a>    return <a link="SS_Secure" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SS_Secure</a>; // A32 EL3 is always Secure
        when <a link="Regime_EL2" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>     return <a link="impl-shared.SecurityStateAtEL.1" file="shared_pseudocode.xml" hover="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>);
        when <a link="Regime_EL20" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>    return <a link="impl-shared.SecurityStateAtEL.1" file="shared_pseudocode.xml" hover="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>);
        when <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>    return <a link="impl-shared.SecurityStateAtEL.1" file="shared_pseudocode.xml" hover="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(<a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a>);</pstext>
    </ps>
    <ps name="shared/translation/vmsa/StageOA" mylink="shared.translation.vmsa.StageOA" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// StageOA()
// =========
// Given the final walk state (a page or block descriptor), map the untranslated
// input address bits to the output address

FullAddress <anchor link="impl-shared.StageOA.3" hover="function: FullAddress StageOA(bits(64) ia, TGx tgx, TTWState walkstate)">StageOA</anchor>(bits(64) ia, <a link="TGx" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate)
    // Output Address
    <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> oa;
    integer csize;

    tsize = <a link="impl-shared.TranslationSize.2" file="shared_pseudocode.xml" hover="function: integer TranslationSize(TGx tgx, integer level)">TranslationSize</a>(tgx, walkstate.level);
    if walkstate.contiguous == '1' then
        csize = <a link="impl-shared.ContiguousSize.2" file="shared_pseudocode.xml" hover="function: integer ContiguousSize(TGx tgx, integer level)">ContiguousSize</a>(tgx, walkstate.level);
    else
        csize = 0;

    ia_msb = tsize + csize;
    oa.paspace = walkstate.baseaddress.paspace;
    oa.address = walkstate.baseaddress.address&lt;51:ia_msb&gt;:ia&lt;ia_msb-1:0&gt;;

    return oa;</pstext>
    </ps>
    <ps name="shared/translation/vmsa/TGx" mylink="shared.translation.vmsa.TGx" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="TGx" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</anchor> {
    <anchor link="TGx_4KB" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</anchor>,
    <anchor link="TGx_16KB" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</anchor>,
    <anchor link="TGx_64KB" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</anchor>
};</pstext>
    </ps>
    <ps name="shared/translation/vmsa/TGxGranuleBits" mylink="shared.translation.vmsa.TGxGranuleBits" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// TGxGranuleBits()
// ================
// Retrieve the address size, in bits, of a granule

integer <anchor link="impl-shared.TGxGranuleBits.1" hover="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</anchor>(<a link="TGx" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx)
    case tgx of
        when <a link="TGx_4KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>  return 12;
        when <a link="TGx_16KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a> return 14;
        when <a link="TGx_64KB" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> return 16;</pstext>
    </ps>
    <ps name="shared/translation/vmsa/TLBContext" mylink="shared.translation.vmsa.TLBContext" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">type <anchor link="TLBContext" hover="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, bits(64) ia, TGx tg, bit cnp, bit xs )">TLBContext</anchor> is (
    <a link="SecurityState" file="shared_pseudocode.xml" hover="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Secure&#13; }">SecurityState</a> ss,
    <a link="Regime" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a>        regime,
    bits(16)      vmid,
    bits(16)      asid,
    bit           nG,
    <a link="PASpace" file="shared_pseudocode.xml" hover="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; }">PASpace</a>       ipaspace, // Used in stage 2 lookups &amp; invalidations only
    boolean       includes_s1,
    boolean       includes_s2,
    bits(64)      ia,       // Input Address
    <a link="TGx" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a>           tg,
    bit           cnp,
    bit           xs        // XS attribute (FEAT_XS)
)</pstext>
    </ps>
    <ps name="shared/translation/vmsa/TLBRecord" mylink="shared.translation.vmsa.TLBRecord" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">type <anchor link="TLBRecord" hover="type TLBRecord is ( TLBContext context, TTWState walkstate, integer blocksize, integer contigsize, bits(64) s1descriptor, bits(64) s2descriptor )">TLBRecord</anchor> is (
    <a link="TLBContext" file="shared_pseudocode.xml" hover="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, bits(64) ia, TGx tg, bit cnp, bit xs )">TLBContext</a>  context,
    <a link="TTWState" file="shared_pseudocode.xml" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a>    walkstate,
    integer     blocksize,    // Number of bits directly mapped from IA to OA
    integer     contigsize,   // Number of entries log 2 marking a contiguous output range
    bits(64)    s1descriptor, // Stage 1 leaf descriptor in memory (valid if the TLB caches stage 1)
    bits(64)    s2descriptor  // Stage 2 leaf descriptor in memory (valid if the TLB caches stage 2)
)</pstext>
    </ps>
    <ps name="shared/translation/vmsa/TTWState" mylink="shared.translation.vmsa.TTWState" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">type <anchor link="TTWState" hover="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</anchor> is (
    boolean             istable,
    integer             level,
    <a link="FullAddress" file="shared_pseudocode.xml" hover="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a>         baseaddress,
    bit                 contiguous,
    bit                 nG,
    bit                 guardedpage,
    <a link="SDFType" file="shared_pseudocode.xml" hover="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType</a>             sdftype, // AArch32 Short-descriptor format walk only
    bits(4)             domain,  // AArch32 Short-descriptor format walk only
    <a link="MemoryAttributes" file="shared_pseudocode.xml" hover="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a>    memattrs,
    <a link="Permissions" file="shared_pseudocode.xml" hover="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(2) s2ap, bit s2xnx, bit s2xn )">Permissions</a>         permissions
)</pstext>
    </ps>
    <ps name="shared/translation/vmsa/TranslationRegime" mylink="shared.translation.vmsa.TranslationRegime" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// TranslationRegime()
// ===================
// Select the translation regime given the target EL and PE state

Regime <anchor link="impl-shared.TranslationRegime.2" hover="function: Regime TranslationRegime(bits(2) el, AccType acctype)">TranslationRegime</anchor>(bits(2) el, <a link="AccType" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype)
    if el == <a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a> then
        return if <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then <a link="Regime_EL30" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> else <a link="Regime_EL3" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>;
    elsif el == <a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a> then
        return if <a link="impl-shared.ELIsInHost.1" file="shared_pseudocode.xml" hover="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then <a link="Regime_EL20" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> else <a link="Regime_EL2" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>;
    elsif el == <a link="EL1" file="shared_pseudocode.xml" hover="constant bits(2) EL1 = '01'">EL1</a> then
        if acctype == <a link="AccType_NV2REGISTER" file="shared_pseudocode.xml" hover="enumeration AccType {AccType_NORMAL, AccType_STREAM, AccType_VEC, AccType_VECSTREAM, AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NV2REGISTER,    AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NV2REGISTER</a> then
            assert <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>();
            return if <a link="impl-shared.ELIsInHost.1" file="shared_pseudocode.xml" hover="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(<a link="EL2" file="shared_pseudocode.xml" hover="constant bits(2) EL2 = '10'">EL2</a>) then <a link="Regime_EL20" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> else <a link="Regime_EL2" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>;
        else
            return <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>;
    elsif el == <a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a> then
        if <a link="impl-shared.IsSecure.0" file="shared_pseudocode.xml" hover="function: boolean IsSecure()">IsSecure</a>() &amp;&amp; <a link="impl-shared.ELUsingAArch32.1" file="shared_pseudocode.xml" hover="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a link="EL3" file="shared_pseudocode.xml" hover="constant bits(2) EL3 = '11'">EL3</a>) then
            return <a link="Regime_EL30" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a>;
        elsif <a link="impl-shared.ELIsInHost.1" file="shared_pseudocode.xml" hover="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(<a link="EL0" file="shared_pseudocode.xml" hover="constant bits(2) EL0 = '00'">EL0</a>) then
            return <a link="Regime_EL20" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>;
        else
            return <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>;
    else
        <a link="impl-shared.Unreachable.0" file="shared_pseudocode.xml" hover="function: Unreachable()">Unreachable</a>();</pstext>
    </ps>
    <ps name="shared/translation/vmsa/TranslationSize" mylink="shared.translation.vmsa.TranslationSize" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// TranslationSize()
// =================
// Compute the number of bits directly mapped from the input address
// to the output address

integer <anchor link="impl-shared.TranslationSize.2" hover="function: integer TranslationSize(TGx tgx, integer level)">TranslationSize</anchor>(<a link="TGx" file="shared_pseudocode.xml" hover="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, integer level)
    granulebits = <a link="impl-shared.TGxGranuleBits.1" file="shared_pseudocode.xml" hover="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(tgx);
    blockbits   = (<a link="FINAL_LEVEL" file="shared_pseudocode.xml" hover="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - level) * (granulebits - 3);

    return granulebits + blockbits;</pstext>
    </ps>
    <ps name="shared/translation/vmsa/UseASID" mylink="shared.translation.vmsa.UseASID" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// UseASID()
// =========
// Determine whether the translation context for the access requires ASID or is a global entry

boolean <anchor link="impl-shared.UseASID.1" hover="function: boolean UseASID(TLBContext access)">UseASID</anchor>(<a link="TLBContext" file="shared_pseudocode.xml" hover="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, bits(64) ia, TGx tg, bit cnp, bit xs )">TLBContext</a> access)
    return <a link="impl-shared.HasUnprivileged.1" file="shared_pseudocode.xml" hover="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(access.regime);</pstext>
    </ps>
    <ps name="shared/translation/vmsa/UseVMID" mylink="shared.translation.vmsa.UseVMID" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">// UseVMID()
// =========
// Determine whether the translation context for the access requires VMID to match a TLB entry

boolean <anchor link="impl-shared.UseVMID.1" hover="function: boolean UseVMID(TLBContext access)">UseVMID</anchor>(<a link="TLBContext" file="shared_pseudocode.xml" hover="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, bits(64) ia, TGx tg, bit cnp, bit xs )">TLBContext</a> access)
    return access.regime == <a link="Regime_EL10" file="shared_pseudocode.xml" hover="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a link="impl-shared.EL2Enabled.0" file="shared_pseudocode.xml" hover="function: boolean EL2Enabled()">EL2Enabled</a>();</pstext>
    </ps>
    <ps name="shared/translation/vmsa/VARange" mylink="shared.translation.vmsa.VARange" enclabels="" sections="1" secttype="Library">
      <pstext mayhavelinks="1" section="Functions" rep_section="functions">enumeration <anchor link="VARange" hover="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange</anchor> {
    <anchor link="VARange_LOWER" hover="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</anchor>,
    <anchor link="VARange_UPPER" hover="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_UPPER</anchor>
};</pstext>
    </ps>
  </ps_section>
</instructionsection>
